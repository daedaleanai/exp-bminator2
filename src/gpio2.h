#pragma once

#include <assert.h>

#include "stm32l4xx.h"

// More convenenient API than the one generated by genstruct
// See RM0394 Section 8

enum GPIO_Conf {

	GPIO_INPUT	= 0x0000,
	GPIO_OUTPUT = 0x1000,
	GPIO_AFOUT	= 0x2000,
	GPIO_ANALOG = 0x3000,

	// OTYPE valid for OUTPUT/AFOUT (0 is push-pull)
	GPIO_OPENDRAIN = 0x0080,

	// PUPD valid for INPUT/OUTPUT/AFOUT, but typically only used for input
	GPIO_PULLUP	  = 0x0010,
	GPIO_PULLDOWN = 0x0020,

	// useful combinations
	GPIO_IPU = GPIO_INPUT | GPIO_PULLUP,
	GPIO_IPD = GPIO_INPUT | GPIO_PULLDOWN,
	GPIO_ODO = GPIO_OUTPUT | GPIO_OPENDRAIN,

	// OSPEED valid for OUTPUT/AFOUT
	GPIO_LOW	= 0x0000,
	GPIO_MEDIUM = 0x0001,
	GPIO_FAST	= 0x0002,
	GPIO_HIGH	= 0x0003,

	// AF Families.  See Datasheet s
	//	DS11451/DS11453 Section 4 Table 16
	GPIO_AF0_SYS	  = GPIO_AFOUT | 0x0000,
	GPIO_AF1_LPTIM	  = GPIO_AFOUT | 0x0100,
	GPIO_AF2_TIM12	  = GPIO_AFOUT | 0x0200,
	GPIO_AF3_USART2	  = GPIO_AFOUT | 0x0300,
	GPIO_AF4_I2C	  = GPIO_AFOUT | 0x0400,
	GPIO_AF5_SPI12	  = GPIO_AFOUT | 0x0500,
	GPIO_AF6_SPI3	  = GPIO_AFOUT | 0x0600,
	GPIO_AF7_USART123 = GPIO_AFOUT | 0x0700,
	GPIO_AF8_LPUART	  = GPIO_AFOUT | 0x0800,
	GPIO_AF9_CANTSC	  = GPIO_AFOUT | 0x0900,
	GPIO_AF10_QUADSPI = GPIO_AFOUT | 0x0A00,
	GPIO_AF11_NOP	  = GPIO_AFOUT | 0x0B00,
	GPIO_AF12_COMP	  = GPIO_AFOUT | 0x0C00,
	GPIO_AF13_SAI1	  = GPIO_AFOUT | 0x0D00,
	GPIO_AF14_TIM1516 = GPIO_AFOUT | 0x0E00,
	GPIO_AF15_EVENT	  = GPIO_AFOUT | 0x0F00,

};

// Pins of the same GPIO can be combined by OR-ing them together: PA3|PA5, but mixing GPIOS like PB3|PH3 makes
// the functions hang. The lower 16 bits represent the pin mask, bits 24:17 index the GPIOx as an array of 1k pages with the
// GPIOA..H and the upper 8 bits are a bitmask of the same.  the functions that use the values check that only 1 bit is set in these
// upper 8, and assert/hang if this is not the case, since it means that pins of different GPIOx ports have been combined.
enum GPIO_Pin {
	Pin_0	= 0x0001,
	Pin_1	= 0x0002,
	Pin_2	= 0x0004,
	Pin_3	= 0x0008,
	Pin_4	= 0x0010,
	Pin_5	= 0x0020,
	Pin_6	= 0x0040,
	Pin_7	= 0x0080,
	Pin_8	= 0x0100,
	Pin_9	= 0x0200,
	Pin_10	= 0x0400,
	Pin_11	= 0x0800,
	Pin_12	= 0x1000,
	Pin_13	= 0x2000,
	Pin_14	= 0x4000,
	Pin_15	= 0x8000,
	Pin_All = 0xFFFF,

	GPIO_A = 0x01000000,
	GPIO_B = 0x02010000,
	GPIO_C = 0x04020000,
	GPIO_D = 0x08030000,
	GPIO_E = 0x10040000,
	GPIO_F = 0x20050000,
#if 0
	GPIO_G = 0x40060000,
	GPIO_H = 0x80070000,
#endif

	/* clang-format off */
 	PA0	  = GPIO_A | Pin_0,  PB0	= GPIO_B | Pin_0,  PC0	= GPIO_C | Pin_0, PD0	 = GPIO_D | Pin_0, PE0	  = GPIO_E | Pin_0,
	PA1	  = GPIO_A | Pin_1,  PB1	= GPIO_B | Pin_1,  PC1	= GPIO_C | Pin_1, PD1	 = GPIO_D | Pin_1, PE1	  = GPIO_E | Pin_1,
	PA2	  = GPIO_A | Pin_2,  PB2	= GPIO_B | Pin_2,  PC2	= GPIO_C | Pin_2, PD2	 = GPIO_D | Pin_2, PE2	  = GPIO_E | Pin_2,
	PA3	  = GPIO_A | Pin_3,  PB3	= GPIO_B | Pin_3,  PC3	= GPIO_C | Pin_3, PD3	 = GPIO_D | Pin_3, PE3	  = GPIO_E | Pin_3,
	PA4	  = GPIO_A | Pin_4,  PB4	= GPIO_B | Pin_4,  PC4	= GPIO_C | Pin_4, PD4	 = GPIO_D | Pin_4, PE4	  = GPIO_E | Pin_4,
	PA5	  = GPIO_A | Pin_5,  PB5	= GPIO_B | Pin_5,  PC5	= GPIO_C | Pin_5, PD5	 = GPIO_D | Pin_5, PE5	  = GPIO_E | Pin_5,
	PA6	  = GPIO_A | Pin_6,  PB6	= GPIO_B | Pin_6,  PC6	= GPIO_C | Pin_6, PD6	 = GPIO_D | Pin_6, PE6	  = GPIO_E | Pin_6,
	PA7	  = GPIO_A | Pin_7,  PB7	= GPIO_B | Pin_7,  PC7	= GPIO_C | Pin_7, PD7	 = GPIO_D | Pin_7, PE7	  = GPIO_E | Pin_7,
	PA8	  = GPIO_A | Pin_8,  PB8	= GPIO_B | Pin_8,  PC8	= GPIO_C | Pin_8, PD8	 = GPIO_D | Pin_8, PE8	  = GPIO_E | Pin_8,
	PA9	  = GPIO_A | Pin_9,  PB9	= GPIO_B | Pin_9,  PC9	= GPIO_C | Pin_9, PD9	 = GPIO_D | Pin_9, PE9	  = GPIO_E | Pin_9,
	PA10  = GPIO_A | Pin_10, PB10   = GPIO_B | Pin_10, PC10 = GPIO_C | Pin_10, PD10  = GPIO_D | Pin_10, PE10  = GPIO_E | Pin_10,
	PA11  = GPIO_A | Pin_11, PB11   = GPIO_B | Pin_11, PC11 = GPIO_C | Pin_11, PD11  = GPIO_D | Pin_11, PE11  = GPIO_E | Pin_11,
	PA12  = GPIO_A | Pin_12, PB12   = GPIO_B | Pin_12, PC12 = GPIO_C | Pin_12, PD12  = GPIO_D | Pin_12, PE12  = GPIO_E | Pin_12,
	PA13  = GPIO_A | Pin_13, PB13   = GPIO_B | Pin_13, PC13 = GPIO_C | Pin_13, PD13  = GPIO_D | Pin_13, PE13  = GPIO_E | Pin_13,
	PA14  = GPIO_A | Pin_14, PB14   = GPIO_B | Pin_14, PC14 = GPIO_C | Pin_14, PD14  = GPIO_D | Pin_14, PE14  = GPIO_E | Pin_14,
	PA15  = GPIO_A | Pin_15, PB15   = GPIO_B | Pin_15, PC15 = GPIO_C | Pin_15, PD15  = GPIO_D | Pin_15, PE15  = GPIO_E | Pin_15,

	PAAll = GPIO_A | Pin_All,PBAll  = GPIO_B | Pin_All, PCAll = GPIO_C | Pin_All, PDAll = GPIO_D | Pin_All, PEAll = GPIO_E | Pin_All,

	/* clang-format on */

};

void gpioConfig(enum GPIO_Pin pins, enum GPIO_Conf mode);

uint32_t gpioLock(enum GPIO_Pin pins);

extern union GPIO_Page {
	struct GPIOA_Type gpio;
	struct {
		uint8_t bytes[0x400];
	} page;
} GPIO_ALL[8];

static inline int validGPIOPins(enum GPIO_Pin pins) { return !((pins >> 24) & ((pins >> 24) - 1)); }

static inline void digitalHi(enum GPIO_Pin hi) {
	assert(!((hi >> 24) & ((hi >> 24) - 1)));
	GPIO_ALL[(hi >> 16) & 0x7].gpio.BSRR = hi & Pin_All;
}

static inline void digitalLo(enum GPIO_Pin lo) {
	assert(!((lo >> 24) & ((lo >> 24) - 1)));
	GPIO_ALL[(lo >> 16) & 0x7].gpio.BSRR = lo << 16;
}

static inline void digitalHiLo(enum GPIO_Pin hi, enum GPIO_Pin lo) {
	assert(!(((hi | lo) >> 24) & (((hi | lo) >> 24) - 1)));
	GPIO_ALL[(lo >> 16) & 0x7].gpio.BSRR = (hi & Pin_All) | (lo << 16);
}

static inline void digitalToggle(enum GPIO_Pin pins) {
	assert(!((pins >> 24) & ((pins >> 24) - 1)));
	GPIO_ALL[(pins >> 16) & 0x7].gpio.ODR ^= pins & Pin_All;
}

static inline enum GPIO_Pin digitalIn(enum GPIO_Pin pins) {
	assert(!((pins >> 24) & ((pins >> 24) - 1)));
	return GPIO_ALL[(pins >> 16) & 0x7].gpio.IDR & (pins & Pin_All);
}
