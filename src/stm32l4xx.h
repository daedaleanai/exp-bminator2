#pragma once

// Generated enums and structures for device STM32L4xx version 1.6
// Generated by genstruct, DO NOT EDIT.

#include <stdint.h>

enum IRQn_Type {
	None_IRQn  = -16, // 0 position of estack reset pointer
	Reset_IRQn = -15, // 1 Reset, not a real IRQ           

	//  Cortex-CM4 Processor Exceptions Numbers 
	NonMaskableInt_IRQn   = -14, // 2 Non Maskable Interrupt                           
	Reserved_3_IRQn       = -13,
	MemoryManagement_IRQn = -12, // 4 Memory Management Interrupt            
	BusFault_IRQn         = -11, // 5 Bus Fault Interrupt                    
	UsageFault_IRQn       = -10, // 6 Usage Fault Interrupt                  
	Reserved_7_IRQn       = -9,
	Reserved_8_IRQn       = -8,
	Reserved_9_IRQn       = -7,
	Reserved_10_IRQn      = -6,
	SVCall_IRQn           = -5, // 11 SV Call Interrupt                     
	DebugMonitor_IRQn     = -4, // 12 Debug Monitor Interrupt               
	Reserved_13_IRQn      = -3,
	PendSV_IRQn           = -2, // 14 Pend SV Interrupt                     
	SysTick_IRQn          = -1, // 15 System Tick Interrupt                 

	//  Device specific Interrupt Numbers
	WWDG_IRQn = 0, // Window Watchdog interrupt
	PVD_PVM_IRQn = 1, // PVD through EXTI line detection
	RTC_TAMP_STAMP_IRQn = 2, // Tamper and TimeStamp interrupts
	RTC_WKUP_IRQn = 3, // RTC Tamper or TimeStamp /CSS on LSE through EXTI line 19 interrupts
	FLASH_IRQn = 4, // Flash global interrupt
	RCC_IRQn = 5, // RCC global interrupt
	EXTI0_IRQn = 6, // EXTI Line 0 interrupt
	EXTI1_IRQn = 7, // EXTI Line 1 interrupt
	EXTI2_IRQn = 8, // EXTI Line 2 interrupt
	EXTI3_IRQn = 9, // EXTI Line 3 interrupt
	EXTI4_IRQn = 10, // EXTI Line4 interrupt
	DMA1_CH1_IRQn = 11, // DMA1 Channel1 global interrupt
	DMA1_CH2_IRQn = 12, // DMA1 Channel2 global interrupt
	DMA1_CH3_IRQn = 13, // DMA1 Channel3 interrupt
	DMA1_CH4_IRQn = 14, // DMA1 Channel4 interrupt
	DMA1_CH5_IRQn = 15, // DMA1 Channel5 interrupt
	DMA1_CH6_IRQn = 16, // DMA1 Channel6 interrupt
	DMA1_CH7_IRQn = 17, // DMA1 Channel 7 interrupt
	ADC1_IRQn = 18, // ADC1 and ADC2 global interrupt
	CAN1_TX_IRQn = 19, // CAN1 TX interrupts
	CAN1_RX0_IRQn = 20, // CAN1 RX0 interrupts
	CAN1_RX1_IRQn = 21, // CAN1 RX1 interrupts
	CAN1_SCE_IRQn = 22, // CAN1 SCE interrupt
	EXTI9_5_IRQn = 23, // EXTI Line5 to Line9 interrupts
	TIM1_BRK_TIM15_IRQn = 24, // Timer 15 global interrupt
	TIM1_UP_TIM16_IRQn = 25, // Timer 16 global interrupt
	TIM1_TRG_COM_IRQn = 26, // TIM1 trigger and commutation interrupt
	TIM1_CC_IRQn = 27, // TIM1 Capture Compare interrupt
	TIM2_IRQn = 28, // TIM2 global interrupt
	TIM3_IRQn = 29, // TIM3 global interrupt
	I2C1_EV_IRQn = 31, // I2C1 event interrupt
	I2C1_ER_IRQn = 32, // I2C1 error interrupt
	I2C2_EV_IRQn = 33, // I2C2 event interrupt
	I2C2_ER_IRQn = 34, // I2C2 error interrupt
	SPI1_IRQn = 35, // SPI1 global interrupt
	SPI2_IRQn = 36, // SPI2 global interrupt
	USART1_IRQn = 37, // USART1 global interrupt
	USART2_IRQn = 38, // USART2 global interrupt
	USART3_IRQn = 39, // USART2 global interrupt
	EXTI15_10_IRQn = 40, // EXTI Lines 10 to 15 interrupts
	RTC_ALARM_IRQn = 41, // RTC alarms through EXTI line 18 interrupts
	SPI3_IRQn = 51, // SPI3 global Interrupt
	UART4_IRQn = 52, // UART4 global Interrupt
	TIM6_DACUNDER_IRQn = 54, // TIM6 global and DAC1 and 2 underrun error interrupts
	TIM7_IRQn = 55, // TIM7 global interrupt
	DMA2_CH1_IRQn = 56, // DMA2 Channel 1 global Interrupt
	DMA2_CH2_IRQn = 57, // DMA2 Channel 2 global Interrupt
	DMA2_CH3_IRQn = 58, // DMA2 Channel 3 global Interrupt
	DMA2_CH4_IRQn = 59, // DMA2 Channel 4 global Interrupt
	DMA2_CH5_IRQn = 60, // DMA2 Channel 5 global Interrupt
	COMP_IRQn = 64, // COMP1 and COMP2 interrupts
	LPTIM1_IRQn = 65, // LP TIM1 interrupt
	LPTIM2_IRQn = 66, // LP TIM2 interrupt
	DMA2_CH6_IRQn = 68, // DMA2 Channel 6 global Interrupt
	DMA2_CH7_IRQn = 69, // DMA2 Channel 7 global Interrupt
	LPUART1_IRQn = 70, // LPUART1 global interrupt
	I2C3_EV_IRQn = 72, // I2C3 event interrupt
	I2C3_ER_IRQn = 73, // I2C3 error interrupt
	FPU_IRQn = 81, // Floating point interrupt
	CRS_IRQn = 82, // CRS interrupt
	I2C4_EV_IRQn = 83, // I2C4 event interrupt, wakeup through EXTI
};


#define __I volatile const // 'read only' permissions
#define __O volatile       // 'write only' permissions
#define __IO volatile      // 'read / write' permissions


/* Analog-to-Digital Converter
There is only one peripheral of type ADC. */
struct ADC_Type {
	__IO uint16_t ISR; // @0 interrupt and status register
	 uint8_t RESERVED0[2]; // @2 
	__IO uint16_t IER; // @4 interrupt enable register
	 uint8_t RESERVED1[2]; // @6 
	__IO uint32_t CR; // @8 control register
	__IO uint32_t CFGR; // @12 configuration register
	__IO uint16_t CFGR2; // @16 configuration register
	 uint8_t RESERVED2[2]; // @18 
	__IO uint32_t SMPR1; // @20 sample time register 1
	__IO uint32_t SMPR2; // @24 sample time register 2
	 uint8_t RESERVED3[4]; // @28 
	__IO uint32_t TR1; // @32 watchdog threshold register 1
	__IO uint32_t TR2; // @36 watchdog threshold register
	__IO uint32_t TR3; // @40 watchdog threshold register 3
	 uint8_t RESERVED4[4]; // @44 
	__IO uint32_t SQR1; // @48 regular sequence register 1
	__IO uint32_t SQR2; // @52 regular sequence register 2
	__IO uint32_t SQR3; // @56 regular sequence register 3
	__IO uint16_t SQR4; // @60 regular sequence register 4
	 uint8_t RESERVED5[2]; // @62 
	__I uint16_t DR; // @64 regular Data Register
	 uint8_t RESERVED6[10]; // @66 
	__IO uint32_t JSQR; // @76 injected sequence register
	 uint8_t RESERVED7[16]; // @80 
	__IO uint32_t OFR1; // @96 offset register 1
	__IO uint32_t OFR2; // @100 offset register 2
	__IO uint32_t OFR3; // @104 offset register 3
	__IO uint32_t OFR4; // @108 offset register 4
	 uint8_t RESERVED8[16]; // @112 
	__I uint16_t JDR1; // @128 injected data register 1
	 uint8_t RESERVED9[2]; // @130 
	__I uint16_t JDR2; // @132 injected data register 2
	 uint8_t RESERVED10[2]; // @134 
	__I uint16_t JDR3; // @136 injected data register 3
	 uint8_t RESERVED11[2]; // @138 
	__I uint16_t JDR4; // @140 injected data register 4
	 uint8_t RESERVED12[18]; // @142 
	__IO uint32_t AWD2CR; // @160 Analog Watchdog 2 Configuration Register
	__IO uint32_t AWD3CR; // @164 Analog Watchdog 3 Configuration Register
	 uint8_t RESERVED13[8]; // @168 
	__IO uint32_t DIFSEL; // @176 Differential Mode Selection Register 2
	__IO uint32_t CALFACT; // @180 Calibration Factors
};
extern struct ADC_Type	ADC;	// @0x50040000 

// ADC->ISR interrupt and status register
enum {
	ADC_ISR_JQOVF = 1UL<<10, // JQOVF
	ADC_ISR_AWD3 = 1UL<<9, // AWD3
	ADC_ISR_AWD2 = 1UL<<8, // AWD2
	ADC_ISR_AWD1 = 1UL<<7, // AWD1
	ADC_ISR_JEOS = 1UL<<6, // JEOS
	ADC_ISR_JEOC = 1UL<<5, // JEOC
	ADC_ISR_OVR = 1UL<<4, // OVR
	ADC_ISR_EOS = 1UL<<3, // EOS
	ADC_ISR_EOC = 1UL<<2, // EOC
	ADC_ISR_EOSMP = 1UL<<1, // EOSMP
	ADC_ISR_ADRDY = 1UL<<0, // ADRDY		
};

// ADC->IER interrupt enable register
enum {
	ADC_IER_JQOVFIE = 1UL<<10, // JQOVFIE
	ADC_IER_AWD3IE = 1UL<<9, // AWD3IE
	ADC_IER_AWD2IE = 1UL<<8, // AWD2IE
	ADC_IER_AWD1IE = 1UL<<7, // AWD1IE
	ADC_IER_JEOSIE = 1UL<<6, // JEOSIE
	ADC_IER_JEOCIE = 1UL<<5, // JEOCIE
	ADC_IER_OVRIE = 1UL<<4, // OVRIE
	ADC_IER_EOSIE = 1UL<<3, // EOSIE
	ADC_IER_EOCIE = 1UL<<2, // EOCIE
	ADC_IER_EOSMPIE = 1UL<<1, // EOSMPIE
	ADC_IER_ADRDYIE = 1UL<<0, // ADRDYIE		
};

// ADC->CR control register
enum {
	ADC_CR_ADCAL = 1UL<<31, // ADCAL
	ADC_CR_ADCALDIF = 1UL<<30, // ADCALDIF
	ADC_CR_DEEPPWD = 1UL<<29, // DEEPPWD
	ADC_CR_ADVREGEN = 1UL<<28, // ADVREGEN
	ADC_CR_JADSTP = 1UL<<5, // JADSTP
	ADC_CR_ADSTP = 1UL<<4, // ADSTP
	ADC_CR_JADSTART = 1UL<<3, // JADSTART
	ADC_CR_ADSTART = 1UL<<2, // ADSTART
	ADC_CR_ADDIS = 1UL<<1, // ADDIS
	ADC_CR_ADEN = 1UL<<0, // ADEN		
};

// ADC->CFGR configuration register
enum {
	ADC_CFGR_AWDCH1CH = ((1UL<<5)-1) << 26, // AWDCH1CH
	ADC_CFGR_JAUTO = 1UL<<25, // JAUTO
	ADC_CFGR_JAWD1EN = 1UL<<24, // JAWD1EN
	ADC_CFGR_AWD1EN = 1UL<<23, // AWD1EN
	ADC_CFGR_AWD1SGL = 1UL<<22, // AWD1SGL
	ADC_CFGR_JQM = 1UL<<21, // JQM
	ADC_CFGR_JDISCEN = 1UL<<20, // JDISCEN
	ADC_CFGR_DISCNUM = ((1UL<<3)-1) << 17, // DISCNUM
	ADC_CFGR_DISCEN = 1UL<<16, // DISCEN
	ADC_CFGR_AUTOFF = 1UL<<15, // AUTOFF
	ADC_CFGR_AUTDLY = 1UL<<14, // AUTDLY
	ADC_CFGR_CONT = 1UL<<13, // CONT
	ADC_CFGR_OVRMOD = 1UL<<12, // OVRMOD
	ADC_CFGR_EXTEN = ((1UL<<2)-1) << 10, // EXTEN
	ADC_CFGR_EXTSEL = ((1UL<<4)-1) << 6, // EXTSEL
	ADC_CFGR_ALIGN = 1UL<<5, // ALIGN
	ADC_CFGR_RES = ((1UL<<2)-1) << 3, // RES
	ADC_CFGR_DMACFG = 1UL<<1, // DMACFG
	ADC_CFGR_DMAEN = 1UL<<0, // DMAEN		
};
static inline void adc_cfgr_set_awdch1ch(uint32_t val) { ADC.CFGR = (ADC.CFGR & ~ADC_CFGR_AWDCH1CH) | ((val<<26) & ADC_CFGR_AWDCH1CH); }
static inline void adc_cfgr_set_discnum(uint32_t val) { ADC.CFGR = (ADC.CFGR & ~ADC_CFGR_DISCNUM) | ((val<<17) & ADC_CFGR_DISCNUM); }
static inline void adc_cfgr_set_exten(uint32_t val) { ADC.CFGR = (ADC.CFGR & ~ADC_CFGR_EXTEN) | ((val<<10) & ADC_CFGR_EXTEN); }
static inline void adc_cfgr_set_extsel(uint32_t val) { ADC.CFGR = (ADC.CFGR & ~ADC_CFGR_EXTSEL) | ((val<<6) & ADC_CFGR_EXTSEL); }
static inline void adc_cfgr_set_res(uint32_t val) { ADC.CFGR = (ADC.CFGR & ~ADC_CFGR_RES) | ((val<<3) & ADC_CFGR_RES); }
static inline uint32_t adc_cfgr_get_awdch1ch(void) { return (ADC.CFGR & ADC_CFGR_AWDCH1CH) >> 26 ; }
static inline uint32_t adc_cfgr_get_discnum(void) { return (ADC.CFGR & ADC_CFGR_DISCNUM) >> 17 ; }
static inline uint32_t adc_cfgr_get_exten(void) { return (ADC.CFGR & ADC_CFGR_EXTEN) >> 10 ; }
static inline uint32_t adc_cfgr_get_extsel(void) { return (ADC.CFGR & ADC_CFGR_EXTSEL) >> 6 ; }
static inline uint32_t adc_cfgr_get_res(void) { return (ADC.CFGR & ADC_CFGR_RES) >> 3 ; }

// ADC->CFGR2 configuration register
enum {
	ADC_CFGR2_ROVSM = 1UL<<10, // EXTEN
	ADC_CFGR2_TOVS = 1UL<<9, // EXTSEL
	ADC_CFGR2_OVSS = ((1UL<<4)-1) << 5, // ALIGN
	ADC_CFGR2_OVSR = ((1UL<<3)-1) << 2, // RES
	ADC_CFGR2_JOVSE = 1UL<<1, // DMACFG
	ADC_CFGR2_ROVSE = 1UL<<0, // DMAEN		
};
static inline void adc_cfgr2_set_ovss(uint32_t val) { ADC.CFGR2 = (ADC.CFGR2 & ~ADC_CFGR2_OVSS) | ((val<<5) & ADC_CFGR2_OVSS); }
static inline void adc_cfgr2_set_ovsr(uint32_t val) { ADC.CFGR2 = (ADC.CFGR2 & ~ADC_CFGR2_OVSR) | ((val<<2) & ADC_CFGR2_OVSR); }
static inline uint32_t adc_cfgr2_get_ovss(void) { return (ADC.CFGR2 & ADC_CFGR2_OVSS) >> 5 ; }
static inline uint32_t adc_cfgr2_get_ovsr(void) { return (ADC.CFGR2 & ADC_CFGR2_OVSR) >> 2 ; }

// ADC->SMPR1 sample time register 1
enum {
	ADC_SMPR1_SMP9 = ((1UL<<3)-1) << 27, // SMP9
	ADC_SMPR1_SMP8 = ((1UL<<3)-1) << 24, // SMP8
	ADC_SMPR1_SMP7 = ((1UL<<3)-1) << 21, // SMP7
	ADC_SMPR1_SMP6 = ((1UL<<3)-1) << 18, // SMP6
	ADC_SMPR1_SMP5 = ((1UL<<3)-1) << 15, // SMP5
	ADC_SMPR1_SMP4 = ((1UL<<3)-1) << 12, // SMP4
	ADC_SMPR1_SMP3 = ((1UL<<3)-1) << 9, // SMP3
	ADC_SMPR1_SMP2 = ((1UL<<3)-1) << 6, // SMP2
	ADC_SMPR1_SMP1 = ((1UL<<3)-1) << 3, // SMP1
	ADC_SMPR1_SMP0 = ((1UL<<3)-1) << 0, // SMP0		
};
static inline void adc_smpr1_set_smp9(uint32_t val) { ADC.SMPR1 = (ADC.SMPR1 & ~ADC_SMPR1_SMP9) | ((val<<27) & ADC_SMPR1_SMP9); }
static inline void adc_smpr1_set_smp8(uint32_t val) { ADC.SMPR1 = (ADC.SMPR1 & ~ADC_SMPR1_SMP8) | ((val<<24) & ADC_SMPR1_SMP8); }
static inline void adc_smpr1_set_smp7(uint32_t val) { ADC.SMPR1 = (ADC.SMPR1 & ~ADC_SMPR1_SMP7) | ((val<<21) & ADC_SMPR1_SMP7); }
static inline void adc_smpr1_set_smp6(uint32_t val) { ADC.SMPR1 = (ADC.SMPR1 & ~ADC_SMPR1_SMP6) | ((val<<18) & ADC_SMPR1_SMP6); }
static inline void adc_smpr1_set_smp5(uint32_t val) { ADC.SMPR1 = (ADC.SMPR1 & ~ADC_SMPR1_SMP5) | ((val<<15) & ADC_SMPR1_SMP5); }
static inline void adc_smpr1_set_smp4(uint32_t val) { ADC.SMPR1 = (ADC.SMPR1 & ~ADC_SMPR1_SMP4) | ((val<<12) & ADC_SMPR1_SMP4); }
static inline void adc_smpr1_set_smp3(uint32_t val) { ADC.SMPR1 = (ADC.SMPR1 & ~ADC_SMPR1_SMP3) | ((val<<9) & ADC_SMPR1_SMP3); }
static inline void adc_smpr1_set_smp2(uint32_t val) { ADC.SMPR1 = (ADC.SMPR1 & ~ADC_SMPR1_SMP2) | ((val<<6) & ADC_SMPR1_SMP2); }
static inline void adc_smpr1_set_smp1(uint32_t val) { ADC.SMPR1 = (ADC.SMPR1 & ~ADC_SMPR1_SMP1) | ((val<<3) & ADC_SMPR1_SMP1); }
static inline void adc_smpr1_set_smp0(uint32_t val) { ADC.SMPR1 = (ADC.SMPR1 & ~ADC_SMPR1_SMP0) | ((val<<0) & ADC_SMPR1_SMP0); }
static inline uint32_t adc_smpr1_get_smp9(void) { return (ADC.SMPR1 & ADC_SMPR1_SMP9) >> 27 ; }
static inline uint32_t adc_smpr1_get_smp8(void) { return (ADC.SMPR1 & ADC_SMPR1_SMP8) >> 24 ; }
static inline uint32_t adc_smpr1_get_smp7(void) { return (ADC.SMPR1 & ADC_SMPR1_SMP7) >> 21 ; }
static inline uint32_t adc_smpr1_get_smp6(void) { return (ADC.SMPR1 & ADC_SMPR1_SMP6) >> 18 ; }
static inline uint32_t adc_smpr1_get_smp5(void) { return (ADC.SMPR1 & ADC_SMPR1_SMP5) >> 15 ; }
static inline uint32_t adc_smpr1_get_smp4(void) { return (ADC.SMPR1 & ADC_SMPR1_SMP4) >> 12 ; }
static inline uint32_t adc_smpr1_get_smp3(void) { return (ADC.SMPR1 & ADC_SMPR1_SMP3) >> 9 ; }
static inline uint32_t adc_smpr1_get_smp2(void) { return (ADC.SMPR1 & ADC_SMPR1_SMP2) >> 6 ; }
static inline uint32_t adc_smpr1_get_smp1(void) { return (ADC.SMPR1 & ADC_SMPR1_SMP1) >> 3 ; }
static inline uint32_t adc_smpr1_get_smp0(void) { return (ADC.SMPR1 & ADC_SMPR1_SMP0) >> 0 ; }

// ADC->SMPR2 sample time register 2
enum {
	ADC_SMPR2_SMP18 = ((1UL<<3)-1) << 24, // SMP18
	ADC_SMPR2_SMP17 = ((1UL<<3)-1) << 21, // SMP17
	ADC_SMPR2_SMP16 = ((1UL<<3)-1) << 18, // SMP16
	ADC_SMPR2_SMP15 = ((1UL<<3)-1) << 15, // SMP15
	ADC_SMPR2_SMP14 = ((1UL<<3)-1) << 12, // SMP14
	ADC_SMPR2_SMP13 = ((1UL<<3)-1) << 9, // SMP13
	ADC_SMPR2_SMP12 = ((1UL<<3)-1) << 6, // SMP12
	ADC_SMPR2_SMP11 = ((1UL<<3)-1) << 3, // SMP11
	ADC_SMPR2_SMP10 = ((1UL<<3)-1) << 0, // SMP10		
};
static inline void adc_smpr2_set_smp18(uint32_t val) { ADC.SMPR2 = (ADC.SMPR2 & ~ADC_SMPR2_SMP18) | ((val<<24) & ADC_SMPR2_SMP18); }
static inline void adc_smpr2_set_smp17(uint32_t val) { ADC.SMPR2 = (ADC.SMPR2 & ~ADC_SMPR2_SMP17) | ((val<<21) & ADC_SMPR2_SMP17); }
static inline void adc_smpr2_set_smp16(uint32_t val) { ADC.SMPR2 = (ADC.SMPR2 & ~ADC_SMPR2_SMP16) | ((val<<18) & ADC_SMPR2_SMP16); }
static inline void adc_smpr2_set_smp15(uint32_t val) { ADC.SMPR2 = (ADC.SMPR2 & ~ADC_SMPR2_SMP15) | ((val<<15) & ADC_SMPR2_SMP15); }
static inline void adc_smpr2_set_smp14(uint32_t val) { ADC.SMPR2 = (ADC.SMPR2 & ~ADC_SMPR2_SMP14) | ((val<<12) & ADC_SMPR2_SMP14); }
static inline void adc_smpr2_set_smp13(uint32_t val) { ADC.SMPR2 = (ADC.SMPR2 & ~ADC_SMPR2_SMP13) | ((val<<9) & ADC_SMPR2_SMP13); }
static inline void adc_smpr2_set_smp12(uint32_t val) { ADC.SMPR2 = (ADC.SMPR2 & ~ADC_SMPR2_SMP12) | ((val<<6) & ADC_SMPR2_SMP12); }
static inline void adc_smpr2_set_smp11(uint32_t val) { ADC.SMPR2 = (ADC.SMPR2 & ~ADC_SMPR2_SMP11) | ((val<<3) & ADC_SMPR2_SMP11); }
static inline void adc_smpr2_set_smp10(uint32_t val) { ADC.SMPR2 = (ADC.SMPR2 & ~ADC_SMPR2_SMP10) | ((val<<0) & ADC_SMPR2_SMP10); }
static inline uint32_t adc_smpr2_get_smp18(void) { return (ADC.SMPR2 & ADC_SMPR2_SMP18) >> 24 ; }
static inline uint32_t adc_smpr2_get_smp17(void) { return (ADC.SMPR2 & ADC_SMPR2_SMP17) >> 21 ; }
static inline uint32_t adc_smpr2_get_smp16(void) { return (ADC.SMPR2 & ADC_SMPR2_SMP16) >> 18 ; }
static inline uint32_t adc_smpr2_get_smp15(void) { return (ADC.SMPR2 & ADC_SMPR2_SMP15) >> 15 ; }
static inline uint32_t adc_smpr2_get_smp14(void) { return (ADC.SMPR2 & ADC_SMPR2_SMP14) >> 12 ; }
static inline uint32_t adc_smpr2_get_smp13(void) { return (ADC.SMPR2 & ADC_SMPR2_SMP13) >> 9 ; }
static inline uint32_t adc_smpr2_get_smp12(void) { return (ADC.SMPR2 & ADC_SMPR2_SMP12) >> 6 ; }
static inline uint32_t adc_smpr2_get_smp11(void) { return (ADC.SMPR2 & ADC_SMPR2_SMP11) >> 3 ; }
static inline uint32_t adc_smpr2_get_smp10(void) { return (ADC.SMPR2 & ADC_SMPR2_SMP10) >> 0 ; }

// ADC->TR1 watchdog threshold register 1
enum {
	ADC_TR1_HT1 = ((1UL<<12)-1) << 16, // HT1
	ADC_TR1_LT1 = ((1UL<<12)-1) << 0, // LT1		
};
static inline void adc_tr1_set_ht1(uint32_t val) { ADC.TR1 = (ADC.TR1 & ~ADC_TR1_HT1) | ((val<<16) & ADC_TR1_HT1); }
static inline void adc_tr1_set_lt1(uint32_t val) { ADC.TR1 = (ADC.TR1 & ~ADC_TR1_LT1) | ((val<<0) & ADC_TR1_LT1); }
static inline uint32_t adc_tr1_get_ht1(void) { return (ADC.TR1 & ADC_TR1_HT1) >> 16 ; }
static inline uint32_t adc_tr1_get_lt1(void) { return (ADC.TR1 & ADC_TR1_LT1) >> 0 ; }

// ADC->TR2 watchdog threshold register
enum {
	ADC_TR2_HT2 = ((1UL<<8)-1) << 16, // HT2
	ADC_TR2_LT2 = ((1UL<<8)-1) << 0, // LT2		
};
static inline void adc_tr2_set_ht2(uint32_t val) { ADC.TR2 = (ADC.TR2 & ~ADC_TR2_HT2) | ((val<<16) & ADC_TR2_HT2); }
static inline void adc_tr2_set_lt2(uint32_t val) { ADC.TR2 = (ADC.TR2 & ~ADC_TR2_LT2) | ((val<<0) & ADC_TR2_LT2); }
static inline uint32_t adc_tr2_get_ht2(void) { return (ADC.TR2 & ADC_TR2_HT2) >> 16 ; }
static inline uint32_t adc_tr2_get_lt2(void) { return (ADC.TR2 & ADC_TR2_LT2) >> 0 ; }

// ADC->TR3 watchdog threshold register 3
enum {
	ADC_TR3_HT3 = ((1UL<<8)-1) << 16, // HT3
	ADC_TR3_LT3 = ((1UL<<8)-1) << 0, // LT3		
};
static inline void adc_tr3_set_ht3(uint32_t val) { ADC.TR3 = (ADC.TR3 & ~ADC_TR3_HT3) | ((val<<16) & ADC_TR3_HT3); }
static inline void adc_tr3_set_lt3(uint32_t val) { ADC.TR3 = (ADC.TR3 & ~ADC_TR3_LT3) | ((val<<0) & ADC_TR3_LT3); }
static inline uint32_t adc_tr3_get_ht3(void) { return (ADC.TR3 & ADC_TR3_HT3) >> 16 ; }
static inline uint32_t adc_tr3_get_lt3(void) { return (ADC.TR3 & ADC_TR3_LT3) >> 0 ; }

// ADC->SQR1 regular sequence register 1
enum {
	ADC_SQR1_SQ4 = ((1UL<<5)-1) << 24, // SQ4
	ADC_SQR1_SQ3 = ((1UL<<5)-1) << 18, // SQ3
	ADC_SQR1_SQ2 = ((1UL<<5)-1) << 12, // SQ2
	ADC_SQR1_SQ1 = ((1UL<<5)-1) << 6, // SQ1
	ADC_SQR1_L3 = ((1UL<<4)-1) << 0, // L3		
};
static inline void adc_sqr1_set_sq4(uint32_t val) { ADC.SQR1 = (ADC.SQR1 & ~ADC_SQR1_SQ4) | ((val<<24) & ADC_SQR1_SQ4); }
static inline void adc_sqr1_set_sq3(uint32_t val) { ADC.SQR1 = (ADC.SQR1 & ~ADC_SQR1_SQ3) | ((val<<18) & ADC_SQR1_SQ3); }
static inline void adc_sqr1_set_sq2(uint32_t val) { ADC.SQR1 = (ADC.SQR1 & ~ADC_SQR1_SQ2) | ((val<<12) & ADC_SQR1_SQ2); }
static inline void adc_sqr1_set_sq1(uint32_t val) { ADC.SQR1 = (ADC.SQR1 & ~ADC_SQR1_SQ1) | ((val<<6) & ADC_SQR1_SQ1); }
static inline void adc_sqr1_set_l3(uint32_t val) { ADC.SQR1 = (ADC.SQR1 & ~ADC_SQR1_L3) | ((val<<0) & ADC_SQR1_L3); }
static inline uint32_t adc_sqr1_get_sq4(void) { return (ADC.SQR1 & ADC_SQR1_SQ4) >> 24 ; }
static inline uint32_t adc_sqr1_get_sq3(void) { return (ADC.SQR1 & ADC_SQR1_SQ3) >> 18 ; }
static inline uint32_t adc_sqr1_get_sq2(void) { return (ADC.SQR1 & ADC_SQR1_SQ2) >> 12 ; }
static inline uint32_t adc_sqr1_get_sq1(void) { return (ADC.SQR1 & ADC_SQR1_SQ1) >> 6 ; }
static inline uint32_t adc_sqr1_get_l3(void) { return (ADC.SQR1 & ADC_SQR1_L3) >> 0 ; }

// ADC->SQR2 regular sequence register 2
enum {
	ADC_SQR2_SQ9 = ((1UL<<5)-1) << 24, // SQ9
	ADC_SQR2_SQ8 = ((1UL<<5)-1) << 18, // SQ8
	ADC_SQR2_SQ7 = ((1UL<<5)-1) << 12, // SQ7
	ADC_SQR2_SQ6 = ((1UL<<5)-1) << 6, // SQ6
	ADC_SQR2_SQ5 = ((1UL<<5)-1) << 0, // SQ5		
};
static inline void adc_sqr2_set_sq9(uint32_t val) { ADC.SQR2 = (ADC.SQR2 & ~ADC_SQR2_SQ9) | ((val<<24) & ADC_SQR2_SQ9); }
static inline void adc_sqr2_set_sq8(uint32_t val) { ADC.SQR2 = (ADC.SQR2 & ~ADC_SQR2_SQ8) | ((val<<18) & ADC_SQR2_SQ8); }
static inline void adc_sqr2_set_sq7(uint32_t val) { ADC.SQR2 = (ADC.SQR2 & ~ADC_SQR2_SQ7) | ((val<<12) & ADC_SQR2_SQ7); }
static inline void adc_sqr2_set_sq6(uint32_t val) { ADC.SQR2 = (ADC.SQR2 & ~ADC_SQR2_SQ6) | ((val<<6) & ADC_SQR2_SQ6); }
static inline void adc_sqr2_set_sq5(uint32_t val) { ADC.SQR2 = (ADC.SQR2 & ~ADC_SQR2_SQ5) | ((val<<0) & ADC_SQR2_SQ5); }
static inline uint32_t adc_sqr2_get_sq9(void) { return (ADC.SQR2 & ADC_SQR2_SQ9) >> 24 ; }
static inline uint32_t adc_sqr2_get_sq8(void) { return (ADC.SQR2 & ADC_SQR2_SQ8) >> 18 ; }
static inline uint32_t adc_sqr2_get_sq7(void) { return (ADC.SQR2 & ADC_SQR2_SQ7) >> 12 ; }
static inline uint32_t adc_sqr2_get_sq6(void) { return (ADC.SQR2 & ADC_SQR2_SQ6) >> 6 ; }
static inline uint32_t adc_sqr2_get_sq5(void) { return (ADC.SQR2 & ADC_SQR2_SQ5) >> 0 ; }

// ADC->SQR3 regular sequence register 3
enum {
	ADC_SQR3_SQ14 = ((1UL<<5)-1) << 24, // SQ14
	ADC_SQR3_SQ13 = ((1UL<<5)-1) << 18, // SQ13
	ADC_SQR3_SQ12 = ((1UL<<5)-1) << 12, // SQ12
	ADC_SQR3_SQ11 = ((1UL<<5)-1) << 6, // SQ11
	ADC_SQR3_SQ10 = ((1UL<<5)-1) << 0, // SQ10		
};
static inline void adc_sqr3_set_sq14(uint32_t val) { ADC.SQR3 = (ADC.SQR3 & ~ADC_SQR3_SQ14) | ((val<<24) & ADC_SQR3_SQ14); }
static inline void adc_sqr3_set_sq13(uint32_t val) { ADC.SQR3 = (ADC.SQR3 & ~ADC_SQR3_SQ13) | ((val<<18) & ADC_SQR3_SQ13); }
static inline void adc_sqr3_set_sq12(uint32_t val) { ADC.SQR3 = (ADC.SQR3 & ~ADC_SQR3_SQ12) | ((val<<12) & ADC_SQR3_SQ12); }
static inline void adc_sqr3_set_sq11(uint32_t val) { ADC.SQR3 = (ADC.SQR3 & ~ADC_SQR3_SQ11) | ((val<<6) & ADC_SQR3_SQ11); }
static inline void adc_sqr3_set_sq10(uint32_t val) { ADC.SQR3 = (ADC.SQR3 & ~ADC_SQR3_SQ10) | ((val<<0) & ADC_SQR3_SQ10); }
static inline uint32_t adc_sqr3_get_sq14(void) { return (ADC.SQR3 & ADC_SQR3_SQ14) >> 24 ; }
static inline uint32_t adc_sqr3_get_sq13(void) { return (ADC.SQR3 & ADC_SQR3_SQ13) >> 18 ; }
static inline uint32_t adc_sqr3_get_sq12(void) { return (ADC.SQR3 & ADC_SQR3_SQ12) >> 12 ; }
static inline uint32_t adc_sqr3_get_sq11(void) { return (ADC.SQR3 & ADC_SQR3_SQ11) >> 6 ; }
static inline uint32_t adc_sqr3_get_sq10(void) { return (ADC.SQR3 & ADC_SQR3_SQ10) >> 0 ; }

// ADC->SQR4 regular sequence register 4
enum {
	ADC_SQR4_SQ16 = ((1UL<<5)-1) << 6, // SQ16
	ADC_SQR4_SQ15 = ((1UL<<5)-1) << 0, // SQ15		
};
static inline void adc_sqr4_set_sq16(uint32_t val) { ADC.SQR4 = (ADC.SQR4 & ~ADC_SQR4_SQ16) | ((val<<6) & ADC_SQR4_SQ16); }
static inline void adc_sqr4_set_sq15(uint32_t val) { ADC.SQR4 = (ADC.SQR4 & ~ADC_SQR4_SQ15) | ((val<<0) & ADC_SQR4_SQ15); }
static inline uint32_t adc_sqr4_get_sq16(void) { return (ADC.SQR4 & ADC_SQR4_SQ16) >> 6 ; }
static inline uint32_t adc_sqr4_get_sq15(void) { return (ADC.SQR4 & ADC_SQR4_SQ15) >> 0 ; }

// ADC->JSQR injected sequence register
enum {
	ADC_JSQR_JSQ4 = ((1UL<<5)-1) << 26, // JSQ4
	ADC_JSQR_JSQ3 = ((1UL<<5)-1) << 20, // JSQ3
	ADC_JSQR_JSQ2 = ((1UL<<5)-1) << 14, // JSQ2
	ADC_JSQR_JSQ1 = ((1UL<<5)-1) << 8, // JSQ1
	ADC_JSQR_JEXTEN = ((1UL<<2)-1) << 6, // JEXTEN
	ADC_JSQR_JEXTSEL = ((1UL<<4)-1) << 2, // JEXTSEL
	ADC_JSQR_JL = ((1UL<<2)-1) << 0, // JL		
};
static inline void adc_jsqr_set_jsq4(uint32_t val) { ADC.JSQR = (ADC.JSQR & ~ADC_JSQR_JSQ4) | ((val<<26) & ADC_JSQR_JSQ4); }
static inline void adc_jsqr_set_jsq3(uint32_t val) { ADC.JSQR = (ADC.JSQR & ~ADC_JSQR_JSQ3) | ((val<<20) & ADC_JSQR_JSQ3); }
static inline void adc_jsqr_set_jsq2(uint32_t val) { ADC.JSQR = (ADC.JSQR & ~ADC_JSQR_JSQ2) | ((val<<14) & ADC_JSQR_JSQ2); }
static inline void adc_jsqr_set_jsq1(uint32_t val) { ADC.JSQR = (ADC.JSQR & ~ADC_JSQR_JSQ1) | ((val<<8) & ADC_JSQR_JSQ1); }
static inline void adc_jsqr_set_jexten(uint32_t val) { ADC.JSQR = (ADC.JSQR & ~ADC_JSQR_JEXTEN) | ((val<<6) & ADC_JSQR_JEXTEN); }
static inline void adc_jsqr_set_jextsel(uint32_t val) { ADC.JSQR = (ADC.JSQR & ~ADC_JSQR_JEXTSEL) | ((val<<2) & ADC_JSQR_JEXTSEL); }
static inline void adc_jsqr_set_jl(uint32_t val) { ADC.JSQR = (ADC.JSQR & ~ADC_JSQR_JL) | ((val<<0) & ADC_JSQR_JL); }
static inline uint32_t adc_jsqr_get_jsq4(void) { return (ADC.JSQR & ADC_JSQR_JSQ4) >> 26 ; }
static inline uint32_t adc_jsqr_get_jsq3(void) { return (ADC.JSQR & ADC_JSQR_JSQ3) >> 20 ; }
static inline uint32_t adc_jsqr_get_jsq2(void) { return (ADC.JSQR & ADC_JSQR_JSQ2) >> 14 ; }
static inline uint32_t adc_jsqr_get_jsq1(void) { return (ADC.JSQR & ADC_JSQR_JSQ1) >> 8 ; }
static inline uint32_t adc_jsqr_get_jexten(void) { return (ADC.JSQR & ADC_JSQR_JEXTEN) >> 6 ; }
static inline uint32_t adc_jsqr_get_jextsel(void) { return (ADC.JSQR & ADC_JSQR_JEXTSEL) >> 2 ; }
static inline uint32_t adc_jsqr_get_jl(void) { return (ADC.JSQR & ADC_JSQR_JL) >> 0 ; }

// ADC->OFR1 offset register 1
enum {
	ADC_OFR1_OFFSET1_EN = 1UL<<31, // OFFSET1_EN
	ADC_OFR1_OFFSET1_CH = ((1UL<<5)-1) << 26, // OFFSET1_CH
	ADC_OFR1_OFFSET1 = ((1UL<<12)-1) << 0, // OFFSET1		
};
static inline void adc_ofr1_set_offset1_ch(uint32_t val) { ADC.OFR1 = (ADC.OFR1 & ~ADC_OFR1_OFFSET1_CH) | ((val<<26) & ADC_OFR1_OFFSET1_CH); }
static inline void adc_ofr1_set_offset1(uint32_t val) { ADC.OFR1 = (ADC.OFR1 & ~ADC_OFR1_OFFSET1) | ((val<<0) & ADC_OFR1_OFFSET1); }
static inline uint32_t adc_ofr1_get_offset1_ch(void) { return (ADC.OFR1 & ADC_OFR1_OFFSET1_CH) >> 26 ; }
static inline uint32_t adc_ofr1_get_offset1(void) { return (ADC.OFR1 & ADC_OFR1_OFFSET1) >> 0 ; }

// ADC->OFR2 offset register 2
enum {
	ADC_OFR2_OFFSET2_EN = 1UL<<31, // OFFSET2_EN
	ADC_OFR2_OFFSET2_CH = ((1UL<<5)-1) << 26, // OFFSET2_CH
	ADC_OFR2_OFFSET2 = ((1UL<<12)-1) << 0, // OFFSET2		
};
static inline void adc_ofr2_set_offset2_ch(uint32_t val) { ADC.OFR2 = (ADC.OFR2 & ~ADC_OFR2_OFFSET2_CH) | ((val<<26) & ADC_OFR2_OFFSET2_CH); }
static inline void adc_ofr2_set_offset2(uint32_t val) { ADC.OFR2 = (ADC.OFR2 & ~ADC_OFR2_OFFSET2) | ((val<<0) & ADC_OFR2_OFFSET2); }
static inline uint32_t adc_ofr2_get_offset2_ch(void) { return (ADC.OFR2 & ADC_OFR2_OFFSET2_CH) >> 26 ; }
static inline uint32_t adc_ofr2_get_offset2(void) { return (ADC.OFR2 & ADC_OFR2_OFFSET2) >> 0 ; }

// ADC->OFR3 offset register 3
enum {
	ADC_OFR3_OFFSET3_EN = 1UL<<31, // OFFSET3_EN
	ADC_OFR3_OFFSET3_CH = ((1UL<<5)-1) << 26, // OFFSET3_CH
	ADC_OFR3_OFFSET3 = ((1UL<<12)-1) << 0, // OFFSET3		
};
static inline void adc_ofr3_set_offset3_ch(uint32_t val) { ADC.OFR3 = (ADC.OFR3 & ~ADC_OFR3_OFFSET3_CH) | ((val<<26) & ADC_OFR3_OFFSET3_CH); }
static inline void adc_ofr3_set_offset3(uint32_t val) { ADC.OFR3 = (ADC.OFR3 & ~ADC_OFR3_OFFSET3) | ((val<<0) & ADC_OFR3_OFFSET3); }
static inline uint32_t adc_ofr3_get_offset3_ch(void) { return (ADC.OFR3 & ADC_OFR3_OFFSET3_CH) >> 26 ; }
static inline uint32_t adc_ofr3_get_offset3(void) { return (ADC.OFR3 & ADC_OFR3_OFFSET3) >> 0 ; }

// ADC->OFR4 offset register 4
enum {
	ADC_OFR4_OFFSET4_EN = 1UL<<31, // OFFSET4_EN
	ADC_OFR4_OFFSET4_CH = ((1UL<<5)-1) << 26, // OFFSET4_CH
	ADC_OFR4_OFFSET4 = ((1UL<<12)-1) << 0, // OFFSET4		
};
static inline void adc_ofr4_set_offset4_ch(uint32_t val) { ADC.OFR4 = (ADC.OFR4 & ~ADC_OFR4_OFFSET4_CH) | ((val<<26) & ADC_OFR4_OFFSET4_CH); }
static inline void adc_ofr4_set_offset4(uint32_t val) { ADC.OFR4 = (ADC.OFR4 & ~ADC_OFR4_OFFSET4) | ((val<<0) & ADC_OFR4_OFFSET4); }
static inline uint32_t adc_ofr4_get_offset4_ch(void) { return (ADC.OFR4 & ADC_OFR4_OFFSET4_CH) >> 26 ; }
static inline uint32_t adc_ofr4_get_offset4(void) { return (ADC.OFR4 & ADC_OFR4_OFFSET4) >> 0 ; }

// ADC->AWD2CR Analog Watchdog 2 Configuration Register
enum {
	ADC_AWD2CR_AWD2CH = ((1UL<<18)-1) << 1, // AWD2CH		
};
static inline void adc_awd2cr_set_awd2ch(uint32_t val) { ADC.AWD2CR = (ADC.AWD2CR & ~ADC_AWD2CR_AWD2CH) | ((val<<1) & ADC_AWD2CR_AWD2CH); }
static inline uint32_t adc_awd2cr_get_awd2ch(void) { return (ADC.AWD2CR & ADC_AWD2CR_AWD2CH) >> 1 ; }

// ADC->AWD3CR Analog Watchdog 3 Configuration Register
enum {
	ADC_AWD3CR_AWD3CH = ((1UL<<18)-1) << 1, // AWD3CH		
};
static inline void adc_awd3cr_set_awd3ch(uint32_t val) { ADC.AWD3CR = (ADC.AWD3CR & ~ADC_AWD3CR_AWD3CH) | ((val<<1) & ADC_AWD3CR_AWD3CH); }
static inline uint32_t adc_awd3cr_get_awd3ch(void) { return (ADC.AWD3CR & ADC_AWD3CR_AWD3CH) >> 1 ; }

// ADC->DIFSEL Differential Mode Selection Register 2
enum {
	ADC_DIFSEL_DIFSEL_16_18 = ((1UL<<3)-1) << 16, // Differential mode for channels 18 to 16
	ADC_DIFSEL_DIFSEL_1_15 = ((1UL<<15)-1) << 1, // Differential mode for channels 15 to 1		
};
static inline void adc_difsel_set_difsel_16_18(uint32_t val) { ADC.DIFSEL = (ADC.DIFSEL & ~ADC_DIFSEL_DIFSEL_16_18) | ((val<<16) & ADC_DIFSEL_DIFSEL_16_18); }
static inline void adc_difsel_set_difsel_1_15(uint32_t val) { ADC.DIFSEL = (ADC.DIFSEL & ~ADC_DIFSEL_DIFSEL_1_15) | ((val<<1) & ADC_DIFSEL_DIFSEL_1_15); }
static inline uint32_t adc_difsel_get_difsel_16_18(void) { return (ADC.DIFSEL & ADC_DIFSEL_DIFSEL_16_18) >> 16 ; }
static inline uint32_t adc_difsel_get_difsel_1_15(void) { return (ADC.DIFSEL & ADC_DIFSEL_DIFSEL_1_15) >> 1 ; }

// ADC->CALFACT Calibration Factors
enum {
	ADC_CALFACT_CALFACT_D = ((1UL<<7)-1) << 16, // CALFACT_D
	ADC_CALFACT_CALFACT_S = ((1UL<<7)-1) << 0, // CALFACT_S		
};
static inline void adc_calfact_set_calfact_d(uint32_t val) { ADC.CALFACT = (ADC.CALFACT & ~ADC_CALFACT_CALFACT_D) | ((val<<16) & ADC_CALFACT_CALFACT_D); }
static inline void adc_calfact_set_calfact_s(uint32_t val) { ADC.CALFACT = (ADC.CALFACT & ~ADC_CALFACT_CALFACT_S) | ((val<<0) & ADC_CALFACT_CALFACT_S); }
static inline uint32_t adc_calfact_get_calfact_d(void) { return (ADC.CALFACT & ADC_CALFACT_CALFACT_D) >> 16 ; }
static inline uint32_t adc_calfact_get_calfact_s(void) { return (ADC.CALFACT & ADC_CALFACT_CALFACT_S) >> 0 ; }

/* Analog-to-Digital Converter
There is only one peripheral of type ADC_Common. */
struct ADC_Common_Type {
	__I uint32_t CSR; // @0 ADC Common status register
	 uint8_t RESERVED0[4]; // @4 
	__IO uint32_t CCR; // @8 ADC common control register
	__I uint32_t CDR; // @12 ADC common regular data register for dual and triple modes
};
extern struct ADC_Common_Type	ADC12_Common;	// @0x50040300 

// ADC_Common->CSR ADC Common status register
enum {
	ADC_COMMON_CSR_JQOVF_SLV = 1UL<<26, // Injected Context Queue Overflow flag of the slave ADC
	ADC_COMMON_CSR_AWD3_SLV = 1UL<<25, // Analog watchdog 3 flag of the slave ADC
	ADC_COMMON_CSR_AWD2_SLV = 1UL<<24, // Analog watchdog 2 flag of the slave ADC
	ADC_COMMON_CSR_AWD1_SLV = 1UL<<23, // Analog watchdog 1 flag of the slave ADC
	ADC_COMMON_CSR_JEOS_SLV = 1UL<<22, // End of injected sequence flag of the slave ADC
	ADC_COMMON_CSR_JEOC_SLV = 1UL<<21, // End of injected conversion flag of the slave ADC
	ADC_COMMON_CSR_OVR_SLV = 1UL<<20, // Overrun flag of the slave ADC
	ADC_COMMON_CSR_EOS_SLV = 1UL<<19, // End of regular sequence flag of the slave ADC
	ADC_COMMON_CSR_EOC_SLV = 1UL<<18, // End of regular conversion of the slave ADC
	ADC_COMMON_CSR_EOSMP_SLV = 1UL<<17, // EOSMP_SLV
	ADC_COMMON_CSR_ADRDY_SLV = 1UL<<16, // ADRDY_SLV
	ADC_COMMON_CSR_JQOVF_MST = 1UL<<10, // JQOVF_MST
	ADC_COMMON_CSR_AWD3_MST = 1UL<<9, // AWD3_MST
	ADC_COMMON_CSR_AWD2_MST = 1UL<<8, // AWD2_MST
	ADC_COMMON_CSR_AWD1_MST = 1UL<<7, // AWD1_MST
	ADC_COMMON_CSR_JEOS_MST = 1UL<<6, // JEOS_MST
	ADC_COMMON_CSR_JEOC_MST = 1UL<<5, // JEOC_MST
	ADC_COMMON_CSR_OVR_MST = 1UL<<4, // OVR_MST
	ADC_COMMON_CSR_EOS_MST = 1UL<<3, // EOS_MST
	ADC_COMMON_CSR_EOC_MST = 1UL<<2, // EOC_MST
	ADC_COMMON_CSR_EOSMP_MST = 1UL<<1, // EOSMP_MST
	ADC_COMMON_CSR_ADDRDY_MST = 1UL<<0, // ADDRDY_MST		
};

// ADC_Common->CCR ADC common control register
enum {
	ADC_COMMON_CCR_VBATSEL = 1UL<<24, // VBAT selection
	ADC_COMMON_CCR_VSENSESEL = 1UL<<23, // VTS selection
	ADC_COMMON_CCR_VREFEN = 1UL<<22, // VREFINT enable
	ADC_COMMON_CCR_PRESC = ((1UL<<4)-1) << 18, // ADC prescaler
	ADC_COMMON_CCR_CKMODE = ((1UL<<2)-1) << 16, // ADC clock mode
	ADC_COMMON_CCR_MDMA = ((1UL<<2)-1) << 14, // Direct memory access mode for multi ADC mode
	ADC_COMMON_CCR_DMACFG = 1UL<<13, // DMA configuration (for multi-ADC mode)
	ADC_COMMON_CCR_DELAY = ((1UL<<4)-1) << 8, // Delay between 2 sampling phases
	ADC_COMMON_CCR_DUAL = ((1UL<<5)-1) << 0, // Dual ADC mode selection		
};
static inline void adc_common_ccr_set_presc(uint32_t val) { ADC12_Common.CCR = (ADC12_Common.CCR & ~ADC_COMMON_CCR_PRESC) | ((val<<18) & ADC_COMMON_CCR_PRESC); }
static inline void adc_common_ccr_set_ckmode(uint32_t val) { ADC12_Common.CCR = (ADC12_Common.CCR & ~ADC_COMMON_CCR_CKMODE) | ((val<<16) & ADC_COMMON_CCR_CKMODE); }
static inline void adc_common_ccr_set_mdma(uint32_t val) { ADC12_Common.CCR = (ADC12_Common.CCR & ~ADC_COMMON_CCR_MDMA) | ((val<<14) & ADC_COMMON_CCR_MDMA); }
static inline void adc_common_ccr_set_delay(uint32_t val) { ADC12_Common.CCR = (ADC12_Common.CCR & ~ADC_COMMON_CCR_DELAY) | ((val<<8) & ADC_COMMON_CCR_DELAY); }
static inline void adc_common_ccr_set_dual(uint32_t val) { ADC12_Common.CCR = (ADC12_Common.CCR & ~ADC_COMMON_CCR_DUAL) | ((val<<0) & ADC_COMMON_CCR_DUAL); }
static inline uint32_t adc_common_ccr_get_presc(void) { return (ADC12_Common.CCR & ADC_COMMON_CCR_PRESC) >> 18 ; }
static inline uint32_t adc_common_ccr_get_ckmode(void) { return (ADC12_Common.CCR & ADC_COMMON_CCR_CKMODE) >> 16 ; }
static inline uint32_t adc_common_ccr_get_mdma(void) { return (ADC12_Common.CCR & ADC_COMMON_CCR_MDMA) >> 14 ; }
static inline uint32_t adc_common_ccr_get_delay(void) { return (ADC12_Common.CCR & ADC_COMMON_CCR_DELAY) >> 8 ; }
static inline uint32_t adc_common_ccr_get_dual(void) { return (ADC12_Common.CCR & ADC_COMMON_CCR_DUAL) >> 0 ; }

// ADC_Common->CDR ADC common regular data register for dual and triple modes
enum {
	ADC_COMMON_CDR_RDATA_SLV = ((1UL<<16)-1) << 16, // Regular data of the slave ADC
	ADC_COMMON_CDR_RDATA_MST = ((1UL<<16)-1) << 0, // Regular data of the master ADC		
};
static inline uint32_t adc_common_cdr_get_rdata_slv(void) { return (ADC12_Common.CDR & ADC_COMMON_CDR_RDATA_SLV) >> 16 ; }
static inline uint32_t adc_common_cdr_get_rdata_mst(void) { return (ADC12_Common.CDR & ADC_COMMON_CDR_RDATA_MST) >> 0 ; }

/* Controller area network
There is only one peripheral of type CAN. */
struct CAN_Type {
	__IO uint32_t MCR; // @0 master control register
	__IO uint16_t MSR; // @4 master status register
	 uint8_t RESERVED0[2]; // @6 
	__IO uint32_t TSR; // @8 transmit status register
	__IO uint8_t RF0R; // @12 receive FIFO 0 register
	 uint8_t RESERVED1[3]; // @13 
	__IO uint8_t RF1R; // @16 receive FIFO 1 register
	 uint8_t RESERVED2[3]; // @17 
	__IO uint32_t IER; // @20 interrupt enable register
	__IO uint32_t ESR; // @24 interrupt enable register
	__IO uint32_t BTR; // @28 bit timing register
	 uint8_t RESERVED3[352]; // @32 
	__IO uint32_t TI0R; // @384 TX mailbox identifier register
	__IO uint32_t TDT0R; // @388 mailbox data length control and time stamp register
	__IO uint32_t TDL0R; // @392 mailbox data low register
	__IO uint32_t TDH0R; // @396 mailbox data high register
	__IO uint32_t TI1R; // @400 mailbox identifier register
	__IO uint32_t TDT1R; // @404 mailbox data length control and time stamp register
	__IO uint32_t TDL1R; // @408 mailbox data low register
	__IO uint32_t TDH1R; // @412 mailbox data high register
	__IO uint32_t TI2R; // @416 mailbox identifier register
	__IO uint32_t TDT2R; // @420 mailbox data length control and time stamp register
	__IO uint32_t TDL2R; // @424 mailbox data low register
	__IO uint32_t TDH2R; // @428 mailbox data high register
	__I uint32_t RI0R; // @432 receive FIFO mailbox identifier register
	__I uint32_t RDT0R; // @436 mailbox data high register
	__I uint32_t RDL0R; // @440 mailbox data high register
	__I uint32_t RDH0R; // @444 receive FIFO mailbox data high register
	__I uint32_t RI1R; // @448 mailbox data high register
	__I uint32_t RDT1R; // @452 mailbox data high register
	__I uint32_t RDL1R; // @456 mailbox data high register
	__I uint32_t RDH1R; // @460 mailbox data high register
	 uint8_t RESERVED4[48]; // @464 
	__IO uint8_t FMR; // @512 filter master register
	 uint8_t RESERVED5[3]; // @513 
	__IO uint16_t FM1R; // @516 filter mode register
	 uint8_t RESERVED6[6]; // @518 
	__IO uint16_t FS1R; // @524 filter scale register
	 uint8_t RESERVED7[6]; // @526 
	__IO uint16_t FFA1R; // @532 filter FIFO assignment register
	 uint8_t RESERVED8[6]; // @534 
	__IO uint16_t FA1R; // @540 filter activation register
	 uint8_t RESERVED9[34]; // @542 
	__IO uint32_t F0R1; // @576 Filter bank 0 register 1
	__IO uint32_t F0R2; // @580 Filter bank 0 register 2
	__IO uint32_t F1R1; // @584 Filter bank 1 register 1
	__IO uint32_t F1R2; // @588 Filter bank 1 register 2
	__IO uint32_t F2R1; // @592 Filter bank 2 register 1
	__IO uint32_t F2R2; // @596 Filter bank 2 register 2
	__IO uint32_t F3R1; // @600 Filter bank 3 register 1
	__IO uint32_t F3R2; // @604 Filter bank 3 register 2
	__IO uint32_t F4R1; // @608 Filter bank 4 register 1
	__IO uint32_t F4R2; // @612 Filter bank 4 register 2
	__IO uint32_t F5R1; // @616 Filter bank 5 register 1
	__IO uint32_t F5R2; // @620 Filter bank 5 register 2
	__IO uint32_t F6R1; // @624 Filter bank 6 register 1
	__IO uint32_t F6R2; // @628 Filter bank 6 register 2
	__IO uint32_t F7R1; // @632 Filter bank 7 register 1
	__IO uint32_t F7R2; // @636 Filter bank 7 register 2
	__IO uint32_t F8R1; // @640 Filter bank 8 register 1
	__IO uint32_t F8R2; // @644 Filter bank 8 register 2
	__IO uint32_t F9R1; // @648 Filter bank 9 register 1
	__IO uint32_t F9R2; // @652 Filter bank 9 register 2
	__IO uint32_t F10R1; // @656 Filter bank 10 register 1
	__IO uint32_t F10R2; // @660 Filter bank 10 register 2
	__IO uint32_t F11R1; // @664 Filter bank 11 register 1
	__IO uint32_t F11R2; // @668 Filter bank 11 register 2
	__IO uint32_t F12R1; // @672 Filter bank 4 register 1
	__IO uint32_t F12R2; // @676 Filter bank 12 register 2
	__IO uint32_t F13R1; // @680 Filter bank 13 register 1
	__IO uint32_t F13R2; // @684 Filter bank 13 register 2
	__IO uint32_t F14R1; // @688 Filter bank 14 register 1
	__IO uint32_t F14R2; // @692 Filter bank 14 register 2
	__IO uint32_t F15R1; // @696 Filter bank 15 register 1
	__IO uint32_t F15R2; // @700 Filter bank 15 register 2
	__IO uint32_t F16R1; // @704 Filter bank 16 register 1
	__IO uint32_t F16R2; // @708 Filter bank 16 register 2
	__IO uint32_t F17R1; // @712 Filter bank 17 register 1
	__IO uint32_t F17R2; // @716 Filter bank 17 register 2
	__IO uint32_t F18R1; // @720 Filter bank 18 register 1
	__IO uint32_t F18R2; // @724 Filter bank 18 register 2
	__IO uint32_t F19R1; // @728 Filter bank 19 register 1
	__IO uint32_t F19R2; // @732 Filter bank 19 register 2
	__IO uint32_t F20R1; // @736 Filter bank 20 register 1
	__IO uint32_t F20R2; // @740 Filter bank 20 register 2
	__IO uint32_t F21R1; // @744 Filter bank 21 register 1
	__IO uint32_t F21R2; // @748 Filter bank 21 register 2
	__IO uint32_t F22R1; // @752 Filter bank 22 register 1
	__IO uint32_t F22R2; // @756 Filter bank 22 register 2
	__IO uint32_t F23R1; // @760 Filter bank 23 register 1
	__IO uint32_t F23R2; // @764 Filter bank 23 register 2
	__IO uint32_t F24R1; // @768 Filter bank 24 register 1
	__IO uint32_t F24R2; // @772 Filter bank 24 register 2
	__IO uint32_t F25R1; // @776 Filter bank 25 register 1
	__IO uint32_t F25R2; // @780 Filter bank 25 register 2
	__IO uint32_t F26R1; // @784 Filter bank 26 register 1
	__IO uint32_t F26R2; // @788 Filter bank 26 register 2
	__IO uint32_t F27R1; // @792 Filter bank 27 register 1
	__IO uint32_t F27R2; // @796 Filter bank 27 register 2
};
extern struct CAN_Type	CAN1;	// @0x40006400 

// CAN->MCR master control register
enum {
	CAN_MCR_DBF = 1UL<<16, // DBF
	CAN_MCR_RESET = 1UL<<15, // RESET
	CAN_MCR_TTCM = 1UL<<7, // TTCM
	CAN_MCR_ABOM = 1UL<<6, // ABOM
	CAN_MCR_AWUM = 1UL<<5, // AWUM
	CAN_MCR_NART = 1UL<<4, // NART
	CAN_MCR_RFLM = 1UL<<3, // RFLM
	CAN_MCR_TXFP = 1UL<<2, // TXFP
	CAN_MCR_SLEEP = 1UL<<1, // SLEEP
	CAN_MCR_INRQ = 1UL<<0, // INRQ		
};

// CAN->MSR master status register
enum {
	CAN_MSR_RX = 1UL<<11, // RX
	CAN_MSR_SAMP = 1UL<<10, // SAMP
	CAN_MSR_RXM = 1UL<<9, // RXM
	CAN_MSR_TXM = 1UL<<8, // TXM
	CAN_MSR_SLAKI = 1UL<<4, // SLAKI
	CAN_MSR_WKUI = 1UL<<3, // WKUI
	CAN_MSR_ERRI = 1UL<<2, // ERRI
	CAN_MSR_SLAK = 1UL<<1, // SLAK
	CAN_MSR_INAK = 1UL<<0, // INAK		
};

// CAN->TSR transmit status register
enum {
	CAN_TSR_LOW2 = 1UL<<31, // Lowest priority flag for mailbox 2
	CAN_TSR_LOW1 = 1UL<<30, // Lowest priority flag for mailbox 1
	CAN_TSR_LOW0 = 1UL<<29, // Lowest priority flag for mailbox 0
	CAN_TSR_TME2 = 1UL<<28, // Lowest priority flag for mailbox 2
	CAN_TSR_TME1 = 1UL<<27, // Lowest priority flag for mailbox 1
	CAN_TSR_TME0 = 1UL<<26, // Lowest priority flag for mailbox 0
	CAN_TSR_CODE = ((1UL<<2)-1) << 24, // CODE
	CAN_TSR_ABRQ2 = 1UL<<23, // ABRQ2
	CAN_TSR_TERR2 = 1UL<<19, // TERR2
	CAN_TSR_ALST2 = 1UL<<18, // ALST2
	CAN_TSR_TXOK2 = 1UL<<17, // TXOK2
	CAN_TSR_RQCP2 = 1UL<<16, // RQCP2
	CAN_TSR_ABRQ1 = 1UL<<15, // ABRQ1
	CAN_TSR_TERR1 = 1UL<<11, // TERR1
	CAN_TSR_ALST1 = 1UL<<10, // ALST1
	CAN_TSR_TXOK1 = 1UL<<9, // TXOK1
	CAN_TSR_RQCP1 = 1UL<<8, // RQCP1
	CAN_TSR_ABRQ0 = 1UL<<7, // ABRQ0
	CAN_TSR_TERR0 = 1UL<<3, // TERR0
	CAN_TSR_ALST0 = 1UL<<2, // ALST0
	CAN_TSR_TXOK0 = 1UL<<1, // TXOK0
	CAN_TSR_RQCP0 = 1UL<<0, // RQCP0		
};
static inline void can_tsr_set_code(uint32_t val) { CAN1.TSR = (CAN1.TSR & ~CAN_TSR_CODE) | ((val<<24) & CAN_TSR_CODE); }
static inline uint32_t can_tsr_get_code(void) { return (CAN1.TSR & CAN_TSR_CODE) >> 24 ; }

// CAN->RF0R receive FIFO 0 register
enum {
	CAN_RF0R_RFOM0 = 1UL<<5, // RFOM0
	CAN_RF0R_FOVR0 = 1UL<<4, // FOVR0
	CAN_RF0R_FULL0 = 1UL<<3, // FULL0
	CAN_RF0R_FMP0 = ((1UL<<2)-1) << 0, // FMP0		
};
static inline void can_rf0r_set_fmp0(uint32_t val) { CAN1.RF0R = (CAN1.RF0R & ~CAN_RF0R_FMP0) | ((val<<0) & CAN_RF0R_FMP0); }
static inline uint32_t can_rf0r_get_fmp0(void) { return (CAN1.RF0R & CAN_RF0R_FMP0) >> 0 ; }

// CAN->RF1R receive FIFO 1 register
enum {
	CAN_RF1R_RFOM1 = 1UL<<5, // RFOM1
	CAN_RF1R_FOVR1 = 1UL<<4, // FOVR1
	CAN_RF1R_FULL1 = 1UL<<3, // FULL1
	CAN_RF1R_FMP1 = ((1UL<<2)-1) << 0, // FMP1		
};
static inline void can_rf1r_set_fmp1(uint32_t val) { CAN1.RF1R = (CAN1.RF1R & ~CAN_RF1R_FMP1) | ((val<<0) & CAN_RF1R_FMP1); }
static inline uint32_t can_rf1r_get_fmp1(void) { return (CAN1.RF1R & CAN_RF1R_FMP1) >> 0 ; }

// CAN->IER interrupt enable register
enum {
	CAN_IER_SLKIE = 1UL<<17, // SLKIE
	CAN_IER_WKUIE = 1UL<<16, // WKUIE
	CAN_IER_ERRIE = 1UL<<15, // ERRIE
	CAN_IER_LECIE = 1UL<<11, // LECIE
	CAN_IER_BOFIE = 1UL<<10, // BOFIE
	CAN_IER_EPVIE = 1UL<<9, // EPVIE
	CAN_IER_EWGIE = 1UL<<8, // EWGIE
	CAN_IER_FOVIE1 = 1UL<<6, // FOVIE1
	CAN_IER_FFIE1 = 1UL<<5, // FFIE1
	CAN_IER_FMPIE1 = 1UL<<4, // FMPIE1
	CAN_IER_FOVIE0 = 1UL<<3, // FOVIE0
	CAN_IER_FFIE0 = 1UL<<2, // FFIE0
	CAN_IER_FMPIE0 = 1UL<<1, // FMPIE0
	CAN_IER_TMEIE = 1UL<<0, // TMEIE		
};

// CAN->ESR interrupt enable register
enum {
	CAN_ESR_REC = ((1UL<<8)-1) << 24, // REC
	CAN_ESR_TEC = ((1UL<<8)-1) << 16, // TEC
	CAN_ESR_LEC = ((1UL<<3)-1) << 4, // LEC
	CAN_ESR_BOFF = 1UL<<2, // BOFF
	CAN_ESR_EPVF = 1UL<<1, // EPVF
	CAN_ESR_EWGF = 1UL<<0, // EWGF		
};
static inline void can_esr_set_rec(uint32_t val) { CAN1.ESR = (CAN1.ESR & ~CAN_ESR_REC) | ((val<<24) & CAN_ESR_REC); }
static inline void can_esr_set_tec(uint32_t val) { CAN1.ESR = (CAN1.ESR & ~CAN_ESR_TEC) | ((val<<16) & CAN_ESR_TEC); }
static inline void can_esr_set_lec(uint32_t val) { CAN1.ESR = (CAN1.ESR & ~CAN_ESR_LEC) | ((val<<4) & CAN_ESR_LEC); }
static inline uint32_t can_esr_get_rec(void) { return (CAN1.ESR & CAN_ESR_REC) >> 24 ; }
static inline uint32_t can_esr_get_tec(void) { return (CAN1.ESR & CAN_ESR_TEC) >> 16 ; }
static inline uint32_t can_esr_get_lec(void) { return (CAN1.ESR & CAN_ESR_LEC) >> 4 ; }

// CAN->BTR bit timing register
enum {
	CAN_BTR_SILM = 1UL<<31, // SILM
	CAN_BTR_LBKM = 1UL<<30, // LBKM
	CAN_BTR_SJW = ((1UL<<2)-1) << 24, // SJW
	CAN_BTR_TS2 = ((1UL<<3)-1) << 20, // TS2
	CAN_BTR_TS1 = ((1UL<<4)-1) << 16, // TS1
	CAN_BTR_BRP = ((1UL<<10)-1) << 0, // BRP		
};
static inline void can_btr_set_sjw(uint32_t val) { CAN1.BTR = (CAN1.BTR & ~CAN_BTR_SJW) | ((val<<24) & CAN_BTR_SJW); }
static inline void can_btr_set_ts2(uint32_t val) { CAN1.BTR = (CAN1.BTR & ~CAN_BTR_TS2) | ((val<<20) & CAN_BTR_TS2); }
static inline void can_btr_set_ts1(uint32_t val) { CAN1.BTR = (CAN1.BTR & ~CAN_BTR_TS1) | ((val<<16) & CAN_BTR_TS1); }
static inline void can_btr_set_brp(uint32_t val) { CAN1.BTR = (CAN1.BTR & ~CAN_BTR_BRP) | ((val<<0) & CAN_BTR_BRP); }
static inline uint32_t can_btr_get_sjw(void) { return (CAN1.BTR & CAN_BTR_SJW) >> 24 ; }
static inline uint32_t can_btr_get_ts2(void) { return (CAN1.BTR & CAN_BTR_TS2) >> 20 ; }
static inline uint32_t can_btr_get_ts1(void) { return (CAN1.BTR & CAN_BTR_TS1) >> 16 ; }
static inline uint32_t can_btr_get_brp(void) { return (CAN1.BTR & CAN_BTR_BRP) >> 0 ; }

// CAN->TI0R TX mailbox identifier register
enum {
	CAN_TI0R_STID = ((1UL<<11)-1) << 21, // STID
	CAN_TI0R_EXID = ((1UL<<18)-1) << 3, // EXID
	CAN_TI0R_IDE = 1UL<<2, // IDE
	CAN_TI0R_RTR = 1UL<<1, // RTR
	CAN_TI0R_TXRQ = 1UL<<0, // TXRQ		
};
static inline void can_ti0r_set_stid(uint32_t val) { CAN1.TI0R = (CAN1.TI0R & ~CAN_TI0R_STID) | ((val<<21) & CAN_TI0R_STID); }
static inline void can_ti0r_set_exid(uint32_t val) { CAN1.TI0R = (CAN1.TI0R & ~CAN_TI0R_EXID) | ((val<<3) & CAN_TI0R_EXID); }
static inline uint32_t can_ti0r_get_stid(void) { return (CAN1.TI0R & CAN_TI0R_STID) >> 21 ; }
static inline uint32_t can_ti0r_get_exid(void) { return (CAN1.TI0R & CAN_TI0R_EXID) >> 3 ; }

// CAN->TDT0R mailbox data length control and time stamp register
enum {
	CAN_TDT0R_TIME = ((1UL<<16)-1) << 16, // TIME
	CAN_TDT0R_TGT = 1UL<<8, // TGT
	CAN_TDT0R_DLC = ((1UL<<4)-1) << 0, // DLC		
};
static inline void can_tdt0r_set_time(uint32_t val) { CAN1.TDT0R = (CAN1.TDT0R & ~CAN_TDT0R_TIME) | ((val<<16) & CAN_TDT0R_TIME); }
static inline void can_tdt0r_set_dlc(uint32_t val) { CAN1.TDT0R = (CAN1.TDT0R & ~CAN_TDT0R_DLC) | ((val<<0) & CAN_TDT0R_DLC); }
static inline uint32_t can_tdt0r_get_time(void) { return (CAN1.TDT0R & CAN_TDT0R_TIME) >> 16 ; }
static inline uint32_t can_tdt0r_get_dlc(void) { return (CAN1.TDT0R & CAN_TDT0R_DLC) >> 0 ; }

// CAN->TDL0R mailbox data low register
enum {
	CAN_TDL0R_DATA3 = ((1UL<<8)-1) << 24, // DATA3
	CAN_TDL0R_DATA2 = ((1UL<<8)-1) << 16, // DATA2
	CAN_TDL0R_DATA1 = ((1UL<<8)-1) << 8, // DATA1
	CAN_TDL0R_DATA0 = ((1UL<<8)-1) << 0, // DATA0		
};
static inline void can_tdl0r_set_data3(uint32_t val) { CAN1.TDL0R = (CAN1.TDL0R & ~CAN_TDL0R_DATA3) | ((val<<24) & CAN_TDL0R_DATA3); }
static inline void can_tdl0r_set_data2(uint32_t val) { CAN1.TDL0R = (CAN1.TDL0R & ~CAN_TDL0R_DATA2) | ((val<<16) & CAN_TDL0R_DATA2); }
static inline void can_tdl0r_set_data1(uint32_t val) { CAN1.TDL0R = (CAN1.TDL0R & ~CAN_TDL0R_DATA1) | ((val<<8) & CAN_TDL0R_DATA1); }
static inline void can_tdl0r_set_data0(uint32_t val) { CAN1.TDL0R = (CAN1.TDL0R & ~CAN_TDL0R_DATA0) | ((val<<0) & CAN_TDL0R_DATA0); }
static inline uint32_t can_tdl0r_get_data3(void) { return (CAN1.TDL0R & CAN_TDL0R_DATA3) >> 24 ; }
static inline uint32_t can_tdl0r_get_data2(void) { return (CAN1.TDL0R & CAN_TDL0R_DATA2) >> 16 ; }
static inline uint32_t can_tdl0r_get_data1(void) { return (CAN1.TDL0R & CAN_TDL0R_DATA1) >> 8 ; }
static inline uint32_t can_tdl0r_get_data0(void) { return (CAN1.TDL0R & CAN_TDL0R_DATA0) >> 0 ; }

// CAN->TDH0R mailbox data high register
enum {
	CAN_TDH0R_DATA7 = ((1UL<<8)-1) << 24, // DATA7
	CAN_TDH0R_DATA6 = ((1UL<<8)-1) << 16, // DATA6
	CAN_TDH0R_DATA5 = ((1UL<<8)-1) << 8, // DATA5
	CAN_TDH0R_DATA4 = ((1UL<<8)-1) << 0, // DATA4		
};
static inline void can_tdh0r_set_data7(uint32_t val) { CAN1.TDH0R = (CAN1.TDH0R & ~CAN_TDH0R_DATA7) | ((val<<24) & CAN_TDH0R_DATA7); }
static inline void can_tdh0r_set_data6(uint32_t val) { CAN1.TDH0R = (CAN1.TDH0R & ~CAN_TDH0R_DATA6) | ((val<<16) & CAN_TDH0R_DATA6); }
static inline void can_tdh0r_set_data5(uint32_t val) { CAN1.TDH0R = (CAN1.TDH0R & ~CAN_TDH0R_DATA5) | ((val<<8) & CAN_TDH0R_DATA5); }
static inline void can_tdh0r_set_data4(uint32_t val) { CAN1.TDH0R = (CAN1.TDH0R & ~CAN_TDH0R_DATA4) | ((val<<0) & CAN_TDH0R_DATA4); }
static inline uint32_t can_tdh0r_get_data7(void) { return (CAN1.TDH0R & CAN_TDH0R_DATA7) >> 24 ; }
static inline uint32_t can_tdh0r_get_data6(void) { return (CAN1.TDH0R & CAN_TDH0R_DATA6) >> 16 ; }
static inline uint32_t can_tdh0r_get_data5(void) { return (CAN1.TDH0R & CAN_TDH0R_DATA5) >> 8 ; }
static inline uint32_t can_tdh0r_get_data4(void) { return (CAN1.TDH0R & CAN_TDH0R_DATA4) >> 0 ; }

// CAN->TI1R mailbox identifier register
enum {
	CAN_TI1R_STID = ((1UL<<11)-1) << 21, // STID
	CAN_TI1R_EXID = ((1UL<<18)-1) << 3, // EXID
	CAN_TI1R_IDE = 1UL<<2, // IDE
	CAN_TI1R_RTR = 1UL<<1, // RTR
	CAN_TI1R_TXRQ = 1UL<<0, // TXRQ		
};
static inline void can_ti1r_set_stid(uint32_t val) { CAN1.TI1R = (CAN1.TI1R & ~CAN_TI1R_STID) | ((val<<21) & CAN_TI1R_STID); }
static inline void can_ti1r_set_exid(uint32_t val) { CAN1.TI1R = (CAN1.TI1R & ~CAN_TI1R_EXID) | ((val<<3) & CAN_TI1R_EXID); }
static inline uint32_t can_ti1r_get_stid(void) { return (CAN1.TI1R & CAN_TI1R_STID) >> 21 ; }
static inline uint32_t can_ti1r_get_exid(void) { return (CAN1.TI1R & CAN_TI1R_EXID) >> 3 ; }

// CAN->TDT1R mailbox data length control and time stamp register
enum {
	CAN_TDT1R_TIME = ((1UL<<16)-1) << 16, // TIME
	CAN_TDT1R_TGT = 1UL<<8, // TGT
	CAN_TDT1R_DLC = ((1UL<<4)-1) << 0, // DLC		
};
static inline void can_tdt1r_set_time(uint32_t val) { CAN1.TDT1R = (CAN1.TDT1R & ~CAN_TDT1R_TIME) | ((val<<16) & CAN_TDT1R_TIME); }
static inline void can_tdt1r_set_dlc(uint32_t val) { CAN1.TDT1R = (CAN1.TDT1R & ~CAN_TDT1R_DLC) | ((val<<0) & CAN_TDT1R_DLC); }
static inline uint32_t can_tdt1r_get_time(void) { return (CAN1.TDT1R & CAN_TDT1R_TIME) >> 16 ; }
static inline uint32_t can_tdt1r_get_dlc(void) { return (CAN1.TDT1R & CAN_TDT1R_DLC) >> 0 ; }

// CAN->TDL1R mailbox data low register
enum {
	CAN_TDL1R_DATA3 = ((1UL<<8)-1) << 24, // DATA3
	CAN_TDL1R_DATA2 = ((1UL<<8)-1) << 16, // DATA2
	CAN_TDL1R_DATA1 = ((1UL<<8)-1) << 8, // DATA1
	CAN_TDL1R_DATA0 = ((1UL<<8)-1) << 0, // DATA0		
};
static inline void can_tdl1r_set_data3(uint32_t val) { CAN1.TDL1R = (CAN1.TDL1R & ~CAN_TDL1R_DATA3) | ((val<<24) & CAN_TDL1R_DATA3); }
static inline void can_tdl1r_set_data2(uint32_t val) { CAN1.TDL1R = (CAN1.TDL1R & ~CAN_TDL1R_DATA2) | ((val<<16) & CAN_TDL1R_DATA2); }
static inline void can_tdl1r_set_data1(uint32_t val) { CAN1.TDL1R = (CAN1.TDL1R & ~CAN_TDL1R_DATA1) | ((val<<8) & CAN_TDL1R_DATA1); }
static inline void can_tdl1r_set_data0(uint32_t val) { CAN1.TDL1R = (CAN1.TDL1R & ~CAN_TDL1R_DATA0) | ((val<<0) & CAN_TDL1R_DATA0); }
static inline uint32_t can_tdl1r_get_data3(void) { return (CAN1.TDL1R & CAN_TDL1R_DATA3) >> 24 ; }
static inline uint32_t can_tdl1r_get_data2(void) { return (CAN1.TDL1R & CAN_TDL1R_DATA2) >> 16 ; }
static inline uint32_t can_tdl1r_get_data1(void) { return (CAN1.TDL1R & CAN_TDL1R_DATA1) >> 8 ; }
static inline uint32_t can_tdl1r_get_data0(void) { return (CAN1.TDL1R & CAN_TDL1R_DATA0) >> 0 ; }

// CAN->TDH1R mailbox data high register
enum {
	CAN_TDH1R_DATA7 = ((1UL<<8)-1) << 24, // DATA7
	CAN_TDH1R_DATA6 = ((1UL<<8)-1) << 16, // DATA6
	CAN_TDH1R_DATA5 = ((1UL<<8)-1) << 8, // DATA5
	CAN_TDH1R_DATA4 = ((1UL<<8)-1) << 0, // DATA4		
};
static inline void can_tdh1r_set_data7(uint32_t val) { CAN1.TDH1R = (CAN1.TDH1R & ~CAN_TDH1R_DATA7) | ((val<<24) & CAN_TDH1R_DATA7); }
static inline void can_tdh1r_set_data6(uint32_t val) { CAN1.TDH1R = (CAN1.TDH1R & ~CAN_TDH1R_DATA6) | ((val<<16) & CAN_TDH1R_DATA6); }
static inline void can_tdh1r_set_data5(uint32_t val) { CAN1.TDH1R = (CAN1.TDH1R & ~CAN_TDH1R_DATA5) | ((val<<8) & CAN_TDH1R_DATA5); }
static inline void can_tdh1r_set_data4(uint32_t val) { CAN1.TDH1R = (CAN1.TDH1R & ~CAN_TDH1R_DATA4) | ((val<<0) & CAN_TDH1R_DATA4); }
static inline uint32_t can_tdh1r_get_data7(void) { return (CAN1.TDH1R & CAN_TDH1R_DATA7) >> 24 ; }
static inline uint32_t can_tdh1r_get_data6(void) { return (CAN1.TDH1R & CAN_TDH1R_DATA6) >> 16 ; }
static inline uint32_t can_tdh1r_get_data5(void) { return (CAN1.TDH1R & CAN_TDH1R_DATA5) >> 8 ; }
static inline uint32_t can_tdh1r_get_data4(void) { return (CAN1.TDH1R & CAN_TDH1R_DATA4) >> 0 ; }

// CAN->TI2R mailbox identifier register
enum {
	CAN_TI2R_STID = ((1UL<<11)-1) << 21, // STID
	CAN_TI2R_EXID = ((1UL<<18)-1) << 3, // EXID
	CAN_TI2R_IDE = 1UL<<2, // IDE
	CAN_TI2R_RTR = 1UL<<1, // RTR
	CAN_TI2R_TXRQ = 1UL<<0, // TXRQ		
};
static inline void can_ti2r_set_stid(uint32_t val) { CAN1.TI2R = (CAN1.TI2R & ~CAN_TI2R_STID) | ((val<<21) & CAN_TI2R_STID); }
static inline void can_ti2r_set_exid(uint32_t val) { CAN1.TI2R = (CAN1.TI2R & ~CAN_TI2R_EXID) | ((val<<3) & CAN_TI2R_EXID); }
static inline uint32_t can_ti2r_get_stid(void) { return (CAN1.TI2R & CAN_TI2R_STID) >> 21 ; }
static inline uint32_t can_ti2r_get_exid(void) { return (CAN1.TI2R & CAN_TI2R_EXID) >> 3 ; }

// CAN->TDT2R mailbox data length control and time stamp register
enum {
	CAN_TDT2R_TIME = ((1UL<<16)-1) << 16, // TIME
	CAN_TDT2R_TGT = 1UL<<8, // TGT
	CAN_TDT2R_DLC = ((1UL<<4)-1) << 0, // DLC		
};
static inline void can_tdt2r_set_time(uint32_t val) { CAN1.TDT2R = (CAN1.TDT2R & ~CAN_TDT2R_TIME) | ((val<<16) & CAN_TDT2R_TIME); }
static inline void can_tdt2r_set_dlc(uint32_t val) { CAN1.TDT2R = (CAN1.TDT2R & ~CAN_TDT2R_DLC) | ((val<<0) & CAN_TDT2R_DLC); }
static inline uint32_t can_tdt2r_get_time(void) { return (CAN1.TDT2R & CAN_TDT2R_TIME) >> 16 ; }
static inline uint32_t can_tdt2r_get_dlc(void) { return (CAN1.TDT2R & CAN_TDT2R_DLC) >> 0 ; }

// CAN->TDL2R mailbox data low register
enum {
	CAN_TDL2R_DATA3 = ((1UL<<8)-1) << 24, // DATA3
	CAN_TDL2R_DATA2 = ((1UL<<8)-1) << 16, // DATA2
	CAN_TDL2R_DATA1 = ((1UL<<8)-1) << 8, // DATA1
	CAN_TDL2R_DATA0 = ((1UL<<8)-1) << 0, // DATA0		
};
static inline void can_tdl2r_set_data3(uint32_t val) { CAN1.TDL2R = (CAN1.TDL2R & ~CAN_TDL2R_DATA3) | ((val<<24) & CAN_TDL2R_DATA3); }
static inline void can_tdl2r_set_data2(uint32_t val) { CAN1.TDL2R = (CAN1.TDL2R & ~CAN_TDL2R_DATA2) | ((val<<16) & CAN_TDL2R_DATA2); }
static inline void can_tdl2r_set_data1(uint32_t val) { CAN1.TDL2R = (CAN1.TDL2R & ~CAN_TDL2R_DATA1) | ((val<<8) & CAN_TDL2R_DATA1); }
static inline void can_tdl2r_set_data0(uint32_t val) { CAN1.TDL2R = (CAN1.TDL2R & ~CAN_TDL2R_DATA0) | ((val<<0) & CAN_TDL2R_DATA0); }
static inline uint32_t can_tdl2r_get_data3(void) { return (CAN1.TDL2R & CAN_TDL2R_DATA3) >> 24 ; }
static inline uint32_t can_tdl2r_get_data2(void) { return (CAN1.TDL2R & CAN_TDL2R_DATA2) >> 16 ; }
static inline uint32_t can_tdl2r_get_data1(void) { return (CAN1.TDL2R & CAN_TDL2R_DATA1) >> 8 ; }
static inline uint32_t can_tdl2r_get_data0(void) { return (CAN1.TDL2R & CAN_TDL2R_DATA0) >> 0 ; }

// CAN->TDH2R mailbox data high register
enum {
	CAN_TDH2R_DATA7 = ((1UL<<8)-1) << 24, // DATA7
	CAN_TDH2R_DATA6 = ((1UL<<8)-1) << 16, // DATA6
	CAN_TDH2R_DATA5 = ((1UL<<8)-1) << 8, // DATA5
	CAN_TDH2R_DATA4 = ((1UL<<8)-1) << 0, // DATA4		
};
static inline void can_tdh2r_set_data7(uint32_t val) { CAN1.TDH2R = (CAN1.TDH2R & ~CAN_TDH2R_DATA7) | ((val<<24) & CAN_TDH2R_DATA7); }
static inline void can_tdh2r_set_data6(uint32_t val) { CAN1.TDH2R = (CAN1.TDH2R & ~CAN_TDH2R_DATA6) | ((val<<16) & CAN_TDH2R_DATA6); }
static inline void can_tdh2r_set_data5(uint32_t val) { CAN1.TDH2R = (CAN1.TDH2R & ~CAN_TDH2R_DATA5) | ((val<<8) & CAN_TDH2R_DATA5); }
static inline void can_tdh2r_set_data4(uint32_t val) { CAN1.TDH2R = (CAN1.TDH2R & ~CAN_TDH2R_DATA4) | ((val<<0) & CAN_TDH2R_DATA4); }
static inline uint32_t can_tdh2r_get_data7(void) { return (CAN1.TDH2R & CAN_TDH2R_DATA7) >> 24 ; }
static inline uint32_t can_tdh2r_get_data6(void) { return (CAN1.TDH2R & CAN_TDH2R_DATA6) >> 16 ; }
static inline uint32_t can_tdh2r_get_data5(void) { return (CAN1.TDH2R & CAN_TDH2R_DATA5) >> 8 ; }
static inline uint32_t can_tdh2r_get_data4(void) { return (CAN1.TDH2R & CAN_TDH2R_DATA4) >> 0 ; }

// CAN->RI0R receive FIFO mailbox identifier register
enum {
	CAN_RI0R_STID = ((1UL<<11)-1) << 21, // STID
	CAN_RI0R_EXID = ((1UL<<18)-1) << 3, // EXID
	CAN_RI0R_IDE = 1UL<<2, // IDE
	CAN_RI0R_RTR = 1UL<<1, // RTR		
};
static inline uint32_t can_ri0r_get_stid(void) { return (CAN1.RI0R & CAN_RI0R_STID) >> 21 ; }
static inline uint32_t can_ri0r_get_exid(void) { return (CAN1.RI0R & CAN_RI0R_EXID) >> 3 ; }

// CAN->RDT0R mailbox data high register
enum {
	CAN_RDT0R_TIME = ((1UL<<16)-1) << 16, // TIME
	CAN_RDT0R_FMI = ((1UL<<8)-1) << 8, // FMI
	CAN_RDT0R_DLC = ((1UL<<4)-1) << 0, // DLC		
};
static inline uint32_t can_rdt0r_get_time(void) { return (CAN1.RDT0R & CAN_RDT0R_TIME) >> 16 ; }
static inline uint32_t can_rdt0r_get_fmi(void) { return (CAN1.RDT0R & CAN_RDT0R_FMI) >> 8 ; }
static inline uint32_t can_rdt0r_get_dlc(void) { return (CAN1.RDT0R & CAN_RDT0R_DLC) >> 0 ; }

// CAN->RDL0R mailbox data high register
enum {
	CAN_RDL0R_DATA3 = ((1UL<<8)-1) << 24, // DATA3
	CAN_RDL0R_DATA2 = ((1UL<<8)-1) << 16, // DATA2
	CAN_RDL0R_DATA1 = ((1UL<<8)-1) << 8, // DATA1
	CAN_RDL0R_DATA0 = ((1UL<<8)-1) << 0, // DATA0		
};
static inline uint32_t can_rdl0r_get_data3(void) { return (CAN1.RDL0R & CAN_RDL0R_DATA3) >> 24 ; }
static inline uint32_t can_rdl0r_get_data2(void) { return (CAN1.RDL0R & CAN_RDL0R_DATA2) >> 16 ; }
static inline uint32_t can_rdl0r_get_data1(void) { return (CAN1.RDL0R & CAN_RDL0R_DATA1) >> 8 ; }
static inline uint32_t can_rdl0r_get_data0(void) { return (CAN1.RDL0R & CAN_RDL0R_DATA0) >> 0 ; }

// CAN->RDH0R receive FIFO mailbox data high register
enum {
	CAN_RDH0R_DATA7 = ((1UL<<8)-1) << 24, // DATA7
	CAN_RDH0R_DATA6 = ((1UL<<8)-1) << 16, // DATA6
	CAN_RDH0R_DATA5 = ((1UL<<8)-1) << 8, // DATA5
	CAN_RDH0R_DATA4 = ((1UL<<8)-1) << 0, // DATA4		
};
static inline uint32_t can_rdh0r_get_data7(void) { return (CAN1.RDH0R & CAN_RDH0R_DATA7) >> 24 ; }
static inline uint32_t can_rdh0r_get_data6(void) { return (CAN1.RDH0R & CAN_RDH0R_DATA6) >> 16 ; }
static inline uint32_t can_rdh0r_get_data5(void) { return (CAN1.RDH0R & CAN_RDH0R_DATA5) >> 8 ; }
static inline uint32_t can_rdh0r_get_data4(void) { return (CAN1.RDH0R & CAN_RDH0R_DATA4) >> 0 ; }

// CAN->RI1R mailbox data high register
enum {
	CAN_RI1R_STID = ((1UL<<11)-1) << 21, // STID
	CAN_RI1R_EXID = ((1UL<<18)-1) << 3, // EXID
	CAN_RI1R_IDE = 1UL<<2, // IDE
	CAN_RI1R_RTR = 1UL<<1, // RTR		
};
static inline uint32_t can_ri1r_get_stid(void) { return (CAN1.RI1R & CAN_RI1R_STID) >> 21 ; }
static inline uint32_t can_ri1r_get_exid(void) { return (CAN1.RI1R & CAN_RI1R_EXID) >> 3 ; }

// CAN->RDT1R mailbox data high register
enum {
	CAN_RDT1R_TIME = ((1UL<<16)-1) << 16, // TIME
	CAN_RDT1R_FMI = ((1UL<<8)-1) << 8, // FMI
	CAN_RDT1R_DLC = ((1UL<<4)-1) << 0, // DLC		
};
static inline uint32_t can_rdt1r_get_time(void) { return (CAN1.RDT1R & CAN_RDT1R_TIME) >> 16 ; }
static inline uint32_t can_rdt1r_get_fmi(void) { return (CAN1.RDT1R & CAN_RDT1R_FMI) >> 8 ; }
static inline uint32_t can_rdt1r_get_dlc(void) { return (CAN1.RDT1R & CAN_RDT1R_DLC) >> 0 ; }

// CAN->RDL1R mailbox data high register
enum {
	CAN_RDL1R_DATA3 = ((1UL<<8)-1) << 24, // DATA3
	CAN_RDL1R_DATA2 = ((1UL<<8)-1) << 16, // DATA2
	CAN_RDL1R_DATA1 = ((1UL<<8)-1) << 8, // DATA1
	CAN_RDL1R_DATA0 = ((1UL<<8)-1) << 0, // DATA0		
};
static inline uint32_t can_rdl1r_get_data3(void) { return (CAN1.RDL1R & CAN_RDL1R_DATA3) >> 24 ; }
static inline uint32_t can_rdl1r_get_data2(void) { return (CAN1.RDL1R & CAN_RDL1R_DATA2) >> 16 ; }
static inline uint32_t can_rdl1r_get_data1(void) { return (CAN1.RDL1R & CAN_RDL1R_DATA1) >> 8 ; }
static inline uint32_t can_rdl1r_get_data0(void) { return (CAN1.RDL1R & CAN_RDL1R_DATA0) >> 0 ; }

// CAN->RDH1R mailbox data high register
enum {
	CAN_RDH1R_DATA7 = ((1UL<<8)-1) << 24, // DATA7
	CAN_RDH1R_DATA6 = ((1UL<<8)-1) << 16, // DATA6
	CAN_RDH1R_DATA5 = ((1UL<<8)-1) << 8, // DATA5
	CAN_RDH1R_DATA4 = ((1UL<<8)-1) << 0, // DATA4		
};
static inline uint32_t can_rdh1r_get_data7(void) { return (CAN1.RDH1R & CAN_RDH1R_DATA7) >> 24 ; }
static inline uint32_t can_rdh1r_get_data6(void) { return (CAN1.RDH1R & CAN_RDH1R_DATA6) >> 16 ; }
static inline uint32_t can_rdh1r_get_data5(void) { return (CAN1.RDH1R & CAN_RDH1R_DATA5) >> 8 ; }
static inline uint32_t can_rdh1r_get_data4(void) { return (CAN1.RDH1R & CAN_RDH1R_DATA4) >> 0 ; }

// CAN->FMR filter master register
enum {
	CAN_FMR_FINIT = 1UL<<0, // Filter initialization mode		
};

// CAN->FM1R filter mode register
enum {
	CAN_FM1R_FBMX  = ((1UL<<14)-1) << 0, // Merged Filter mode		
};
static inline void can_fm1r_set_fbmx (uint32_t val) { CAN1.FM1R = (CAN1.FM1R & ~CAN_FM1R_FBMX ) | ((val<<0) & CAN_FM1R_FBMX ); }
static inline uint32_t can_fm1r_get_fbmx (void) { return (CAN1.FM1R & CAN_FM1R_FBMX ) >> 0 ; }

// CAN->FS1R filter scale register
enum {
	CAN_FS1R_FSCX  = ((1UL<<14)-1) << 0, // Merged Filter scale configuration		
};
static inline void can_fs1r_set_fscx (uint32_t val) { CAN1.FS1R = (CAN1.FS1R & ~CAN_FS1R_FSCX ) | ((val<<0) & CAN_FS1R_FSCX ); }
static inline uint32_t can_fs1r_get_fscx (void) { return (CAN1.FS1R & CAN_FS1R_FSCX ) >> 0 ; }

// CAN->FFA1R filter FIFO assignment register
enum {
	CAN_FFA1R_FFAX  = ((1UL<<14)-1) << 0, // Merged Filter FIFO assignment for filter 13		
};
static inline void can_ffa1r_set_ffax (uint32_t val) { CAN1.FFA1R = (CAN1.FFA1R & ~CAN_FFA1R_FFAX ) | ((val<<0) & CAN_FFA1R_FFAX ); }
static inline uint32_t can_ffa1r_get_ffax (void) { return (CAN1.FFA1R & CAN_FFA1R_FFAX ) >> 0 ; }

// CAN->FA1R filter activation register
enum {
	CAN_FA1R_FACTX  = ((1UL<<14)-1) << 0, // Merged Filter active		
};
static inline void can_fa1r_set_factx (uint32_t val) { CAN1.FA1R = (CAN1.FA1R & ~CAN_FA1R_FACTX ) | ((val<<0) & CAN_FA1R_FACTX ); }
static inline uint32_t can_fa1r_get_factx (void) { return (CAN1.FA1R & CAN_FA1R_FACTX ) >> 0 ; }

/* Comparator
There is only one peripheral of type COMP. */
struct COMP_Type {
	__IO uint32_t COMP1_CSR; // @0 Comparator 1 control and status register
	__IO uint32_t COMP2_CSR; // @4 Comparator 2 control and status register
};
extern struct COMP_Type	COMP;	// @0x40010200 

// COMP->COMP1_CSR Comparator 1 control and status register
enum {
	COMP_COMP1_CSR_COMP1_LOCK = 1UL<<31, // COMP1_CSR register lock bit
	COMP_COMP1_CSR_COMP1_VALUE = 1UL<<30, // Comparator 1 output status bit
	COMP_COMP1_CSR_COMP1_INMESEL = ((1UL<<2)-1) << 25, // comparator 1 input minus extended selection bits
	COMP_COMP1_CSR_COMP1_SCALEN = 1UL<<23, // Voltage scaler enable bit
	COMP_COMP1_CSR_COMP1_BRGEN = 1UL<<22, // Scaler bridge enable
	COMP_COMP1_CSR_COMP1_BLANKING = ((1UL<<3)-1) << 18, // Comparator 1 blanking source selection bits
	COMP_COMP1_CSR_COMP1_HYST = ((1UL<<2)-1) << 16, // Comparator 1 hysteresis selection bits
	COMP_COMP1_CSR_COMP1_POLARITY = 1UL<<15, // Comparator 1 polarity selection bit
	COMP_COMP1_CSR_COMP1_INPSEL = ((1UL<<2)-1) << 7, // Comparator1 input plus selection bit
	COMP_COMP1_CSR_COMP1_INMSEL = ((1UL<<3)-1) << 4, // Comparator 1 Input Minus connection configuration bit
	COMP_COMP1_CSR_COMP1_PWRMODE = ((1UL<<2)-1) << 2, // Power Mode of the comparator 1
	COMP_COMP1_CSR_COMP1_EN = 1UL<<0, // Comparator 1 enable bit		
};
static inline void comp_comp1_csr_set_comp1_inmesel(uint32_t val) { COMP.COMP1_CSR = (COMP.COMP1_CSR & ~COMP_COMP1_CSR_COMP1_INMESEL) | ((val<<25) & COMP_COMP1_CSR_COMP1_INMESEL); }
static inline void comp_comp1_csr_set_comp1_blanking(uint32_t val) { COMP.COMP1_CSR = (COMP.COMP1_CSR & ~COMP_COMP1_CSR_COMP1_BLANKING) | ((val<<18) & COMP_COMP1_CSR_COMP1_BLANKING); }
static inline void comp_comp1_csr_set_comp1_hyst(uint32_t val) { COMP.COMP1_CSR = (COMP.COMP1_CSR & ~COMP_COMP1_CSR_COMP1_HYST) | ((val<<16) & COMP_COMP1_CSR_COMP1_HYST); }
static inline void comp_comp1_csr_set_comp1_inpsel(uint32_t val) { COMP.COMP1_CSR = (COMP.COMP1_CSR & ~COMP_COMP1_CSR_COMP1_INPSEL) | ((val<<7) & COMP_COMP1_CSR_COMP1_INPSEL); }
static inline void comp_comp1_csr_set_comp1_inmsel(uint32_t val) { COMP.COMP1_CSR = (COMP.COMP1_CSR & ~COMP_COMP1_CSR_COMP1_INMSEL) | ((val<<4) & COMP_COMP1_CSR_COMP1_INMSEL); }
static inline void comp_comp1_csr_set_comp1_pwrmode(uint32_t val) { COMP.COMP1_CSR = (COMP.COMP1_CSR & ~COMP_COMP1_CSR_COMP1_PWRMODE) | ((val<<2) & COMP_COMP1_CSR_COMP1_PWRMODE); }
static inline uint32_t comp_comp1_csr_get_comp1_inmesel(void) { return (COMP.COMP1_CSR & COMP_COMP1_CSR_COMP1_INMESEL) >> 25 ; }
static inline uint32_t comp_comp1_csr_get_comp1_blanking(void) { return (COMP.COMP1_CSR & COMP_COMP1_CSR_COMP1_BLANKING) >> 18 ; }
static inline uint32_t comp_comp1_csr_get_comp1_hyst(void) { return (COMP.COMP1_CSR & COMP_COMP1_CSR_COMP1_HYST) >> 16 ; }
static inline uint32_t comp_comp1_csr_get_comp1_inpsel(void) { return (COMP.COMP1_CSR & COMP_COMP1_CSR_COMP1_INPSEL) >> 7 ; }
static inline uint32_t comp_comp1_csr_get_comp1_inmsel(void) { return (COMP.COMP1_CSR & COMP_COMP1_CSR_COMP1_INMSEL) >> 4 ; }
static inline uint32_t comp_comp1_csr_get_comp1_pwrmode(void) { return (COMP.COMP1_CSR & COMP_COMP1_CSR_COMP1_PWRMODE) >> 2 ; }

// COMP->COMP2_CSR Comparator 2 control and status register
enum {
	COMP_COMP2_CSR_COMP2_LOCK = 1UL<<31, // COMP2_CSR register lock bit
	COMP_COMP2_CSR_COMP2_VALUE = 1UL<<30, // Comparator 2 output status bit
	COMP_COMP2_CSR_COMP2_INMESEL = ((1UL<<2)-1) << 25, // comparator 2 input minus extended selection bits
	COMP_COMP2_CSR_COMP2_SCALEN = 1UL<<23, // Voltage scaler enable bit
	COMP_COMP2_CSR_COMP2_BRGEN = 1UL<<22, // Scaler bridge enable
	COMP_COMP2_CSR_COMP2_BLANKING = ((1UL<<3)-1) << 18, // Comparator 2 blanking source selection bits
	COMP_COMP2_CSR_COMP2_HYST = ((1UL<<2)-1) << 16, // Comparator 2 hysteresis selection bits
	COMP_COMP2_CSR_COMP2_POLARITY = 1UL<<15, // Comparator 2 polarity selection bit
	COMP_COMP2_CSR_COMP2_WINMODE = 1UL<<9, // Windows mode selection bit
	COMP_COMP2_CSR_COMP2_INPSEL = ((1UL<<2)-1) << 7, // Comparator 2 Input Plus connection configuration bit
	COMP_COMP2_CSR_COMP2_INMSEL = ((1UL<<3)-1) << 4, // Comparator 2 Input Minus connection configuration bit
	COMP_COMP2_CSR_COMP2_PWRMODE = ((1UL<<2)-1) << 2, // Power Mode of the comparator 2
	COMP_COMP2_CSR_COMP2_EN = 1UL<<0, // Comparator 2 enable bit		
};
static inline void comp_comp2_csr_set_comp2_inmesel(uint32_t val) { COMP.COMP2_CSR = (COMP.COMP2_CSR & ~COMP_COMP2_CSR_COMP2_INMESEL) | ((val<<25) & COMP_COMP2_CSR_COMP2_INMESEL); }
static inline void comp_comp2_csr_set_comp2_blanking(uint32_t val) { COMP.COMP2_CSR = (COMP.COMP2_CSR & ~COMP_COMP2_CSR_COMP2_BLANKING) | ((val<<18) & COMP_COMP2_CSR_COMP2_BLANKING); }
static inline void comp_comp2_csr_set_comp2_hyst(uint32_t val) { COMP.COMP2_CSR = (COMP.COMP2_CSR & ~COMP_COMP2_CSR_COMP2_HYST) | ((val<<16) & COMP_COMP2_CSR_COMP2_HYST); }
static inline void comp_comp2_csr_set_comp2_inpsel(uint32_t val) { COMP.COMP2_CSR = (COMP.COMP2_CSR & ~COMP_COMP2_CSR_COMP2_INPSEL) | ((val<<7) & COMP_COMP2_CSR_COMP2_INPSEL); }
static inline void comp_comp2_csr_set_comp2_inmsel(uint32_t val) { COMP.COMP2_CSR = (COMP.COMP2_CSR & ~COMP_COMP2_CSR_COMP2_INMSEL) | ((val<<4) & COMP_COMP2_CSR_COMP2_INMSEL); }
static inline void comp_comp2_csr_set_comp2_pwrmode(uint32_t val) { COMP.COMP2_CSR = (COMP.COMP2_CSR & ~COMP_COMP2_CSR_COMP2_PWRMODE) | ((val<<2) & COMP_COMP2_CSR_COMP2_PWRMODE); }
static inline uint32_t comp_comp2_csr_get_comp2_inmesel(void) { return (COMP.COMP2_CSR & COMP_COMP2_CSR_COMP2_INMESEL) >> 25 ; }
static inline uint32_t comp_comp2_csr_get_comp2_blanking(void) { return (COMP.COMP2_CSR & COMP_COMP2_CSR_COMP2_BLANKING) >> 18 ; }
static inline uint32_t comp_comp2_csr_get_comp2_hyst(void) { return (COMP.COMP2_CSR & COMP_COMP2_CSR_COMP2_HYST) >> 16 ; }
static inline uint32_t comp_comp2_csr_get_comp2_inpsel(void) { return (COMP.COMP2_CSR & COMP_COMP2_CSR_COMP2_INPSEL) >> 7 ; }
static inline uint32_t comp_comp2_csr_get_comp2_inmsel(void) { return (COMP.COMP2_CSR & COMP_COMP2_CSR_COMP2_INMSEL) >> 4 ; }
static inline uint32_t comp_comp2_csr_get_comp2_pwrmode(void) { return (COMP.COMP2_CSR & COMP_COMP2_CSR_COMP2_PWRMODE) >> 2 ; }

/* Cyclic redundancy check calculation unit
There is only one peripheral of type CRC. */
struct CRC_Type {
	__IO uint32_t DR; // @0 Data register
	__IO uint8_t IDR; // @4 Independent data register
	 uint8_t RESERVED0[3]; // @5 
	__IO uint8_t CR; // @8 Control register
	 uint8_t RESERVED1[7]; // @9 
	__IO uint32_t INIT; // @16 Initial CRC value
	__IO uint32_t POL; // @20 polynomial
};
extern struct CRC_Type	CRC;	// @0x40023000 

// CRC->CR Control register
enum {
	CRC_CR_REV_OUT = 1UL<<7, // Reverse output data
	CRC_CR_REV_IN = ((1UL<<2)-1) << 5, // Reverse input data
	CRC_CR_POLYSIZE = ((1UL<<2)-1) << 3, // Polynomial size
	CRC_CR_RESET = 1UL<<0, // RESET bit		
};
static inline void crc_cr_set_rev_in(uint32_t val) { CRC.CR = (CRC.CR & ~CRC_CR_REV_IN) | ((val<<5) & CRC_CR_REV_IN); }
static inline void crc_cr_set_polysize(uint32_t val) { CRC.CR = (CRC.CR & ~CRC_CR_POLYSIZE) | ((val<<3) & CRC_CR_POLYSIZE); }
static inline uint32_t crc_cr_get_rev_in(void) { return (CRC.CR & CRC_CR_REV_IN) >> 5 ; }
static inline uint32_t crc_cr_get_polysize(void) { return (CRC.CR & CRC_CR_POLYSIZE) >> 3 ; }

/* Clock recovery system
There is only one peripheral of type CRS. */
struct CRS_Type {
	__IO uint16_t CR; // @0 control register
	 uint8_t RESERVED0[2]; // @2 
	__IO uint32_t CFGR; // @4 configuration register
	__I uint32_t ISR; // @8 interrupt and status register
	__IO uint8_t ICR; // @12 interrupt flag clear register
};
extern struct CRS_Type	CRS;	// @0x40006000 

// CRS->CR control register
enum {
	CRS_CR_TRIM = ((1UL<<6)-1) << 8, // HSI48 oscillator smooth trimming
	CRS_CR_SWSYNC = 1UL<<7, // Generate software SYNC event
	CRS_CR_AUTOTRIMEN = 1UL<<6, // Automatic trimming enable
	CRS_CR_CEN = 1UL<<5, // Frequency error counter enable
	CRS_CR_ESYNCIE = 1UL<<3, // Expected SYNC interrupt enable
	CRS_CR_ERRIE = 1UL<<2, // Synchronization or trimming error interrupt enable
	CRS_CR_SYNCWARNIE = 1UL<<1, // SYNC warning interrupt enable
	CRS_CR_SYNCOKIE = 1UL<<0, // SYNC event OK interrupt enable		
};
static inline void crs_cr_set_trim(uint32_t val) { CRS.CR = (CRS.CR & ~CRS_CR_TRIM) | ((val<<8) & CRS_CR_TRIM); }
static inline uint32_t crs_cr_get_trim(void) { return (CRS.CR & CRS_CR_TRIM) >> 8 ; }

// CRS->CFGR configuration register
enum {
	CRS_CFGR_SYNCPOL = 1UL<<31, // SYNC polarity selection
	CRS_CFGR_SYNCSRC = ((1UL<<2)-1) << 28, // SYNC signal source selection
	CRS_CFGR_SYNCDIV = ((1UL<<3)-1) << 24, // SYNC divider
	CRS_CFGR_FELIM = ((1UL<<8)-1) << 16, // Frequency error limit
	CRS_CFGR_RELOAD = ((1UL<<16)-1) << 0, // Counter reload value		
};
static inline void crs_cfgr_set_syncsrc(uint32_t val) { CRS.CFGR = (CRS.CFGR & ~CRS_CFGR_SYNCSRC) | ((val<<28) & CRS_CFGR_SYNCSRC); }
static inline void crs_cfgr_set_syncdiv(uint32_t val) { CRS.CFGR = (CRS.CFGR & ~CRS_CFGR_SYNCDIV) | ((val<<24) & CRS_CFGR_SYNCDIV); }
static inline void crs_cfgr_set_felim(uint32_t val) { CRS.CFGR = (CRS.CFGR & ~CRS_CFGR_FELIM) | ((val<<16) & CRS_CFGR_FELIM); }
static inline void crs_cfgr_set_reload(uint32_t val) { CRS.CFGR = (CRS.CFGR & ~CRS_CFGR_RELOAD) | ((val<<0) & CRS_CFGR_RELOAD); }
static inline uint32_t crs_cfgr_get_syncsrc(void) { return (CRS.CFGR & CRS_CFGR_SYNCSRC) >> 28 ; }
static inline uint32_t crs_cfgr_get_syncdiv(void) { return (CRS.CFGR & CRS_CFGR_SYNCDIV) >> 24 ; }
static inline uint32_t crs_cfgr_get_felim(void) { return (CRS.CFGR & CRS_CFGR_FELIM) >> 16 ; }
static inline uint32_t crs_cfgr_get_reload(void) { return (CRS.CFGR & CRS_CFGR_RELOAD) >> 0 ; }

// CRS->ISR interrupt and status register
enum {
	CRS_ISR_FECAP = ((1UL<<16)-1) << 16, // Frequency error capture
	CRS_ISR_FEDIR = 1UL<<15, // Frequency error direction
	CRS_ISR_TRIMOVF = 1UL<<10, // Trimming overflow or underflow
	CRS_ISR_SYNCMISS = 1UL<<9, // SYNC missed
	CRS_ISR_SYNCERR = 1UL<<8, // SYNC error
	CRS_ISR_ESYNCF = 1UL<<3, // Expected SYNC flag
	CRS_ISR_ERRF = 1UL<<2, // Error flag
	CRS_ISR_SYNCWARNF = 1UL<<1, // SYNC warning flag
	CRS_ISR_SYNCOKF = 1UL<<0, // SYNC event OK flag		
};
static inline uint32_t crs_isr_get_fecap(void) { return (CRS.ISR & CRS_ISR_FECAP) >> 16 ; }

// CRS->ICR interrupt flag clear register
enum {
	CRS_ICR_ESYNCC = 1UL<<3, // Expected SYNC clear flag
	CRS_ICR_ERRC = 1UL<<2, // Error clear flag
	CRS_ICR_SYNCWARNC = 1UL<<1, // SYNC warning clear flag
	CRS_ICR_SYNCOKC = 1UL<<0, // SYNC event OK clear flag		
};

/* Digital-to-analog converter
There is only one peripheral of type DAC. */
struct DAC_Type {
	__IO uint32_t CR; // @0 control register
	__O uint8_t SWTRIGR; // @4 software trigger register
	 uint8_t RESERVED0[3]; // @5 
	__IO uint16_t DHR12R1; // @8 channel1 12-bit right-aligned data holding register
	 uint8_t RESERVED1[2]; // @10 
	__IO uint16_t DHR12L1; // @12 channel1 12-bit left-aligned data holding register
	 uint8_t RESERVED2[2]; // @14 
	__IO uint8_t DHR8R1; // @16 channel1 8-bit right-aligned data holding register
	 uint8_t RESERVED3[3]; // @17 
	__IO uint16_t DHR12R2; // @20 channel2 12-bit right aligned data holding register
	 uint8_t RESERVED4[2]; // @22 
	__IO uint16_t DHR12L2; // @24 channel2 12-bit left aligned data holding register
	 uint8_t RESERVED5[2]; // @26 
	__IO uint8_t DHR8R2; // @28 channel2 8-bit right-aligned data holding register
	 uint8_t RESERVED6[3]; // @29 
	__IO uint32_t DHR12RD; // @32 Dual DAC 12-bit right-aligned data holding register
	__IO uint32_t DHR12LD; // @36 DUAL DAC 12-bit left aligned data holding register
	__IO uint16_t DHR8RD; // @40 DUAL DAC 8-bit right aligned data holding register
	 uint8_t RESERVED7[2]; // @42 
	__I uint16_t DOR1; // @44 channel1 data output register
	 uint8_t RESERVED8[2]; // @46 
	__I uint16_t DOR2; // @48 channel2 data output register
	 uint8_t RESERVED9[2]; // @50 
	__IO uint32_t SR; // @52 status register
	__IO uint32_t CCR; // @56 calibration control register
	__IO uint32_t MCR; // @60 mode control register
	__IO uint16_t SHSR1; // @64 Sample and Hold sample time register 1
	 uint8_t RESERVED10[2]; // @66 
	__IO uint16_t SHSR2; // @68 Sample and Hold sample time register 2
	 uint8_t RESERVED11[2]; // @70 
	__IO uint32_t SHHR; // @72 Sample and Hold hold time register
	__IO uint32_t SHRR; // @76 Sample and Hold refresh time register
};
extern struct DAC_Type	DAC1;	// @0x40007400 

// DAC->CR control register
enum {
	DAC_CR_CEN2 = 1UL<<30, // DAC Channel 2 calibration enable
	DAC_CR_DMAUDRIE2 = 1UL<<29, // DAC channel2 DMA underrun interrupt enable
	DAC_CR_DMAEN2 = 1UL<<28, // DAC channel2 DMA enable
	DAC_CR_MAMP2 = ((1UL<<4)-1) << 24, // DAC channel2 mask/amplitude selector
	DAC_CR_WAVE2 = ((1UL<<2)-1) << 22, // DAC channel2 noise/triangle wave generation enable
	DAC_CR_TSEL2 = ((1UL<<3)-1) << 19, // DAC channel2 trigger selection
	DAC_CR_TEN2 = 1UL<<18, // DAC channel2 trigger enable
	DAC_CR_EN2 = 1UL<<16, // DAC channel2 enable
	DAC_CR_CEN1 = 1UL<<14, // DAC Channel 1 calibration enable
	DAC_CR_DMAUDRIE1 = 1UL<<13, // DAC channel1 DMA Underrun Interrupt enable
	DAC_CR_DMAEN1 = 1UL<<12, // DAC channel1 DMA enable
	DAC_CR_MAMP1 = ((1UL<<4)-1) << 8, // DAC channel1 mask/amplitude selector
	DAC_CR_WAVE1 = ((1UL<<2)-1) << 6, // DAC channel1 noise/triangle wave generation enable
	DAC_CR_TSEL1 = ((1UL<<3)-1) << 3, // DAC channel1 trigger selection
	DAC_CR_TEN1 = 1UL<<2, // DAC channel1 trigger enable
	DAC_CR_EN1 = 1UL<<0, // DAC channel1 enable		
};
static inline void dac_cr_set_mamp2(uint32_t val) { DAC1.CR = (DAC1.CR & ~DAC_CR_MAMP2) | ((val<<24) & DAC_CR_MAMP2); }
static inline void dac_cr_set_wave2(uint32_t val) { DAC1.CR = (DAC1.CR & ~DAC_CR_WAVE2) | ((val<<22) & DAC_CR_WAVE2); }
static inline void dac_cr_set_tsel2(uint32_t val) { DAC1.CR = (DAC1.CR & ~DAC_CR_TSEL2) | ((val<<19) & DAC_CR_TSEL2); }
static inline void dac_cr_set_mamp1(uint32_t val) { DAC1.CR = (DAC1.CR & ~DAC_CR_MAMP1) | ((val<<8) & DAC_CR_MAMP1); }
static inline void dac_cr_set_wave1(uint32_t val) { DAC1.CR = (DAC1.CR & ~DAC_CR_WAVE1) | ((val<<6) & DAC_CR_WAVE1); }
static inline void dac_cr_set_tsel1(uint32_t val) { DAC1.CR = (DAC1.CR & ~DAC_CR_TSEL1) | ((val<<3) & DAC_CR_TSEL1); }
static inline uint32_t dac_cr_get_mamp2(void) { return (DAC1.CR & DAC_CR_MAMP2) >> 24 ; }
static inline uint32_t dac_cr_get_wave2(void) { return (DAC1.CR & DAC_CR_WAVE2) >> 22 ; }
static inline uint32_t dac_cr_get_tsel2(void) { return (DAC1.CR & DAC_CR_TSEL2) >> 19 ; }
static inline uint32_t dac_cr_get_mamp1(void) { return (DAC1.CR & DAC_CR_MAMP1) >> 8 ; }
static inline uint32_t dac_cr_get_wave1(void) { return (DAC1.CR & DAC_CR_WAVE1) >> 6 ; }
static inline uint32_t dac_cr_get_tsel1(void) { return (DAC1.CR & DAC_CR_TSEL1) >> 3 ; }

// DAC->SWTRIGR software trigger register
enum {
	DAC_SWTRIGR_SWTRIGX  = ((1UL<<2)-1) << 0, // Merged DAC channel2 software trigger		
};
static inline void dac_swtrigr_set_swtrigx (uint32_t val) { DAC1.SWTRIGR = (DAC1.SWTRIGR & ~DAC_SWTRIGR_SWTRIGX ) | ((val<<0) & DAC_SWTRIGR_SWTRIGX ); }
static inline uint32_t dac_swtrigr_get_swtrigx (void) { return (DAC1.SWTRIGR & DAC_SWTRIGR_SWTRIGX ) >> 0 ; }

// DAC->DHR12R1 channel1 12-bit right-aligned data holding register
enum {
	DAC_DHR12R1_DACC1DHR = ((1UL<<12)-1) << 0, // DAC channel1 12-bit right-aligned data		
};
static inline void dac_dhr12r1_set_dacc1dhr(uint32_t val) { DAC1.DHR12R1 = (DAC1.DHR12R1 & ~DAC_DHR12R1_DACC1DHR) | ((val<<0) & DAC_DHR12R1_DACC1DHR); }
static inline uint32_t dac_dhr12r1_get_dacc1dhr(void) { return (DAC1.DHR12R1 & DAC_DHR12R1_DACC1DHR) >> 0 ; }

// DAC->DHR12L1 channel1 12-bit left-aligned data holding register
enum {
	DAC_DHR12L1_DACC1DHR = ((1UL<<12)-1) << 4, // DAC channel1 12-bit left-aligned data		
};
static inline void dac_dhr12l1_set_dacc1dhr(uint32_t val) { DAC1.DHR12L1 = (DAC1.DHR12L1 & ~DAC_DHR12L1_DACC1DHR) | ((val<<4) & DAC_DHR12L1_DACC1DHR); }
static inline uint32_t dac_dhr12l1_get_dacc1dhr(void) { return (DAC1.DHR12L1 & DAC_DHR12L1_DACC1DHR) >> 4 ; }

// DAC->DHR12R2 channel2 12-bit right aligned data holding register
enum {
	DAC_DHR12R2_DACC2DHR = ((1UL<<12)-1) << 0, // DAC channel2 12-bit right-aligned data		
};
static inline void dac_dhr12r2_set_dacc2dhr(uint32_t val) { DAC1.DHR12R2 = (DAC1.DHR12R2 & ~DAC_DHR12R2_DACC2DHR) | ((val<<0) & DAC_DHR12R2_DACC2DHR); }
static inline uint32_t dac_dhr12r2_get_dacc2dhr(void) { return (DAC1.DHR12R2 & DAC_DHR12R2_DACC2DHR) >> 0 ; }

// DAC->DHR12L2 channel2 12-bit left aligned data holding register
enum {
	DAC_DHR12L2_DACC2DHR = ((1UL<<12)-1) << 4, // DAC channel2 12-bit left-aligned data		
};
static inline void dac_dhr12l2_set_dacc2dhr(uint32_t val) { DAC1.DHR12L2 = (DAC1.DHR12L2 & ~DAC_DHR12L2_DACC2DHR) | ((val<<4) & DAC_DHR12L2_DACC2DHR); }
static inline uint32_t dac_dhr12l2_get_dacc2dhr(void) { return (DAC1.DHR12L2 & DAC_DHR12L2_DACC2DHR) >> 4 ; }

// DAC->DHR12RD Dual DAC 12-bit right-aligned data holding register
enum {
	DAC_DHR12RD_DACC2DHR = ((1UL<<12)-1) << 16, // DAC channel2 12-bit right-aligned data
	DAC_DHR12RD_DACC1DHR = ((1UL<<12)-1) << 0, // DAC channel1 12-bit right-aligned data		
};
static inline void dac_dhr12rd_set_dacc2dhr(uint32_t val) { DAC1.DHR12RD = (DAC1.DHR12RD & ~DAC_DHR12RD_DACC2DHR) | ((val<<16) & DAC_DHR12RD_DACC2DHR); }
static inline void dac_dhr12rd_set_dacc1dhr(uint32_t val) { DAC1.DHR12RD = (DAC1.DHR12RD & ~DAC_DHR12RD_DACC1DHR) | ((val<<0) & DAC_DHR12RD_DACC1DHR); }
static inline uint32_t dac_dhr12rd_get_dacc2dhr(void) { return (DAC1.DHR12RD & DAC_DHR12RD_DACC2DHR) >> 16 ; }
static inline uint32_t dac_dhr12rd_get_dacc1dhr(void) { return (DAC1.DHR12RD & DAC_DHR12RD_DACC1DHR) >> 0 ; }

// DAC->DHR12LD DUAL DAC 12-bit left aligned data holding register
enum {
	DAC_DHR12LD_DACC2DHR = ((1UL<<12)-1) << 20, // DAC channel2 12-bit left-aligned data
	DAC_DHR12LD_DACC1DHR = ((1UL<<12)-1) << 4, // DAC channel1 12-bit left-aligned data		
};
static inline void dac_dhr12ld_set_dacc2dhr(uint32_t val) { DAC1.DHR12LD = (DAC1.DHR12LD & ~DAC_DHR12LD_DACC2DHR) | ((val<<20) & DAC_DHR12LD_DACC2DHR); }
static inline void dac_dhr12ld_set_dacc1dhr(uint32_t val) { DAC1.DHR12LD = (DAC1.DHR12LD & ~DAC_DHR12LD_DACC1DHR) | ((val<<4) & DAC_DHR12LD_DACC1DHR); }
static inline uint32_t dac_dhr12ld_get_dacc2dhr(void) { return (DAC1.DHR12LD & DAC_DHR12LD_DACC2DHR) >> 20 ; }
static inline uint32_t dac_dhr12ld_get_dacc1dhr(void) { return (DAC1.DHR12LD & DAC_DHR12LD_DACC1DHR) >> 4 ; }

// DAC->DHR8RD DUAL DAC 8-bit right aligned data holding register
enum {
	DAC_DHR8RD_DACC2DHR = ((1UL<<8)-1) << 8, // DAC channel2 8-bit right-aligned data
	DAC_DHR8RD_DACC1DHR = ((1UL<<8)-1) << 0, // DAC channel1 8-bit right-aligned data		
};
static inline void dac_dhr8rd_set_dacc2dhr(uint32_t val) { DAC1.DHR8RD = (DAC1.DHR8RD & ~DAC_DHR8RD_DACC2DHR) | ((val<<8) & DAC_DHR8RD_DACC2DHR); }
static inline void dac_dhr8rd_set_dacc1dhr(uint32_t val) { DAC1.DHR8RD = (DAC1.DHR8RD & ~DAC_DHR8RD_DACC1DHR) | ((val<<0) & DAC_DHR8RD_DACC1DHR); }
static inline uint32_t dac_dhr8rd_get_dacc2dhr(void) { return (DAC1.DHR8RD & DAC_DHR8RD_DACC2DHR) >> 8 ; }
static inline uint32_t dac_dhr8rd_get_dacc1dhr(void) { return (DAC1.DHR8RD & DAC_DHR8RD_DACC1DHR) >> 0 ; }

// DAC->DOR1 channel1 data output register
enum {
	DAC_DOR1_DACC1DOR = ((1UL<<12)-1) << 0, // DAC channel1 data output		
};
static inline uint32_t dac_dor1_get_dacc1dor(void) { return (DAC1.DOR1 & DAC_DOR1_DACC1DOR) >> 0 ; }

// DAC->DOR2 channel2 data output register
enum {
	DAC_DOR2_DACC2DOR = ((1UL<<12)-1) << 0, // DAC channel2 data output		
};
static inline uint32_t dac_dor2_get_dacc2dor(void) { return (DAC1.DOR2 & DAC_DOR2_DACC2DOR) >> 0 ; }

// DAC->SR status register
enum {
	DAC_SR_BWST2 = 1UL<<31, // DAC Channel 2 busy writing sample time flag
	DAC_SR_CAL_FLAG2 = 1UL<<30, // DAC Channel 2 calibration offset status
	DAC_SR_DMAUDR2 = 1UL<<29, // DAC channel2 DMA underrun flag
	DAC_SR_BWST1 = 1UL<<15, // DAC Channel 1 busy writing sample time flag
	DAC_SR_CAL_FLAG1 = 1UL<<14, // DAC Channel 1 calibration offset status
	DAC_SR_DMAUDR1 = 1UL<<13, // DAC channel1 DMA underrun flag		
};

// DAC->CCR calibration control register
enum {
	DAC_CCR_OTRIM2 = ((1UL<<5)-1) << 16, // DAC Channel 2 offset trimming value
	DAC_CCR_OTRIM1 = ((1UL<<5)-1) << 0, // DAC Channel 1 offset trimming value		
};
static inline void dac_ccr_set_otrim2(uint32_t val) { DAC1.CCR = (DAC1.CCR & ~DAC_CCR_OTRIM2) | ((val<<16) & DAC_CCR_OTRIM2); }
static inline void dac_ccr_set_otrim1(uint32_t val) { DAC1.CCR = (DAC1.CCR & ~DAC_CCR_OTRIM1) | ((val<<0) & DAC_CCR_OTRIM1); }
static inline uint32_t dac_ccr_get_otrim2(void) { return (DAC1.CCR & DAC_CCR_OTRIM2) >> 16 ; }
static inline uint32_t dac_ccr_get_otrim1(void) { return (DAC1.CCR & DAC_CCR_OTRIM1) >> 0 ; }

// DAC->MCR mode control register
enum {
	DAC_MCR_MODE2 = ((1UL<<3)-1) << 16, // DAC Channel 2 mode
	DAC_MCR_MODE1 = ((1UL<<3)-1) << 0, // DAC Channel 1 mode		
};
static inline void dac_mcr_set_mode2(uint32_t val) { DAC1.MCR = (DAC1.MCR & ~DAC_MCR_MODE2) | ((val<<16) & DAC_MCR_MODE2); }
static inline void dac_mcr_set_mode1(uint32_t val) { DAC1.MCR = (DAC1.MCR & ~DAC_MCR_MODE1) | ((val<<0) & DAC_MCR_MODE1); }
static inline uint32_t dac_mcr_get_mode2(void) { return (DAC1.MCR & DAC_MCR_MODE2) >> 16 ; }
static inline uint32_t dac_mcr_get_mode1(void) { return (DAC1.MCR & DAC_MCR_MODE1) >> 0 ; }

// DAC->SHSR1 Sample and Hold sample time register 1
enum {
	DAC_SHSR1_TSAMPLE1 = ((1UL<<10)-1) << 0, // DAC Channel 1 sample Time		
};
static inline void dac_shsr1_set_tsample1(uint32_t val) { DAC1.SHSR1 = (DAC1.SHSR1 & ~DAC_SHSR1_TSAMPLE1) | ((val<<0) & DAC_SHSR1_TSAMPLE1); }
static inline uint32_t dac_shsr1_get_tsample1(void) { return (DAC1.SHSR1 & DAC_SHSR1_TSAMPLE1) >> 0 ; }

// DAC->SHSR2 Sample and Hold sample time register 2
enum {
	DAC_SHSR2_TSAMPLE2 = ((1UL<<10)-1) << 0, // DAC Channel 2 sample Time		
};
static inline void dac_shsr2_set_tsample2(uint32_t val) { DAC1.SHSR2 = (DAC1.SHSR2 & ~DAC_SHSR2_TSAMPLE2) | ((val<<0) & DAC_SHSR2_TSAMPLE2); }
static inline uint32_t dac_shsr2_get_tsample2(void) { return (DAC1.SHSR2 & DAC_SHSR2_TSAMPLE2) >> 0 ; }

// DAC->SHHR Sample and Hold hold time register
enum {
	DAC_SHHR_THOLD2 = ((1UL<<10)-1) << 16, // DAC Channel 2 hold time
	DAC_SHHR_THOLD1 = ((1UL<<10)-1) << 0, // DAC Channel 1 hold Time		
};
static inline void dac_shhr_set_thold2(uint32_t val) { DAC1.SHHR = (DAC1.SHHR & ~DAC_SHHR_THOLD2) | ((val<<16) & DAC_SHHR_THOLD2); }
static inline void dac_shhr_set_thold1(uint32_t val) { DAC1.SHHR = (DAC1.SHHR & ~DAC_SHHR_THOLD1) | ((val<<0) & DAC_SHHR_THOLD1); }
static inline uint32_t dac_shhr_get_thold2(void) { return (DAC1.SHHR & DAC_SHHR_THOLD2) >> 16 ; }
static inline uint32_t dac_shhr_get_thold1(void) { return (DAC1.SHHR & DAC_SHHR_THOLD1) >> 0 ; }

// DAC->SHRR Sample and Hold refresh time register
enum {
	DAC_SHRR_TREFRESH2 = ((1UL<<8)-1) << 16, // DAC Channel 2 refresh Time
	DAC_SHRR_TREFRESH1 = ((1UL<<8)-1) << 0, // DAC Channel 1 refresh Time		
};
static inline void dac_shrr_set_trefresh2(uint32_t val) { DAC1.SHRR = (DAC1.SHRR & ~DAC_SHRR_TREFRESH2) | ((val<<16) & DAC_SHRR_TREFRESH2); }
static inline void dac_shrr_set_trefresh1(uint32_t val) { DAC1.SHRR = (DAC1.SHRR & ~DAC_SHRR_TREFRESH1) | ((val<<0) & DAC_SHRR_TREFRESH1); }
static inline uint32_t dac_shrr_get_trefresh2(void) { return (DAC1.SHRR & DAC_SHRR_TREFRESH2) >> 16 ; }
static inline uint32_t dac_shrr_get_trefresh1(void) { return (DAC1.SHRR & DAC_SHRR_TREFRESH1) >> 0 ; }

/* MCU debug component
There is only one peripheral of type DBGMCU. */
struct DBGMCU_Type {
	__I uint32_t IDCODE; // @0 DBGMCU_IDCODE
	__IO uint8_t CR; // @4 Debug MCU configuration register
	 uint8_t RESERVED0[3]; // @5 
	__IO uint32_t APB1FZR1; // @8 Debug MCU APB1 freeze register1
	__IO uint8_t APB1FZR2; // @12 Debug MCU APB1 freeze register 2
	 uint8_t RESERVED1[3]; // @13 
	__IO uint32_t APB2FZR; // @16 Debug MCU APB2 freeze register
};
extern struct DBGMCU_Type	DBGMCU;	// @0xE0042000 

// DBGMCU->IDCODE DBGMCU_IDCODE
enum {
	DBGMCU_IDCODE_REV_ID = ((1UL<<16)-1) << 16, // Revision identifie
	DBGMCU_IDCODE_DEV_ID = ((1UL<<12)-1) << 0, // Device identifier		
};
static inline uint32_t dbgmcu_idcode_get_rev_id(void) { return (DBGMCU.IDCODE & DBGMCU_IDCODE_REV_ID) >> 16 ; }
static inline uint32_t dbgmcu_idcode_get_dev_id(void) { return (DBGMCU.IDCODE & DBGMCU_IDCODE_DEV_ID) >> 0 ; }

// DBGMCU->CR Debug MCU configuration register
enum {
	DBGMCU_CR_TRACE_MODE = ((1UL<<2)-1) << 6, // Trace pin assignment control
	DBGMCU_CR_TRACE_IOEN = 1UL<<5, // Trace pin assignment control
	DBGMCU_CR_DBG_STANDBY = 1UL<<2, // Debug Standby mode
	DBGMCU_CR_DBG_STOP = 1UL<<1, // Debug Stop mode
	DBGMCU_CR_DBG_SLEEP = 1UL<<0, // Debug Sleep mode		
};
static inline void dbgmcu_cr_set_trace_mode(uint32_t val) { DBGMCU.CR = (DBGMCU.CR & ~DBGMCU_CR_TRACE_MODE) | ((val<<6) & DBGMCU_CR_TRACE_MODE); }
static inline uint32_t dbgmcu_cr_get_trace_mode(void) { return (DBGMCU.CR & DBGMCU_CR_TRACE_MODE) >> 6 ; }

// DBGMCU->APB1FZR1 Debug MCU APB1 freeze register1
enum {
	DBGMCU_APB1FZR1_DBG_LPTIM1_STOP = 1UL<<31, // LPTIM1 counter stopped when core is halted
	DBGMCU_APB1FZR1_DBG_CAN_STOP = 1UL<<25, // bxCAN stopped when core is halted
	DBGMCU_APB1FZR1_DBG_I2C3_STOP = 1UL<<23, // I2C3 SMBUS timeout counter stopped when core is halted
	DBGMCU_APB1FZR1_DBG_I2C2_STOP = 1UL<<22, // I2C2 SMBUS timeout counter stopped when core is halted
	DBGMCU_APB1FZR1_DBG_I2C1_STOP = 1UL<<21, // I2C1 SMBUS timeout counter stopped when core is halted
	DBGMCU_APB1FZR1_DBG_IWDG_STOP = 1UL<<12, // Independent watchdog counter stopped when core is halted
	DBGMCU_APB1FZR1_DBG_WWDG_STOP = 1UL<<11, // Window watchdog counter stopped when core is halted
	DBGMCU_APB1FZR1_DBG_RTC_STOP = 1UL<<10, // RTC counter stopped when core is halted
	DBGMCU_APB1FZR1_DBG_TIM7_STOP = 1UL<<5, // TIM7 counter stopped when core is halted
	DBGMCU_APB1FZR1_DBG_TIM6_STOP = 1UL<<4, // TIM6 counter stopped when core is halted
	DBGMCU_APB1FZR1_DBG_TIM2_STOP = 1UL<<0, // TIM2 counter stopped when core is halted		
};

// DBGMCU->APB1FZR2 Debug MCU APB1 freeze register 2
enum {
	DBGMCU_APB1FZR2_DBG_LPTIM2_STOP = 1UL<<5, // LPTIM2 counter stopped when core is halted		
};

// DBGMCU->APB2FZR Debug MCU APB2 freeze register
enum {
	DBGMCU_APB2FZR_DBG_TIM16_STOP = 1UL<<17, // TIM16 counter stopped when core is halted
	DBGMCU_APB2FZR_DBG_TIM15_STOP = 1UL<<16, // TIM15 counter stopped when core is halted
	DBGMCU_APB2FZR_DBG_TIM1_STOP = 1UL<<11, // TIM1 counter stopped when core is halted		
};

/* Direct memory access controller */
struct DMA_Type {
	__I uint32_t ISR; // @0 interrupt status register
	__O uint32_t IFCR; // @4 interrupt flag clear register
	__IO uint32_t CCR1; // @8 channel x configuration register
	__IO uint32_t CNDTR1; // @12 channel x number of data register
	__IO uint32_t CPAR1; // @16 channel x peripheral address register
	__IO uint32_t CMAR1; // @20 channel x memory address register
	 uint8_t RESERVED0[4]; // @24 
	__IO uint32_t CCR2; // @28 channel x configuration register
	__IO uint32_t CNDTR2; // @32 channel x number of data register
	__IO uint32_t CPAR2; // @36 channel x peripheral address register
	__IO uint32_t CMAR2; // @40 channel x memory address register
	 uint8_t RESERVED1[4]; // @44 
	__IO uint32_t CCR3; // @48 channel x configuration register
	__IO uint32_t CNDTR3; // @52 channel x number of data register
	__IO uint32_t CPAR3; // @56 channel x peripheral address register
	__IO uint32_t CMAR3; // @60 channel x memory address register
	 uint8_t RESERVED2[4]; // @64 
	__IO uint32_t CCR4; // @68 channel x configuration register
	__IO uint32_t CNDTR4; // @72 channel x number of data register
	__IO uint32_t CPAR4; // @76 channel x peripheral address register
	__IO uint32_t CMAR4; // @80 channel x memory address register
	 uint8_t RESERVED3[4]; // @84 
	__IO uint32_t CCR5; // @88 channel x configuration register
	__IO uint32_t CNDTR5; // @92 channel x number of data register
	__IO uint32_t CPAR5; // @96 channel x peripheral address register
	__IO uint32_t CMAR5; // @100 channel x memory address register
	 uint8_t RESERVED4[4]; // @104 
	__IO uint32_t CCR6; // @108 channel x configuration register
	__IO uint32_t CNDTR6; // @112 channel x number of data register
	__IO uint32_t CPAR6; // @116 channel x peripheral address register
	__IO uint32_t CMAR6; // @120 channel x memory address register
	 uint8_t RESERVED5[4]; // @124 
	__IO uint32_t CCR7; // @128 channel x configuration register
	__IO uint32_t CNDTR7; // @132 channel x number of data register
	__IO uint32_t CPAR7; // @136 channel x peripheral address register
	__IO uint32_t CMAR7; // @140 channel x memory address register
	 uint8_t RESERVED6[24]; // @144 
	__IO uint32_t CSELR; // @168 channel selection register
};
extern struct DMA_Type	DMA1;	// @0x40020000 
extern struct DMA_Type 	DMA2;	// @0x40020400

// DMA->ISR interrupt status register
enum {
	DMA_ISR_TEIF7 = 1UL<<27, // Channel x transfer error flag (x = 1 ..7)
	DMA_ISR_HTIF7 = 1UL<<26, // Channel x half transfer flag (x = 1 ..7)
	DMA_ISR_TCIF7 = 1UL<<25, // Channel x transfer complete flag (x = 1 ..7)
	DMA_ISR_GIF7 = 1UL<<24, // Channel x global interrupt flag (x = 1 ..7)
	DMA_ISR_TEIF6 = 1UL<<23, // Channel x transfer error flag (x = 1 ..7)
	DMA_ISR_HTIF6 = 1UL<<22, // Channel x half transfer flag (x = 1 ..7)
	DMA_ISR_TCIF6 = 1UL<<21, // Channel x transfer complete flag (x = 1 ..7)
	DMA_ISR_GIF6 = 1UL<<20, // Channel x global interrupt flag (x = 1 ..7)
	DMA_ISR_TEIF5 = 1UL<<19, // Channel x transfer error flag (x = 1 ..7)
	DMA_ISR_HTIF5 = 1UL<<18, // Channel x half transfer flag (x = 1 ..7)
	DMA_ISR_TCIF5 = 1UL<<17, // Channel x transfer complete flag (x = 1 ..7)
	DMA_ISR_GIF5 = 1UL<<16, // Channel x global interrupt flag (x = 1 ..7)
	DMA_ISR_TEIF4 = 1UL<<15, // Channel x transfer error flag (x = 1 ..7)
	DMA_ISR_HTIF4 = 1UL<<14, // Channel x half transfer flag (x = 1 ..7)
	DMA_ISR_TCIF4 = 1UL<<13, // Channel x transfer complete flag (x = 1 ..7)
	DMA_ISR_GIF4 = 1UL<<12, // Channel x global interrupt flag (x = 1 ..7)
	DMA_ISR_TEIF3 = 1UL<<11, // Channel x transfer error flag (x = 1 ..7)
	DMA_ISR_HTIF3 = 1UL<<10, // Channel x half transfer flag (x = 1 ..7)
	DMA_ISR_TCIF3 = 1UL<<9, // Channel x transfer complete flag (x = 1 ..7)
	DMA_ISR_GIF3 = 1UL<<8, // Channel x global interrupt flag (x = 1 ..7)
	DMA_ISR_TEIF2 = 1UL<<7, // Channel x transfer error flag (x = 1 ..7)
	DMA_ISR_HTIF2 = 1UL<<6, // Channel x half transfer flag (x = 1 ..7)
	DMA_ISR_TCIF2 = 1UL<<5, // Channel x transfer complete flag (x = 1 ..7)
	DMA_ISR_GIF2 = 1UL<<4, // Channel x global interrupt flag (x = 1 ..7)
	DMA_ISR_TEIF1 = 1UL<<3, // Channel x transfer error flag (x = 1 ..7)
	DMA_ISR_HTIF1 = 1UL<<2, // Channel x half transfer flag (x = 1 ..7)
	DMA_ISR_TCIF1 = 1UL<<1, // Channel x transfer complete flag (x = 1 ..7)
	DMA_ISR_GIF1 = 1UL<<0, // Channel x global interrupt flag (x = 1 ..7)		
};

// DMA->IFCR interrupt flag clear register
enum {
	DMA_IFCR_CTEIF7 = 1UL<<27, // Channel x transfer error clear (x = 1 ..7)
	DMA_IFCR_CHTIF7 = 1UL<<26, // Channel x half transfer clear (x = 1 ..7)
	DMA_IFCR_CTCIF7 = 1UL<<25, // Channel x transfer complete clear (x = 1 ..7)
	DMA_IFCR_CGIF7 = 1UL<<24, // Channel x global interrupt clear (x = 1 ..7)
	DMA_IFCR_CTEIF6 = 1UL<<23, // Channel x transfer error clear (x = 1 ..7)
	DMA_IFCR_CHTIF6 = 1UL<<22, // Channel x half transfer clear (x = 1 ..7)
	DMA_IFCR_CTCIF6 = 1UL<<21, // Channel x transfer complete clear (x = 1 ..7)
	DMA_IFCR_CGIF6 = 1UL<<20, // Channel x global interrupt clear (x = 1 ..7)
	DMA_IFCR_CTEIF5 = 1UL<<19, // Channel x transfer error clear (x = 1 ..7)
	DMA_IFCR_CHTIF5 = 1UL<<18, // Channel x half transfer clear (x = 1 ..7)
	DMA_IFCR_CTCIF5 = 1UL<<17, // Channel x transfer complete clear (x = 1 ..7)
	DMA_IFCR_CGIF5 = 1UL<<16, // Channel x global interrupt clear (x = 1 ..7)
	DMA_IFCR_CTEIF4 = 1UL<<15, // Channel x transfer error clear (x = 1 ..7)
	DMA_IFCR_CHTIF4 = 1UL<<14, // Channel x half transfer clear (x = 1 ..7)
	DMA_IFCR_CTCIF4 = 1UL<<13, // Channel x transfer complete clear (x = 1 ..7)
	DMA_IFCR_CGIF4 = 1UL<<12, // Channel x global interrupt clear (x = 1 ..7)
	DMA_IFCR_CTEIF3 = 1UL<<11, // Channel x transfer error clear (x = 1 ..7)
	DMA_IFCR_CHTIF3 = 1UL<<10, // Channel x half transfer clear (x = 1 ..7)
	DMA_IFCR_CTCIF3 = 1UL<<9, // Channel x transfer complete clear (x = 1 ..7)
	DMA_IFCR_CGIF3 = 1UL<<8, // Channel x global interrupt clear (x = 1 ..7)
	DMA_IFCR_CTEIF2 = 1UL<<7, // Channel x transfer error clear (x = 1 ..7)
	DMA_IFCR_CHTIF2 = 1UL<<6, // Channel x half transfer clear (x = 1 ..7)
	DMA_IFCR_CTCIF2 = 1UL<<5, // Channel x transfer complete clear (x = 1 ..7)
	DMA_IFCR_CGIF2 = 1UL<<4, // Channel x global interrupt clear (x = 1 ..7)
	DMA_IFCR_CTEIF1 = 1UL<<3, // Channel x transfer error clear (x = 1 ..7)
	DMA_IFCR_CHTIF1 = 1UL<<2, // Channel x half transfer clear (x = 1 ..7)
	DMA_IFCR_CTCIF1 = 1UL<<1, // Channel x transfer complete clear (x = 1 ..7)
	DMA_IFCR_CGIF1 = 1UL<<0, // Channel x global interrupt clear (x = 1 ..7)		
};

// DMA->CCR1 channel x configuration register
enum {
	DMA_CCR1_DUMMY = 1UL<<31, // force this to be a 32 bit register
	DMA_CCR1_MEM2MEM = 1UL<<14, // Memory to memory mode
	DMA_CCR1_PL = ((1UL<<2)-1) << 12, // Channel priority level
	DMA_CCR1_MSIZE = ((1UL<<2)-1) << 10, // Memory size
	DMA_CCR1_PSIZE = ((1UL<<2)-1) << 8, // Peripheral size
	DMA_CCR1_MINC = 1UL<<7, // Memory increment mode
	DMA_CCR1_PINC = 1UL<<6, // Peripheral increment mode
	DMA_CCR1_CIRC = 1UL<<5, // Circular mode
	DMA_CCR1_DIR = 1UL<<4, // Data transfer direction
	DMA_CCR1_TEIE = 1UL<<3, // Transfer error interrupt enable
	DMA_CCR1_HTIE = 1UL<<2, // Half transfer interrupt enable
	DMA_CCR1_TCIE = 1UL<<1, // Transfer complete interrupt enable
	DMA_CCR1_EN = 1UL<<0, // Channel enable		
};
static inline void dma_ccr1_set_pl(struct DMA_Type* p, uint32_t val) { p->CCR1 = (p->CCR1 & ~DMA_CCR1_PL) | ((val<<12) & DMA_CCR1_PL); }
static inline void dma_ccr1_set_msize(struct DMA_Type* p, uint32_t val) { p->CCR1 = (p->CCR1 & ~DMA_CCR1_MSIZE) | ((val<<10) & DMA_CCR1_MSIZE); }
static inline void dma_ccr1_set_psize(struct DMA_Type* p, uint32_t val) { p->CCR1 = (p->CCR1 & ~DMA_CCR1_PSIZE) | ((val<<8) & DMA_CCR1_PSIZE); }
static inline uint32_t dma_ccr1_get_pl(struct DMA_Type* p) { return (p->CCR1 & DMA_CCR1_PL) >> 12 ; }
static inline uint32_t dma_ccr1_get_msize(struct DMA_Type* p) { return (p->CCR1 & DMA_CCR1_MSIZE) >> 10 ; }
static inline uint32_t dma_ccr1_get_psize(struct DMA_Type* p) { return (p->CCR1 & DMA_CCR1_PSIZE) >> 8 ; }

// DMA->CCR2 channel x configuration register
enum {
	DMA_CCR2_DUMMY = 1UL<<31, // force this to be a 32 bit register
	DMA_CCR2_MEM2MEM = 1UL<<14, // Memory to memory mode
	DMA_CCR2_PL = ((1UL<<2)-1) << 12, // Channel priority level
	DMA_CCR2_MSIZE = ((1UL<<2)-1) << 10, // Memory size
	DMA_CCR2_PSIZE = ((1UL<<2)-1) << 8, // Peripheral size
	DMA_CCR2_MINC = 1UL<<7, // Memory increment mode
	DMA_CCR2_PINC = 1UL<<6, // Peripheral increment mode
	DMA_CCR2_CIRC = 1UL<<5, // Circular mode
	DMA_CCR2_DIR = 1UL<<4, // Data transfer direction
	DMA_CCR2_TEIE = 1UL<<3, // Transfer error interrupt enable
	DMA_CCR2_HTIE = 1UL<<2, // Half transfer interrupt enable
	DMA_CCR2_TCIE = 1UL<<1, // Transfer complete interrupt enable
	DMA_CCR2_EN = 1UL<<0, // Channel enable		
};
static inline void dma_ccr2_set_pl(struct DMA_Type* p, uint32_t val) { p->CCR2 = (p->CCR2 & ~DMA_CCR2_PL) | ((val<<12) & DMA_CCR2_PL); }
static inline void dma_ccr2_set_msize(struct DMA_Type* p, uint32_t val) { p->CCR2 = (p->CCR2 & ~DMA_CCR2_MSIZE) | ((val<<10) & DMA_CCR2_MSIZE); }
static inline void dma_ccr2_set_psize(struct DMA_Type* p, uint32_t val) { p->CCR2 = (p->CCR2 & ~DMA_CCR2_PSIZE) | ((val<<8) & DMA_CCR2_PSIZE); }
static inline uint32_t dma_ccr2_get_pl(struct DMA_Type* p) { return (p->CCR2 & DMA_CCR2_PL) >> 12 ; }
static inline uint32_t dma_ccr2_get_msize(struct DMA_Type* p) { return (p->CCR2 & DMA_CCR2_MSIZE) >> 10 ; }
static inline uint32_t dma_ccr2_get_psize(struct DMA_Type* p) { return (p->CCR2 & DMA_CCR2_PSIZE) >> 8 ; }

// DMA->CCR3 channel x configuration register
enum {
	DMA_CCR3_DUMMY = 1UL<<31, // force this to be a 32 bit register
	DMA_CCR3_MEM2MEM = 1UL<<14, // Memory to memory mode
	DMA_CCR3_PL = ((1UL<<2)-1) << 12, // Channel priority level
	DMA_CCR3_MSIZE = ((1UL<<2)-1) << 10, // Memory size
	DMA_CCR3_PSIZE = ((1UL<<2)-1) << 8, // Peripheral size
	DMA_CCR3_MINC = 1UL<<7, // Memory increment mode
	DMA_CCR3_PINC = 1UL<<6, // Peripheral increment mode
	DMA_CCR3_CIRC = 1UL<<5, // Circular mode
	DMA_CCR3_DIR = 1UL<<4, // Data transfer direction
	DMA_CCR3_TEIE = 1UL<<3, // Transfer error interrupt enable
	DMA_CCR3_HTIE = 1UL<<2, // Half transfer interrupt enable
	DMA_CCR3_TCIE = 1UL<<1, // Transfer complete interrupt enable
	DMA_CCR3_EN = 1UL<<0, // Channel enable		
};
static inline void dma_ccr3_set_pl(struct DMA_Type* p, uint32_t val) { p->CCR3 = (p->CCR3 & ~DMA_CCR3_PL) | ((val<<12) & DMA_CCR3_PL); }
static inline void dma_ccr3_set_msize(struct DMA_Type* p, uint32_t val) { p->CCR3 = (p->CCR3 & ~DMA_CCR3_MSIZE) | ((val<<10) & DMA_CCR3_MSIZE); }
static inline void dma_ccr3_set_psize(struct DMA_Type* p, uint32_t val) { p->CCR3 = (p->CCR3 & ~DMA_CCR3_PSIZE) | ((val<<8) & DMA_CCR3_PSIZE); }
static inline uint32_t dma_ccr3_get_pl(struct DMA_Type* p) { return (p->CCR3 & DMA_CCR3_PL) >> 12 ; }
static inline uint32_t dma_ccr3_get_msize(struct DMA_Type* p) { return (p->CCR3 & DMA_CCR3_MSIZE) >> 10 ; }
static inline uint32_t dma_ccr3_get_psize(struct DMA_Type* p) { return (p->CCR3 & DMA_CCR3_PSIZE) >> 8 ; }

// DMA->CCR4 channel x configuration register
enum {
	DMA_CCR4_DUMMY = 1UL<<31, // force this to be a 32 bit register
	DMA_CCR4_MEM2MEM = 1UL<<14, // Memory to memory mode
	DMA_CCR4_PL = ((1UL<<2)-1) << 12, // Channel priority level
	DMA_CCR4_MSIZE = ((1UL<<2)-1) << 10, // Memory size
	DMA_CCR4_PSIZE = ((1UL<<2)-1) << 8, // Peripheral size
	DMA_CCR4_MINC = 1UL<<7, // Memory increment mode
	DMA_CCR4_PINC = 1UL<<6, // Peripheral increment mode
	DMA_CCR4_CIRC = 1UL<<5, // Circular mode
	DMA_CCR4_DIR = 1UL<<4, // Data transfer direction
	DMA_CCR4_TEIE = 1UL<<3, // Transfer error interrupt enable
	DMA_CCR4_HTIE = 1UL<<2, // Half transfer interrupt enable
	DMA_CCR4_TCIE = 1UL<<1, // Transfer complete interrupt enable
	DMA_CCR4_EN = 1UL<<0, // Channel enable		
};
static inline void dma_ccr4_set_pl(struct DMA_Type* p, uint32_t val) { p->CCR4 = (p->CCR4 & ~DMA_CCR4_PL) | ((val<<12) & DMA_CCR4_PL); }
static inline void dma_ccr4_set_msize(struct DMA_Type* p, uint32_t val) { p->CCR4 = (p->CCR4 & ~DMA_CCR4_MSIZE) | ((val<<10) & DMA_CCR4_MSIZE); }
static inline void dma_ccr4_set_psize(struct DMA_Type* p, uint32_t val) { p->CCR4 = (p->CCR4 & ~DMA_CCR4_PSIZE) | ((val<<8) & DMA_CCR4_PSIZE); }
static inline uint32_t dma_ccr4_get_pl(struct DMA_Type* p) { return (p->CCR4 & DMA_CCR4_PL) >> 12 ; }
static inline uint32_t dma_ccr4_get_msize(struct DMA_Type* p) { return (p->CCR4 & DMA_CCR4_MSIZE) >> 10 ; }
static inline uint32_t dma_ccr4_get_psize(struct DMA_Type* p) { return (p->CCR4 & DMA_CCR4_PSIZE) >> 8 ; }

// DMA->CCR5 channel x configuration register
enum {
	DMA_CCR5_DUMMY = 1UL<<31, // force this to be a 32 bit register
	DMA_CCR5_MEM2MEM = 1UL<<14, // Memory to memory mode
	DMA_CCR5_PL = ((1UL<<2)-1) << 12, // Channel priority level
	DMA_CCR5_MSIZE = ((1UL<<2)-1) << 10, // Memory size
	DMA_CCR5_PSIZE = ((1UL<<2)-1) << 8, // Peripheral size
	DMA_CCR5_MINC = 1UL<<7, // Memory increment mode
	DMA_CCR5_PINC = 1UL<<6, // Peripheral increment mode
	DMA_CCR5_CIRC = 1UL<<5, // Circular mode
	DMA_CCR5_DIR = 1UL<<4, // Data transfer direction
	DMA_CCR5_TEIE = 1UL<<3, // Transfer error interrupt enable
	DMA_CCR5_HTIE = 1UL<<2, // Half transfer interrupt enable
	DMA_CCR5_TCIE = 1UL<<1, // Transfer complete interrupt enable
	DMA_CCR5_EN = 1UL<<0, // Channel enable		
};
static inline void dma_ccr5_set_pl(struct DMA_Type* p, uint32_t val) { p->CCR5 = (p->CCR5 & ~DMA_CCR5_PL) | ((val<<12) & DMA_CCR5_PL); }
static inline void dma_ccr5_set_msize(struct DMA_Type* p, uint32_t val) { p->CCR5 = (p->CCR5 & ~DMA_CCR5_MSIZE) | ((val<<10) & DMA_CCR5_MSIZE); }
static inline void dma_ccr5_set_psize(struct DMA_Type* p, uint32_t val) { p->CCR5 = (p->CCR5 & ~DMA_CCR5_PSIZE) | ((val<<8) & DMA_CCR5_PSIZE); }
static inline uint32_t dma_ccr5_get_pl(struct DMA_Type* p) { return (p->CCR5 & DMA_CCR5_PL) >> 12 ; }
static inline uint32_t dma_ccr5_get_msize(struct DMA_Type* p) { return (p->CCR5 & DMA_CCR5_MSIZE) >> 10 ; }
static inline uint32_t dma_ccr5_get_psize(struct DMA_Type* p) { return (p->CCR5 & DMA_CCR5_PSIZE) >> 8 ; }

// DMA->CCR6 channel x configuration register
enum {
	DMA_CCR6_DUMMY = 1UL<<31, // force this to be a 32 bit register
	DMA_CCR6_MEM2MEM = 1UL<<14, // Memory to memory mode
	DMA_CCR6_PL = ((1UL<<2)-1) << 12, // Channel priority level
	DMA_CCR6_MSIZE = ((1UL<<2)-1) << 10, // Memory size
	DMA_CCR6_PSIZE = ((1UL<<2)-1) << 8, // Peripheral size
	DMA_CCR6_MINC = 1UL<<7, // Memory increment mode
	DMA_CCR6_PINC = 1UL<<6, // Peripheral increment mode
	DMA_CCR6_CIRC = 1UL<<5, // Circular mode
	DMA_CCR6_DIR = 1UL<<4, // Data transfer direction
	DMA_CCR6_TEIE = 1UL<<3, // Transfer error interrupt enable
	DMA_CCR6_HTIE = 1UL<<2, // Half transfer interrupt enable
	DMA_CCR6_TCIE = 1UL<<1, // Transfer complete interrupt enable
	DMA_CCR6_EN = 1UL<<0, // Channel enable		
};
static inline void dma_ccr6_set_pl(struct DMA_Type* p, uint32_t val) { p->CCR6 = (p->CCR6 & ~DMA_CCR6_PL) | ((val<<12) & DMA_CCR6_PL); }
static inline void dma_ccr6_set_msize(struct DMA_Type* p, uint32_t val) { p->CCR6 = (p->CCR6 & ~DMA_CCR6_MSIZE) | ((val<<10) & DMA_CCR6_MSIZE); }
static inline void dma_ccr6_set_psize(struct DMA_Type* p, uint32_t val) { p->CCR6 = (p->CCR6 & ~DMA_CCR6_PSIZE) | ((val<<8) & DMA_CCR6_PSIZE); }
static inline uint32_t dma_ccr6_get_pl(struct DMA_Type* p) { return (p->CCR6 & DMA_CCR6_PL) >> 12 ; }
static inline uint32_t dma_ccr6_get_msize(struct DMA_Type* p) { return (p->CCR6 & DMA_CCR6_MSIZE) >> 10 ; }
static inline uint32_t dma_ccr6_get_psize(struct DMA_Type* p) { return (p->CCR6 & DMA_CCR6_PSIZE) >> 8 ; }

// DMA->CCR7 channel x configuration register
enum {
	DMA_CCR7_DUMMY = 1UL<<31, // force this to be a 32 bit register
	DMA_CCR7_MEM2MEM = 1UL<<14, // Memory to memory mode
	DMA_CCR7_PL = ((1UL<<2)-1) << 12, // Channel priority level
	DMA_CCR7_MSIZE = ((1UL<<2)-1) << 10, // Memory size
	DMA_CCR7_PSIZE = ((1UL<<2)-1) << 8, // Peripheral size
	DMA_CCR7_MINC = 1UL<<7, // Memory increment mode
	DMA_CCR7_PINC = 1UL<<6, // Peripheral increment mode
	DMA_CCR7_CIRC = 1UL<<5, // Circular mode
	DMA_CCR7_DIR = 1UL<<4, // Data transfer direction
	DMA_CCR7_TEIE = 1UL<<3, // Transfer error interrupt enable
	DMA_CCR7_HTIE = 1UL<<2, // Half transfer interrupt enable
	DMA_CCR7_TCIE = 1UL<<1, // Transfer complete interrupt enable
	DMA_CCR7_EN = 1UL<<0, // Channel enable		
};
static inline void dma_ccr7_set_pl(struct DMA_Type* p, uint32_t val) { p->CCR7 = (p->CCR7 & ~DMA_CCR7_PL) | ((val<<12) & DMA_CCR7_PL); }
static inline void dma_ccr7_set_msize(struct DMA_Type* p, uint32_t val) { p->CCR7 = (p->CCR7 & ~DMA_CCR7_MSIZE) | ((val<<10) & DMA_CCR7_MSIZE); }
static inline void dma_ccr7_set_psize(struct DMA_Type* p, uint32_t val) { p->CCR7 = (p->CCR7 & ~DMA_CCR7_PSIZE) | ((val<<8) & DMA_CCR7_PSIZE); }
static inline uint32_t dma_ccr7_get_pl(struct DMA_Type* p) { return (p->CCR7 & DMA_CCR7_PL) >> 12 ; }
static inline uint32_t dma_ccr7_get_msize(struct DMA_Type* p) { return (p->CCR7 & DMA_CCR7_MSIZE) >> 10 ; }
static inline uint32_t dma_ccr7_get_psize(struct DMA_Type* p) { return (p->CCR7 & DMA_CCR7_PSIZE) >> 8 ; }

// DMA->CSELR channel selection register
enum {
	DMA_CSELR_C7S = ((1UL<<4)-1) << 24, // DMA channel 7 selection
	DMA_CSELR_C6S = ((1UL<<4)-1) << 20, // DMA channel 6 selection
	DMA_CSELR_C5S = ((1UL<<4)-1) << 16, // DMA channel 5 selection
	DMA_CSELR_C4S = ((1UL<<4)-1) << 12, // DMA channel 4 selection
	DMA_CSELR_C3S = ((1UL<<4)-1) << 8, // DMA channel 3 selection
	DMA_CSELR_C2S = ((1UL<<4)-1) << 4, // DMA channel 2 selection
	DMA_CSELR_C1S = ((1UL<<4)-1) << 0, // DMA channel 1 selection		
};
static inline void dma_cselr_set_c7s(struct DMA_Type* p, uint32_t val) { p->CSELR = (p->CSELR & ~DMA_CSELR_C7S) | ((val<<24) & DMA_CSELR_C7S); }
static inline void dma_cselr_set_c6s(struct DMA_Type* p, uint32_t val) { p->CSELR = (p->CSELR & ~DMA_CSELR_C6S) | ((val<<20) & DMA_CSELR_C6S); }
static inline void dma_cselr_set_c5s(struct DMA_Type* p, uint32_t val) { p->CSELR = (p->CSELR & ~DMA_CSELR_C5S) | ((val<<16) & DMA_CSELR_C5S); }
static inline void dma_cselr_set_c4s(struct DMA_Type* p, uint32_t val) { p->CSELR = (p->CSELR & ~DMA_CSELR_C4S) | ((val<<12) & DMA_CSELR_C4S); }
static inline void dma_cselr_set_c3s(struct DMA_Type* p, uint32_t val) { p->CSELR = (p->CSELR & ~DMA_CSELR_C3S) | ((val<<8) & DMA_CSELR_C3S); }
static inline void dma_cselr_set_c2s(struct DMA_Type* p, uint32_t val) { p->CSELR = (p->CSELR & ~DMA_CSELR_C2S) | ((val<<4) & DMA_CSELR_C2S); }
static inline void dma_cselr_set_c1s(struct DMA_Type* p, uint32_t val) { p->CSELR = (p->CSELR & ~DMA_CSELR_C1S) | ((val<<0) & DMA_CSELR_C1S); }
static inline uint32_t dma_cselr_get_c7s(struct DMA_Type* p) { return (p->CSELR & DMA_CSELR_C7S) >> 24 ; }
static inline uint32_t dma_cselr_get_c6s(struct DMA_Type* p) { return (p->CSELR & DMA_CSELR_C6S) >> 20 ; }
static inline uint32_t dma_cselr_get_c5s(struct DMA_Type* p) { return (p->CSELR & DMA_CSELR_C5S) >> 16 ; }
static inline uint32_t dma_cselr_get_c4s(struct DMA_Type* p) { return (p->CSELR & DMA_CSELR_C4S) >> 12 ; }
static inline uint32_t dma_cselr_get_c3s(struct DMA_Type* p) { return (p->CSELR & DMA_CSELR_C3S) >> 8 ; }
static inline uint32_t dma_cselr_get_c2s(struct DMA_Type* p) { return (p->CSELR & DMA_CSELR_C2S) >> 4 ; }
static inline uint32_t dma_cselr_get_c1s(struct DMA_Type* p) { return (p->CSELR & DMA_CSELR_C1S) >> 0 ; }


/* External interrupt/event controller
There is only one peripheral of type EXTI. */
struct EXTI_Type {
	__IO uint32_t IMR1; // @0 Interrupt mask register
	__IO uint32_t EMR1; // @4 Event mask register
	__IO uint32_t RTSR1; // @8 Rising Trigger selection register
	__IO uint32_t FTSR1; // @12 Falling Trigger selection register
	__IO uint32_t SWIER1; // @16 Software interrupt event register
	__IO uint32_t PR1; // @20 Pending register
	 uint8_t RESERVED0[8]; // @24 
	__IO uint8_t IMR2; // @32 Interrupt mask register
	 uint8_t RESERVED1[3]; // @33 
	__IO uint8_t EMR2; // @36 Event mask register
	 uint8_t RESERVED2[3]; // @37 
	__IO uint8_t RTSR2; // @40 Rising Trigger selection register
	 uint8_t RESERVED3[3]; // @41 
	__IO uint8_t FTSR2; // @44 Falling Trigger selection register
	 uint8_t RESERVED4[3]; // @45 
	__IO uint8_t SWIER2; // @48 Software interrupt event register
	 uint8_t RESERVED5[3]; // @49 
	__IO uint8_t PR2; // @52 Pending register
};
extern struct EXTI_Type	EXTI;	// @0x40010400 

// EXTI->RTSR1 Rising Trigger selection register
enum {
	EXTI_RTSR1_TR22 = 1UL<<22, // Rising trigger event configuration of line 22
	EXTI_RTSR1_TR21 = 1UL<<21, // Rising trigger event configuration of line 21
	EXTI_RTSR1_TR20 = 1UL<<20, // Rising trigger event configuration of line 20
	EXTI_RTSR1_TR19 = 1UL<<19, // Rising trigger event configuration of line 19
	EXTI_RTSR1_TR18 = 1UL<<18, // Rising trigger event configuration of line 18
	EXTI_RTSR1_TR16 = 1UL<<16, // Rising trigger event configuration of line 16
	EXTI_RTSR1_TR15 = 1UL<<15, // Rising trigger event configuration of line 15
	EXTI_RTSR1_TR14 = 1UL<<14, // Rising trigger event configuration of line 14
	EXTI_RTSR1_TR13 = 1UL<<13, // Rising trigger event configuration of line 13
	EXTI_RTSR1_TR12 = 1UL<<12, // Rising trigger event configuration of line 12
	EXTI_RTSR1_TR11 = 1UL<<11, // Rising trigger event configuration of line 11
	EXTI_RTSR1_TR10 = 1UL<<10, // Rising trigger event configuration of line 10
	EXTI_RTSR1_TR9 = 1UL<<9, // Rising trigger event configuration of line 9
	EXTI_RTSR1_TR8 = 1UL<<8, // Rising trigger event configuration of line 8
	EXTI_RTSR1_TR7 = 1UL<<7, // Rising trigger event configuration of line 7
	EXTI_RTSR1_TR6 = 1UL<<6, // Rising trigger event configuration of line 6
	EXTI_RTSR1_TR5 = 1UL<<5, // Rising trigger event configuration of line 5
	EXTI_RTSR1_TR4 = 1UL<<4, // Rising trigger event configuration of line 4
	EXTI_RTSR1_TR3 = 1UL<<3, // Rising trigger event configuration of line 3
	EXTI_RTSR1_TR2 = 1UL<<2, // Rising trigger event configuration of line 2
	EXTI_RTSR1_TR1 = 1UL<<1, // Rising trigger event configuration of line 1
	EXTI_RTSR1_TR0 = 1UL<<0, // Rising trigger event configuration of line 0		
};

// EXTI->FTSR1 Falling Trigger selection register
enum {
	EXTI_FTSR1_TR22 = 1UL<<22, // Falling trigger event configuration of line 22
	EXTI_FTSR1_TR21 = 1UL<<21, // Falling trigger event configuration of line 21
	EXTI_FTSR1_TR20 = 1UL<<20, // Falling trigger event configuration of line 20
	EXTI_FTSR1_TR19 = 1UL<<19, // Falling trigger event configuration of line 19
	EXTI_FTSR1_TR18 = 1UL<<18, // Falling trigger event configuration of line 18
	EXTI_FTSR1_TR16 = 1UL<<16, // Falling trigger event configuration of line 16
	EXTI_FTSR1_TR15 = 1UL<<15, // Falling trigger event configuration of line 15
	EXTI_FTSR1_TR14 = 1UL<<14, // Falling trigger event configuration of line 14
	EXTI_FTSR1_TR13 = 1UL<<13, // Falling trigger event configuration of line 13
	EXTI_FTSR1_TR12 = 1UL<<12, // Falling trigger event configuration of line 12
	EXTI_FTSR1_TR11 = 1UL<<11, // Falling trigger event configuration of line 11
	EXTI_FTSR1_TR10 = 1UL<<10, // Falling trigger event configuration of line 10
	EXTI_FTSR1_TR9 = 1UL<<9, // Falling trigger event configuration of line 9
	EXTI_FTSR1_TR8 = 1UL<<8, // Falling trigger event configuration of line 8
	EXTI_FTSR1_TR7 = 1UL<<7, // Falling trigger event configuration of line 7
	EXTI_FTSR1_TR6 = 1UL<<6, // Falling trigger event configuration of line 6
	EXTI_FTSR1_TR5 = 1UL<<5, // Falling trigger event configuration of line 5
	EXTI_FTSR1_TR4 = 1UL<<4, // Falling trigger event configuration of line 4
	EXTI_FTSR1_TR3 = 1UL<<3, // Falling trigger event configuration of line 3
	EXTI_FTSR1_TR2 = 1UL<<2, // Falling trigger event configuration of line 2
	EXTI_FTSR1_TR1 = 1UL<<1, // Falling trigger event configuration of line 1
	EXTI_FTSR1_TR0 = 1UL<<0, // Falling trigger event configuration of line 0		
};

// EXTI->SWIER1 Software interrupt event register
enum {
	EXTI_SWIER1_SWIER22 = 1UL<<22, // Software Interrupt on line 22
	EXTI_SWIER1_SWIER21 = 1UL<<21, // Software Interrupt on line 21
	EXTI_SWIER1_SWIER20 = 1UL<<20, // Software Interrupt on line 20
	EXTI_SWIER1_SWIER19 = 1UL<<19, // Software Interrupt on line 19
	EXTI_SWIER1_SWIER18 = 1UL<<18, // Software Interrupt on line 18
	EXTI_SWIER1_SWIER16 = 1UL<<16, // Software Interrupt on line 16
	EXTI_SWIER1_SWIER15 = 1UL<<15, // Software Interrupt on line 15
	EXTI_SWIER1_SWIER14 = 1UL<<14, // Software Interrupt on line 14
	EXTI_SWIER1_SWIER13 = 1UL<<13, // Software Interrupt on line 13
	EXTI_SWIER1_SWIER12 = 1UL<<12, // Software Interrupt on line 12
	EXTI_SWIER1_SWIER11 = 1UL<<11, // Software Interrupt on line 11
	EXTI_SWIER1_SWIER10 = 1UL<<10, // Software Interrupt on line 10
	EXTI_SWIER1_SWIER9 = 1UL<<9, // Software Interrupt on line 9
	EXTI_SWIER1_SWIER8 = 1UL<<8, // Software Interrupt on line 8
	EXTI_SWIER1_SWIER7 = 1UL<<7, // Software Interrupt on line 7
	EXTI_SWIER1_SWIER6 = 1UL<<6, // Software Interrupt on line 6
	EXTI_SWIER1_SWIER5 = 1UL<<5, // Software Interrupt on line 5
	EXTI_SWIER1_SWIER4 = 1UL<<4, // Software Interrupt on line 4
	EXTI_SWIER1_SWIER3 = 1UL<<3, // Software Interrupt on line 3
	EXTI_SWIER1_SWIER2 = 1UL<<2, // Software Interrupt on line 2
	EXTI_SWIER1_SWIER1 = 1UL<<1, // Software Interrupt on line 1
	EXTI_SWIER1_SWIER0 = 1UL<<0, // Software Interrupt on line 0		
};

// EXTI->PR1 Pending register
enum {
	EXTI_PR1_PR22 = 1UL<<22, // Pending bit 22
	EXTI_PR1_PR21 = 1UL<<21, // Pending bit 21
	EXTI_PR1_PR20 = 1UL<<20, // Pending bit 20
	EXTI_PR1_PR19 = 1UL<<19, // Pending bit 19
	EXTI_PR1_PR18 = 1UL<<18, // Pending bit 18
	EXTI_PR1_PR16 = 1UL<<16, // Pending bit 16
	EXTI_PR1_PR15 = 1UL<<15, // Pending bit 15
	EXTI_PR1_PR14 = 1UL<<14, // Pending bit 14
	EXTI_PR1_PR13 = 1UL<<13, // Pending bit 13
	EXTI_PR1_PR12 = 1UL<<12, // Pending bit 12
	EXTI_PR1_PR11 = 1UL<<11, // Pending bit 11
	EXTI_PR1_PR10 = 1UL<<10, // Pending bit 10
	EXTI_PR1_PR9 = 1UL<<9, // Pending bit 9
	EXTI_PR1_PR8 = 1UL<<8, // Pending bit 8
	EXTI_PR1_PR7 = 1UL<<7, // Pending bit 7
	EXTI_PR1_PR6 = 1UL<<6, // Pending bit 6
	EXTI_PR1_PR5 = 1UL<<5, // Pending bit 5
	EXTI_PR1_PR4 = 1UL<<4, // Pending bit 4
	EXTI_PR1_PR3 = 1UL<<3, // Pending bit 3
	EXTI_PR1_PR2 = 1UL<<2, // Pending bit 2
	EXTI_PR1_PR1 = 1UL<<1, // Pending bit 1
	EXTI_PR1_PR0 = 1UL<<0, // Pending bit 0		
};

// EXTI->RTSR2 Rising Trigger selection register
enum {
	EXTI_RTSR2_RT38 = 1UL<<6, // Rising trigger event configuration bit of line 38
	EXTI_RTSR2_RT37 = 1UL<<5, // Rising trigger event configuration bit of line 37
	EXTI_RTSR2_RT36 = 1UL<<4, // Rising trigger event configuration bit of line 36
	EXTI_RTSR2_RT35 = 1UL<<3, // Rising trigger event configuration bit of line 35		
};

// EXTI->FTSR2 Falling Trigger selection register
enum {
	EXTI_FTSR2_FT38 = 1UL<<6, // Falling trigger event configuration bit of line 38
	EXTI_FTSR2_FT37 = 1UL<<5, // Falling trigger event configuration bit of line 37
	EXTI_FTSR2_FT36 = 1UL<<4, // Falling trigger event configuration bit of line 36
	EXTI_FTSR2_FT35 = 1UL<<3, // Falling trigger event configuration bit of line 35		
};

// EXTI->SWIER2 Software interrupt event register
enum {
	EXTI_SWIER2_SWI38 = 1UL<<6, // Software interrupt on line 38
	EXTI_SWIER2_SWI37 = 1UL<<5, // Software interrupt on line 37
	EXTI_SWIER2_SWI36 = 1UL<<4, // Software interrupt on line 36
	EXTI_SWIER2_SWI35 = 1UL<<3, // Software interrupt on line 35		
};

// EXTI->PR2 Pending register
enum {
	EXTI_PR2_PIF38 = 1UL<<6, // Pending interrupt flag on line 38
	EXTI_PR2_PIF37 = 1UL<<5, // Pending interrupt flag on line 37
	EXTI_PR2_PIF36 = 1UL<<4, // Pending interrupt flag on line 36
	EXTI_PR2_PIF35 = 1UL<<3, // Pending interrupt flag on line 35		
};

/* Flash
There is only one peripheral of type FLASH. */
struct FLASH_Type {
	__IO uint16_t ACR; // @0 Access control register
	 uint8_t RESERVED0[2]; // @2 
	__O uint32_t PDKEYR; // @4 Power down key register
	__O uint32_t KEYR; // @8 Flash key register
	__O uint32_t OPTKEYR; // @12 Option byte key register
	__IO uint32_t SR; // @16 Status register
	__IO uint32_t CR; // @20 Flash control register
	__IO uint32_t ECCR; // @24 Flash ECC register
	 uint8_t RESERVED1[4]; // @28 
	__IO uint32_t OPTR; // @32 Flash option register
	__IO uint16_t PCROP1SR; // @36 Flash Bank 1 PCROP Start address register
	 uint8_t RESERVED2[2]; // @38 
	__IO uint32_t PCROP1ER; // @40 Flash Bank 1 PCROP End address register
	__IO uint32_t WRP1AR; // @44 Flash Bank 1 WRP area A address register
	__IO uint32_t WRP1BR; // @48 Flash Bank 1 WRP area B address register
	 uint8_t RESERVED3[16]; // @52 
	__IO uint16_t PCROP2SR; // @68 Flash Bank 2 PCROP Start address register
	 uint8_t RESERVED4[2]; // @70 
	__IO uint16_t PCROP2ER; // @72 Flash Bank 2 PCROP End address register
	 uint8_t RESERVED5[2]; // @74 
	__IO uint32_t WRP2AR; // @76 Flash Bank 2 WRP area A address register
	__IO uint32_t WRP2BR; // @80 Flash Bank 2 WRP area B address register
};
extern struct FLASH_Type	FLASH;	// @0x40022000 

// FLASH->ACR Access control register
enum {
	FLASH_ACR_SLEEP_PD = 1UL<<14, // Flash Power-down mode during Low-power sleep mode
	FLASH_ACR_RUN_PD = 1UL<<13, // Flash Power-down mode during Low-power run mode
	FLASH_ACR_DCRST = 1UL<<12, // Data cache reset
	FLASH_ACR_ICRST = 1UL<<11, // Instruction cache reset
	FLASH_ACR_DCEN = 1UL<<10, // Data cache enable
	FLASH_ACR_ICEN = 1UL<<9, // Instruction cache enable
	FLASH_ACR_PRFTEN = 1UL<<8, // Prefetch enable
	FLASH_ACR_LATENCY = ((1UL<<3)-1) << 0, // Latency		
};
static inline void flash_acr_set_latency(uint32_t val) { FLASH.ACR = (FLASH.ACR & ~FLASH_ACR_LATENCY) | ((val<<0) & FLASH_ACR_LATENCY); }
static inline uint32_t flash_acr_get_latency(void) { return (FLASH.ACR & FLASH_ACR_LATENCY) >> 0 ; }

// FLASH->SR Status register
enum {
	FLASH_SR_BSY = 1UL<<16, // Busy
	FLASH_SR_OPTVERR = 1UL<<15, // Option validity error
	FLASH_SR_RDERR = 1UL<<14, // PCROP read error
	FLASH_SR_FASTERR = 1UL<<9, // Fast programming error
	FLASH_SR_MISERR = 1UL<<8, // Fast programming data miss error
	FLASH_SR_PGSERR = 1UL<<7, // Programming sequence error
	FLASH_SR_SIZERR = 1UL<<6, // Size error
	FLASH_SR_PGAERR = 1UL<<5, // Programming alignment error
	FLASH_SR_WRPERR = 1UL<<4, // Write protected error
	FLASH_SR_PROGERR = 1UL<<3, // Programming error
	FLASH_SR_OPERR = 1UL<<1, // Operation error
	FLASH_SR_EOP = 1UL<<0, // End of operation		
};

// FLASH->CR Flash control register
enum {
	FLASH_CR_LOCK = 1UL<<31, // FLASH_CR Lock
	FLASH_CR_OPTLOCK = 1UL<<30, // Options Lock
	FLASH_CR_OBL_LAUNCH = 1UL<<27, // Force the option byte loading
	FLASH_CR_RDERRIE = 1UL<<26, // PCROP read error interrupt enable
	FLASH_CR_ERRIE = 1UL<<25, // Error interrupt enable
	FLASH_CR_EOPIE = 1UL<<24, // End of operation interrupt enable
	FLASH_CR_FSTPG = 1UL<<18, // Fast programming
	FLASH_CR_OPTSTRT = 1UL<<17, // Options modification start
	FLASH_CR_START = 1UL<<16, // Start
	FLASH_CR_MER2 = 1UL<<15, // Bank 2 Mass erase
	FLASH_CR_BKER = 1UL<<11, // Bank erase
	FLASH_CR_PNB = ((1UL<<8)-1) << 3, // Page number
	FLASH_CR_MER1 = 1UL<<2, // Bank 1 Mass erase
	FLASH_CR_PER = 1UL<<1, // Page erase
	FLASH_CR_PG = 1UL<<0, // Programming		
};
static inline void flash_cr_set_pnb(uint32_t val) { FLASH.CR = (FLASH.CR & ~FLASH_CR_PNB) | ((val<<3) & FLASH_CR_PNB); }
static inline uint32_t flash_cr_get_pnb(void) { return (FLASH.CR & FLASH_CR_PNB) >> 3 ; }

// FLASH->ECCR Flash ECC register
enum {
	FLASH_ECCR_ECCD = 1UL<<31, // ECC detection
	FLASH_ECCR_ECCC = 1UL<<30, // ECC correction
	FLASH_ECCR_ECCIE = 1UL<<24, // ECC correction interrupt enable
	FLASH_ECCR_SYSF_ECC = 1UL<<20, // System Flash ECC fail
	FLASH_ECCR_BK_ECC = 1UL<<19, // ECC fail bank
	FLASH_ECCR_ADDR_ECC = ((1UL<<19)-1) << 0, // ECC fail address		
};
static inline void flash_eccr_set_addr_ecc(uint32_t val) { FLASH.ECCR = (FLASH.ECCR & ~FLASH_ECCR_ADDR_ECC) | ((val<<0) & FLASH_ECCR_ADDR_ECC); }
static inline uint32_t flash_eccr_get_addr_ecc(void) { return (FLASH.ECCR & FLASH_ECCR_ADDR_ECC) >> 0 ; }

// FLASH->OPTR Flash option register
enum {
	FLASH_OPTR_SRAM2_RST = 1UL<<25, // SRAM2 Erase when system reset
	FLASH_OPTR_SRAM2_PE = 1UL<<24, // SRAM2 parity check enable
	FLASH_OPTR_NBOOT1 = 1UL<<23, // Boot configuration
	FLASH_OPTR_DUALBANK = 1UL<<21, // Dual-Bank on 512 KB or 256 KB Flash memory devices
	FLASH_OPTR_BFB2 = 1UL<<20, // Dual-bank boot
	FLASH_OPTR_WWDG_SW = 1UL<<19, // Window watchdog selection
	FLASH_OPTR_IWDG_STDBY = 1UL<<18, // Independent watchdog counter freeze in Standby mode
	FLASH_OPTR_IWDG_STOP = 1UL<<17, // Independent watchdog counter freeze in Stop mode
	FLASH_OPTR_IDWG_SW = 1UL<<16, // Independent watchdog selection
	FLASH_OPTR_NRST_STDBY = 1UL<<13, // nRST_STDBY
	FLASH_OPTR_NRST_STOP = 1UL<<12, // nRST_STOP
	FLASH_OPTR_BOR_LEV = ((1UL<<3)-1) << 8, // BOR reset Level
	FLASH_OPTR_RDP = ((1UL<<8)-1) << 0, // Read protection level		
};
static inline void flash_optr_set_bor_lev(uint32_t val) { FLASH.OPTR = (FLASH.OPTR & ~FLASH_OPTR_BOR_LEV) | ((val<<8) & FLASH_OPTR_BOR_LEV); }
static inline void flash_optr_set_rdp(uint32_t val) { FLASH.OPTR = (FLASH.OPTR & ~FLASH_OPTR_RDP) | ((val<<0) & FLASH_OPTR_RDP); }
static inline uint32_t flash_optr_get_bor_lev(void) { return (FLASH.OPTR & FLASH_OPTR_BOR_LEV) >> 8 ; }
static inline uint32_t flash_optr_get_rdp(void) { return (FLASH.OPTR & FLASH_OPTR_RDP) >> 0 ; }

// FLASH->PCROP1ER Flash Bank 1 PCROP End address register
enum {
	FLASH_PCROP1ER_PCROP_RDP = 1UL<<31, // PCROP area preserved when RDP level decreased
	FLASH_PCROP1ER_PCROP1_END = ((1UL<<16)-1) << 0, // Bank 1 PCROP area end offset		
};
static inline void flash_pcrop1er_set_pcrop1_end(uint32_t val) { FLASH.PCROP1ER = (FLASH.PCROP1ER & ~FLASH_PCROP1ER_PCROP1_END) | ((val<<0) & FLASH_PCROP1ER_PCROP1_END); }
static inline uint32_t flash_pcrop1er_get_pcrop1_end(void) { return (FLASH.PCROP1ER & FLASH_PCROP1ER_PCROP1_END) >> 0 ; }

// FLASH->WRP1AR Flash Bank 1 WRP area A address register
enum {
	FLASH_WRP1AR_WRP1A_END = ((1UL<<8)-1) << 16, // Bank 1 WRP first area A end offset
	FLASH_WRP1AR_WRP1A_STRT = ((1UL<<8)-1) << 0, // Bank 1 WRP first area tart offset		
};
static inline void flash_wrp1ar_set_wrp1a_end(uint32_t val) { FLASH.WRP1AR = (FLASH.WRP1AR & ~FLASH_WRP1AR_WRP1A_END) | ((val<<16) & FLASH_WRP1AR_WRP1A_END); }
static inline void flash_wrp1ar_set_wrp1a_strt(uint32_t val) { FLASH.WRP1AR = (FLASH.WRP1AR & ~FLASH_WRP1AR_WRP1A_STRT) | ((val<<0) & FLASH_WRP1AR_WRP1A_STRT); }
static inline uint32_t flash_wrp1ar_get_wrp1a_end(void) { return (FLASH.WRP1AR & FLASH_WRP1AR_WRP1A_END) >> 16 ; }
static inline uint32_t flash_wrp1ar_get_wrp1a_strt(void) { return (FLASH.WRP1AR & FLASH_WRP1AR_WRP1A_STRT) >> 0 ; }

// FLASH->WRP1BR Flash Bank 1 WRP area B address register
enum {
	FLASH_WRP1BR_WRP1B_STRT = ((1UL<<8)-1) << 16, // Bank 1 WRP second area B end offset
	FLASH_WRP1BR_WRP1B_END = ((1UL<<8)-1) << 0, // Bank 1 WRP second area B start offset		
};
static inline void flash_wrp1br_set_wrp1b_strt(uint32_t val) { FLASH.WRP1BR = (FLASH.WRP1BR & ~FLASH_WRP1BR_WRP1B_STRT) | ((val<<16) & FLASH_WRP1BR_WRP1B_STRT); }
static inline void flash_wrp1br_set_wrp1b_end(uint32_t val) { FLASH.WRP1BR = (FLASH.WRP1BR & ~FLASH_WRP1BR_WRP1B_END) | ((val<<0) & FLASH_WRP1BR_WRP1B_END); }
static inline uint32_t flash_wrp1br_get_wrp1b_strt(void) { return (FLASH.WRP1BR & FLASH_WRP1BR_WRP1B_STRT) >> 16 ; }
static inline uint32_t flash_wrp1br_get_wrp1b_end(void) { return (FLASH.WRP1BR & FLASH_WRP1BR_WRP1B_END) >> 0 ; }

// FLASH->WRP2AR Flash Bank 2 WRP area A address register
enum {
	FLASH_WRP2AR_WRP2A_END = ((1UL<<8)-1) << 16, // Bank 2 WRP first area A end offset
	FLASH_WRP2AR_WRP2A_STRT = ((1UL<<8)-1) << 0, // Bank 2 WRP first area A start offset		
};
static inline void flash_wrp2ar_set_wrp2a_end(uint32_t val) { FLASH.WRP2AR = (FLASH.WRP2AR & ~FLASH_WRP2AR_WRP2A_END) | ((val<<16) & FLASH_WRP2AR_WRP2A_END); }
static inline void flash_wrp2ar_set_wrp2a_strt(uint32_t val) { FLASH.WRP2AR = (FLASH.WRP2AR & ~FLASH_WRP2AR_WRP2A_STRT) | ((val<<0) & FLASH_WRP2AR_WRP2A_STRT); }
static inline uint32_t flash_wrp2ar_get_wrp2a_end(void) { return (FLASH.WRP2AR & FLASH_WRP2AR_WRP2A_END) >> 16 ; }
static inline uint32_t flash_wrp2ar_get_wrp2a_strt(void) { return (FLASH.WRP2AR & FLASH_WRP2AR_WRP2A_STRT) >> 0 ; }

// FLASH->WRP2BR Flash Bank 2 WRP area B address register
enum {
	FLASH_WRP2BR_WRP2B_END = ((1UL<<8)-1) << 16, // Bank 2 WRP second area B end offset
	FLASH_WRP2BR_WRP2B_STRT = ((1UL<<8)-1) << 0, // Bank 2 WRP second area B start offset		
};
static inline void flash_wrp2br_set_wrp2b_end(uint32_t val) { FLASH.WRP2BR = (FLASH.WRP2BR & ~FLASH_WRP2BR_WRP2B_END) | ((val<<16) & FLASH_WRP2BR_WRP2B_END); }
static inline void flash_wrp2br_set_wrp2b_strt(uint32_t val) { FLASH.WRP2BR = (FLASH.WRP2BR & ~FLASH_WRP2BR_WRP2B_STRT) | ((val<<0) & FLASH_WRP2BR_WRP2B_STRT); }
static inline uint32_t flash_wrp2br_get_wrp2b_end(void) { return (FLASH.WRP2BR & FLASH_WRP2BR_WRP2B_END) >> 16 ; }
static inline uint32_t flash_wrp2br_get_wrp2b_strt(void) { return (FLASH.WRP2BR & FLASH_WRP2BR_WRP2B_STRT) >> 0 ; }

/* Floating point unit CPACR
There is only one peripheral of type FPU_CPACR. */
struct FPU_CPACR_Type {
	__IO uint32_t CPACR; // @0 Coprocessor access control register
};
extern struct FPU_CPACR_Type	FPU_CPACR;	// @0xE000ED88 

// FPU_CPACR->CPACR Coprocessor access control register
enum {
	FPU_CPACR_CPACR_CP = ((1UL<<4)-1) << 20, // CP		
};
static inline void fpu_cpacr_cpacr_set_cp(uint32_t val) { FPU_CPACR.CPACR = (FPU_CPACR.CPACR & ~FPU_CPACR_CPACR_CP) | ((val<<20) & FPU_CPACR_CPACR_CP); }
static inline uint32_t fpu_cpacr_cpacr_get_cp(void) { return (FPU_CPACR.CPACR & FPU_CPACR_CPACR_CP) >> 20 ; }

/* General-purpose I/Os */
struct GPIOE_Type {
	__IO uint32_t MODER; // @0 GPIO port mode register
	__IO uint16_t OTYPER; // @4 GPIO port output type register
	 uint8_t RESERVED0[2]; // @6 
	__IO uint32_t OSPEEDR; // @8 GPIO port output speed register
	__IO uint32_t PUPDR; // @12 GPIO port pull-up/pull-down register
	__I uint16_t IDR; // @16 GPIO port input data register
	 uint8_t RESERVED1[2]; // @18 
	__IO uint16_t ODR; // @20 GPIO port output data register
	 uint8_t RESERVED2[2]; // @22 
	__O uint32_t BSRR; // @24 GPIO port bit set/reset register
	__IO uint32_t LCKR; // @28 GPIO port configuration lock register
	__IO uint32_t AFRL; // @32 GPIO alternate function low register
	__IO uint32_t AFRH; // @36 GPIO alternate function high register
};
extern struct GPIOE_Type	GPIOA;	// @0x48000000 
extern struct GPIOE_Type 	GPIOB;	// @0x48000400
extern struct GPIOE_Type 	GPIOC;	// @0x48000800
extern struct GPIOE_Type 	GPIOD;	// @0x48000C00
extern struct GPIOE_Type 	GPIOE;	// @0x48001000
extern struct GPIOE_Type 	GPIOH;	// @0x48001C00

// GPIOE->MODER GPIO port mode register
enum {
	GPIOE_MODER_MODER15 = ((1UL<<2)-1) << 30, // Port x configuration bits (y = 0..15)
	GPIOE_MODER_MODER14 = ((1UL<<2)-1) << 28, // Port x configuration bits (y = 0..15)
	GPIOE_MODER_MODER13 = ((1UL<<2)-1) << 26, // Port x configuration bits (y = 0..15)
	GPIOE_MODER_MODER12 = ((1UL<<2)-1) << 24, // Port x configuration bits (y = 0..15)
	GPIOE_MODER_MODER11 = ((1UL<<2)-1) << 22, // Port x configuration bits (y = 0..15)
	GPIOE_MODER_MODER10 = ((1UL<<2)-1) << 20, // Port x configuration bits (y = 0..15)
	GPIOE_MODER_MODER9 = ((1UL<<2)-1) << 18, // Port x configuration bits (y = 0..15)
	GPIOE_MODER_MODER8 = ((1UL<<2)-1) << 16, // Port x configuration bits (y = 0..15)
	GPIOE_MODER_MODER7 = ((1UL<<2)-1) << 14, // Port x configuration bits (y = 0..15)
	GPIOE_MODER_MODER6 = ((1UL<<2)-1) << 12, // Port x configuration bits (y = 0..15)
	GPIOE_MODER_MODER5 = ((1UL<<2)-1) << 10, // Port x configuration bits (y = 0..15)
	GPIOE_MODER_MODER4 = ((1UL<<2)-1) << 8, // Port x configuration bits (y = 0..15)
	GPIOE_MODER_MODER3 = ((1UL<<2)-1) << 6, // Port x configuration bits (y = 0..15)
	GPIOE_MODER_MODER2 = ((1UL<<2)-1) << 4, // Port x configuration bits (y = 0..15)
	GPIOE_MODER_MODER1 = ((1UL<<2)-1) << 2, // Port x configuration bits (y = 0..15)
	GPIOE_MODER_MODER0 = ((1UL<<2)-1) << 0, // Port x configuration bits (y = 0..15)		
};
static inline void gpioe_moder_set_moder15(struct GPIOE_Type* p, uint32_t val) { p->MODER = (p->MODER & ~GPIOE_MODER_MODER15) | ((val<<30) & GPIOE_MODER_MODER15); }
static inline void gpioe_moder_set_moder14(struct GPIOE_Type* p, uint32_t val) { p->MODER = (p->MODER & ~GPIOE_MODER_MODER14) | ((val<<28) & GPIOE_MODER_MODER14); }
static inline void gpioe_moder_set_moder13(struct GPIOE_Type* p, uint32_t val) { p->MODER = (p->MODER & ~GPIOE_MODER_MODER13) | ((val<<26) & GPIOE_MODER_MODER13); }
static inline void gpioe_moder_set_moder12(struct GPIOE_Type* p, uint32_t val) { p->MODER = (p->MODER & ~GPIOE_MODER_MODER12) | ((val<<24) & GPIOE_MODER_MODER12); }
static inline void gpioe_moder_set_moder11(struct GPIOE_Type* p, uint32_t val) { p->MODER = (p->MODER & ~GPIOE_MODER_MODER11) | ((val<<22) & GPIOE_MODER_MODER11); }
static inline void gpioe_moder_set_moder10(struct GPIOE_Type* p, uint32_t val) { p->MODER = (p->MODER & ~GPIOE_MODER_MODER10) | ((val<<20) & GPIOE_MODER_MODER10); }
static inline void gpioe_moder_set_moder9(struct GPIOE_Type* p, uint32_t val) { p->MODER = (p->MODER & ~GPIOE_MODER_MODER9) | ((val<<18) & GPIOE_MODER_MODER9); }
static inline void gpioe_moder_set_moder8(struct GPIOE_Type* p, uint32_t val) { p->MODER = (p->MODER & ~GPIOE_MODER_MODER8) | ((val<<16) & GPIOE_MODER_MODER8); }
static inline void gpioe_moder_set_moder7(struct GPIOE_Type* p, uint32_t val) { p->MODER = (p->MODER & ~GPIOE_MODER_MODER7) | ((val<<14) & GPIOE_MODER_MODER7); }
static inline void gpioe_moder_set_moder6(struct GPIOE_Type* p, uint32_t val) { p->MODER = (p->MODER & ~GPIOE_MODER_MODER6) | ((val<<12) & GPIOE_MODER_MODER6); }
static inline void gpioe_moder_set_moder5(struct GPIOE_Type* p, uint32_t val) { p->MODER = (p->MODER & ~GPIOE_MODER_MODER5) | ((val<<10) & GPIOE_MODER_MODER5); }
static inline void gpioe_moder_set_moder4(struct GPIOE_Type* p, uint32_t val) { p->MODER = (p->MODER & ~GPIOE_MODER_MODER4) | ((val<<8) & GPIOE_MODER_MODER4); }
static inline void gpioe_moder_set_moder3(struct GPIOE_Type* p, uint32_t val) { p->MODER = (p->MODER & ~GPIOE_MODER_MODER3) | ((val<<6) & GPIOE_MODER_MODER3); }
static inline void gpioe_moder_set_moder2(struct GPIOE_Type* p, uint32_t val) { p->MODER = (p->MODER & ~GPIOE_MODER_MODER2) | ((val<<4) & GPIOE_MODER_MODER2); }
static inline void gpioe_moder_set_moder1(struct GPIOE_Type* p, uint32_t val) { p->MODER = (p->MODER & ~GPIOE_MODER_MODER1) | ((val<<2) & GPIOE_MODER_MODER1); }
static inline void gpioe_moder_set_moder0(struct GPIOE_Type* p, uint32_t val) { p->MODER = (p->MODER & ~GPIOE_MODER_MODER0) | ((val<<0) & GPIOE_MODER_MODER0); }
static inline uint32_t gpioe_moder_get_moder15(struct GPIOE_Type* p) { return (p->MODER & GPIOE_MODER_MODER15) >> 30 ; }
static inline uint32_t gpioe_moder_get_moder14(struct GPIOE_Type* p) { return (p->MODER & GPIOE_MODER_MODER14) >> 28 ; }
static inline uint32_t gpioe_moder_get_moder13(struct GPIOE_Type* p) { return (p->MODER & GPIOE_MODER_MODER13) >> 26 ; }
static inline uint32_t gpioe_moder_get_moder12(struct GPIOE_Type* p) { return (p->MODER & GPIOE_MODER_MODER12) >> 24 ; }
static inline uint32_t gpioe_moder_get_moder11(struct GPIOE_Type* p) { return (p->MODER & GPIOE_MODER_MODER11) >> 22 ; }
static inline uint32_t gpioe_moder_get_moder10(struct GPIOE_Type* p) { return (p->MODER & GPIOE_MODER_MODER10) >> 20 ; }
static inline uint32_t gpioe_moder_get_moder9(struct GPIOE_Type* p) { return (p->MODER & GPIOE_MODER_MODER9) >> 18 ; }
static inline uint32_t gpioe_moder_get_moder8(struct GPIOE_Type* p) { return (p->MODER & GPIOE_MODER_MODER8) >> 16 ; }
static inline uint32_t gpioe_moder_get_moder7(struct GPIOE_Type* p) { return (p->MODER & GPIOE_MODER_MODER7) >> 14 ; }
static inline uint32_t gpioe_moder_get_moder6(struct GPIOE_Type* p) { return (p->MODER & GPIOE_MODER_MODER6) >> 12 ; }
static inline uint32_t gpioe_moder_get_moder5(struct GPIOE_Type* p) { return (p->MODER & GPIOE_MODER_MODER5) >> 10 ; }
static inline uint32_t gpioe_moder_get_moder4(struct GPIOE_Type* p) { return (p->MODER & GPIOE_MODER_MODER4) >> 8 ; }
static inline uint32_t gpioe_moder_get_moder3(struct GPIOE_Type* p) { return (p->MODER & GPIOE_MODER_MODER3) >> 6 ; }
static inline uint32_t gpioe_moder_get_moder2(struct GPIOE_Type* p) { return (p->MODER & GPIOE_MODER_MODER2) >> 4 ; }
static inline uint32_t gpioe_moder_get_moder1(struct GPIOE_Type* p) { return (p->MODER & GPIOE_MODER_MODER1) >> 2 ; }
static inline uint32_t gpioe_moder_get_moder0(struct GPIOE_Type* p) { return (p->MODER & GPIOE_MODER_MODER0) >> 0 ; }

// GPIOE->OSPEEDR GPIO port output speed register
enum {
	GPIOE_OSPEEDR_OSPEEDR15 = ((1UL<<2)-1) << 30, // Port x configuration bits (y = 0..15)
	GPIOE_OSPEEDR_OSPEEDR14 = ((1UL<<2)-1) << 28, // Port x configuration bits (y = 0..15)
	GPIOE_OSPEEDR_OSPEEDR13 = ((1UL<<2)-1) << 26, // Port x configuration bits (y = 0..15)
	GPIOE_OSPEEDR_OSPEEDR12 = ((1UL<<2)-1) << 24, // Port x configuration bits (y = 0..15)
	GPIOE_OSPEEDR_OSPEEDR11 = ((1UL<<2)-1) << 22, // Port x configuration bits (y = 0..15)
	GPIOE_OSPEEDR_OSPEEDR10 = ((1UL<<2)-1) << 20, // Port x configuration bits (y = 0..15)
	GPIOE_OSPEEDR_OSPEEDR9 = ((1UL<<2)-1) << 18, // Port x configuration bits (y = 0..15)
	GPIOE_OSPEEDR_OSPEEDR8 = ((1UL<<2)-1) << 16, // Port x configuration bits (y = 0..15)
	GPIOE_OSPEEDR_OSPEEDR7 = ((1UL<<2)-1) << 14, // Port x configuration bits (y = 0..15)
	GPIOE_OSPEEDR_OSPEEDR6 = ((1UL<<2)-1) << 12, // Port x configuration bits (y = 0..15)
	GPIOE_OSPEEDR_OSPEEDR5 = ((1UL<<2)-1) << 10, // Port x configuration bits (y = 0..15)
	GPIOE_OSPEEDR_OSPEEDR4 = ((1UL<<2)-1) << 8, // Port x configuration bits (y = 0..15)
	GPIOE_OSPEEDR_OSPEEDR3 = ((1UL<<2)-1) << 6, // Port x configuration bits (y = 0..15)
	GPIOE_OSPEEDR_OSPEEDR2 = ((1UL<<2)-1) << 4, // Port x configuration bits (y = 0..15)
	GPIOE_OSPEEDR_OSPEEDR1 = ((1UL<<2)-1) << 2, // Port x configuration bits (y = 0..15)
	GPIOE_OSPEEDR_OSPEEDR0 = ((1UL<<2)-1) << 0, // Port x configuration bits (y = 0..15)		
};
static inline void gpioe_ospeedr_set_ospeedr15(struct GPIOE_Type* p, uint32_t val) { p->OSPEEDR = (p->OSPEEDR & ~GPIOE_OSPEEDR_OSPEEDR15) | ((val<<30) & GPIOE_OSPEEDR_OSPEEDR15); }
static inline void gpioe_ospeedr_set_ospeedr14(struct GPIOE_Type* p, uint32_t val) { p->OSPEEDR = (p->OSPEEDR & ~GPIOE_OSPEEDR_OSPEEDR14) | ((val<<28) & GPIOE_OSPEEDR_OSPEEDR14); }
static inline void gpioe_ospeedr_set_ospeedr13(struct GPIOE_Type* p, uint32_t val) { p->OSPEEDR = (p->OSPEEDR & ~GPIOE_OSPEEDR_OSPEEDR13) | ((val<<26) & GPIOE_OSPEEDR_OSPEEDR13); }
static inline void gpioe_ospeedr_set_ospeedr12(struct GPIOE_Type* p, uint32_t val) { p->OSPEEDR = (p->OSPEEDR & ~GPIOE_OSPEEDR_OSPEEDR12) | ((val<<24) & GPIOE_OSPEEDR_OSPEEDR12); }
static inline void gpioe_ospeedr_set_ospeedr11(struct GPIOE_Type* p, uint32_t val) { p->OSPEEDR = (p->OSPEEDR & ~GPIOE_OSPEEDR_OSPEEDR11) | ((val<<22) & GPIOE_OSPEEDR_OSPEEDR11); }
static inline void gpioe_ospeedr_set_ospeedr10(struct GPIOE_Type* p, uint32_t val) { p->OSPEEDR = (p->OSPEEDR & ~GPIOE_OSPEEDR_OSPEEDR10) | ((val<<20) & GPIOE_OSPEEDR_OSPEEDR10); }
static inline void gpioe_ospeedr_set_ospeedr9(struct GPIOE_Type* p, uint32_t val) { p->OSPEEDR = (p->OSPEEDR & ~GPIOE_OSPEEDR_OSPEEDR9) | ((val<<18) & GPIOE_OSPEEDR_OSPEEDR9); }
static inline void gpioe_ospeedr_set_ospeedr8(struct GPIOE_Type* p, uint32_t val) { p->OSPEEDR = (p->OSPEEDR & ~GPIOE_OSPEEDR_OSPEEDR8) | ((val<<16) & GPIOE_OSPEEDR_OSPEEDR8); }
static inline void gpioe_ospeedr_set_ospeedr7(struct GPIOE_Type* p, uint32_t val) { p->OSPEEDR = (p->OSPEEDR & ~GPIOE_OSPEEDR_OSPEEDR7) | ((val<<14) & GPIOE_OSPEEDR_OSPEEDR7); }
static inline void gpioe_ospeedr_set_ospeedr6(struct GPIOE_Type* p, uint32_t val) { p->OSPEEDR = (p->OSPEEDR & ~GPIOE_OSPEEDR_OSPEEDR6) | ((val<<12) & GPIOE_OSPEEDR_OSPEEDR6); }
static inline void gpioe_ospeedr_set_ospeedr5(struct GPIOE_Type* p, uint32_t val) { p->OSPEEDR = (p->OSPEEDR & ~GPIOE_OSPEEDR_OSPEEDR5) | ((val<<10) & GPIOE_OSPEEDR_OSPEEDR5); }
static inline void gpioe_ospeedr_set_ospeedr4(struct GPIOE_Type* p, uint32_t val) { p->OSPEEDR = (p->OSPEEDR & ~GPIOE_OSPEEDR_OSPEEDR4) | ((val<<8) & GPIOE_OSPEEDR_OSPEEDR4); }
static inline void gpioe_ospeedr_set_ospeedr3(struct GPIOE_Type* p, uint32_t val) { p->OSPEEDR = (p->OSPEEDR & ~GPIOE_OSPEEDR_OSPEEDR3) | ((val<<6) & GPIOE_OSPEEDR_OSPEEDR3); }
static inline void gpioe_ospeedr_set_ospeedr2(struct GPIOE_Type* p, uint32_t val) { p->OSPEEDR = (p->OSPEEDR & ~GPIOE_OSPEEDR_OSPEEDR2) | ((val<<4) & GPIOE_OSPEEDR_OSPEEDR2); }
static inline void gpioe_ospeedr_set_ospeedr1(struct GPIOE_Type* p, uint32_t val) { p->OSPEEDR = (p->OSPEEDR & ~GPIOE_OSPEEDR_OSPEEDR1) | ((val<<2) & GPIOE_OSPEEDR_OSPEEDR1); }
static inline void gpioe_ospeedr_set_ospeedr0(struct GPIOE_Type* p, uint32_t val) { p->OSPEEDR = (p->OSPEEDR & ~GPIOE_OSPEEDR_OSPEEDR0) | ((val<<0) & GPIOE_OSPEEDR_OSPEEDR0); }
static inline uint32_t gpioe_ospeedr_get_ospeedr15(struct GPIOE_Type* p) { return (p->OSPEEDR & GPIOE_OSPEEDR_OSPEEDR15) >> 30 ; }
static inline uint32_t gpioe_ospeedr_get_ospeedr14(struct GPIOE_Type* p) { return (p->OSPEEDR & GPIOE_OSPEEDR_OSPEEDR14) >> 28 ; }
static inline uint32_t gpioe_ospeedr_get_ospeedr13(struct GPIOE_Type* p) { return (p->OSPEEDR & GPIOE_OSPEEDR_OSPEEDR13) >> 26 ; }
static inline uint32_t gpioe_ospeedr_get_ospeedr12(struct GPIOE_Type* p) { return (p->OSPEEDR & GPIOE_OSPEEDR_OSPEEDR12) >> 24 ; }
static inline uint32_t gpioe_ospeedr_get_ospeedr11(struct GPIOE_Type* p) { return (p->OSPEEDR & GPIOE_OSPEEDR_OSPEEDR11) >> 22 ; }
static inline uint32_t gpioe_ospeedr_get_ospeedr10(struct GPIOE_Type* p) { return (p->OSPEEDR & GPIOE_OSPEEDR_OSPEEDR10) >> 20 ; }
static inline uint32_t gpioe_ospeedr_get_ospeedr9(struct GPIOE_Type* p) { return (p->OSPEEDR & GPIOE_OSPEEDR_OSPEEDR9) >> 18 ; }
static inline uint32_t gpioe_ospeedr_get_ospeedr8(struct GPIOE_Type* p) { return (p->OSPEEDR & GPIOE_OSPEEDR_OSPEEDR8) >> 16 ; }
static inline uint32_t gpioe_ospeedr_get_ospeedr7(struct GPIOE_Type* p) { return (p->OSPEEDR & GPIOE_OSPEEDR_OSPEEDR7) >> 14 ; }
static inline uint32_t gpioe_ospeedr_get_ospeedr6(struct GPIOE_Type* p) { return (p->OSPEEDR & GPIOE_OSPEEDR_OSPEEDR6) >> 12 ; }
static inline uint32_t gpioe_ospeedr_get_ospeedr5(struct GPIOE_Type* p) { return (p->OSPEEDR & GPIOE_OSPEEDR_OSPEEDR5) >> 10 ; }
static inline uint32_t gpioe_ospeedr_get_ospeedr4(struct GPIOE_Type* p) { return (p->OSPEEDR & GPIOE_OSPEEDR_OSPEEDR4) >> 8 ; }
static inline uint32_t gpioe_ospeedr_get_ospeedr3(struct GPIOE_Type* p) { return (p->OSPEEDR & GPIOE_OSPEEDR_OSPEEDR3) >> 6 ; }
static inline uint32_t gpioe_ospeedr_get_ospeedr2(struct GPIOE_Type* p) { return (p->OSPEEDR & GPIOE_OSPEEDR_OSPEEDR2) >> 4 ; }
static inline uint32_t gpioe_ospeedr_get_ospeedr1(struct GPIOE_Type* p) { return (p->OSPEEDR & GPIOE_OSPEEDR_OSPEEDR1) >> 2 ; }
static inline uint32_t gpioe_ospeedr_get_ospeedr0(struct GPIOE_Type* p) { return (p->OSPEEDR & GPIOE_OSPEEDR_OSPEEDR0) >> 0 ; }

// GPIOE->PUPDR GPIO port pull-up/pull-down register
enum {
	GPIOE_PUPDR_PUPDR15 = ((1UL<<2)-1) << 30, // Port x configuration bits (y = 0..15)
	GPIOE_PUPDR_PUPDR14 = ((1UL<<2)-1) << 28, // Port x configuration bits (y = 0..15)
	GPIOE_PUPDR_PUPDR13 = ((1UL<<2)-1) << 26, // Port x configuration bits (y = 0..15)
	GPIOE_PUPDR_PUPDR12 = ((1UL<<2)-1) << 24, // Port x configuration bits (y = 0..15)
	GPIOE_PUPDR_PUPDR11 = ((1UL<<2)-1) << 22, // Port x configuration bits (y = 0..15)
	GPIOE_PUPDR_PUPDR10 = ((1UL<<2)-1) << 20, // Port x configuration bits (y = 0..15)
	GPIOE_PUPDR_PUPDR9 = ((1UL<<2)-1) << 18, // Port x configuration bits (y = 0..15)
	GPIOE_PUPDR_PUPDR8 = ((1UL<<2)-1) << 16, // Port x configuration bits (y = 0..15)
	GPIOE_PUPDR_PUPDR7 = ((1UL<<2)-1) << 14, // Port x configuration bits (y = 0..15)
	GPIOE_PUPDR_PUPDR6 = ((1UL<<2)-1) << 12, // Port x configuration bits (y = 0..15)
	GPIOE_PUPDR_PUPDR5 = ((1UL<<2)-1) << 10, // Port x configuration bits (y = 0..15)
	GPIOE_PUPDR_PUPDR4 = ((1UL<<2)-1) << 8, // Port x configuration bits (y = 0..15)
	GPIOE_PUPDR_PUPDR3 = ((1UL<<2)-1) << 6, // Port x configuration bits (y = 0..15)
	GPIOE_PUPDR_PUPDR2 = ((1UL<<2)-1) << 4, // Port x configuration bits (y = 0..15)
	GPIOE_PUPDR_PUPDR1 = ((1UL<<2)-1) << 2, // Port x configuration bits (y = 0..15)
	GPIOE_PUPDR_PUPDR0 = ((1UL<<2)-1) << 0, // Port x configuration bits (y = 0..15)		
};
static inline void gpioe_pupdr_set_pupdr15(struct GPIOE_Type* p, uint32_t val) { p->PUPDR = (p->PUPDR & ~GPIOE_PUPDR_PUPDR15) | ((val<<30) & GPIOE_PUPDR_PUPDR15); }
static inline void gpioe_pupdr_set_pupdr14(struct GPIOE_Type* p, uint32_t val) { p->PUPDR = (p->PUPDR & ~GPIOE_PUPDR_PUPDR14) | ((val<<28) & GPIOE_PUPDR_PUPDR14); }
static inline void gpioe_pupdr_set_pupdr13(struct GPIOE_Type* p, uint32_t val) { p->PUPDR = (p->PUPDR & ~GPIOE_PUPDR_PUPDR13) | ((val<<26) & GPIOE_PUPDR_PUPDR13); }
static inline void gpioe_pupdr_set_pupdr12(struct GPIOE_Type* p, uint32_t val) { p->PUPDR = (p->PUPDR & ~GPIOE_PUPDR_PUPDR12) | ((val<<24) & GPIOE_PUPDR_PUPDR12); }
static inline void gpioe_pupdr_set_pupdr11(struct GPIOE_Type* p, uint32_t val) { p->PUPDR = (p->PUPDR & ~GPIOE_PUPDR_PUPDR11) | ((val<<22) & GPIOE_PUPDR_PUPDR11); }
static inline void gpioe_pupdr_set_pupdr10(struct GPIOE_Type* p, uint32_t val) { p->PUPDR = (p->PUPDR & ~GPIOE_PUPDR_PUPDR10) | ((val<<20) & GPIOE_PUPDR_PUPDR10); }
static inline void gpioe_pupdr_set_pupdr9(struct GPIOE_Type* p, uint32_t val) { p->PUPDR = (p->PUPDR & ~GPIOE_PUPDR_PUPDR9) | ((val<<18) & GPIOE_PUPDR_PUPDR9); }
static inline void gpioe_pupdr_set_pupdr8(struct GPIOE_Type* p, uint32_t val) { p->PUPDR = (p->PUPDR & ~GPIOE_PUPDR_PUPDR8) | ((val<<16) & GPIOE_PUPDR_PUPDR8); }
static inline void gpioe_pupdr_set_pupdr7(struct GPIOE_Type* p, uint32_t val) { p->PUPDR = (p->PUPDR & ~GPIOE_PUPDR_PUPDR7) | ((val<<14) & GPIOE_PUPDR_PUPDR7); }
static inline void gpioe_pupdr_set_pupdr6(struct GPIOE_Type* p, uint32_t val) { p->PUPDR = (p->PUPDR & ~GPIOE_PUPDR_PUPDR6) | ((val<<12) & GPIOE_PUPDR_PUPDR6); }
static inline void gpioe_pupdr_set_pupdr5(struct GPIOE_Type* p, uint32_t val) { p->PUPDR = (p->PUPDR & ~GPIOE_PUPDR_PUPDR5) | ((val<<10) & GPIOE_PUPDR_PUPDR5); }
static inline void gpioe_pupdr_set_pupdr4(struct GPIOE_Type* p, uint32_t val) { p->PUPDR = (p->PUPDR & ~GPIOE_PUPDR_PUPDR4) | ((val<<8) & GPIOE_PUPDR_PUPDR4); }
static inline void gpioe_pupdr_set_pupdr3(struct GPIOE_Type* p, uint32_t val) { p->PUPDR = (p->PUPDR & ~GPIOE_PUPDR_PUPDR3) | ((val<<6) & GPIOE_PUPDR_PUPDR3); }
static inline void gpioe_pupdr_set_pupdr2(struct GPIOE_Type* p, uint32_t val) { p->PUPDR = (p->PUPDR & ~GPIOE_PUPDR_PUPDR2) | ((val<<4) & GPIOE_PUPDR_PUPDR2); }
static inline void gpioe_pupdr_set_pupdr1(struct GPIOE_Type* p, uint32_t val) { p->PUPDR = (p->PUPDR & ~GPIOE_PUPDR_PUPDR1) | ((val<<2) & GPIOE_PUPDR_PUPDR1); }
static inline void gpioe_pupdr_set_pupdr0(struct GPIOE_Type* p, uint32_t val) { p->PUPDR = (p->PUPDR & ~GPIOE_PUPDR_PUPDR0) | ((val<<0) & GPIOE_PUPDR_PUPDR0); }
static inline uint32_t gpioe_pupdr_get_pupdr15(struct GPIOE_Type* p) { return (p->PUPDR & GPIOE_PUPDR_PUPDR15) >> 30 ; }
static inline uint32_t gpioe_pupdr_get_pupdr14(struct GPIOE_Type* p) { return (p->PUPDR & GPIOE_PUPDR_PUPDR14) >> 28 ; }
static inline uint32_t gpioe_pupdr_get_pupdr13(struct GPIOE_Type* p) { return (p->PUPDR & GPIOE_PUPDR_PUPDR13) >> 26 ; }
static inline uint32_t gpioe_pupdr_get_pupdr12(struct GPIOE_Type* p) { return (p->PUPDR & GPIOE_PUPDR_PUPDR12) >> 24 ; }
static inline uint32_t gpioe_pupdr_get_pupdr11(struct GPIOE_Type* p) { return (p->PUPDR & GPIOE_PUPDR_PUPDR11) >> 22 ; }
static inline uint32_t gpioe_pupdr_get_pupdr10(struct GPIOE_Type* p) { return (p->PUPDR & GPIOE_PUPDR_PUPDR10) >> 20 ; }
static inline uint32_t gpioe_pupdr_get_pupdr9(struct GPIOE_Type* p) { return (p->PUPDR & GPIOE_PUPDR_PUPDR9) >> 18 ; }
static inline uint32_t gpioe_pupdr_get_pupdr8(struct GPIOE_Type* p) { return (p->PUPDR & GPIOE_PUPDR_PUPDR8) >> 16 ; }
static inline uint32_t gpioe_pupdr_get_pupdr7(struct GPIOE_Type* p) { return (p->PUPDR & GPIOE_PUPDR_PUPDR7) >> 14 ; }
static inline uint32_t gpioe_pupdr_get_pupdr6(struct GPIOE_Type* p) { return (p->PUPDR & GPIOE_PUPDR_PUPDR6) >> 12 ; }
static inline uint32_t gpioe_pupdr_get_pupdr5(struct GPIOE_Type* p) { return (p->PUPDR & GPIOE_PUPDR_PUPDR5) >> 10 ; }
static inline uint32_t gpioe_pupdr_get_pupdr4(struct GPIOE_Type* p) { return (p->PUPDR & GPIOE_PUPDR_PUPDR4) >> 8 ; }
static inline uint32_t gpioe_pupdr_get_pupdr3(struct GPIOE_Type* p) { return (p->PUPDR & GPIOE_PUPDR_PUPDR3) >> 6 ; }
static inline uint32_t gpioe_pupdr_get_pupdr2(struct GPIOE_Type* p) { return (p->PUPDR & GPIOE_PUPDR_PUPDR2) >> 4 ; }
static inline uint32_t gpioe_pupdr_get_pupdr1(struct GPIOE_Type* p) { return (p->PUPDR & GPIOE_PUPDR_PUPDR1) >> 2 ; }
static inline uint32_t gpioe_pupdr_get_pupdr0(struct GPIOE_Type* p) { return (p->PUPDR & GPIOE_PUPDR_PUPDR0) >> 0 ; }

// GPIOE->BSRR GPIO port bit set/reset register
enum {
	GPIOE_BSRR_BR15 = 1UL<<31, // Port x reset bit y (y = 0..15)
	GPIOE_BSRR_BR14 = 1UL<<30, // Port x reset bit y (y = 0..15)
	GPIOE_BSRR_BR13 = 1UL<<29, // Port x reset bit y (y = 0..15)
	GPIOE_BSRR_BR12 = 1UL<<28, // Port x reset bit y (y = 0..15)
	GPIOE_BSRR_BR11 = 1UL<<27, // Port x reset bit y (y = 0..15)
	GPIOE_BSRR_BR10 = 1UL<<26, // Port x reset bit y (y = 0..15)
	GPIOE_BSRR_BR9 = 1UL<<25, // Port x reset bit y (y = 0..15)
	GPIOE_BSRR_BR8 = 1UL<<24, // Port x reset bit y (y = 0..15)
	GPIOE_BSRR_BR7 = 1UL<<23, // Port x reset bit y (y = 0..15)
	GPIOE_BSRR_BR6 = 1UL<<22, // Port x reset bit y (y = 0..15)
	GPIOE_BSRR_BR5 = 1UL<<21, // Port x reset bit y (y = 0..15)
	GPIOE_BSRR_BR4 = 1UL<<20, // Port x reset bit y (y = 0..15)
	GPIOE_BSRR_BR3 = 1UL<<19, // Port x reset bit y (y = 0..15)
	GPIOE_BSRR_BR2 = 1UL<<18, // Port x reset bit y (y = 0..15)
	GPIOE_BSRR_BR1 = 1UL<<17, // Port x reset bit y (y = 0..15)
	GPIOE_BSRR_BR0 = 1UL<<16, // Port x set bit y (y= 0..15)
	GPIOE_BSRR_BS15 = 1UL<<15, // Port x set bit y (y= 0..15)
	GPIOE_BSRR_BS14 = 1UL<<14, // Port x set bit y (y= 0..15)
	GPIOE_BSRR_BS13 = 1UL<<13, // Port x set bit y (y= 0..15)
	GPIOE_BSRR_BS12 = 1UL<<12, // Port x set bit y (y= 0..15)
	GPIOE_BSRR_BS11 = 1UL<<11, // Port x set bit y (y= 0..15)
	GPIOE_BSRR_BS10 = 1UL<<10, // Port x set bit y (y= 0..15)
	GPIOE_BSRR_BS9 = 1UL<<9, // Port x set bit y (y= 0..15)
	GPIOE_BSRR_BS8 = 1UL<<8, // Port x set bit y (y= 0..15)
	GPIOE_BSRR_BS7 = 1UL<<7, // Port x set bit y (y= 0..15)
	GPIOE_BSRR_BS6 = 1UL<<6, // Port x set bit y (y= 0..15)
	GPIOE_BSRR_BS5 = 1UL<<5, // Port x set bit y (y= 0..15)
	GPIOE_BSRR_BS4 = 1UL<<4, // Port x set bit y (y= 0..15)
	GPIOE_BSRR_BS3 = 1UL<<3, // Port x set bit y (y= 0..15)
	GPIOE_BSRR_BS2 = 1UL<<2, // Port x set bit y (y= 0..15)
	GPIOE_BSRR_BS1 = 1UL<<1, // Port x set bit y (y= 0..15)
	GPIOE_BSRR_BS0 = 1UL<<0, // Port x set bit y (y= 0..15)		
};

// GPIOE->LCKR GPIO port configuration lock register
enum {
	GPIOE_LCKR_LCKK = 1UL<<16, // Port x lock bit y (y= 0..15)
	GPIOE_LCKR_LCK15 = 1UL<<15, // Port x lock bit y (y= 0..15)
	GPIOE_LCKR_LCK14 = 1UL<<14, // Port x lock bit y (y= 0..15)
	GPIOE_LCKR_LCK13 = 1UL<<13, // Port x lock bit y (y= 0..15)
	GPIOE_LCKR_LCK12 = 1UL<<12, // Port x lock bit y (y= 0..15)
	GPIOE_LCKR_LCK11 = 1UL<<11, // Port x lock bit y (y= 0..15)
	GPIOE_LCKR_LCK10 = 1UL<<10, // Port x lock bit y (y= 0..15)
	GPIOE_LCKR_LCK9 = 1UL<<9, // Port x lock bit y (y= 0..15)
	GPIOE_LCKR_LCK8 = 1UL<<8, // Port x lock bit y (y= 0..15)
	GPIOE_LCKR_LCK7 = 1UL<<7, // Port x lock bit y (y= 0..15)
	GPIOE_LCKR_LCK6 = 1UL<<6, // Port x lock bit y (y= 0..15)
	GPIOE_LCKR_LCK5 = 1UL<<5, // Port x lock bit y (y= 0..15)
	GPIOE_LCKR_LCK4 = 1UL<<4, // Port x lock bit y (y= 0..15)
	GPIOE_LCKR_LCK3 = 1UL<<3, // Port x lock bit y (y= 0..15)
	GPIOE_LCKR_LCK2 = 1UL<<2, // Port x lock bit y (y= 0..15)
	GPIOE_LCKR_LCK1 = 1UL<<1, // Port x lock bit y (y= 0..15)
	GPIOE_LCKR_LCK0 = 1UL<<0, // Port x lock bit y (y= 0..15)		
};

// GPIOE->AFRL GPIO alternate function low register
enum {
	GPIOE_AFRL_AFRL7 = ((1UL<<4)-1) << 28, // Alternate function selection for port x bit y (y = 0..7)
	GPIOE_AFRL_AFRL6 = ((1UL<<4)-1) << 24, // Alternate function selection for port x bit y (y = 0..7)
	GPIOE_AFRL_AFRL5 = ((1UL<<4)-1) << 20, // Alternate function selection for port x bit y (y = 0..7)
	GPIOE_AFRL_AFRL4 = ((1UL<<4)-1) << 16, // Alternate function selection for port x bit y (y = 0..7)
	GPIOE_AFRL_AFRL3 = ((1UL<<4)-1) << 12, // Alternate function selection for port x bit y (y = 0..7)
	GPIOE_AFRL_AFRL2 = ((1UL<<4)-1) << 8, // Alternate function selection for port x bit y (y = 0..7)
	GPIOE_AFRL_AFRL1 = ((1UL<<4)-1) << 4, // Alternate function selection for port x bit y (y = 0..7)
	GPIOE_AFRL_AFRL0 = ((1UL<<4)-1) << 0, // Alternate function selection for port x bit y (y = 0..7)		
};
static inline void gpioe_afrl_set_afrl7(struct GPIOE_Type* p, uint32_t val) { p->AFRL = (p->AFRL & ~GPIOE_AFRL_AFRL7) | ((val<<28) & GPIOE_AFRL_AFRL7); }
static inline void gpioe_afrl_set_afrl6(struct GPIOE_Type* p, uint32_t val) { p->AFRL = (p->AFRL & ~GPIOE_AFRL_AFRL6) | ((val<<24) & GPIOE_AFRL_AFRL6); }
static inline void gpioe_afrl_set_afrl5(struct GPIOE_Type* p, uint32_t val) { p->AFRL = (p->AFRL & ~GPIOE_AFRL_AFRL5) | ((val<<20) & GPIOE_AFRL_AFRL5); }
static inline void gpioe_afrl_set_afrl4(struct GPIOE_Type* p, uint32_t val) { p->AFRL = (p->AFRL & ~GPIOE_AFRL_AFRL4) | ((val<<16) & GPIOE_AFRL_AFRL4); }
static inline void gpioe_afrl_set_afrl3(struct GPIOE_Type* p, uint32_t val) { p->AFRL = (p->AFRL & ~GPIOE_AFRL_AFRL3) | ((val<<12) & GPIOE_AFRL_AFRL3); }
static inline void gpioe_afrl_set_afrl2(struct GPIOE_Type* p, uint32_t val) { p->AFRL = (p->AFRL & ~GPIOE_AFRL_AFRL2) | ((val<<8) & GPIOE_AFRL_AFRL2); }
static inline void gpioe_afrl_set_afrl1(struct GPIOE_Type* p, uint32_t val) { p->AFRL = (p->AFRL & ~GPIOE_AFRL_AFRL1) | ((val<<4) & GPIOE_AFRL_AFRL1); }
static inline void gpioe_afrl_set_afrl0(struct GPIOE_Type* p, uint32_t val) { p->AFRL = (p->AFRL & ~GPIOE_AFRL_AFRL0) | ((val<<0) & GPIOE_AFRL_AFRL0); }
static inline uint32_t gpioe_afrl_get_afrl7(struct GPIOE_Type* p) { return (p->AFRL & GPIOE_AFRL_AFRL7) >> 28 ; }
static inline uint32_t gpioe_afrl_get_afrl6(struct GPIOE_Type* p) { return (p->AFRL & GPIOE_AFRL_AFRL6) >> 24 ; }
static inline uint32_t gpioe_afrl_get_afrl5(struct GPIOE_Type* p) { return (p->AFRL & GPIOE_AFRL_AFRL5) >> 20 ; }
static inline uint32_t gpioe_afrl_get_afrl4(struct GPIOE_Type* p) { return (p->AFRL & GPIOE_AFRL_AFRL4) >> 16 ; }
static inline uint32_t gpioe_afrl_get_afrl3(struct GPIOE_Type* p) { return (p->AFRL & GPIOE_AFRL_AFRL3) >> 12 ; }
static inline uint32_t gpioe_afrl_get_afrl2(struct GPIOE_Type* p) { return (p->AFRL & GPIOE_AFRL_AFRL2) >> 8 ; }
static inline uint32_t gpioe_afrl_get_afrl1(struct GPIOE_Type* p) { return (p->AFRL & GPIOE_AFRL_AFRL1) >> 4 ; }
static inline uint32_t gpioe_afrl_get_afrl0(struct GPIOE_Type* p) { return (p->AFRL & GPIOE_AFRL_AFRL0) >> 0 ; }

// GPIOE->AFRH GPIO alternate function high register
enum {
	GPIOE_AFRH_AFRH15 = ((1UL<<4)-1) << 28, // Alternate function selection for port x bit y (y = 8..15)
	GPIOE_AFRH_AFRH14 = ((1UL<<4)-1) << 24, // Alternate function selection for port x bit y (y = 8..15)
	GPIOE_AFRH_AFRH13 = ((1UL<<4)-1) << 20, // Alternate function selection for port x bit y (y = 8..15)
	GPIOE_AFRH_AFRH12 = ((1UL<<4)-1) << 16, // Alternate function selection for port x bit y (y = 8..15)
	GPIOE_AFRH_AFRH11 = ((1UL<<4)-1) << 12, // Alternate function selection for port x bit y (y = 8..15)
	GPIOE_AFRH_AFRH10 = ((1UL<<4)-1) << 8, // Alternate function selection for port x bit y (y = 8..15)
	GPIOE_AFRH_AFRH9 = ((1UL<<4)-1) << 4, // Alternate function selection for port x bit y (y = 8..15)
	GPIOE_AFRH_AFRH8 = ((1UL<<4)-1) << 0, // Alternate function selection for port x bit y (y = 8..15)		
};
static inline void gpioe_afrh_set_afrh15(struct GPIOE_Type* p, uint32_t val) { p->AFRH = (p->AFRH & ~GPIOE_AFRH_AFRH15) | ((val<<28) & GPIOE_AFRH_AFRH15); }
static inline void gpioe_afrh_set_afrh14(struct GPIOE_Type* p, uint32_t val) { p->AFRH = (p->AFRH & ~GPIOE_AFRH_AFRH14) | ((val<<24) & GPIOE_AFRH_AFRH14); }
static inline void gpioe_afrh_set_afrh13(struct GPIOE_Type* p, uint32_t val) { p->AFRH = (p->AFRH & ~GPIOE_AFRH_AFRH13) | ((val<<20) & GPIOE_AFRH_AFRH13); }
static inline void gpioe_afrh_set_afrh12(struct GPIOE_Type* p, uint32_t val) { p->AFRH = (p->AFRH & ~GPIOE_AFRH_AFRH12) | ((val<<16) & GPIOE_AFRH_AFRH12); }
static inline void gpioe_afrh_set_afrh11(struct GPIOE_Type* p, uint32_t val) { p->AFRH = (p->AFRH & ~GPIOE_AFRH_AFRH11) | ((val<<12) & GPIOE_AFRH_AFRH11); }
static inline void gpioe_afrh_set_afrh10(struct GPIOE_Type* p, uint32_t val) { p->AFRH = (p->AFRH & ~GPIOE_AFRH_AFRH10) | ((val<<8) & GPIOE_AFRH_AFRH10); }
static inline void gpioe_afrh_set_afrh9(struct GPIOE_Type* p, uint32_t val) { p->AFRH = (p->AFRH & ~GPIOE_AFRH_AFRH9) | ((val<<4) & GPIOE_AFRH_AFRH9); }
static inline void gpioe_afrh_set_afrh8(struct GPIOE_Type* p, uint32_t val) { p->AFRH = (p->AFRH & ~GPIOE_AFRH_AFRH8) | ((val<<0) & GPIOE_AFRH_AFRH8); }
static inline uint32_t gpioe_afrh_get_afrh15(struct GPIOE_Type* p) { return (p->AFRH & GPIOE_AFRH_AFRH15) >> 28 ; }
static inline uint32_t gpioe_afrh_get_afrh14(struct GPIOE_Type* p) { return (p->AFRH & GPIOE_AFRH_AFRH14) >> 24 ; }
static inline uint32_t gpioe_afrh_get_afrh13(struct GPIOE_Type* p) { return (p->AFRH & GPIOE_AFRH_AFRH13) >> 20 ; }
static inline uint32_t gpioe_afrh_get_afrh12(struct GPIOE_Type* p) { return (p->AFRH & GPIOE_AFRH_AFRH12) >> 16 ; }
static inline uint32_t gpioe_afrh_get_afrh11(struct GPIOE_Type* p) { return (p->AFRH & GPIOE_AFRH_AFRH11) >> 12 ; }
static inline uint32_t gpioe_afrh_get_afrh10(struct GPIOE_Type* p) { return (p->AFRH & GPIOE_AFRH_AFRH10) >> 8 ; }
static inline uint32_t gpioe_afrh_get_afrh9(struct GPIOE_Type* p) { return (p->AFRH & GPIOE_AFRH_AFRH9) >> 4 ; }
static inline uint32_t gpioe_afrh_get_afrh8(struct GPIOE_Type* p) { return (p->AFRH & GPIOE_AFRH_AFRH8) >> 0 ; }






/* Inter-integrated circuit */
struct I2C_Type {
	__IO uint32_t CR1; // @0 Control register 1
	__IO uint32_t CR2; // @4 Control register 2
	__IO uint16_t OAR1; // @8 Own address register 1
	 uint8_t RESERVED0[2]; // @10 
	__IO uint16_t OAR2; // @12 Own address register 2
	 uint8_t RESERVED1[2]; // @14 
	__IO uint32_t TIMINGR; // @16 Timing register
	__IO uint32_t TIMEOUTR; // @20 Status register 1
	__IO uint32_t ISR; // @24 Interrupt and Status register
	__O uint16_t ICR; // @28 Interrupt clear register
	 uint8_t RESERVED2[2]; // @30 
	__I uint8_t PECR; // @32 PEC register
	 uint8_t RESERVED3[3]; // @33 
	__I uint8_t RXDR; // @36 Receive data register
	 uint8_t RESERVED4[3]; // @37 
	__IO uint8_t TXDR; // @40 Transmit data register
};
extern struct I2C_Type	I2C1;	// @0x40005400 
extern struct I2C_Type 	I2C2;	// @0x40005800
extern struct I2C_Type 	I2C3;	// @0x40005C00
extern struct I2C_Type 	I2C4;	// @0x40008400

// I2C->CR1 Control register 1
enum {
	I2C_CR1_PECEN = 1UL<<23, // PEC enable
	I2C_CR1_ALERTEN = 1UL<<22, // SMBUS alert enable
	I2C_CR1_SMBDEN = 1UL<<21, // SMBus Device Default address enable
	I2C_CR1_SMBHEN = 1UL<<20, // SMBus Host address enable
	I2C_CR1_GCEN = 1UL<<19, // General call enable
	I2C_CR1_WUPEN = 1UL<<18, // Wakeup from STOP enable
	I2C_CR1_NOSTRETCH = 1UL<<17, // Clock stretching disable
	I2C_CR1_SBC = 1UL<<16, // Slave byte control
	I2C_CR1_RXDMAEN = 1UL<<15, // DMA reception requests enable
	I2C_CR1_TXDMAEN = 1UL<<14, // DMA transmission requests enable
	I2C_CR1_ANFOFF = 1UL<<12, // Analog noise filter OFF
	I2C_CR1_DNF = ((1UL<<4)-1) << 8, // Digital noise filter
	I2C_CR1_ERRIE = 1UL<<7, // Error interrupts enable
	I2C_CR1_TCIE = 1UL<<6, // Transfer Complete interrupt enable
	I2C_CR1_STOPIE = 1UL<<5, // STOP detection Interrupt enable
	I2C_CR1_NACKIE = 1UL<<4, // Not acknowledge received interrupt enable
	I2C_CR1_ADDRIE = 1UL<<3, // Address match interrupt enable (slave only)
	I2C_CR1_RXIE = 1UL<<2, // RX Interrupt enable
	I2C_CR1_TXIE = 1UL<<1, // TX Interrupt enable
	I2C_CR1_PE = 1UL<<0, // Peripheral enable		
};
static inline void i2c_cr1_set_dnf(struct I2C_Type* p, uint32_t val) { p->CR1 = (p->CR1 & ~I2C_CR1_DNF) | ((val<<8) & I2C_CR1_DNF); }
static inline uint32_t i2c_cr1_get_dnf(struct I2C_Type* p) { return (p->CR1 & I2C_CR1_DNF) >> 8 ; }

// I2C->CR2 Control register 2
enum {
	I2C_CR2_PECBYTE = 1UL<<26, // Packet error checking byte
	I2C_CR2_AUTOEND = 1UL<<25, // Automatic end mode (master mode)
	I2C_CR2_RELOAD = 1UL<<24, // NBYTES reload mode
	I2C_CR2_NBYTES = ((1UL<<8)-1) << 16, // Number of bytes
	I2C_CR2_NACK = 1UL<<15, // NACK generation (slave mode)
	I2C_CR2_STOP = 1UL<<14, // Stop generation (master mode)
	I2C_CR2_START = 1UL<<13, // Start generation
	I2C_CR2_HEAD10R = 1UL<<12, // 10-bit address header only read direction (master receiver mode)
	I2C_CR2_ADD10 = 1UL<<11, // 10-bit addressing mode (master mode)
	I2C_CR2_RD_WRN = 1UL<<10, // Transfer direction (master mode)
	I2C_CR2_SADD = ((1UL<<10)-1) << 0, // Slave address bit (master mode)		
};
static inline void i2c_cr2_set_nbytes(struct I2C_Type* p, uint32_t val) { p->CR2 = (p->CR2 & ~I2C_CR2_NBYTES) | ((val<<16) & I2C_CR2_NBYTES); }
static inline void i2c_cr2_set_sadd(struct I2C_Type* p, uint32_t val) { p->CR2 = (p->CR2 & ~I2C_CR2_SADD) | ((val<<0) & I2C_CR2_SADD); }
static inline uint32_t i2c_cr2_get_nbytes(struct I2C_Type* p) { return (p->CR2 & I2C_CR2_NBYTES) >> 16 ; }
static inline uint32_t i2c_cr2_get_sadd(struct I2C_Type* p) { return (p->CR2 & I2C_CR2_SADD) >> 0 ; }

// I2C->OAR1 Own address register 1
enum {
	I2C_OAR1_OA1EN = 1UL<<15, // Own Address 1 enable
	I2C_OAR1_OA1MODE = 1UL<<10, // Own Address 1 10-bit mode
	I2C_OAR1_OA1 = ((1UL<<10)-1) << 0, // Interface address		
};
static inline void i2c_oar1_set_oa1(struct I2C_Type* p, uint32_t val) { p->OAR1 = (p->OAR1 & ~I2C_OAR1_OA1) | ((val<<0) & I2C_OAR1_OA1); }
static inline uint32_t i2c_oar1_get_oa1(struct I2C_Type* p) { return (p->OAR1 & I2C_OAR1_OA1) >> 0 ; }

// I2C->OAR2 Own address register 2
enum {
	I2C_OAR2_OA2EN = 1UL<<15, // Own Address 2 enable
	I2C_OAR2_OA2MSK = ((1UL<<3)-1) << 8, // Own Address 2 masks
	I2C_OAR2_OA2 = ((1UL<<7)-1) << 1, // Interface address		
};
static inline void i2c_oar2_set_oa2msk(struct I2C_Type* p, uint32_t val) { p->OAR2 = (p->OAR2 & ~I2C_OAR2_OA2MSK) | ((val<<8) & I2C_OAR2_OA2MSK); }
static inline void i2c_oar2_set_oa2(struct I2C_Type* p, uint32_t val) { p->OAR2 = (p->OAR2 & ~I2C_OAR2_OA2) | ((val<<1) & I2C_OAR2_OA2); }
static inline uint32_t i2c_oar2_get_oa2msk(struct I2C_Type* p) { return (p->OAR2 & I2C_OAR2_OA2MSK) >> 8 ; }
static inline uint32_t i2c_oar2_get_oa2(struct I2C_Type* p) { return (p->OAR2 & I2C_OAR2_OA2) >> 1 ; }

// I2C->TIMINGR Timing register
enum {
	I2C_TIMINGR_PRESC = ((1UL<<4)-1) << 28, // Timing prescaler
	I2C_TIMINGR_SCLDEL = ((1UL<<4)-1) << 20, // Data setup time
	I2C_TIMINGR_SDADEL = ((1UL<<4)-1) << 16, // Data hold time
	I2C_TIMINGR_SCLH = ((1UL<<8)-1) << 8, // SCL high period (master mode)
	I2C_TIMINGR_SCLL = ((1UL<<8)-1) << 0, // SCL low period (master mode)		
};
static inline void i2c_timingr_set_presc(struct I2C_Type* p, uint32_t val) { p->TIMINGR = (p->TIMINGR & ~I2C_TIMINGR_PRESC) | ((val<<28) & I2C_TIMINGR_PRESC); }
static inline void i2c_timingr_set_scldel(struct I2C_Type* p, uint32_t val) { p->TIMINGR = (p->TIMINGR & ~I2C_TIMINGR_SCLDEL) | ((val<<20) & I2C_TIMINGR_SCLDEL); }
static inline void i2c_timingr_set_sdadel(struct I2C_Type* p, uint32_t val) { p->TIMINGR = (p->TIMINGR & ~I2C_TIMINGR_SDADEL) | ((val<<16) & I2C_TIMINGR_SDADEL); }
static inline void i2c_timingr_set_sclh(struct I2C_Type* p, uint32_t val) { p->TIMINGR = (p->TIMINGR & ~I2C_TIMINGR_SCLH) | ((val<<8) & I2C_TIMINGR_SCLH); }
static inline void i2c_timingr_set_scll(struct I2C_Type* p, uint32_t val) { p->TIMINGR = (p->TIMINGR & ~I2C_TIMINGR_SCLL) | ((val<<0) & I2C_TIMINGR_SCLL); }
static inline uint32_t i2c_timingr_get_presc(struct I2C_Type* p) { return (p->TIMINGR & I2C_TIMINGR_PRESC) >> 28 ; }
static inline uint32_t i2c_timingr_get_scldel(struct I2C_Type* p) { return (p->TIMINGR & I2C_TIMINGR_SCLDEL) >> 20 ; }
static inline uint32_t i2c_timingr_get_sdadel(struct I2C_Type* p) { return (p->TIMINGR & I2C_TIMINGR_SDADEL) >> 16 ; }
static inline uint32_t i2c_timingr_get_sclh(struct I2C_Type* p) { return (p->TIMINGR & I2C_TIMINGR_SCLH) >> 8 ; }
static inline uint32_t i2c_timingr_get_scll(struct I2C_Type* p) { return (p->TIMINGR & I2C_TIMINGR_SCLL) >> 0 ; }

// I2C->TIMEOUTR Status register 1
enum {
	I2C_TIMEOUTR_TEXTEN = 1UL<<31, // Extended clock timeout enable
	I2C_TIMEOUTR_TIMEOUTB = ((1UL<<12)-1) << 16, // Bus timeout B
	I2C_TIMEOUTR_TIMOUTEN = 1UL<<15, // Clock timeout enable
	I2C_TIMEOUTR_TIDLE = 1UL<<12, // Idle clock timeout detection
	I2C_TIMEOUTR_TIMEOUTA = ((1UL<<12)-1) << 0, // Bus timeout A		
};
static inline void i2c_timeoutr_set_timeoutb(struct I2C_Type* p, uint32_t val) { p->TIMEOUTR = (p->TIMEOUTR & ~I2C_TIMEOUTR_TIMEOUTB) | ((val<<16) & I2C_TIMEOUTR_TIMEOUTB); }
static inline void i2c_timeoutr_set_timeouta(struct I2C_Type* p, uint32_t val) { p->TIMEOUTR = (p->TIMEOUTR & ~I2C_TIMEOUTR_TIMEOUTA) | ((val<<0) & I2C_TIMEOUTR_TIMEOUTA); }
static inline uint32_t i2c_timeoutr_get_timeoutb(struct I2C_Type* p) { return (p->TIMEOUTR & I2C_TIMEOUTR_TIMEOUTB) >> 16 ; }
static inline uint32_t i2c_timeoutr_get_timeouta(struct I2C_Type* p) { return (p->TIMEOUTR & I2C_TIMEOUTR_TIMEOUTA) >> 0 ; }

// I2C->ISR Interrupt and Status register
enum {
	I2C_ISR_ADDCODE = ((1UL<<7)-1) << 17, // Address match code (Slave mode)
	I2C_ISR_DIR = 1UL<<16, // Transfer direction (Slave mode)
	I2C_ISR_BUSY = 1UL<<15, // Bus busy
	I2C_ISR_ALERT = 1UL<<13, // SMBus alert
	I2C_ISR_TIMEOUT = 1UL<<12, // Timeout or t_low detection flag
	I2C_ISR_PECERR = 1UL<<11, // PEC Error in reception
	I2C_ISR_OVR = 1UL<<10, // Overrun/Underrun (slave mode)
	I2C_ISR_ARLO = 1UL<<9, // Arbitration lost
	I2C_ISR_BERR = 1UL<<8, // Bus error
	I2C_ISR_TCR = 1UL<<7, // Transfer Complete Reload
	I2C_ISR_TC = 1UL<<6, // Transfer Complete (master mode)
	I2C_ISR_STOPF = 1UL<<5, // Stop detection flag
	I2C_ISR_NACKF = 1UL<<4, // Not acknowledge received flag
	I2C_ISR_ADDR = 1UL<<3, // Address matched (slave mode)
	I2C_ISR_RXNE = 1UL<<2, // Receive data register not empty (receivers)
	I2C_ISR_TXIS = 1UL<<1, // Transmit interrupt status (transmitters)
	I2C_ISR_TXE = 1UL<<0, // Transmit data register empty (transmitters)		
};
static inline void i2c_isr_set_addcode(struct I2C_Type* p, uint32_t val) { p->ISR = (p->ISR & ~I2C_ISR_ADDCODE) | ((val<<17) & I2C_ISR_ADDCODE); }
static inline uint32_t i2c_isr_get_addcode(struct I2C_Type* p) { return (p->ISR & I2C_ISR_ADDCODE) >> 17 ; }

// I2C->ICR Interrupt clear register
enum {
	I2C_ICR_ALERTCF = 1UL<<13, // Alert flag clear
	I2C_ICR_TIMOUTCF = 1UL<<12, // Timeout detection flag clear
	I2C_ICR_PECCF = 1UL<<11, // PEC Error flag clear
	I2C_ICR_OVRCF = 1UL<<10, // Overrun/Underrun flag clear
	I2C_ICR_ARLOCF = 1UL<<9, // Arbitration lost flag clear
	I2C_ICR_BERRCF = 1UL<<8, // Bus error flag clear
	I2C_ICR_STOPCF = 1UL<<5, // Stop detection flag clear
	I2C_ICR_NACKCF = 1UL<<4, // Not Acknowledge flag clear
	I2C_ICR_ADDRCF = 1UL<<3, // Address Matched flag clear		
};




/* Independent watchdog
There is only one peripheral of type IWDG. */
struct IWDG_Type {
	__O uint16_t KR; // @0 Key register
	 uint8_t RESERVED0[2]; // @2 
	__IO uint8_t PR; // @4 Prescaler register
	 uint8_t RESERVED1[3]; // @5 
	__IO uint16_t RLR; // @8 Reload register
	 uint8_t RESERVED2[2]; // @10 
	__I uint8_t SR; // @12 Status register
	 uint8_t RESERVED3[3]; // @13 
	__IO uint16_t WINR; // @16 Window register
};
extern struct IWDG_Type	IWDG;	// @0x40003000 

// IWDG->PR Prescaler register
enum {
	IWDG_PR_PR = ((1UL<<3)-1) << 0, // Prescaler divider		
};
static inline void iwdg_pr_set_pr(uint32_t val) { IWDG.PR = (IWDG.PR & ~IWDG_PR_PR) | ((val<<0) & IWDG_PR_PR); }
static inline uint32_t iwdg_pr_get_pr(void) { return (IWDG.PR & IWDG_PR_PR) >> 0 ; }

// IWDG->RLR Reload register
enum {
	IWDG_RLR_RL = ((1UL<<12)-1) << 0, // Watchdog counter reload value		
};
static inline void iwdg_rlr_set_rl(uint32_t val) { IWDG.RLR = (IWDG.RLR & ~IWDG_RLR_RL) | ((val<<0) & IWDG_RLR_RL); }
static inline uint32_t iwdg_rlr_get_rl(void) { return (IWDG.RLR & IWDG_RLR_RL) >> 0 ; }

// IWDG->SR Status register
enum {
	IWDG_SR_WVU = 1UL<<2, // Watchdog counter window value update
	IWDG_SR_RVU = 1UL<<1, // Watchdog counter reload value update
	IWDG_SR_PVU = 1UL<<0, // Watchdog prescaler value update		
};

// IWDG->WINR Window register
enum {
	IWDG_WINR_WIN = ((1UL<<12)-1) << 0, // Watchdog counter window value		
};
static inline void iwdg_winr_set_win(uint32_t val) { IWDG.WINR = (IWDG.WINR & ~IWDG_WINR_WIN) | ((val<<0) & IWDG_WINR_WIN); }
static inline uint32_t iwdg_winr_get_win(void) { return (IWDG.WINR & IWDG_WINR_WIN) >> 0 ; }

/* Low power timer */
struct LPTIM_Type {
	__I uint8_t ISR; // @0 Interrupt and Status Register
	 uint8_t RESERVED0[3]; // @1 
	__O uint8_t ICR; // @4 Interrupt Clear Register
	 uint8_t RESERVED1[3]; // @5 
	__IO uint8_t IER; // @8 Interrupt Enable Register
	 uint8_t RESERVED2[3]; // @9 
	__IO uint32_t CFGR; // @12 Configuration Register
	__IO uint8_t CR; // @16 Control Register
	 uint8_t RESERVED3[3]; // @17 
	__IO uint16_t CMP; // @20 Compare Register
	 uint8_t RESERVED4[2]; // @22 
	__IO uint16_t ARR; // @24 Autoreload Register
	 uint8_t RESERVED5[2]; // @26 
	__I uint16_t CNT; // @28 Counter Register
};
extern struct LPTIM_Type	LPTIM1;	// @0x40007C00 
extern struct LPTIM_Type 	LPTIM2;	// @0x40009400

// LPTIM->ISR Interrupt and Status Register
enum {
	LPTIM_ISR_DOWN = 1UL<<6, // Counter direction change up to down
	LPTIM_ISR_UP = 1UL<<5, // Counter direction change down to up
	LPTIM_ISR_ARROK = 1UL<<4, // Autoreload register update OK
	LPTIM_ISR_CMPOK = 1UL<<3, // Compare register update OK
	LPTIM_ISR_EXTTRIG = 1UL<<2, // External trigger edge event
	LPTIM_ISR_ARRM = 1UL<<1, // Autoreload match
	LPTIM_ISR_CMPM = 1UL<<0, // Compare match		
};

// LPTIM->ICR Interrupt Clear Register
enum {
	LPTIM_ICR_DOWNCF = 1UL<<6, // Direction change to down Clear Flag
	LPTIM_ICR_UPCF = 1UL<<5, // Direction change to UP Clear Flag
	LPTIM_ICR_ARROKCF = 1UL<<4, // Autoreload register update OK Clear Flag
	LPTIM_ICR_CMPOKCF = 1UL<<3, // Compare register update OK Clear Flag
	LPTIM_ICR_EXTTRIGCF = 1UL<<2, // External trigger valid edge Clear Flag
	LPTIM_ICR_ARRMCF = 1UL<<1, // Autoreload match Clear Flag
	LPTIM_ICR_CMPMCF = 1UL<<0, // compare match Clear Flag		
};

// LPTIM->IER Interrupt Enable Register
enum {
	LPTIM_IER_DOWNIE = 1UL<<6, // Direction change to down Interrupt Enable
	LPTIM_IER_UPIE = 1UL<<5, // Direction change to UP Interrupt Enable
	LPTIM_IER_ARROKIE = 1UL<<4, // Autoreload register update OK Interrupt Enable
	LPTIM_IER_CMPOKIE = 1UL<<3, // Compare register update OK Interrupt Enable
	LPTIM_IER_EXTTRIGIE = 1UL<<2, // External trigger valid edge Interrupt Enable
	LPTIM_IER_ARRMIE = 1UL<<1, // Autoreload match Interrupt Enable
	LPTIM_IER_CMPMIE = 1UL<<0, // Compare match Interrupt Enable		
};

// LPTIM->CFGR Configuration Register
enum {
	LPTIM_CFGR_ENC = 1UL<<24, // Encoder mode enable
	LPTIM_CFGR_COUNTMODE = 1UL<<23, // counter mode enabled
	LPTIM_CFGR_PRELOAD = 1UL<<22, // Registers update mode
	LPTIM_CFGR_WAVPOL = 1UL<<21, // Waveform shape polarity
	LPTIM_CFGR_WAVE = 1UL<<20, // Waveform shape
	LPTIM_CFGR_TIMOUT = 1UL<<19, // Timeout enable
	LPTIM_CFGR_TRIGEN = ((1UL<<2)-1) << 17, // Trigger enable and polarity
	LPTIM_CFGR_TRIGSEL = ((1UL<<3)-1) << 13, // Trigger selector
	LPTIM_CFGR_PRESC = ((1UL<<3)-1) << 9, // Clock prescaler
	LPTIM_CFGR_TRGFLT = ((1UL<<2)-1) << 6, // Configurable digital filter for trigger
	LPTIM_CFGR_CKFLT = ((1UL<<2)-1) << 3, // Configurable digital filter for external clock
	LPTIM_CFGR_CKPOL = ((1UL<<2)-1) << 1, // Clock Polarity
	LPTIM_CFGR_CKSEL = 1UL<<0, // Clock selector		
};
static inline void lptim_cfgr_set_trigen(struct LPTIM_Type* p, uint32_t val) { p->CFGR = (p->CFGR & ~LPTIM_CFGR_TRIGEN) | ((val<<17) & LPTIM_CFGR_TRIGEN); }
static inline void lptim_cfgr_set_trigsel(struct LPTIM_Type* p, uint32_t val) { p->CFGR = (p->CFGR & ~LPTIM_CFGR_TRIGSEL) | ((val<<13) & LPTIM_CFGR_TRIGSEL); }
static inline void lptim_cfgr_set_presc(struct LPTIM_Type* p, uint32_t val) { p->CFGR = (p->CFGR & ~LPTIM_CFGR_PRESC) | ((val<<9) & LPTIM_CFGR_PRESC); }
static inline void lptim_cfgr_set_trgflt(struct LPTIM_Type* p, uint32_t val) { p->CFGR = (p->CFGR & ~LPTIM_CFGR_TRGFLT) | ((val<<6) & LPTIM_CFGR_TRGFLT); }
static inline void lptim_cfgr_set_ckflt(struct LPTIM_Type* p, uint32_t val) { p->CFGR = (p->CFGR & ~LPTIM_CFGR_CKFLT) | ((val<<3) & LPTIM_CFGR_CKFLT); }
static inline void lptim_cfgr_set_ckpol(struct LPTIM_Type* p, uint32_t val) { p->CFGR = (p->CFGR & ~LPTIM_CFGR_CKPOL) | ((val<<1) & LPTIM_CFGR_CKPOL); }
static inline uint32_t lptim_cfgr_get_trigen(struct LPTIM_Type* p) { return (p->CFGR & LPTIM_CFGR_TRIGEN) >> 17 ; }
static inline uint32_t lptim_cfgr_get_trigsel(struct LPTIM_Type* p) { return (p->CFGR & LPTIM_CFGR_TRIGSEL) >> 13 ; }
static inline uint32_t lptim_cfgr_get_presc(struct LPTIM_Type* p) { return (p->CFGR & LPTIM_CFGR_PRESC) >> 9 ; }
static inline uint32_t lptim_cfgr_get_trgflt(struct LPTIM_Type* p) { return (p->CFGR & LPTIM_CFGR_TRGFLT) >> 6 ; }
static inline uint32_t lptim_cfgr_get_ckflt(struct LPTIM_Type* p) { return (p->CFGR & LPTIM_CFGR_CKFLT) >> 3 ; }
static inline uint32_t lptim_cfgr_get_ckpol(struct LPTIM_Type* p) { return (p->CFGR & LPTIM_CFGR_CKPOL) >> 1 ; }

// LPTIM->CR Control Register
enum {
	LPTIM_CR_CNTSTRT = 1UL<<2, // Timer start in continuous mode
	LPTIM_CR_SNGSTRT = 1UL<<1, // LPTIM start in single mode
	LPTIM_CR_ENABLE = 1UL<<0, // LPTIM Enable		
};


/* Universal synchronous asynchronous receiver transmitter
There is only one peripheral of type LPUART. */
struct LPUART_Type {
	__IO uint32_t CR1; // @0 Control register 1
	__IO uint32_t CR2; // @4 Control register 2
	__IO uint32_t CR3; // @8 Control register 3
	__IO uint32_t BRR; // @12 Baud rate register
	 uint8_t RESERVED0[8]; // @16 
	__O uint8_t RQR; // @24 Request register
	 uint8_t RESERVED1[3]; // @25 
	__I uint32_t ISR; // @28 Interrupt & status register
	__O uint32_t ICR; // @32 Interrupt flag clear register
	__I uint16_t RDR; // @36 Receive data register
	 uint8_t RESERVED2[2]; // @38 
	__IO uint16_t TDR; // @40 Transmit data register
};
extern struct LPUART_Type	LPUART1;	// @0x40008000 

// LPUART->CR1 Control register 1
enum {
	LPUART_CR1_M1 = 1UL<<28, // Word length
	LPUART_CR1_DEAT4 = 1UL<<25, // Driver Enable assertion time
	LPUART_CR1_DEAT3 = 1UL<<24, // DEAT3
	LPUART_CR1_DEAT2 = 1UL<<23, // DEAT2
	LPUART_CR1_DEAT1 = 1UL<<22, // DEAT1
	LPUART_CR1_DEAT0 = 1UL<<21, // DEAT0
	LPUART_CR1_DEDT4 = 1UL<<20, // Driver Enable de-assertion time
	LPUART_CR1_DEDT3 = 1UL<<19, // DEDT3
	LPUART_CR1_DEDT2 = 1UL<<18, // DEDT2
	LPUART_CR1_DEDT1 = 1UL<<17, // DEDT1
	LPUART_CR1_DEDT0 = 1UL<<16, // DEDT0
	LPUART_CR1_CMIE = 1UL<<14, // Character match interrupt enable
	LPUART_CR1_MME = 1UL<<13, // Mute mode enable
	LPUART_CR1_M0 = 1UL<<12, // Word length
	LPUART_CR1_WAKE = 1UL<<11, // Receiver wakeup method
	LPUART_CR1_PCE = 1UL<<10, // Parity control enable
	LPUART_CR1_PS = 1UL<<9, // Parity selection
	LPUART_CR1_PEIE = 1UL<<8, // PE interrupt enable
	LPUART_CR1_TXEIE = 1UL<<7, // interrupt enable
	LPUART_CR1_TCIE = 1UL<<6, // Transmission complete interrupt enable
	LPUART_CR1_RXNEIE = 1UL<<5, // RXNE interrupt enable
	LPUART_CR1_IDLEIE = 1UL<<4, // IDLE interrupt enable
	LPUART_CR1_TE = 1UL<<3, // Transmitter enable
	LPUART_CR1_RE = 1UL<<2, // Receiver enable
	LPUART_CR1_UESM = 1UL<<1, // USART enable in Stop mode
	LPUART_CR1_UE = 1UL<<0, // USART enable		
};

// LPUART->CR2 Control register 2
enum {
	LPUART_CR2_ADD4_7 = ((1UL<<4)-1) << 28, // Address of the USART node
	LPUART_CR2_ADD0_3 = ((1UL<<4)-1) << 24, // Address of the USART node
	LPUART_CR2_MSBFIRST = 1UL<<19, // Most significant bit first
	LPUART_CR2_TAINV = 1UL<<18, // Binary data inversion
	LPUART_CR2_TXINV = 1UL<<17, // TX pin active level inversion
	LPUART_CR2_RXINV = 1UL<<16, // RX pin active level inversion
	LPUART_CR2_SWAP = 1UL<<15, // Swap TX/RX pins
	LPUART_CR2_STOP = ((1UL<<2)-1) << 12, // STOP bits
	LPUART_CR2_CLKEN = 1UL<<11, // Clock enable
	LPUART_CR2_ADDM7 = 1UL<<4, // 7-bit Address Detection/4-bit Address Detection		
};
static inline void lpuart_cr2_set_add4_7(uint32_t val) { LPUART1.CR2 = (LPUART1.CR2 & ~LPUART_CR2_ADD4_7) | ((val<<28) & LPUART_CR2_ADD4_7); }
static inline void lpuart_cr2_set_add0_3(uint32_t val) { LPUART1.CR2 = (LPUART1.CR2 & ~LPUART_CR2_ADD0_3) | ((val<<24) & LPUART_CR2_ADD0_3); }
static inline void lpuart_cr2_set_stop(uint32_t val) { LPUART1.CR2 = (LPUART1.CR2 & ~LPUART_CR2_STOP) | ((val<<12) & LPUART_CR2_STOP); }
static inline uint32_t lpuart_cr2_get_add4_7(void) { return (LPUART1.CR2 & LPUART_CR2_ADD4_7) >> 28 ; }
static inline uint32_t lpuart_cr2_get_add0_3(void) { return (LPUART1.CR2 & LPUART_CR2_ADD0_3) >> 24 ; }
static inline uint32_t lpuart_cr2_get_stop(void) { return (LPUART1.CR2 & LPUART_CR2_STOP) >> 12 ; }

// LPUART->CR3 Control register 3
enum {
	LPUART_CR3_WUFIE = 1UL<<22, // Wakeup from Stop mode interrupt enable
	LPUART_CR3_WUS = ((1UL<<2)-1) << 20, // Wakeup from Stop mode interrupt flag selection
	LPUART_CR3_DEP = 1UL<<15, // Driver enable polarity selection
	LPUART_CR3_DEM = 1UL<<14, // Driver enable mode
	LPUART_CR3_DDRE = 1UL<<13, // DMA Disable on Reception Error
	LPUART_CR3_OVRDIS = 1UL<<12, // Overrun Disable
	LPUART_CR3_CTSIE = 1UL<<10, // CTS interrupt enable
	LPUART_CR3_CTSE = 1UL<<9, // CTS enable
	LPUART_CR3_RTSE = 1UL<<8, // RTS enable
	LPUART_CR3_DMAT = 1UL<<7, // DMA enable transmitter
	LPUART_CR3_DMAR = 1UL<<6, // DMA enable receiver
	LPUART_CR3_HDSEL = 1UL<<3, // Half-duplex selection
	LPUART_CR3_EIE = 1UL<<0, // Error interrupt enable		
};
static inline void lpuart_cr3_set_wus(uint32_t val) { LPUART1.CR3 = (LPUART1.CR3 & ~LPUART_CR3_WUS) | ((val<<20) & LPUART_CR3_WUS); }
static inline uint32_t lpuart_cr3_get_wus(void) { return (LPUART1.CR3 & LPUART_CR3_WUS) >> 20 ; }

// LPUART->BRR Baud rate register
enum {
	LPUART_BRR_BRR = ((1UL<<20)-1) << 0, // BRR		
};
static inline void lpuart_brr_set_brr(uint32_t val) { LPUART1.BRR = (LPUART1.BRR & ~LPUART_BRR_BRR) | ((val<<0) & LPUART_BRR_BRR); }
static inline uint32_t lpuart_brr_get_brr(void) { return (LPUART1.BRR & LPUART_BRR_BRR) >> 0 ; }

// LPUART->RQR Request register
enum {
	LPUART_RQR_RXFRQ = 1UL<<3, // Receive data flush request
	LPUART_RQR_MMRQ = 1UL<<2, // Mute mode request
	LPUART_RQR_SBKRQ = 1UL<<1, // Send break request		
};

// LPUART->ISR Interrupt & status register
enum {
	LPUART_ISR_REACK = 1UL<<22, // REACK
	LPUART_ISR_TEACK = 1UL<<21, // TEACK
	LPUART_ISR_WUF = 1UL<<20, // WUF
	LPUART_ISR_RWU = 1UL<<19, // RWU
	LPUART_ISR_SBKF = 1UL<<18, // SBKF
	LPUART_ISR_CMF = 1UL<<17, // CMF
	LPUART_ISR_BUSY = 1UL<<16, // BUSY
	LPUART_ISR_CTS = 1UL<<10, // CTS
	LPUART_ISR_CTSIF = 1UL<<9, // CTSIF
	LPUART_ISR_TXE = 1UL<<7, // TXE
	LPUART_ISR_TC = 1UL<<6, // TC
	LPUART_ISR_RXNE = 1UL<<5, // RXNE
	LPUART_ISR_IDLE = 1UL<<4, // IDLE
	LPUART_ISR_ORE = 1UL<<3, // ORE
	LPUART_ISR_NF = 1UL<<2, // NF
	LPUART_ISR_FE = 1UL<<1, // FE
	LPUART_ISR_PE = 1UL<<0, // PE		
};

// LPUART->ICR Interrupt flag clear register
enum {
	LPUART_ICR_WUCF = 1UL<<20, // Wakeup from Stop mode clear flag
	LPUART_ICR_CMCF = 1UL<<17, // Character match clear flag
	LPUART_ICR_CTSCF = 1UL<<9, // CTS clear flag
	LPUART_ICR_TCCF = 1UL<<6, // Transmission complete clear flag
	LPUART_ICR_IDLECF = 1UL<<4, // Idle line detected clear flag
	LPUART_ICR_ORECF = 1UL<<3, // Overrun error clear flag
	LPUART_ICR_NCF = 1UL<<2, // Noise detected clear flag
	LPUART_ICR_FECF = 1UL<<1, // Framing error clear flag
	LPUART_ICR_PECF = 1UL<<0, // Parity error clear flag		
};

// LPUART->RDR Receive data register
enum {
	LPUART_RDR_RDR = ((1UL<<9)-1) << 0, // Receive data value		
};
static inline uint32_t lpuart_rdr_get_rdr(void) { return (LPUART1.RDR & LPUART_RDR_RDR) >> 0 ; }

// LPUART->TDR Transmit data register
enum {
	LPUART_TDR_TDR = ((1UL<<9)-1) << 0, // Transmit data value		
};
static inline void lpuart_tdr_set_tdr(uint32_t val) { LPUART1.TDR = (LPUART1.TDR & ~LPUART_TDR_TDR) | ((val<<0) & LPUART_TDR_TDR); }
static inline uint32_t lpuart_tdr_get_tdr(void) { return (LPUART1.TDR & LPUART_TDR_TDR) >> 0 ; }

/* Nested Vectored Interrupt Controller
There is only one peripheral of type NVIC. */
struct NVIC_Type {
	__IO uint32_t ISER0; // @0 Interrupt Set-Enable Register
	__IO uint32_t ISER1; // @4 Interrupt Set-Enable Register
	__IO uint32_t ISER2; // @8 Interrupt Set-Enable Register
	 uint8_t RESERVED0[116]; // @12 
	__IO uint32_t ICER0; // @128 Interrupt Clear-Enable Register
	__IO uint32_t ICER1; // @132 Interrupt Clear-Enable Register
	__IO uint32_t ICER2; // @136 Interrupt Clear-Enable Register
	 uint8_t RESERVED1[116]; // @140 
	__IO uint32_t ISPR0; // @256 Interrupt Set-Pending Register
	__IO uint32_t ISPR1; // @260 Interrupt Set-Pending Register
	__IO uint32_t ISPR2; // @264 Interrupt Set-Pending Register
	 uint8_t RESERVED2[116]; // @268 
	__IO uint32_t ICPR0; // @384 Interrupt Clear-Pending Register
	__IO uint32_t ICPR1; // @388 Interrupt Clear-Pending Register
	__IO uint32_t ICPR2; // @392 Interrupt Clear-Pending Register
	 uint8_t RESERVED3[116]; // @396 
	__I uint32_t IABR0; // @512 Interrupt Active Bit Register
	__I uint32_t IABR1; // @516 Interrupt Active Bit Register
	__I uint32_t IABR2; // @520 Interrupt Active Bit Register
	 uint8_t RESERVED4[244]; // @524 
	__IO uint32_t IPR0; // @768 Interrupt Priority Register
	__IO uint32_t IPR1; // @772 Interrupt Priority Register
	__IO uint32_t IPR2; // @776 Interrupt Priority Register
	__IO uint32_t IPR3; // @780 Interrupt Priority Register
	__IO uint32_t IPR4; // @784 Interrupt Priority Register
	__IO uint32_t IPR5; // @788 Interrupt Priority Register
	__IO uint32_t IPR6; // @792 Interrupt Priority Register
	__IO uint32_t IPR7; // @796 Interrupt Priority Register
	__IO uint32_t IPR8; // @800 Interrupt Priority Register
	__IO uint32_t IPR9; // @804 Interrupt Priority Register
	__IO uint32_t IPR10; // @808 Interrupt Priority Register
	__IO uint32_t IPR11; // @812 Interrupt Priority Register
	__IO uint32_t IPR12; // @816 Interrupt Priority Register
	__IO uint32_t IPR13; // @820 Interrupt Priority Register
	__IO uint32_t IPR14; // @824 Interrupt Priority Register
	__IO uint32_t IPR15; // @828 Interrupt Priority Register
	__IO uint32_t IPR16; // @832 Interrupt Priority Register
	__IO uint32_t IPR17; // @836 Interrupt Priority Register
	__IO uint32_t IPR18; // @840 Interrupt Priority Register
	__IO uint32_t IPR19; // @844 Interrupt Priority Register
	__IO uint32_t IPR20; // @848 Interrupt Priority Register
};
extern struct NVIC_Type	NVIC;	// @0xE000E100 

// NVIC->IPR0 Interrupt Priority Register
enum {
	NVIC_IPR0_IPR_N3 = ((1UL<<8)-1) << 24, // IPR_N3
	NVIC_IPR0_IPR_N2 = ((1UL<<8)-1) << 16, // IPR_N2
	NVIC_IPR0_IPR_N1 = ((1UL<<8)-1) << 8, // IPR_N1
	NVIC_IPR0_IPR_N0 = ((1UL<<8)-1) << 0, // IPR_N0		
};
static inline void nvic_ipr0_set_ipr_n3(uint32_t val) { NVIC.IPR0 = (NVIC.IPR0 & ~NVIC_IPR0_IPR_N3) | ((val<<24) & NVIC_IPR0_IPR_N3); }
static inline void nvic_ipr0_set_ipr_n2(uint32_t val) { NVIC.IPR0 = (NVIC.IPR0 & ~NVIC_IPR0_IPR_N2) | ((val<<16) & NVIC_IPR0_IPR_N2); }
static inline void nvic_ipr0_set_ipr_n1(uint32_t val) { NVIC.IPR0 = (NVIC.IPR0 & ~NVIC_IPR0_IPR_N1) | ((val<<8) & NVIC_IPR0_IPR_N1); }
static inline void nvic_ipr0_set_ipr_n0(uint32_t val) { NVIC.IPR0 = (NVIC.IPR0 & ~NVIC_IPR0_IPR_N0) | ((val<<0) & NVIC_IPR0_IPR_N0); }
static inline uint32_t nvic_ipr0_get_ipr_n3(void) { return (NVIC.IPR0 & NVIC_IPR0_IPR_N3) >> 24 ; }
static inline uint32_t nvic_ipr0_get_ipr_n2(void) { return (NVIC.IPR0 & NVIC_IPR0_IPR_N2) >> 16 ; }
static inline uint32_t nvic_ipr0_get_ipr_n1(void) { return (NVIC.IPR0 & NVIC_IPR0_IPR_N1) >> 8 ; }
static inline uint32_t nvic_ipr0_get_ipr_n0(void) { return (NVIC.IPR0 & NVIC_IPR0_IPR_N0) >> 0 ; }

// NVIC->IPR1 Interrupt Priority Register
enum {
	NVIC_IPR1_IPR_N3 = ((1UL<<8)-1) << 24, // IPR_N3
	NVIC_IPR1_IPR_N2 = ((1UL<<8)-1) << 16, // IPR_N2
	NVIC_IPR1_IPR_N1 = ((1UL<<8)-1) << 8, // IPR_N1
	NVIC_IPR1_IPR_N0 = ((1UL<<8)-1) << 0, // IPR_N0		
};
static inline void nvic_ipr1_set_ipr_n3(uint32_t val) { NVIC.IPR1 = (NVIC.IPR1 & ~NVIC_IPR1_IPR_N3) | ((val<<24) & NVIC_IPR1_IPR_N3); }
static inline void nvic_ipr1_set_ipr_n2(uint32_t val) { NVIC.IPR1 = (NVIC.IPR1 & ~NVIC_IPR1_IPR_N2) | ((val<<16) & NVIC_IPR1_IPR_N2); }
static inline void nvic_ipr1_set_ipr_n1(uint32_t val) { NVIC.IPR1 = (NVIC.IPR1 & ~NVIC_IPR1_IPR_N1) | ((val<<8) & NVIC_IPR1_IPR_N1); }
static inline void nvic_ipr1_set_ipr_n0(uint32_t val) { NVIC.IPR1 = (NVIC.IPR1 & ~NVIC_IPR1_IPR_N0) | ((val<<0) & NVIC_IPR1_IPR_N0); }
static inline uint32_t nvic_ipr1_get_ipr_n3(void) { return (NVIC.IPR1 & NVIC_IPR1_IPR_N3) >> 24 ; }
static inline uint32_t nvic_ipr1_get_ipr_n2(void) { return (NVIC.IPR1 & NVIC_IPR1_IPR_N2) >> 16 ; }
static inline uint32_t nvic_ipr1_get_ipr_n1(void) { return (NVIC.IPR1 & NVIC_IPR1_IPR_N1) >> 8 ; }
static inline uint32_t nvic_ipr1_get_ipr_n0(void) { return (NVIC.IPR1 & NVIC_IPR1_IPR_N0) >> 0 ; }

// NVIC->IPR2 Interrupt Priority Register
enum {
	NVIC_IPR2_IPR_N3 = ((1UL<<8)-1) << 24, // IPR_N3
	NVIC_IPR2_IPR_N2 = ((1UL<<8)-1) << 16, // IPR_N2
	NVIC_IPR2_IPR_N1 = ((1UL<<8)-1) << 8, // IPR_N1
	NVIC_IPR2_IPR_N0 = ((1UL<<8)-1) << 0, // IPR_N0		
};
static inline void nvic_ipr2_set_ipr_n3(uint32_t val) { NVIC.IPR2 = (NVIC.IPR2 & ~NVIC_IPR2_IPR_N3) | ((val<<24) & NVIC_IPR2_IPR_N3); }
static inline void nvic_ipr2_set_ipr_n2(uint32_t val) { NVIC.IPR2 = (NVIC.IPR2 & ~NVIC_IPR2_IPR_N2) | ((val<<16) & NVIC_IPR2_IPR_N2); }
static inline void nvic_ipr2_set_ipr_n1(uint32_t val) { NVIC.IPR2 = (NVIC.IPR2 & ~NVIC_IPR2_IPR_N1) | ((val<<8) & NVIC_IPR2_IPR_N1); }
static inline void nvic_ipr2_set_ipr_n0(uint32_t val) { NVIC.IPR2 = (NVIC.IPR2 & ~NVIC_IPR2_IPR_N0) | ((val<<0) & NVIC_IPR2_IPR_N0); }
static inline uint32_t nvic_ipr2_get_ipr_n3(void) { return (NVIC.IPR2 & NVIC_IPR2_IPR_N3) >> 24 ; }
static inline uint32_t nvic_ipr2_get_ipr_n2(void) { return (NVIC.IPR2 & NVIC_IPR2_IPR_N2) >> 16 ; }
static inline uint32_t nvic_ipr2_get_ipr_n1(void) { return (NVIC.IPR2 & NVIC_IPR2_IPR_N1) >> 8 ; }
static inline uint32_t nvic_ipr2_get_ipr_n0(void) { return (NVIC.IPR2 & NVIC_IPR2_IPR_N0) >> 0 ; }

// NVIC->IPR3 Interrupt Priority Register
enum {
	NVIC_IPR3_IPR_N3 = ((1UL<<8)-1) << 24, // IPR_N3
	NVIC_IPR3_IPR_N2 = ((1UL<<8)-1) << 16, // IPR_N2
	NVIC_IPR3_IPR_N1 = ((1UL<<8)-1) << 8, // IPR_N1
	NVIC_IPR3_IPR_N0 = ((1UL<<8)-1) << 0, // IPR_N0		
};
static inline void nvic_ipr3_set_ipr_n3(uint32_t val) { NVIC.IPR3 = (NVIC.IPR3 & ~NVIC_IPR3_IPR_N3) | ((val<<24) & NVIC_IPR3_IPR_N3); }
static inline void nvic_ipr3_set_ipr_n2(uint32_t val) { NVIC.IPR3 = (NVIC.IPR3 & ~NVIC_IPR3_IPR_N2) | ((val<<16) & NVIC_IPR3_IPR_N2); }
static inline void nvic_ipr3_set_ipr_n1(uint32_t val) { NVIC.IPR3 = (NVIC.IPR3 & ~NVIC_IPR3_IPR_N1) | ((val<<8) & NVIC_IPR3_IPR_N1); }
static inline void nvic_ipr3_set_ipr_n0(uint32_t val) { NVIC.IPR3 = (NVIC.IPR3 & ~NVIC_IPR3_IPR_N0) | ((val<<0) & NVIC_IPR3_IPR_N0); }
static inline uint32_t nvic_ipr3_get_ipr_n3(void) { return (NVIC.IPR3 & NVIC_IPR3_IPR_N3) >> 24 ; }
static inline uint32_t nvic_ipr3_get_ipr_n2(void) { return (NVIC.IPR3 & NVIC_IPR3_IPR_N2) >> 16 ; }
static inline uint32_t nvic_ipr3_get_ipr_n1(void) { return (NVIC.IPR3 & NVIC_IPR3_IPR_N1) >> 8 ; }
static inline uint32_t nvic_ipr3_get_ipr_n0(void) { return (NVIC.IPR3 & NVIC_IPR3_IPR_N0) >> 0 ; }

// NVIC->IPR4 Interrupt Priority Register
enum {
	NVIC_IPR4_IPR_N3 = ((1UL<<8)-1) << 24, // IPR_N3
	NVIC_IPR4_IPR_N2 = ((1UL<<8)-1) << 16, // IPR_N2
	NVIC_IPR4_IPR_N1 = ((1UL<<8)-1) << 8, // IPR_N1
	NVIC_IPR4_IPR_N0 = ((1UL<<8)-1) << 0, // IPR_N0		
};
static inline void nvic_ipr4_set_ipr_n3(uint32_t val) { NVIC.IPR4 = (NVIC.IPR4 & ~NVIC_IPR4_IPR_N3) | ((val<<24) & NVIC_IPR4_IPR_N3); }
static inline void nvic_ipr4_set_ipr_n2(uint32_t val) { NVIC.IPR4 = (NVIC.IPR4 & ~NVIC_IPR4_IPR_N2) | ((val<<16) & NVIC_IPR4_IPR_N2); }
static inline void nvic_ipr4_set_ipr_n1(uint32_t val) { NVIC.IPR4 = (NVIC.IPR4 & ~NVIC_IPR4_IPR_N1) | ((val<<8) & NVIC_IPR4_IPR_N1); }
static inline void nvic_ipr4_set_ipr_n0(uint32_t val) { NVIC.IPR4 = (NVIC.IPR4 & ~NVIC_IPR4_IPR_N0) | ((val<<0) & NVIC_IPR4_IPR_N0); }
static inline uint32_t nvic_ipr4_get_ipr_n3(void) { return (NVIC.IPR4 & NVIC_IPR4_IPR_N3) >> 24 ; }
static inline uint32_t nvic_ipr4_get_ipr_n2(void) { return (NVIC.IPR4 & NVIC_IPR4_IPR_N2) >> 16 ; }
static inline uint32_t nvic_ipr4_get_ipr_n1(void) { return (NVIC.IPR4 & NVIC_IPR4_IPR_N1) >> 8 ; }
static inline uint32_t nvic_ipr4_get_ipr_n0(void) { return (NVIC.IPR4 & NVIC_IPR4_IPR_N0) >> 0 ; }

// NVIC->IPR5 Interrupt Priority Register
enum {
	NVIC_IPR5_IPR_N3 = ((1UL<<8)-1) << 24, // IPR_N3
	NVIC_IPR5_IPR_N2 = ((1UL<<8)-1) << 16, // IPR_N2
	NVIC_IPR5_IPR_N1 = ((1UL<<8)-1) << 8, // IPR_N1
	NVIC_IPR5_IPR_N0 = ((1UL<<8)-1) << 0, // IPR_N0		
};
static inline void nvic_ipr5_set_ipr_n3(uint32_t val) { NVIC.IPR5 = (NVIC.IPR5 & ~NVIC_IPR5_IPR_N3) | ((val<<24) & NVIC_IPR5_IPR_N3); }
static inline void nvic_ipr5_set_ipr_n2(uint32_t val) { NVIC.IPR5 = (NVIC.IPR5 & ~NVIC_IPR5_IPR_N2) | ((val<<16) & NVIC_IPR5_IPR_N2); }
static inline void nvic_ipr5_set_ipr_n1(uint32_t val) { NVIC.IPR5 = (NVIC.IPR5 & ~NVIC_IPR5_IPR_N1) | ((val<<8) & NVIC_IPR5_IPR_N1); }
static inline void nvic_ipr5_set_ipr_n0(uint32_t val) { NVIC.IPR5 = (NVIC.IPR5 & ~NVIC_IPR5_IPR_N0) | ((val<<0) & NVIC_IPR5_IPR_N0); }
static inline uint32_t nvic_ipr5_get_ipr_n3(void) { return (NVIC.IPR5 & NVIC_IPR5_IPR_N3) >> 24 ; }
static inline uint32_t nvic_ipr5_get_ipr_n2(void) { return (NVIC.IPR5 & NVIC_IPR5_IPR_N2) >> 16 ; }
static inline uint32_t nvic_ipr5_get_ipr_n1(void) { return (NVIC.IPR5 & NVIC_IPR5_IPR_N1) >> 8 ; }
static inline uint32_t nvic_ipr5_get_ipr_n0(void) { return (NVIC.IPR5 & NVIC_IPR5_IPR_N0) >> 0 ; }

// NVIC->IPR6 Interrupt Priority Register
enum {
	NVIC_IPR6_IPR_N3 = ((1UL<<8)-1) << 24, // IPR_N3
	NVIC_IPR6_IPR_N2 = ((1UL<<8)-1) << 16, // IPR_N2
	NVIC_IPR6_IPR_N1 = ((1UL<<8)-1) << 8, // IPR_N1
	NVIC_IPR6_IPR_N0 = ((1UL<<8)-1) << 0, // IPR_N0		
};
static inline void nvic_ipr6_set_ipr_n3(uint32_t val) { NVIC.IPR6 = (NVIC.IPR6 & ~NVIC_IPR6_IPR_N3) | ((val<<24) & NVIC_IPR6_IPR_N3); }
static inline void nvic_ipr6_set_ipr_n2(uint32_t val) { NVIC.IPR6 = (NVIC.IPR6 & ~NVIC_IPR6_IPR_N2) | ((val<<16) & NVIC_IPR6_IPR_N2); }
static inline void nvic_ipr6_set_ipr_n1(uint32_t val) { NVIC.IPR6 = (NVIC.IPR6 & ~NVIC_IPR6_IPR_N1) | ((val<<8) & NVIC_IPR6_IPR_N1); }
static inline void nvic_ipr6_set_ipr_n0(uint32_t val) { NVIC.IPR6 = (NVIC.IPR6 & ~NVIC_IPR6_IPR_N0) | ((val<<0) & NVIC_IPR6_IPR_N0); }
static inline uint32_t nvic_ipr6_get_ipr_n3(void) { return (NVIC.IPR6 & NVIC_IPR6_IPR_N3) >> 24 ; }
static inline uint32_t nvic_ipr6_get_ipr_n2(void) { return (NVIC.IPR6 & NVIC_IPR6_IPR_N2) >> 16 ; }
static inline uint32_t nvic_ipr6_get_ipr_n1(void) { return (NVIC.IPR6 & NVIC_IPR6_IPR_N1) >> 8 ; }
static inline uint32_t nvic_ipr6_get_ipr_n0(void) { return (NVIC.IPR6 & NVIC_IPR6_IPR_N0) >> 0 ; }

// NVIC->IPR7 Interrupt Priority Register
enum {
	NVIC_IPR7_IPR_N3 = ((1UL<<8)-1) << 24, // IPR_N3
	NVIC_IPR7_IPR_N2 = ((1UL<<8)-1) << 16, // IPR_N2
	NVIC_IPR7_IPR_N1 = ((1UL<<8)-1) << 8, // IPR_N1
	NVIC_IPR7_IPR_N0 = ((1UL<<8)-1) << 0, // IPR_N0		
};
static inline void nvic_ipr7_set_ipr_n3(uint32_t val) { NVIC.IPR7 = (NVIC.IPR7 & ~NVIC_IPR7_IPR_N3) | ((val<<24) & NVIC_IPR7_IPR_N3); }
static inline void nvic_ipr7_set_ipr_n2(uint32_t val) { NVIC.IPR7 = (NVIC.IPR7 & ~NVIC_IPR7_IPR_N2) | ((val<<16) & NVIC_IPR7_IPR_N2); }
static inline void nvic_ipr7_set_ipr_n1(uint32_t val) { NVIC.IPR7 = (NVIC.IPR7 & ~NVIC_IPR7_IPR_N1) | ((val<<8) & NVIC_IPR7_IPR_N1); }
static inline void nvic_ipr7_set_ipr_n0(uint32_t val) { NVIC.IPR7 = (NVIC.IPR7 & ~NVIC_IPR7_IPR_N0) | ((val<<0) & NVIC_IPR7_IPR_N0); }
static inline uint32_t nvic_ipr7_get_ipr_n3(void) { return (NVIC.IPR7 & NVIC_IPR7_IPR_N3) >> 24 ; }
static inline uint32_t nvic_ipr7_get_ipr_n2(void) { return (NVIC.IPR7 & NVIC_IPR7_IPR_N2) >> 16 ; }
static inline uint32_t nvic_ipr7_get_ipr_n1(void) { return (NVIC.IPR7 & NVIC_IPR7_IPR_N1) >> 8 ; }
static inline uint32_t nvic_ipr7_get_ipr_n0(void) { return (NVIC.IPR7 & NVIC_IPR7_IPR_N0) >> 0 ; }

// NVIC->IPR8 Interrupt Priority Register
enum {
	NVIC_IPR8_IPR_N3 = ((1UL<<8)-1) << 24, // IPR_N3
	NVIC_IPR8_IPR_N2 = ((1UL<<8)-1) << 16, // IPR_N2
	NVIC_IPR8_IPR_N1 = ((1UL<<8)-1) << 8, // IPR_N1
	NVIC_IPR8_IPR_N0 = ((1UL<<8)-1) << 0, // IPR_N0		
};
static inline void nvic_ipr8_set_ipr_n3(uint32_t val) { NVIC.IPR8 = (NVIC.IPR8 & ~NVIC_IPR8_IPR_N3) | ((val<<24) & NVIC_IPR8_IPR_N3); }
static inline void nvic_ipr8_set_ipr_n2(uint32_t val) { NVIC.IPR8 = (NVIC.IPR8 & ~NVIC_IPR8_IPR_N2) | ((val<<16) & NVIC_IPR8_IPR_N2); }
static inline void nvic_ipr8_set_ipr_n1(uint32_t val) { NVIC.IPR8 = (NVIC.IPR8 & ~NVIC_IPR8_IPR_N1) | ((val<<8) & NVIC_IPR8_IPR_N1); }
static inline void nvic_ipr8_set_ipr_n0(uint32_t val) { NVIC.IPR8 = (NVIC.IPR8 & ~NVIC_IPR8_IPR_N0) | ((val<<0) & NVIC_IPR8_IPR_N0); }
static inline uint32_t nvic_ipr8_get_ipr_n3(void) { return (NVIC.IPR8 & NVIC_IPR8_IPR_N3) >> 24 ; }
static inline uint32_t nvic_ipr8_get_ipr_n2(void) { return (NVIC.IPR8 & NVIC_IPR8_IPR_N2) >> 16 ; }
static inline uint32_t nvic_ipr8_get_ipr_n1(void) { return (NVIC.IPR8 & NVIC_IPR8_IPR_N1) >> 8 ; }
static inline uint32_t nvic_ipr8_get_ipr_n0(void) { return (NVIC.IPR8 & NVIC_IPR8_IPR_N0) >> 0 ; }

// NVIC->IPR9 Interrupt Priority Register
enum {
	NVIC_IPR9_IPR_N3 = ((1UL<<8)-1) << 24, // IPR_N3
	NVIC_IPR9_IPR_N2 = ((1UL<<8)-1) << 16, // IPR_N2
	NVIC_IPR9_IPR_N1 = ((1UL<<8)-1) << 8, // IPR_N1
	NVIC_IPR9_IPR_N0 = ((1UL<<8)-1) << 0, // IPR_N0		
};
static inline void nvic_ipr9_set_ipr_n3(uint32_t val) { NVIC.IPR9 = (NVIC.IPR9 & ~NVIC_IPR9_IPR_N3) | ((val<<24) & NVIC_IPR9_IPR_N3); }
static inline void nvic_ipr9_set_ipr_n2(uint32_t val) { NVIC.IPR9 = (NVIC.IPR9 & ~NVIC_IPR9_IPR_N2) | ((val<<16) & NVIC_IPR9_IPR_N2); }
static inline void nvic_ipr9_set_ipr_n1(uint32_t val) { NVIC.IPR9 = (NVIC.IPR9 & ~NVIC_IPR9_IPR_N1) | ((val<<8) & NVIC_IPR9_IPR_N1); }
static inline void nvic_ipr9_set_ipr_n0(uint32_t val) { NVIC.IPR9 = (NVIC.IPR9 & ~NVIC_IPR9_IPR_N0) | ((val<<0) & NVIC_IPR9_IPR_N0); }
static inline uint32_t nvic_ipr9_get_ipr_n3(void) { return (NVIC.IPR9 & NVIC_IPR9_IPR_N3) >> 24 ; }
static inline uint32_t nvic_ipr9_get_ipr_n2(void) { return (NVIC.IPR9 & NVIC_IPR9_IPR_N2) >> 16 ; }
static inline uint32_t nvic_ipr9_get_ipr_n1(void) { return (NVIC.IPR9 & NVIC_IPR9_IPR_N1) >> 8 ; }
static inline uint32_t nvic_ipr9_get_ipr_n0(void) { return (NVIC.IPR9 & NVIC_IPR9_IPR_N0) >> 0 ; }

// NVIC->IPR10 Interrupt Priority Register
enum {
	NVIC_IPR10_IPR_N3 = ((1UL<<8)-1) << 24, // IPR_N3
	NVIC_IPR10_IPR_N2 = ((1UL<<8)-1) << 16, // IPR_N2
	NVIC_IPR10_IPR_N1 = ((1UL<<8)-1) << 8, // IPR_N1
	NVIC_IPR10_IPR_N0 = ((1UL<<8)-1) << 0, // IPR_N0		
};
static inline void nvic_ipr10_set_ipr_n3(uint32_t val) { NVIC.IPR10 = (NVIC.IPR10 & ~NVIC_IPR10_IPR_N3) | ((val<<24) & NVIC_IPR10_IPR_N3); }
static inline void nvic_ipr10_set_ipr_n2(uint32_t val) { NVIC.IPR10 = (NVIC.IPR10 & ~NVIC_IPR10_IPR_N2) | ((val<<16) & NVIC_IPR10_IPR_N2); }
static inline void nvic_ipr10_set_ipr_n1(uint32_t val) { NVIC.IPR10 = (NVIC.IPR10 & ~NVIC_IPR10_IPR_N1) | ((val<<8) & NVIC_IPR10_IPR_N1); }
static inline void nvic_ipr10_set_ipr_n0(uint32_t val) { NVIC.IPR10 = (NVIC.IPR10 & ~NVIC_IPR10_IPR_N0) | ((val<<0) & NVIC_IPR10_IPR_N0); }
static inline uint32_t nvic_ipr10_get_ipr_n3(void) { return (NVIC.IPR10 & NVIC_IPR10_IPR_N3) >> 24 ; }
static inline uint32_t nvic_ipr10_get_ipr_n2(void) { return (NVIC.IPR10 & NVIC_IPR10_IPR_N2) >> 16 ; }
static inline uint32_t nvic_ipr10_get_ipr_n1(void) { return (NVIC.IPR10 & NVIC_IPR10_IPR_N1) >> 8 ; }
static inline uint32_t nvic_ipr10_get_ipr_n0(void) { return (NVIC.IPR10 & NVIC_IPR10_IPR_N0) >> 0 ; }

// NVIC->IPR11 Interrupt Priority Register
enum {
	NVIC_IPR11_IPR_N3 = ((1UL<<8)-1) << 24, // IPR_N3
	NVIC_IPR11_IPR_N2 = ((1UL<<8)-1) << 16, // IPR_N2
	NVIC_IPR11_IPR_N1 = ((1UL<<8)-1) << 8, // IPR_N1
	NVIC_IPR11_IPR_N0 = ((1UL<<8)-1) << 0, // IPR_N0		
};
static inline void nvic_ipr11_set_ipr_n3(uint32_t val) { NVIC.IPR11 = (NVIC.IPR11 & ~NVIC_IPR11_IPR_N3) | ((val<<24) & NVIC_IPR11_IPR_N3); }
static inline void nvic_ipr11_set_ipr_n2(uint32_t val) { NVIC.IPR11 = (NVIC.IPR11 & ~NVIC_IPR11_IPR_N2) | ((val<<16) & NVIC_IPR11_IPR_N2); }
static inline void nvic_ipr11_set_ipr_n1(uint32_t val) { NVIC.IPR11 = (NVIC.IPR11 & ~NVIC_IPR11_IPR_N1) | ((val<<8) & NVIC_IPR11_IPR_N1); }
static inline void nvic_ipr11_set_ipr_n0(uint32_t val) { NVIC.IPR11 = (NVIC.IPR11 & ~NVIC_IPR11_IPR_N0) | ((val<<0) & NVIC_IPR11_IPR_N0); }
static inline uint32_t nvic_ipr11_get_ipr_n3(void) { return (NVIC.IPR11 & NVIC_IPR11_IPR_N3) >> 24 ; }
static inline uint32_t nvic_ipr11_get_ipr_n2(void) { return (NVIC.IPR11 & NVIC_IPR11_IPR_N2) >> 16 ; }
static inline uint32_t nvic_ipr11_get_ipr_n1(void) { return (NVIC.IPR11 & NVIC_IPR11_IPR_N1) >> 8 ; }
static inline uint32_t nvic_ipr11_get_ipr_n0(void) { return (NVIC.IPR11 & NVIC_IPR11_IPR_N0) >> 0 ; }

// NVIC->IPR12 Interrupt Priority Register
enum {
	NVIC_IPR12_IPR_N3 = ((1UL<<8)-1) << 24, // IPR_N3
	NVIC_IPR12_IPR_N2 = ((1UL<<8)-1) << 16, // IPR_N2
	NVIC_IPR12_IPR_N1 = ((1UL<<8)-1) << 8, // IPR_N1
	NVIC_IPR12_IPR_N0 = ((1UL<<8)-1) << 0, // IPR_N0		
};
static inline void nvic_ipr12_set_ipr_n3(uint32_t val) { NVIC.IPR12 = (NVIC.IPR12 & ~NVIC_IPR12_IPR_N3) | ((val<<24) & NVIC_IPR12_IPR_N3); }
static inline void nvic_ipr12_set_ipr_n2(uint32_t val) { NVIC.IPR12 = (NVIC.IPR12 & ~NVIC_IPR12_IPR_N2) | ((val<<16) & NVIC_IPR12_IPR_N2); }
static inline void nvic_ipr12_set_ipr_n1(uint32_t val) { NVIC.IPR12 = (NVIC.IPR12 & ~NVIC_IPR12_IPR_N1) | ((val<<8) & NVIC_IPR12_IPR_N1); }
static inline void nvic_ipr12_set_ipr_n0(uint32_t val) { NVIC.IPR12 = (NVIC.IPR12 & ~NVIC_IPR12_IPR_N0) | ((val<<0) & NVIC_IPR12_IPR_N0); }
static inline uint32_t nvic_ipr12_get_ipr_n3(void) { return (NVIC.IPR12 & NVIC_IPR12_IPR_N3) >> 24 ; }
static inline uint32_t nvic_ipr12_get_ipr_n2(void) { return (NVIC.IPR12 & NVIC_IPR12_IPR_N2) >> 16 ; }
static inline uint32_t nvic_ipr12_get_ipr_n1(void) { return (NVIC.IPR12 & NVIC_IPR12_IPR_N1) >> 8 ; }
static inline uint32_t nvic_ipr12_get_ipr_n0(void) { return (NVIC.IPR12 & NVIC_IPR12_IPR_N0) >> 0 ; }

// NVIC->IPR13 Interrupt Priority Register
enum {
	NVIC_IPR13_IPR_N3 = ((1UL<<8)-1) << 24, // IPR_N3
	NVIC_IPR13_IPR_N2 = ((1UL<<8)-1) << 16, // IPR_N2
	NVIC_IPR13_IPR_N1 = ((1UL<<8)-1) << 8, // IPR_N1
	NVIC_IPR13_IPR_N0 = ((1UL<<8)-1) << 0, // IPR_N0		
};
static inline void nvic_ipr13_set_ipr_n3(uint32_t val) { NVIC.IPR13 = (NVIC.IPR13 & ~NVIC_IPR13_IPR_N3) | ((val<<24) & NVIC_IPR13_IPR_N3); }
static inline void nvic_ipr13_set_ipr_n2(uint32_t val) { NVIC.IPR13 = (NVIC.IPR13 & ~NVIC_IPR13_IPR_N2) | ((val<<16) & NVIC_IPR13_IPR_N2); }
static inline void nvic_ipr13_set_ipr_n1(uint32_t val) { NVIC.IPR13 = (NVIC.IPR13 & ~NVIC_IPR13_IPR_N1) | ((val<<8) & NVIC_IPR13_IPR_N1); }
static inline void nvic_ipr13_set_ipr_n0(uint32_t val) { NVIC.IPR13 = (NVIC.IPR13 & ~NVIC_IPR13_IPR_N0) | ((val<<0) & NVIC_IPR13_IPR_N0); }
static inline uint32_t nvic_ipr13_get_ipr_n3(void) { return (NVIC.IPR13 & NVIC_IPR13_IPR_N3) >> 24 ; }
static inline uint32_t nvic_ipr13_get_ipr_n2(void) { return (NVIC.IPR13 & NVIC_IPR13_IPR_N2) >> 16 ; }
static inline uint32_t nvic_ipr13_get_ipr_n1(void) { return (NVIC.IPR13 & NVIC_IPR13_IPR_N1) >> 8 ; }
static inline uint32_t nvic_ipr13_get_ipr_n0(void) { return (NVIC.IPR13 & NVIC_IPR13_IPR_N0) >> 0 ; }

// NVIC->IPR14 Interrupt Priority Register
enum {
	NVIC_IPR14_IPR_N3 = ((1UL<<8)-1) << 24, // IPR_N3
	NVIC_IPR14_IPR_N2 = ((1UL<<8)-1) << 16, // IPR_N2
	NVIC_IPR14_IPR_N1 = ((1UL<<8)-1) << 8, // IPR_N1
	NVIC_IPR14_IPR_N0 = ((1UL<<8)-1) << 0, // IPR_N0		
};
static inline void nvic_ipr14_set_ipr_n3(uint32_t val) { NVIC.IPR14 = (NVIC.IPR14 & ~NVIC_IPR14_IPR_N3) | ((val<<24) & NVIC_IPR14_IPR_N3); }
static inline void nvic_ipr14_set_ipr_n2(uint32_t val) { NVIC.IPR14 = (NVIC.IPR14 & ~NVIC_IPR14_IPR_N2) | ((val<<16) & NVIC_IPR14_IPR_N2); }
static inline void nvic_ipr14_set_ipr_n1(uint32_t val) { NVIC.IPR14 = (NVIC.IPR14 & ~NVIC_IPR14_IPR_N1) | ((val<<8) & NVIC_IPR14_IPR_N1); }
static inline void nvic_ipr14_set_ipr_n0(uint32_t val) { NVIC.IPR14 = (NVIC.IPR14 & ~NVIC_IPR14_IPR_N0) | ((val<<0) & NVIC_IPR14_IPR_N0); }
static inline uint32_t nvic_ipr14_get_ipr_n3(void) { return (NVIC.IPR14 & NVIC_IPR14_IPR_N3) >> 24 ; }
static inline uint32_t nvic_ipr14_get_ipr_n2(void) { return (NVIC.IPR14 & NVIC_IPR14_IPR_N2) >> 16 ; }
static inline uint32_t nvic_ipr14_get_ipr_n1(void) { return (NVIC.IPR14 & NVIC_IPR14_IPR_N1) >> 8 ; }
static inline uint32_t nvic_ipr14_get_ipr_n0(void) { return (NVIC.IPR14 & NVIC_IPR14_IPR_N0) >> 0 ; }

// NVIC->IPR15 Interrupt Priority Register
enum {
	NVIC_IPR15_IPR_N3 = ((1UL<<8)-1) << 24, // IPR_N3
	NVIC_IPR15_IPR_N2 = ((1UL<<8)-1) << 16, // IPR_N2
	NVIC_IPR15_IPR_N1 = ((1UL<<8)-1) << 8, // IPR_N1
	NVIC_IPR15_IPR_N0 = ((1UL<<8)-1) << 0, // IPR_N0		
};
static inline void nvic_ipr15_set_ipr_n3(uint32_t val) { NVIC.IPR15 = (NVIC.IPR15 & ~NVIC_IPR15_IPR_N3) | ((val<<24) & NVIC_IPR15_IPR_N3); }
static inline void nvic_ipr15_set_ipr_n2(uint32_t val) { NVIC.IPR15 = (NVIC.IPR15 & ~NVIC_IPR15_IPR_N2) | ((val<<16) & NVIC_IPR15_IPR_N2); }
static inline void nvic_ipr15_set_ipr_n1(uint32_t val) { NVIC.IPR15 = (NVIC.IPR15 & ~NVIC_IPR15_IPR_N1) | ((val<<8) & NVIC_IPR15_IPR_N1); }
static inline void nvic_ipr15_set_ipr_n0(uint32_t val) { NVIC.IPR15 = (NVIC.IPR15 & ~NVIC_IPR15_IPR_N0) | ((val<<0) & NVIC_IPR15_IPR_N0); }
static inline uint32_t nvic_ipr15_get_ipr_n3(void) { return (NVIC.IPR15 & NVIC_IPR15_IPR_N3) >> 24 ; }
static inline uint32_t nvic_ipr15_get_ipr_n2(void) { return (NVIC.IPR15 & NVIC_IPR15_IPR_N2) >> 16 ; }
static inline uint32_t nvic_ipr15_get_ipr_n1(void) { return (NVIC.IPR15 & NVIC_IPR15_IPR_N1) >> 8 ; }
static inline uint32_t nvic_ipr15_get_ipr_n0(void) { return (NVIC.IPR15 & NVIC_IPR15_IPR_N0) >> 0 ; }

// NVIC->IPR16 Interrupt Priority Register
enum {
	NVIC_IPR16_IPR_N3 = ((1UL<<8)-1) << 24, // IPR_N3
	NVIC_IPR16_IPR_N2 = ((1UL<<8)-1) << 16, // IPR_N2
	NVIC_IPR16_IPR_N1 = ((1UL<<8)-1) << 8, // IPR_N1
	NVIC_IPR16_IPR_N0 = ((1UL<<8)-1) << 0, // IPR_N0		
};
static inline void nvic_ipr16_set_ipr_n3(uint32_t val) { NVIC.IPR16 = (NVIC.IPR16 & ~NVIC_IPR16_IPR_N3) | ((val<<24) & NVIC_IPR16_IPR_N3); }
static inline void nvic_ipr16_set_ipr_n2(uint32_t val) { NVIC.IPR16 = (NVIC.IPR16 & ~NVIC_IPR16_IPR_N2) | ((val<<16) & NVIC_IPR16_IPR_N2); }
static inline void nvic_ipr16_set_ipr_n1(uint32_t val) { NVIC.IPR16 = (NVIC.IPR16 & ~NVIC_IPR16_IPR_N1) | ((val<<8) & NVIC_IPR16_IPR_N1); }
static inline void nvic_ipr16_set_ipr_n0(uint32_t val) { NVIC.IPR16 = (NVIC.IPR16 & ~NVIC_IPR16_IPR_N0) | ((val<<0) & NVIC_IPR16_IPR_N0); }
static inline uint32_t nvic_ipr16_get_ipr_n3(void) { return (NVIC.IPR16 & NVIC_IPR16_IPR_N3) >> 24 ; }
static inline uint32_t nvic_ipr16_get_ipr_n2(void) { return (NVIC.IPR16 & NVIC_IPR16_IPR_N2) >> 16 ; }
static inline uint32_t nvic_ipr16_get_ipr_n1(void) { return (NVIC.IPR16 & NVIC_IPR16_IPR_N1) >> 8 ; }
static inline uint32_t nvic_ipr16_get_ipr_n0(void) { return (NVIC.IPR16 & NVIC_IPR16_IPR_N0) >> 0 ; }

// NVIC->IPR17 Interrupt Priority Register
enum {
	NVIC_IPR17_IPR_N3 = ((1UL<<8)-1) << 24, // IPR_N3
	NVIC_IPR17_IPR_N2 = ((1UL<<8)-1) << 16, // IPR_N2
	NVIC_IPR17_IPR_N1 = ((1UL<<8)-1) << 8, // IPR_N1
	NVIC_IPR17_IPR_N0 = ((1UL<<8)-1) << 0, // IPR_N0		
};
static inline void nvic_ipr17_set_ipr_n3(uint32_t val) { NVIC.IPR17 = (NVIC.IPR17 & ~NVIC_IPR17_IPR_N3) | ((val<<24) & NVIC_IPR17_IPR_N3); }
static inline void nvic_ipr17_set_ipr_n2(uint32_t val) { NVIC.IPR17 = (NVIC.IPR17 & ~NVIC_IPR17_IPR_N2) | ((val<<16) & NVIC_IPR17_IPR_N2); }
static inline void nvic_ipr17_set_ipr_n1(uint32_t val) { NVIC.IPR17 = (NVIC.IPR17 & ~NVIC_IPR17_IPR_N1) | ((val<<8) & NVIC_IPR17_IPR_N1); }
static inline void nvic_ipr17_set_ipr_n0(uint32_t val) { NVIC.IPR17 = (NVIC.IPR17 & ~NVIC_IPR17_IPR_N0) | ((val<<0) & NVIC_IPR17_IPR_N0); }
static inline uint32_t nvic_ipr17_get_ipr_n3(void) { return (NVIC.IPR17 & NVIC_IPR17_IPR_N3) >> 24 ; }
static inline uint32_t nvic_ipr17_get_ipr_n2(void) { return (NVIC.IPR17 & NVIC_IPR17_IPR_N2) >> 16 ; }
static inline uint32_t nvic_ipr17_get_ipr_n1(void) { return (NVIC.IPR17 & NVIC_IPR17_IPR_N1) >> 8 ; }
static inline uint32_t nvic_ipr17_get_ipr_n0(void) { return (NVIC.IPR17 & NVIC_IPR17_IPR_N0) >> 0 ; }

// NVIC->IPR18 Interrupt Priority Register
enum {
	NVIC_IPR18_IPR_N3 = ((1UL<<8)-1) << 24, // IPR_N3
	NVIC_IPR18_IPR_N2 = ((1UL<<8)-1) << 16, // IPR_N2
	NVIC_IPR18_IPR_N1 = ((1UL<<8)-1) << 8, // IPR_N1
	NVIC_IPR18_IPR_N0 = ((1UL<<8)-1) << 0, // IPR_N0		
};
static inline void nvic_ipr18_set_ipr_n3(uint32_t val) { NVIC.IPR18 = (NVIC.IPR18 & ~NVIC_IPR18_IPR_N3) | ((val<<24) & NVIC_IPR18_IPR_N3); }
static inline void nvic_ipr18_set_ipr_n2(uint32_t val) { NVIC.IPR18 = (NVIC.IPR18 & ~NVIC_IPR18_IPR_N2) | ((val<<16) & NVIC_IPR18_IPR_N2); }
static inline void nvic_ipr18_set_ipr_n1(uint32_t val) { NVIC.IPR18 = (NVIC.IPR18 & ~NVIC_IPR18_IPR_N1) | ((val<<8) & NVIC_IPR18_IPR_N1); }
static inline void nvic_ipr18_set_ipr_n0(uint32_t val) { NVIC.IPR18 = (NVIC.IPR18 & ~NVIC_IPR18_IPR_N0) | ((val<<0) & NVIC_IPR18_IPR_N0); }
static inline uint32_t nvic_ipr18_get_ipr_n3(void) { return (NVIC.IPR18 & NVIC_IPR18_IPR_N3) >> 24 ; }
static inline uint32_t nvic_ipr18_get_ipr_n2(void) { return (NVIC.IPR18 & NVIC_IPR18_IPR_N2) >> 16 ; }
static inline uint32_t nvic_ipr18_get_ipr_n1(void) { return (NVIC.IPR18 & NVIC_IPR18_IPR_N1) >> 8 ; }
static inline uint32_t nvic_ipr18_get_ipr_n0(void) { return (NVIC.IPR18 & NVIC_IPR18_IPR_N0) >> 0 ; }

// NVIC->IPR19 Interrupt Priority Register
enum {
	NVIC_IPR19_IPR_N3 = ((1UL<<8)-1) << 24, // IPR_N3
	NVIC_IPR19_IPR_N2 = ((1UL<<8)-1) << 16, // IPR_N2
	NVIC_IPR19_IPR_N1 = ((1UL<<8)-1) << 8, // IPR_N1
	NVIC_IPR19_IPR_N0 = ((1UL<<8)-1) << 0, // IPR_N0		
};
static inline void nvic_ipr19_set_ipr_n3(uint32_t val) { NVIC.IPR19 = (NVIC.IPR19 & ~NVIC_IPR19_IPR_N3) | ((val<<24) & NVIC_IPR19_IPR_N3); }
static inline void nvic_ipr19_set_ipr_n2(uint32_t val) { NVIC.IPR19 = (NVIC.IPR19 & ~NVIC_IPR19_IPR_N2) | ((val<<16) & NVIC_IPR19_IPR_N2); }
static inline void nvic_ipr19_set_ipr_n1(uint32_t val) { NVIC.IPR19 = (NVIC.IPR19 & ~NVIC_IPR19_IPR_N1) | ((val<<8) & NVIC_IPR19_IPR_N1); }
static inline void nvic_ipr19_set_ipr_n0(uint32_t val) { NVIC.IPR19 = (NVIC.IPR19 & ~NVIC_IPR19_IPR_N0) | ((val<<0) & NVIC_IPR19_IPR_N0); }
static inline uint32_t nvic_ipr19_get_ipr_n3(void) { return (NVIC.IPR19 & NVIC_IPR19_IPR_N3) >> 24 ; }
static inline uint32_t nvic_ipr19_get_ipr_n2(void) { return (NVIC.IPR19 & NVIC_IPR19_IPR_N2) >> 16 ; }
static inline uint32_t nvic_ipr19_get_ipr_n1(void) { return (NVIC.IPR19 & NVIC_IPR19_IPR_N1) >> 8 ; }
static inline uint32_t nvic_ipr19_get_ipr_n0(void) { return (NVIC.IPR19 & NVIC_IPR19_IPR_N0) >> 0 ; }

// NVIC->IPR20 Interrupt Priority Register
enum {
	NVIC_IPR20_IPR_N3 = ((1UL<<8)-1) << 24, // IPR_N3
	NVIC_IPR20_IPR_N2 = ((1UL<<8)-1) << 16, // IPR_N2
	NVIC_IPR20_IPR_N1 = ((1UL<<8)-1) << 8, // IPR_N1
	NVIC_IPR20_IPR_N0 = ((1UL<<8)-1) << 0, // IPR_N0		
};
static inline void nvic_ipr20_set_ipr_n3(uint32_t val) { NVIC.IPR20 = (NVIC.IPR20 & ~NVIC_IPR20_IPR_N3) | ((val<<24) & NVIC_IPR20_IPR_N3); }
static inline void nvic_ipr20_set_ipr_n2(uint32_t val) { NVIC.IPR20 = (NVIC.IPR20 & ~NVIC_IPR20_IPR_N2) | ((val<<16) & NVIC_IPR20_IPR_N2); }
static inline void nvic_ipr20_set_ipr_n1(uint32_t val) { NVIC.IPR20 = (NVIC.IPR20 & ~NVIC_IPR20_IPR_N1) | ((val<<8) & NVIC_IPR20_IPR_N1); }
static inline void nvic_ipr20_set_ipr_n0(uint32_t val) { NVIC.IPR20 = (NVIC.IPR20 & ~NVIC_IPR20_IPR_N0) | ((val<<0) & NVIC_IPR20_IPR_N0); }
static inline uint32_t nvic_ipr20_get_ipr_n3(void) { return (NVIC.IPR20 & NVIC_IPR20_IPR_N3) >> 24 ; }
static inline uint32_t nvic_ipr20_get_ipr_n2(void) { return (NVIC.IPR20 & NVIC_IPR20_IPR_N2) >> 16 ; }
static inline uint32_t nvic_ipr20_get_ipr_n1(void) { return (NVIC.IPR20 & NVIC_IPR20_IPR_N1) >> 8 ; }
static inline uint32_t nvic_ipr20_get_ipr_n0(void) { return (NVIC.IPR20 & NVIC_IPR20_IPR_N0) >> 0 ; }

/* Nested vectored interrupt controller
There is only one peripheral of type NVIC_STIR. */
struct NVIC_STIR_Type {
	__IO uint16_t STIR; // @0 Software trigger interrupt register
};
extern struct NVIC_STIR_Type	NVIC_STIR;	// @0xE000EF00 

// NVIC_STIR->STIR Software trigger interrupt register
enum {
	NVIC_STIR_STIR_INTID = ((1UL<<9)-1) << 0, // Software generated interrupt ID		
};
static inline void nvic_stir_stir_set_intid(uint32_t val) { NVIC_STIR.STIR = (NVIC_STIR.STIR & ~NVIC_STIR_STIR_INTID) | ((val<<0) & NVIC_STIR_STIR_INTID); }
static inline uint32_t nvic_stir_stir_get_intid(void) { return (NVIC_STIR.STIR & NVIC_STIR_STIR_INTID) >> 0 ; }

/* Power control
There is only one peripheral of type PWR. */
struct PWR_Type {
	__IO uint16_t CR1; // @0 Power control register 1
	 uint8_t RESERVED0[2]; // @2 
	__IO uint16_t CR2; // @4 Power control register 2
	 uint8_t RESERVED1[2]; // @6 
	__IO uint16_t CR3; // @8 Power control register 3
	 uint8_t RESERVED2[2]; // @10 
	__IO uint16_t CR4; // @12 Power control register 4
	 uint8_t RESERVED3[2]; // @14 
	__I uint16_t SR1; // @16 Power status register 1
	 uint8_t RESERVED4[2]; // @18 
	__I uint16_t SR2; // @20 Power status register 2
	 uint8_t RESERVED5[2]; // @22 
	__O uint16_t SCR; // @24 Power status clear register
	 uint8_t RESERVED6[6]; // @26 
	__IO uint16_t PUCRA; // @32 Power Port A pull-up control register
	 uint8_t RESERVED7[2]; // @34 
	__IO uint16_t PDCRA; // @36 Power Port A pull-down control register
	 uint8_t RESERVED8[2]; // @38 
	__IO uint16_t PUCRB; // @40 Power Port B pull-up control register
	 uint8_t RESERVED9[2]; // @42 
	__IO uint16_t PDCRB; // @44 Power Port B pull-down control register
	 uint8_t RESERVED10[2]; // @46 
	__IO uint16_t PUCRC; // @48 Power Port C pull-up control register
	 uint8_t RESERVED11[2]; // @50 
	__IO uint16_t PDCRC; // @52 Power Port C pull-down control register
	 uint8_t RESERVED12[2]; // @54 
	__IO uint16_t PUCRD; // @56 Power Port D pull-up control register
	 uint8_t RESERVED13[2]; // @58 
	__IO uint16_t PDCRD; // @60 Power Port D pull-down control register
	 uint8_t RESERVED14[2]; // @62 
	__IO uint16_t PUCRE; // @64 Power Port E pull-up control register
	 uint8_t RESERVED15[2]; // @66 
	__IO uint16_t PDCRE; // @68 Power Port E pull-down control register
	 uint8_t RESERVED16[2]; // @70 
	__IO uint16_t PUCRF; // @72 Power Port F pull-up control register
	 uint8_t RESERVED17[2]; // @74 
	__IO uint16_t PDCRF; // @76 Power Port F pull-down control register
	 uint8_t RESERVED18[2]; // @78 
	__IO uint16_t PUCRG; // @80 Power Port G pull-up control register
	 uint8_t RESERVED19[2]; // @82 
	__IO uint16_t PDCRG; // @84 Power Port G pull-down control register
	 uint8_t RESERVED20[2]; // @86 
	__IO uint8_t PUCRH; // @88 Power Port H pull-up control register
	 uint8_t RESERVED21[3]; // @89 
	__IO uint8_t PDCRH; // @92 Power Port H pull-down control register
};
extern struct PWR_Type	PWR;	// @0x40007000 

// PWR->CR1 Power control register 1
enum {
	PWR_CR1_LPR = 1UL<<14, // Low-power run
	PWR_CR1_VOS = ((1UL<<2)-1) << 9, // Voltage scaling range selection
	PWR_CR1_DBP = 1UL<<8, // Disable backup domain write protection
	PWR_CR1_LPMS = ((1UL<<3)-1) << 0, // Low-power mode selection		
};
static inline void pwr_cr1_set_vos(uint32_t val) { PWR.CR1 = (PWR.CR1 & ~PWR_CR1_VOS) | ((val<<9) & PWR_CR1_VOS); }
static inline void pwr_cr1_set_lpms(uint32_t val) { PWR.CR1 = (PWR.CR1 & ~PWR_CR1_LPMS) | ((val<<0) & PWR_CR1_LPMS); }
static inline uint32_t pwr_cr1_get_vos(void) { return (PWR.CR1 & PWR_CR1_VOS) >> 9 ; }
static inline uint32_t pwr_cr1_get_lpms(void) { return (PWR.CR1 & PWR_CR1_LPMS) >> 0 ; }

// PWR->CR2 Power control register 2
enum {
	PWR_CR2_USV = 1UL<<10, // VDDUSB USB supply valid
	PWR_CR2_IOSV = 1UL<<9, // VDDIO2 Independent I/Os supply valid
	PWR_CR2_PVME4 = 1UL<<7, // Peripheral voltage monitoring 4 enable: VDDA vs. 2.2V
	PWR_CR2_PVME3 = 1UL<<6, // Peripheral voltage monitoring 3 enable: VDDA vs. 1.62V
	PWR_CR2_PVME2 = 1UL<<5, // Peripheral voltage monitoring 2 enable: VDDIO2 vs. 0.9V
	PWR_CR2_PVME1 = 1UL<<4, // Peripheral voltage monitoring 1 enable: VDDUSB vs. 1.2V
	PWR_CR2_PLS = ((1UL<<3)-1) << 1, // Power voltage detector level selection
	PWR_CR2_PVDE = 1UL<<0, // Power voltage detector enable		
};
static inline void pwr_cr2_set_pls(uint32_t val) { PWR.CR2 = (PWR.CR2 & ~PWR_CR2_PLS) | ((val<<1) & PWR_CR2_PLS); }
static inline uint32_t pwr_cr2_get_pls(void) { return (PWR.CR2 & PWR_CR2_PLS) >> 1 ; }

// PWR->CR3 Power control register 3
enum {
	PWR_CR3_EWF = 1UL<<15, // Enable internal wakeup line
	PWR_CR3_APC = 1UL<<10, // Apply pull-up and pull-down configuration
	PWR_CR3_RRS = 1UL<<8, // SRAM2 retention in Standby mode
	PWR_CR3_EWUP5 = 1UL<<4, // Enable Wakeup pin WKUP5
	PWR_CR3_EWUP4 = 1UL<<3, // Enable Wakeup pin WKUP4
	PWR_CR3_EWUP3 = 1UL<<2, // Enable Wakeup pin WKUP3
	PWR_CR3_EWUP2 = 1UL<<1, // Enable Wakeup pin WKUP2
	PWR_CR3_EWUP1 = 1UL<<0, // Enable Wakeup pin WKUP1		
};

// PWR->CR4 Power control register 4
enum {
	PWR_CR4_VBRS = 1UL<<9, // VBAT battery charging resistor selection
	PWR_CR4_VBE = 1UL<<8, // VBAT battery charging enable
	PWR_CR4_WP5 = 1UL<<4, // Wakeup pin WKUP5 polarity
	PWR_CR4_WP4 = 1UL<<3, // Wakeup pin WKUP4 polarity
	PWR_CR4_WP3 = 1UL<<2, // Wakeup pin WKUP3 polarity
	PWR_CR4_WP2 = 1UL<<1, // Wakeup pin WKUP2 polarity
	PWR_CR4_WP1 = 1UL<<0, // Wakeup pin WKUP1 polarity		
};

// PWR->SR1 Power status register 1
enum {
	PWR_SR1_WUFI = 1UL<<15, // Wakeup flag internal
	PWR_SR1_CSBF = 1UL<<8, // Standby flag
	PWR_SR1_CWUF5 = 1UL<<4, // Wakeup flag 5
	PWR_SR1_CWUF4 = 1UL<<3, // Wakeup flag 4
	PWR_SR1_CWUF3 = 1UL<<2, // Wakeup flag 3
	PWR_SR1_CWUF2 = 1UL<<1, // Wakeup flag 2
	PWR_SR1_CWUF1 = 1UL<<0, // Wakeup flag 1		
};

// PWR->SR2 Power status register 2
enum {
	PWR_SR2_PVMO4 = 1UL<<15, // Peripheral voltage monitoring output: VDDA vs. 2.2 V
	PWR_SR2_PVMO3 = 1UL<<14, // Peripheral voltage monitoring output: VDDA vs. 1.62 V
	PWR_SR2_PVMO2 = 1UL<<13, // Peripheral voltage monitoring output: VDDIO2 vs. 0.9 V
	PWR_SR2_PVMO1 = 1UL<<12, // Peripheral voltage monitoring output: VDDUSB vs. 1.2 V
	PWR_SR2_PVDO = 1UL<<11, // Power voltage detector output
	PWR_SR2_VOSF = 1UL<<10, // Voltage scaling flag
	PWR_SR2_REGLPF = 1UL<<9, // Low-power regulator flag
	PWR_SR2_REGLPS = 1UL<<8, // Low-power regulator started		
};

// PWR->SCR Power status clear register
enum {
	PWR_SCR_SBF = 1UL<<8, // Clear standby flag
	PWR_SCR_WUF5 = 1UL<<4, // Clear wakeup flag 5
	PWR_SCR_WUF4 = 1UL<<3, // Clear wakeup flag 4
	PWR_SCR_WUF3 = 1UL<<2, // Clear wakeup flag 3
	PWR_SCR_WUF2 = 1UL<<1, // Clear wakeup flag 2
	PWR_SCR_WUF1 = 1UL<<0, // Clear wakeup flag 1		
};

// PWR->PUCRH Power Port H pull-up control register
enum {
	PWR_PUCRH_PUX  = ((1UL<<2)-1) << 0, // Merged Port H pull-up bit y (y=0..1)		
};
static inline void pwr_pucrh_set_pux (uint32_t val) { PWR.PUCRH = (PWR.PUCRH & ~PWR_PUCRH_PUX ) | ((val<<0) & PWR_PUCRH_PUX ); }
static inline uint32_t pwr_pucrh_get_pux (void) { return (PWR.PUCRH & PWR_PUCRH_PUX ) >> 0 ; }

// PWR->PDCRH Power Port H pull-down control register
enum {
	PWR_PDCRH_PDX  = ((1UL<<2)-1) << 0, // Merged Port H pull-down bit y (y=0..1)		
};
static inline void pwr_pdcrh_set_pdx (uint32_t val) { PWR.PDCRH = (PWR.PDCRH & ~PWR_PDCRH_PDX ) | ((val<<0) & PWR_PDCRH_PDX ); }
static inline uint32_t pwr_pdcrh_get_pdx (void) { return (PWR.PDCRH & PWR_PDCRH_PDX ) >> 0 ; }

/* Reset and clock control
There is only one peripheral of type RCC. */
struct RCC_Type {
	__IO uint32_t CR; // @0 Clock control register
	__IO uint32_t ICSCR; // @4 Internal clock sources calibration register
	__IO uint32_t CFGR; // @8 Clock configuration register
	__IO uint32_t PLLCFGR; // @12 PLL configuration register
	__IO uint32_t PLLSAI1CFGR; // @16 PLLSAI1 configuration register
	 uint8_t RESERVED0[4]; // @20 
	__IO uint16_t CIER; // @24 Clock interrupt enable register
	 uint8_t RESERVED1[2]; // @26 
	__I uint16_t CIFR; // @28 Clock interrupt flag register
	 uint8_t RESERVED2[2]; // @30 
	__O uint16_t CICR; // @32 Clock interrupt clear register
	 uint8_t RESERVED3[6]; // @34 
	__IO uint32_t AHB1RSTR; // @40 AHB1 peripheral reset register
	__IO uint32_t AHB2RSTR; // @44 AHB2 peripheral reset register
	__IO uint16_t AHB3RSTR; // @48 AHB3 peripheral reset register
	 uint8_t RESERVED4[6]; // @50 
	__IO uint32_t APB1RSTR1; // @56 APB1 peripheral reset register 1
	__IO uint8_t APB1RSTR2; // @60 APB1 peripheral reset register 2
	 uint8_t RESERVED5[3]; // @61 
	__IO uint32_t APB2RSTR; // @64 APB2 peripheral reset register
	 uint8_t RESERVED6[4]; // @68 
	__IO uint32_t AHB1ENR; // @72 AHB1 peripheral clock enable register
	__IO uint32_t AHB2ENR; // @76 AHB2 peripheral clock enable register
	__IO uint16_t AHB3ENR; // @80 AHB3 peripheral clock enable register
	 uint8_t RESERVED7[6]; // @82 
	__IO uint32_t APB1ENR1; // @88 APB1ENR1
	__IO uint32_t APB1ENR2; // @92 APB1 peripheral clock enable register 2
	__IO uint32_t APB2ENR; // @96 APB2ENR
	 uint8_t RESERVED8[4]; // @100 
	__IO uint32_t AHB1SMENR; // @104 AHB1 peripheral clocks enable in Sleep and Stop modes register
	__IO uint32_t AHB2SMENR; // @108 AHB2 peripheral clocks enable in Sleep and Stop modes register
	__IO uint16_t AHB3SMENR; // @112 AHB3 peripheral clocks enable in Sleep and Stop modes register
	 uint8_t RESERVED9[6]; // @114 
	__IO uint32_t APB1SMENR1; // @120 APB1SMENR1
	__IO uint8_t APB1SMENR2; // @124 APB1 peripheral clocks enable in Sleep and Stop modes register 2
	 uint8_t RESERVED10[3]; // @125 
	__IO uint32_t APB2SMENR; // @128 APB2SMENR
	 uint8_t RESERVED11[4]; // @132 
	__IO uint32_t CCIPR; // @136 CCIPR
	 uint8_t RESERVED12[4]; // @140 
	__IO uint32_t BDCR; // @144 BDCR
	__IO uint32_t CSR; // @148 CSR
	__IO uint16_t CRRCR; // @152 Clock recovery RC register
};
extern struct RCC_Type	RCC;	// @0x40021000 

// RCC->CR Clock control register
enum {
	RCC_CR_PLLSAI1RDY = 1UL<<27, // SAI1 PLL clock ready flag
	RCC_CR_PLLSAI1ON = 1UL<<26, // SAI1 PLL enable
	RCC_CR_PLLRDY = 1UL<<25, // Main PLL clock ready flag
	RCC_CR_PLLON = 1UL<<24, // Main PLL enable
	RCC_CR_CSSON = 1UL<<19, // Clock security system enable
	RCC_CR_HSEBYP = 1UL<<18, // HSE crystal oscillator bypass
	RCC_CR_HSERDY = 1UL<<17, // HSE clock ready flag
	RCC_CR_HSEON = 1UL<<16, // HSE clock enable
	RCC_CR_HSIASFS = 1UL<<11, // HSI automatic start from Stop
	RCC_CR_HSIRDY = 1UL<<10, // HSI clock ready flag
	RCC_CR_HSIKERON = 1UL<<9, // HSI always enable for peripheral kernels
	RCC_CR_HSION = 1UL<<8, // HSI clock enable
	RCC_CR_MSIRANGE = ((1UL<<4)-1) << 4, // MSI clock ranges
	RCC_CR_MSIRGSEL = 1UL<<3, // MSI clock range selection
	RCC_CR_MSIPLLEN = 1UL<<2, // MSI clock PLL enable
	RCC_CR_MSIRDY = 1UL<<1, // MSI clock ready flag
	RCC_CR_MSION = 1UL<<0, // MSI clock enable		
};
static inline void rcc_cr_set_msirange(uint32_t val) { RCC.CR = (RCC.CR & ~RCC_CR_MSIRANGE) | ((val<<4) & RCC_CR_MSIRANGE); }
static inline uint32_t rcc_cr_get_msirange(void) { return (RCC.CR & RCC_CR_MSIRANGE) >> 4 ; }

// RCC->ICSCR Internal clock sources calibration register
enum {
	RCC_ICSCR_HSITRIM = ((1UL<<5)-1) << 24, // HSI clock trimming
	RCC_ICSCR_HSICAL = ((1UL<<8)-1) << 16, // HSI clock calibration
	RCC_ICSCR_MSITRIM = ((1UL<<8)-1) << 8, // MSI clock trimming
	RCC_ICSCR_MSICAL = ((1UL<<8)-1) << 0, // MSI clock calibration		
};
static inline void rcc_icscr_set_hsitrim(uint32_t val) { RCC.ICSCR = (RCC.ICSCR & ~RCC_ICSCR_HSITRIM) | ((val<<24) & RCC_ICSCR_HSITRIM); }
static inline void rcc_icscr_set_hsical(uint32_t val) { RCC.ICSCR = (RCC.ICSCR & ~RCC_ICSCR_HSICAL) | ((val<<16) & RCC_ICSCR_HSICAL); }
static inline void rcc_icscr_set_msitrim(uint32_t val) { RCC.ICSCR = (RCC.ICSCR & ~RCC_ICSCR_MSITRIM) | ((val<<8) & RCC_ICSCR_MSITRIM); }
static inline void rcc_icscr_set_msical(uint32_t val) { RCC.ICSCR = (RCC.ICSCR & ~RCC_ICSCR_MSICAL) | ((val<<0) & RCC_ICSCR_MSICAL); }
static inline uint32_t rcc_icscr_get_hsitrim(void) { return (RCC.ICSCR & RCC_ICSCR_HSITRIM) >> 24 ; }
static inline uint32_t rcc_icscr_get_hsical(void) { return (RCC.ICSCR & RCC_ICSCR_HSICAL) >> 16 ; }
static inline uint32_t rcc_icscr_get_msitrim(void) { return (RCC.ICSCR & RCC_ICSCR_MSITRIM) >> 8 ; }
static inline uint32_t rcc_icscr_get_msical(void) { return (RCC.ICSCR & RCC_ICSCR_MSICAL) >> 0 ; }

// RCC->CFGR Clock configuration register
enum {
	RCC_CFGR_MCOPRE = ((1UL<<3)-1) << 28, // Microcontroller clock output prescaler
	RCC_CFGR_MCOSEL = ((1UL<<3)-1) << 24, // Microcontroller clock output
	RCC_CFGR_STOPWUCK = 1UL<<15, // Wakeup from Stop and CSS backup clock selection
	RCC_CFGR_PPRE2 = ((1UL<<3)-1) << 11, // APB high-speed prescaler (APB2)
	RCC_CFGR_PPRE1 = ((1UL<<3)-1) << 8, // PB low-speed prescaler (APB1)
	RCC_CFGR_HPRE = ((1UL<<4)-1) << 4, // AHB prescaler
	RCC_CFGR_SWS = ((1UL<<2)-1) << 2, // System clock switch status
	RCC_CFGR_SW = ((1UL<<2)-1) << 0, // System clock switch		
};
static inline void rcc_cfgr_set_mcopre(uint32_t val) { RCC.CFGR = (RCC.CFGR & ~RCC_CFGR_MCOPRE) | ((val<<28) & RCC_CFGR_MCOPRE); }
static inline void rcc_cfgr_set_mcosel(uint32_t val) { RCC.CFGR = (RCC.CFGR & ~RCC_CFGR_MCOSEL) | ((val<<24) & RCC_CFGR_MCOSEL); }
static inline void rcc_cfgr_set_ppre2(uint32_t val) { RCC.CFGR = (RCC.CFGR & ~RCC_CFGR_PPRE2) | ((val<<11) & RCC_CFGR_PPRE2); }
static inline void rcc_cfgr_set_ppre1(uint32_t val) { RCC.CFGR = (RCC.CFGR & ~RCC_CFGR_PPRE1) | ((val<<8) & RCC_CFGR_PPRE1); }
static inline void rcc_cfgr_set_hpre(uint32_t val) { RCC.CFGR = (RCC.CFGR & ~RCC_CFGR_HPRE) | ((val<<4) & RCC_CFGR_HPRE); }
static inline void rcc_cfgr_set_sws(uint32_t val) { RCC.CFGR = (RCC.CFGR & ~RCC_CFGR_SWS) | ((val<<2) & RCC_CFGR_SWS); }
static inline void rcc_cfgr_set_sw(uint32_t val) { RCC.CFGR = (RCC.CFGR & ~RCC_CFGR_SW) | ((val<<0) & RCC_CFGR_SW); }
static inline uint32_t rcc_cfgr_get_mcopre(void) { return (RCC.CFGR & RCC_CFGR_MCOPRE) >> 28 ; }
static inline uint32_t rcc_cfgr_get_mcosel(void) { return (RCC.CFGR & RCC_CFGR_MCOSEL) >> 24 ; }
static inline uint32_t rcc_cfgr_get_ppre2(void) { return (RCC.CFGR & RCC_CFGR_PPRE2) >> 11 ; }
static inline uint32_t rcc_cfgr_get_ppre1(void) { return (RCC.CFGR & RCC_CFGR_PPRE1) >> 8 ; }
static inline uint32_t rcc_cfgr_get_hpre(void) { return (RCC.CFGR & RCC_CFGR_HPRE) >> 4 ; }
static inline uint32_t rcc_cfgr_get_sws(void) { return (RCC.CFGR & RCC_CFGR_SWS) >> 2 ; }
static inline uint32_t rcc_cfgr_get_sw(void) { return (RCC.CFGR & RCC_CFGR_SW) >> 0 ; }

// RCC->PLLCFGR PLL configuration register
enum {
	RCC_PLLCFGR_PLLPDIV = ((1UL<<5)-1) << 27, // Main PLL division factor for PLLSAI2CLK
	RCC_PLLCFGR_PLLR = ((1UL<<2)-1) << 25, // Main PLL division factor for PLLCLK (system clock)
	RCC_PLLCFGR_PLLREN = 1UL<<24, // Main PLL PLLCLK output enable
	RCC_PLLCFGR_PLLQ = ((1UL<<2)-1) << 21, // Main PLL division factor for PLLUSB1CLK(48 MHz clock)
	RCC_PLLCFGR_PLLQEN = 1UL<<20, // Main PLL PLLUSB1CLK output enable
	RCC_PLLCFGR_PLLP = 1UL<<17, // Main PLL division factor for PLLSAI3CLK (SAI1 and SAI2 clock)
	RCC_PLLCFGR_PLLPEN = 1UL<<16, // Main PLL PLLSAI3CLK output enable
	RCC_PLLCFGR_PLLN = ((1UL<<7)-1) << 8, // Main PLL multiplication factor for VCO
	RCC_PLLCFGR_PLLM = ((1UL<<3)-1) << 4, // Division factor for the main PLL and audio PLL (PLLSAI1 and PLLSAI2) input clock
	RCC_PLLCFGR_PLLSRC = ((1UL<<2)-1) << 0, // Main PLL, PLLSAI1 and PLLSAI2 entry clock source		
};
static inline void rcc_pllcfgr_set_pllpdiv(uint32_t val) { RCC.PLLCFGR = (RCC.PLLCFGR & ~RCC_PLLCFGR_PLLPDIV) | ((val<<27) & RCC_PLLCFGR_PLLPDIV); }
static inline void rcc_pllcfgr_set_pllr(uint32_t val) { RCC.PLLCFGR = (RCC.PLLCFGR & ~RCC_PLLCFGR_PLLR) | ((val<<25) & RCC_PLLCFGR_PLLR); }
static inline void rcc_pllcfgr_set_pllq(uint32_t val) { RCC.PLLCFGR = (RCC.PLLCFGR & ~RCC_PLLCFGR_PLLQ) | ((val<<21) & RCC_PLLCFGR_PLLQ); }
static inline void rcc_pllcfgr_set_plln(uint32_t val) { RCC.PLLCFGR = (RCC.PLLCFGR & ~RCC_PLLCFGR_PLLN) | ((val<<8) & RCC_PLLCFGR_PLLN); }
static inline void rcc_pllcfgr_set_pllm(uint32_t val) { RCC.PLLCFGR = (RCC.PLLCFGR & ~RCC_PLLCFGR_PLLM) | ((val<<4) & RCC_PLLCFGR_PLLM); }
static inline void rcc_pllcfgr_set_pllsrc(uint32_t val) { RCC.PLLCFGR = (RCC.PLLCFGR & ~RCC_PLLCFGR_PLLSRC) | ((val<<0) & RCC_PLLCFGR_PLLSRC); }
static inline uint32_t rcc_pllcfgr_get_pllpdiv(void) { return (RCC.PLLCFGR & RCC_PLLCFGR_PLLPDIV) >> 27 ; }
static inline uint32_t rcc_pllcfgr_get_pllr(void) { return (RCC.PLLCFGR & RCC_PLLCFGR_PLLR) >> 25 ; }
static inline uint32_t rcc_pllcfgr_get_pllq(void) { return (RCC.PLLCFGR & RCC_PLLCFGR_PLLQ) >> 21 ; }
static inline uint32_t rcc_pllcfgr_get_plln(void) { return (RCC.PLLCFGR & RCC_PLLCFGR_PLLN) >> 8 ; }
static inline uint32_t rcc_pllcfgr_get_pllm(void) { return (RCC.PLLCFGR & RCC_PLLCFGR_PLLM) >> 4 ; }
static inline uint32_t rcc_pllcfgr_get_pllsrc(void) { return (RCC.PLLCFGR & RCC_PLLCFGR_PLLSRC) >> 0 ; }

// RCC->PLLSAI1CFGR PLLSAI1 configuration register
enum {
	RCC_PLLSAI1CFGR_PLLSAI1PDIV = ((1UL<<5)-1) << 27, // PLLSAI1 division factor for PLLSAI1CLK
	RCC_PLLSAI1CFGR_PLLSAI1R = ((1UL<<2)-1) << 25, // PLLSAI1 division factor for PLLADC1CLK (ADC clock)
	RCC_PLLSAI1CFGR_PLLSAI1REN = 1UL<<24, // PLLSAI1 PLLADC1CLK output enable
	RCC_PLLSAI1CFGR_PLLSAI1Q = ((1UL<<2)-1) << 21, // SAI1PLL division factor for PLLUSB2CLK (48 MHz clock)
	RCC_PLLSAI1CFGR_PLLSAI1QEN = 1UL<<20, // SAI1PLL PLLUSB2CLK output enable
	RCC_PLLSAI1CFGR_PLLSAI1P = 1UL<<17, // SAI1PLL division factor for PLLSAI1CLK (SAI1 or SAI2 clock)
	RCC_PLLSAI1CFGR_PLLSAI1PEN = 1UL<<16, // SAI1PLL PLLSAI1CLK output enable
	RCC_PLLSAI1CFGR_PLLSAI1N = ((1UL<<7)-1) << 8, // SAI1PLL multiplication factor for VCO		
};
static inline void rcc_pllsai1cfgr_set_pllsai1pdiv(uint32_t val) { RCC.PLLSAI1CFGR = (RCC.PLLSAI1CFGR & ~RCC_PLLSAI1CFGR_PLLSAI1PDIV) | ((val<<27) & RCC_PLLSAI1CFGR_PLLSAI1PDIV); }
static inline void rcc_pllsai1cfgr_set_pllsai1r(uint32_t val) { RCC.PLLSAI1CFGR = (RCC.PLLSAI1CFGR & ~RCC_PLLSAI1CFGR_PLLSAI1R) | ((val<<25) & RCC_PLLSAI1CFGR_PLLSAI1R); }
static inline void rcc_pllsai1cfgr_set_pllsai1q(uint32_t val) { RCC.PLLSAI1CFGR = (RCC.PLLSAI1CFGR & ~RCC_PLLSAI1CFGR_PLLSAI1Q) | ((val<<21) & RCC_PLLSAI1CFGR_PLLSAI1Q); }
static inline void rcc_pllsai1cfgr_set_pllsai1n(uint32_t val) { RCC.PLLSAI1CFGR = (RCC.PLLSAI1CFGR & ~RCC_PLLSAI1CFGR_PLLSAI1N) | ((val<<8) & RCC_PLLSAI1CFGR_PLLSAI1N); }
static inline uint32_t rcc_pllsai1cfgr_get_pllsai1pdiv(void) { return (RCC.PLLSAI1CFGR & RCC_PLLSAI1CFGR_PLLSAI1PDIV) >> 27 ; }
static inline uint32_t rcc_pllsai1cfgr_get_pllsai1r(void) { return (RCC.PLLSAI1CFGR & RCC_PLLSAI1CFGR_PLLSAI1R) >> 25 ; }
static inline uint32_t rcc_pllsai1cfgr_get_pllsai1q(void) { return (RCC.PLLSAI1CFGR & RCC_PLLSAI1CFGR_PLLSAI1Q) >> 21 ; }
static inline uint32_t rcc_pllsai1cfgr_get_pllsai1n(void) { return (RCC.PLLSAI1CFGR & RCC_PLLSAI1CFGR_PLLSAI1N) >> 8 ; }

// RCC->CIER Clock interrupt enable register
enum {
	RCC_CIER_HSI48RDYIE = 1UL<<10, // HSI48 ready interrupt enable
	RCC_CIER_LSECSSIE = 1UL<<9, // LSE clock security system interrupt enable
	RCC_CIER_PLLSAI1RDYIE = 1UL<<6, // PLLSAI1 ready interrupt enable
	RCC_CIER_PLLRDYIE = 1UL<<5, // PLL ready interrupt enable
	RCC_CIER_HSERDYIE = 1UL<<4, // HSE ready interrupt enable
	RCC_CIER_HSIRDYIE = 1UL<<3, // HSI ready interrupt enable
	RCC_CIER_MSIRDYIE = 1UL<<2, // MSI ready interrupt enable
	RCC_CIER_LSERDYIE = 1UL<<1, // LSE ready interrupt enable
	RCC_CIER_LSIRDYIE = 1UL<<0, // LSI ready interrupt enable		
};

// RCC->CIFR Clock interrupt flag register
enum {
	RCC_CIFR_HSI48RDYF = 1UL<<10, // HSI48 ready interrupt flag
	RCC_CIFR_LSECSSF = 1UL<<9, // LSE Clock security system interrupt flag
	RCC_CIFR_CSSF = 1UL<<8, // Clock security system interrupt flag
	RCC_CIFR_PLLSAI1RDYF = 1UL<<6, // PLLSAI1 ready interrupt flag
	RCC_CIFR_PLLRDYF = 1UL<<5, // PLL ready interrupt flag
	RCC_CIFR_HSERDYF = 1UL<<4, // HSE ready interrupt flag
	RCC_CIFR_HSIRDYF = 1UL<<3, // HSI ready interrupt flag
	RCC_CIFR_MSIRDYF = 1UL<<2, // MSI ready interrupt flag
	RCC_CIFR_LSERDYF = 1UL<<1, // LSE ready interrupt flag
	RCC_CIFR_LSIRDYF = 1UL<<0, // LSI ready interrupt flag		
};

// RCC->CICR Clock interrupt clear register
enum {
	RCC_CICR_HSI48RDYC = 1UL<<10, // HSI48 oscillator ready interrupt clear
	RCC_CICR_LSECSSC = 1UL<<9, // LSE Clock security system interrupt clear
	RCC_CICR_CSSC = 1UL<<8, // Clock security system interrupt clear
	RCC_CICR_PLLSAI1RDYC = 1UL<<6, // PLLSAI1 ready interrupt clear
	RCC_CICR_PLLRDYC = 1UL<<5, // PLL ready interrupt clear
	RCC_CICR_HSERDYC = 1UL<<4, // HSE ready interrupt clear
	RCC_CICR_HSIRDYC = 1UL<<3, // HSI ready interrupt clear
	RCC_CICR_MSIRDYC = 1UL<<2, // MSI ready interrupt clear
	RCC_CICR_LSERDYC = 1UL<<1, // LSE ready interrupt clear
	RCC_CICR_LSIRDYC = 1UL<<0, // LSI ready interrupt clear		
};

// RCC->AHB1RSTR AHB1 peripheral reset register
enum {
	RCC_AHB1RSTR_TSCRST = 1UL<<16, // Touch Sensing Controller reset
	RCC_AHB1RSTR_CRCRST = 1UL<<11, // CRC reset
	RCC_AHB1RSTR_FLASHRST = 1UL<<8, // Flash memory interface reset
	RCC_AHB1RSTR_DMA2RST = 1UL<<1, // DMA2 reset
	RCC_AHB1RSTR_DMA1RST = 1UL<<0, // DMA1 reset		
};

// RCC->AHB2RSTR AHB2 peripheral reset register
enum {
	RCC_AHB2RSTR_RNGRST = 1UL<<18, // Random number generator reset
	RCC_AHB2RSTR_AESRST = 1UL<<16, // AES hardware accelerator reset
	RCC_AHB2RSTR_ADCRST = 1UL<<13, // ADC reset
	RCC_AHB2RSTR_GPIOHRST = 1UL<<7, // IO port H reset
	RCC_AHB2RSTR_GPIOERST = 1UL<<4, // IO port E reset
	RCC_AHB2RSTR_GPIODRST = 1UL<<3, // IO port D reset
	RCC_AHB2RSTR_GPIOCRST = 1UL<<2, // IO port C reset
	RCC_AHB2RSTR_GPIOBRST = 1UL<<1, // IO port B reset
	RCC_AHB2RSTR_GPIOARST = 1UL<<0, // IO port A reset		
};

// RCC->AHB3RSTR AHB3 peripheral reset register
enum {
	RCC_AHB3RSTR_QSPIRST = 1UL<<8, // Quad SPI memory interface reset		
};

// RCC->APB1RSTR1 APB1 peripheral reset register 1
enum {
	RCC_APB1RSTR1_LPTIM1RST = 1UL<<31, // Low Power Timer 1 reset
	RCC_APB1RSTR1_OPAMPRST = 1UL<<30, // OPAMP interface reset
	RCC_APB1RSTR1_DAC1RST = 1UL<<29, // DAC1 interface reset
	RCC_APB1RSTR1_PWRRST = 1UL<<28, // Power interface reset
	RCC_APB1RSTR1_USBFSRST = 1UL<<26, // USB FS reset
	RCC_APB1RSTR1_CAN1RST = 1UL<<25, // CAN1 reset
	RCC_APB1RSTR1_CRSRST = 1UL<<24, // CRS reset
	RCC_APB1RSTR1_I2C3RST = 1UL<<23, // I2C3 reset
	RCC_APB1RSTR1_I2C2RST = 1UL<<22, // I2C2 reset
	RCC_APB1RSTR1_I2C1RST = 1UL<<21, // I2C1 reset
	RCC_APB1RSTR1_USART4RST = 1UL<<19, // USART4 reset.
	RCC_APB1RSTR1_USART1RST = 1UL<<18, // USART1 reset
	RCC_APB1RSTR1_USART2RST = 1UL<<17, // USART2 reset
	RCC_APB1RSTR1_SPI3RST = 1UL<<15, // SPI3 reset
	RCC_APB1RSTR1_SPI2RST = 1UL<<14, // SPI2 reset
	RCC_APB1RSTR1_LCDRST = 1UL<<9, // LCD interface reset
	RCC_APB1RSTR1_TIM7RST = 1UL<<5, // TIM7 timer reset
	RCC_APB1RSTR1_TIM6RST = 1UL<<4, // TIM6 timer reset
	RCC_APB1RSTR1_TIM2RST = 1UL<<0, // TIM2 timer reset		
};

// RCC->APB1RSTR2 APB1 peripheral reset register 2
enum {
	RCC_APB1RSTR2_LPTIM2RST = 1UL<<5, // Low-power timer 2 reset
	RCC_APB1RSTR2_SWPMI1RST = 1UL<<2, // Single wire protocol reset
	RCC_APB1RSTR2_I2C4RST = 1UL<<1, // I2C4 reset
	RCC_APB1RSTR2_LPUART1RST = 1UL<<0, // Low-power UART 1 reset		
};

// RCC->APB2RSTR APB2 peripheral reset register
enum {
	RCC_APB2RSTR_DFSDMRST = 1UL<<24, // DFSDM filter reset
	RCC_APB2RSTR_SAI1RST = 1UL<<21, // Serial audio interface 1 (SAI1) reset
	RCC_APB2RSTR_TIM16RST = 1UL<<17, // TIM16 timer reset
	RCC_APB2RSTR_TIM15RST = 1UL<<16, // TIM15 timer reset
	RCC_APB2RSTR_USART1RST = 1UL<<14, // USART1 reset
	RCC_APB2RSTR_SPI1RST = 1UL<<12, // SPI1 reset
	RCC_APB2RSTR_TIM1RST = 1UL<<11, // TIM1 timer reset
	RCC_APB2RSTR_SDMMCRST = 1UL<<10, // SDMMC reset
	RCC_APB2RSTR_SYSCFGRST = 1UL<<0, // System configuration (SYSCFG) reset		
};

// RCC->AHB1ENR AHB1 peripheral clock enable register
enum {
	RCC_AHB1ENR_TSCEN = 1UL<<16, // Touch Sensing Controller clock enable
	RCC_AHB1ENR_CRCEN = 1UL<<12, // CRC clock enable
	RCC_AHB1ENR_FLASHEN = 1UL<<8, // Flash memory interface clock enable
	RCC_AHB1ENR_DMA2EN = 1UL<<1, // DMA2 clock enable
	RCC_AHB1ENR_DMA1EN = 1UL<<0, // DMA1 clock enable		
};

// RCC->AHB2ENR AHB2 peripheral clock enable register
enum {
	RCC_AHB2ENR_RNGEN = 1UL<<18, // Random Number Generator clock enable
	RCC_AHB2ENR_AESEN = 1UL<<16, // AES accelerator clock enable
	RCC_AHB2ENR_ADCEN = 1UL<<13, // ADC clock enable
	RCC_AHB2ENR_GPIOHEN = 1UL<<7, // IO port H clock enable
	RCC_AHB2ENR_GPIOEEN = 1UL<<4, // IO port E clock enable
	RCC_AHB2ENR_GPIODEN = 1UL<<3, // IO port D clock enable
	RCC_AHB2ENR_GPIOCEN = 1UL<<2, // IO port C clock enable
	RCC_AHB2ENR_GPIOBEN = 1UL<<1, // IO port B clock enable
	RCC_AHB2ENR_GPIOAEN = 1UL<<0, // IO port A clock enable		
};

// RCC->AHB3ENR AHB3 peripheral clock enable register
enum {
	RCC_AHB3ENR_QSPIEN = 1UL<<8, // QSPIEN		
};

// RCC->APB1ENR1 APB1ENR1
enum {
	RCC_APB1ENR1_LPTIM1EN = 1UL<<31, // Low power timer 1 clock enable
	RCC_APB1ENR1_OPAMPEN = 1UL<<30, // OPAMP interface clock enable
	RCC_APB1ENR1_DAC1EN = 1UL<<29, // DAC1 interface clock enable
	RCC_APB1ENR1_PWREN = 1UL<<28, // Power interface clock enable
	RCC_APB1ENR1_USBF = 1UL<<26, // USB FS clock enable
	RCC_APB1ENR1_CAN1EN = 1UL<<25, // CAN1 clock enable
	RCC_APB1ENR1_CRSEN = 1UL<<24, // CRS clock enable
	RCC_APB1ENR1_I2C3EN = 1UL<<23, // I2C3 clock enable
	RCC_APB1ENR1_I2C2EN = 1UL<<22, // I2C2 clock enable
	RCC_APB1ENR1_I2C1EN = 1UL<<21, // I2C1 clock enable
	RCC_APB1ENR1_UART4EN = 1UL<<19, // UART4 clock enable
	RCC_APB1ENR1_USART3EN = 1UL<<18, // USART3 clock enable
	RCC_APB1ENR1_USART2EN = 1UL<<17, // USART2 clock enable
	RCC_APB1ENR1_SPI3EN = 1UL<<15, // SPI3 clock enable
	RCC_APB1ENR1_SPI2EN = 1UL<<14, // SPI2 clock enable
	RCC_APB1ENR1_WWDGEN = 1UL<<11, // Window watchdog clock enable
	RCC_APB1ENR1_RTCAPBEN = 1UL<<10, // RTC APB clock enable
	RCC_APB1ENR1_LCDEN = 1UL<<9, // LCD clock enable
	RCC_APB1ENR1_TIM7EN = 1UL<<5, // TIM7 timer clock enable
	RCC_APB1ENR1_TIM6EN = 1UL<<4, // TIM6 timer clock enable
	RCC_APB1ENR1_TIM3EN = 1UL<<1, // TIM3 timer clock enable
	RCC_APB1ENR1_TIM2EN = 1UL<<0, // TIM2 timer clock enable		
};

// RCC->APB1ENR2 APB1 peripheral clock enable register 2
enum {
	RCC_APB1ENR2_DFSDMEN = 1UL<<24, // DFSDMEN enable
	RCC_APB1ENR2_LPTIM2EN = 1UL<<5, // LPTIM2EN
	RCC_APB1ENR2_SWPMI1EN = 1UL<<2, // Single wire protocol clock enable
	RCC_APB1ENR2_I2C4EN = 1UL<<1, // I2C4 clock enable
	RCC_APB1ENR2_LPUART1EN = 1UL<<0, // Low power UART 1 clock enable		
};

// RCC->APB2ENR APB2ENR
enum {
	RCC_APB2ENR_SAI1EN = 1UL<<21, // SAI1 clock enable
	RCC_APB2ENR_TIM16EN = 1UL<<17, // TIM16 timer clock enable
	RCC_APB2ENR_TIM15EN = 1UL<<16, // TIM15 timer clock enable
	RCC_APB2ENR_USART1EN = 1UL<<14, // USART1clock enable
	RCC_APB2ENR_SPI1EN = 1UL<<12, // SPI1 clock enable
	RCC_APB2ENR_TIM1EN = 1UL<<11, // TIM1 timer clock enable
	RCC_APB2ENR_SDMMCEN = 1UL<<10, // SDMMC clock enable
	RCC_APB2ENR_FIREWALLEN = 1UL<<7, // Firewall clock enable
	RCC_APB2ENR_SYSCFGEN = 1UL<<0, // SYSCFG clock enable		
};

// RCC->AHB1SMENR AHB1 peripheral clocks enable in Sleep and Stop modes register
enum {
	RCC_AHB1SMENR_TSCSMEN = 1UL<<16, // Touch Sensing Controller clocks enable during Sleep and Stop modes
	RCC_AHB1SMENR_CRCSMEN = 1UL<<12, // CRCSMEN
	RCC_AHB1SMENR_SRAM1SMEN = 1UL<<9, // SRAM1 interface clocks enable during Sleep and Stop modes
	RCC_AHB1SMENR_FLASHSMEN = 1UL<<8, // Flash memory interface clocks enable during Sleep and Stop modes
	RCC_AHB1SMENR_DMA2SMEN = 1UL<<1, // DMA2 clocks enable during Sleep and Stop modes
	RCC_AHB1SMENR_DMA1SMEN = 1UL<<0, // DMA1 clocks enable during Sleep and Stop modes		
};

// RCC->AHB2SMENR AHB2 peripheral clocks enable in Sleep and Stop modes register
enum {
	RCC_AHB2SMENR_RNGSMEN = 1UL<<18, // Random Number Generator clocks enable during Sleep and Stop modes
	RCC_AHB2SMENR_AESSMEN = 1UL<<16, // AES accelerator clocks enable during Sleep and Stop modes
	RCC_AHB2SMENR_ADCFSSMEN = 1UL<<13, // ADC clocks enable during Sleep and Stop modes
	RCC_AHB2SMENR_SRAM2SMEN = 1UL<<9, // SRAM2 interface clocks enable during Sleep and Stop modes
	RCC_AHB2SMENR_GPIOHSMEN = 1UL<<7, // IO port H clocks enable during Sleep and Stop modes
	RCC_AHB2SMENR_GPIOESMEN = 1UL<<4, // IO port E clocks enable during Sleep and Stop modes
	RCC_AHB2SMENR_GPIODSMEN = 1UL<<3, // IO port D clocks enable during Sleep and Stop modes
	RCC_AHB2SMENR_GPIOCSMEN = 1UL<<2, // IO port C clocks enable during Sleep and Stop modes
	RCC_AHB2SMENR_GPIOBSMEN = 1UL<<1, // IO port B clocks enable during Sleep and Stop modes
	RCC_AHB2SMENR_GPIOASMEN = 1UL<<0, // IO port A clocks enable during Sleep and Stop modes		
};

// RCC->AHB3SMENR AHB3 peripheral clocks enable in Sleep and Stop modes register
enum {
	RCC_AHB3SMENR_QSPISMEN = 1UL<<8, // QSPISMEN		
};

// RCC->APB1SMENR1 APB1SMENR1
enum {
	RCC_APB1SMENR1_LPTIM1SMEN = 1UL<<31, // Low power timer 1 clocks enable during Sleep and Stop modes
	RCC_APB1SMENR1_OPAMPSMEN = 1UL<<30, // OPAMP interface clocks enable during Sleep and Stop modes
	RCC_APB1SMENR1_DAC1SMEN = 1UL<<29, // DAC1 interface clocks enable during Sleep and Stop modes
	RCC_APB1SMENR1_PWRSMEN = 1UL<<28, // Power interface clocks enable during Sleep and Stop modes
	RCC_APB1SMENR1_USBFSSMEN = 1UL<<26, // USB FS clock enable during Sleep and Stop modes
	RCC_APB1SMENR1_CAN1SMEN = 1UL<<25, // CAN1 clocks enable during Sleep and Stop modes
	RCC_APB1SMENR1_CRSSMEN = 1UL<<24, // CRS clock enable during Sleep and Stop modes
	RCC_APB1SMENR1_I2C3SMEN = 1UL<<23, // I2C3 clocks enable during Sleep and Stop modes
	RCC_APB1SMENR1_I2C2SMEN = 1UL<<22, // I2C2 clocks enable during Sleep and Stop modes
	RCC_APB1SMENR1_I2C1SMEN = 1UL<<21, // I2C1 clocks enable during Sleep and Stop modes
	RCC_APB1SMENR1_USART2SMEN = 1UL<<18, // USART2 clocks enable during Sleep and Stop modes
	RCC_APB1SMENR1_USART1SMEN = 1UL<<17, // USART1 clocks enable during Sleep and Stop modes
	RCC_APB1SMENR1_SPI3SMEN = 1UL<<15, // SPI3 clocks enable during Sleep and Stop modes
	RCC_APB1SMENR1_SPI2SMEN = 1UL<<14, // SPI2 clocks enable during Sleep and Stop modes
	RCC_APB1SMENR1_WWDGSMEN = 1UL<<11, // Window watchdog clocks enable during Sleep and Stop modes
	RCC_APB1SMENR1_RTCAPBSMEN = 1UL<<10, // RTC APB clock enable during Sleep and Stop modes
	RCC_APB1SMENR1_LCDSMEN = 1UL<<9, // LCD clocks enable during Sleep and Stop modes
	RCC_APB1SMENR1_TIM7SMEN = 1UL<<5, // TIM7 timer clocks enable during Sleep and Stop modes
	RCC_APB1SMENR1_TIM6SMEN = 1UL<<4, // TIM6 timer clocks enable during Sleep and Stop modes
	RCC_APB1SMENR1_TIM2SMEN = 1UL<<0, // TIM2 timer clocks enable during Sleep and Stop modes		
};

// RCC->APB1SMENR2 APB1 peripheral clocks enable in Sleep and Stop modes register 2
enum {
	RCC_APB1SMENR2_LPTIM2SMEN = 1UL<<5, // LPTIM2SMEN
	RCC_APB1SMENR2_SWPMI1SMEN = 1UL<<2, // Single wire protocol clocks enable during Sleep and Stop modes
	RCC_APB1SMENR2_LPUART1SMEN = 1UL<<0, // Low power UART 1 clocks enable during Sleep and Stop modes		
};

// RCC->APB2SMENR APB2SMENR
enum {
	RCC_APB2SMENR_SAI1SMEN = 1UL<<21, // SAI1 clocks enable during Sleep and Stop modes
	RCC_APB2SMENR_TIM16SMEN = 1UL<<17, // TIM16 timer clocks enable during Sleep and Stop modes
	RCC_APB2SMENR_TIM15SMEN = 1UL<<16, // TIM15 timer clocks enable during Sleep and Stop modes
	RCC_APB2SMENR_USART1SMEN = 1UL<<14, // USART1clocks enable during Sleep and Stop modes
	RCC_APB2SMENR_SPI1SMEN = 1UL<<12, // SPI1 clocks enable during Sleep and Stop modes
	RCC_APB2SMENR_TIM1SMEN = 1UL<<11, // TIM1 timer clocks enable during Sleep and Stop modes
	RCC_APB2SMENR_SDMMCSMEN = 1UL<<10, // SDMMC clocks enable during Sleep and Stop modes
	RCC_APB2SMENR_SYSCFGSMEN = 1UL<<0, // SYSCFG clocks enable during Sleep and Stop modes		
};

// RCC->CCIPR CCIPR
enum {
	RCC_CCIPR_SWPMI1SEL = 1UL<<30, // SWPMI1 clock source selection
	RCC_CCIPR_ADCSEL = ((1UL<<2)-1) << 28, // ADCs clock source selection
	RCC_CCIPR_CLK48SEL = ((1UL<<2)-1) << 26, // 48 MHz clock source selection
	RCC_CCIPR_SAI1SEL = ((1UL<<2)-1) << 22, // SAI1 clock source selection
	RCC_CCIPR_LPTIM2SEL = ((1UL<<2)-1) << 20, // Low power timer 2 clock source selection
	RCC_CCIPR_LPTIM1SEL = ((1UL<<2)-1) << 18, // Low power timer 1 clock source selection
	RCC_CCIPR_I2C3SEL = ((1UL<<2)-1) << 16, // I2C3 clock source selection
	RCC_CCIPR_I2C2SEL = ((1UL<<2)-1) << 14, // I2C2 clock source selection
	RCC_CCIPR_I2C1SEL = ((1UL<<2)-1) << 12, // I2C1 clock source selection
	RCC_CCIPR_LPUART1SEL = ((1UL<<2)-1) << 10, // LPUART1 clock source selection
	RCC_CCIPR_USART4SEL = ((1UL<<2)-1) << 6, // USART4 clock source selection
	RCC_CCIPR_USART3SEL = ((1UL<<2)-1) << 4, // USART3 clock source selection
	RCC_CCIPR_USART2SEL = ((1UL<<2)-1) << 2, // USART2 clock source selection
	RCC_CCIPR_USART1SEL = ((1UL<<2)-1) << 0, // USART1 clock source selection		
};
static inline void rcc_ccipr_set_adcsel(uint32_t val) { RCC.CCIPR = (RCC.CCIPR & ~RCC_CCIPR_ADCSEL) | ((val<<28) & RCC_CCIPR_ADCSEL); }
static inline void rcc_ccipr_set_clk48sel(uint32_t val) { RCC.CCIPR = (RCC.CCIPR & ~RCC_CCIPR_CLK48SEL) | ((val<<26) & RCC_CCIPR_CLK48SEL); }
static inline void rcc_ccipr_set_sai1sel(uint32_t val) { RCC.CCIPR = (RCC.CCIPR & ~RCC_CCIPR_SAI1SEL) | ((val<<22) & RCC_CCIPR_SAI1SEL); }
static inline void rcc_ccipr_set_lptim2sel(uint32_t val) { RCC.CCIPR = (RCC.CCIPR & ~RCC_CCIPR_LPTIM2SEL) | ((val<<20) & RCC_CCIPR_LPTIM2SEL); }
static inline void rcc_ccipr_set_lptim1sel(uint32_t val) { RCC.CCIPR = (RCC.CCIPR & ~RCC_CCIPR_LPTIM1SEL) | ((val<<18) & RCC_CCIPR_LPTIM1SEL); }
static inline void rcc_ccipr_set_i2c3sel(uint32_t val) { RCC.CCIPR = (RCC.CCIPR & ~RCC_CCIPR_I2C3SEL) | ((val<<16) & RCC_CCIPR_I2C3SEL); }
static inline void rcc_ccipr_set_i2c2sel(uint32_t val) { RCC.CCIPR = (RCC.CCIPR & ~RCC_CCIPR_I2C2SEL) | ((val<<14) & RCC_CCIPR_I2C2SEL); }
static inline void rcc_ccipr_set_i2c1sel(uint32_t val) { RCC.CCIPR = (RCC.CCIPR & ~RCC_CCIPR_I2C1SEL) | ((val<<12) & RCC_CCIPR_I2C1SEL); }
static inline void rcc_ccipr_set_lpuart1sel(uint32_t val) { RCC.CCIPR = (RCC.CCIPR & ~RCC_CCIPR_LPUART1SEL) | ((val<<10) & RCC_CCIPR_LPUART1SEL); }
static inline void rcc_ccipr_set_usart4sel(uint32_t val) { RCC.CCIPR = (RCC.CCIPR & ~RCC_CCIPR_USART4SEL) | ((val<<6) & RCC_CCIPR_USART4SEL); }
static inline void rcc_ccipr_set_usart3sel(uint32_t val) { RCC.CCIPR = (RCC.CCIPR & ~RCC_CCIPR_USART3SEL) | ((val<<4) & RCC_CCIPR_USART3SEL); }
static inline void rcc_ccipr_set_usart2sel(uint32_t val) { RCC.CCIPR = (RCC.CCIPR & ~RCC_CCIPR_USART2SEL) | ((val<<2) & RCC_CCIPR_USART2SEL); }
static inline void rcc_ccipr_set_usart1sel(uint32_t val) { RCC.CCIPR = (RCC.CCIPR & ~RCC_CCIPR_USART1SEL) | ((val<<0) & RCC_CCIPR_USART1SEL); }
static inline uint32_t rcc_ccipr_get_adcsel(void) { return (RCC.CCIPR & RCC_CCIPR_ADCSEL) >> 28 ; }
static inline uint32_t rcc_ccipr_get_clk48sel(void) { return (RCC.CCIPR & RCC_CCIPR_CLK48SEL) >> 26 ; }
static inline uint32_t rcc_ccipr_get_sai1sel(void) { return (RCC.CCIPR & RCC_CCIPR_SAI1SEL) >> 22 ; }
static inline uint32_t rcc_ccipr_get_lptim2sel(void) { return (RCC.CCIPR & RCC_CCIPR_LPTIM2SEL) >> 20 ; }
static inline uint32_t rcc_ccipr_get_lptim1sel(void) { return (RCC.CCIPR & RCC_CCIPR_LPTIM1SEL) >> 18 ; }
static inline uint32_t rcc_ccipr_get_i2c3sel(void) { return (RCC.CCIPR & RCC_CCIPR_I2C3SEL) >> 16 ; }
static inline uint32_t rcc_ccipr_get_i2c2sel(void) { return (RCC.CCIPR & RCC_CCIPR_I2C2SEL) >> 14 ; }
static inline uint32_t rcc_ccipr_get_i2c1sel(void) { return (RCC.CCIPR & RCC_CCIPR_I2C1SEL) >> 12 ; }
static inline uint32_t rcc_ccipr_get_lpuart1sel(void) { return (RCC.CCIPR & RCC_CCIPR_LPUART1SEL) >> 10 ; }
static inline uint32_t rcc_ccipr_get_usart4sel(void) { return (RCC.CCIPR & RCC_CCIPR_USART4SEL) >> 6 ; }
static inline uint32_t rcc_ccipr_get_usart3sel(void) { return (RCC.CCIPR & RCC_CCIPR_USART3SEL) >> 4 ; }
static inline uint32_t rcc_ccipr_get_usart2sel(void) { return (RCC.CCIPR & RCC_CCIPR_USART2SEL) >> 2 ; }
static inline uint32_t rcc_ccipr_get_usart1sel(void) { return (RCC.CCIPR & RCC_CCIPR_USART1SEL) >> 0 ; }

// RCC->BDCR BDCR
enum {
	RCC_BDCR_LSCOSEL = 1UL<<25, // Low speed clock output selection
	RCC_BDCR_LSCOEN = 1UL<<24, // Low speed clock output enable
	RCC_BDCR_BDRST = 1UL<<16, // Backup domain software reset
	RCC_BDCR_RTCEN = 1UL<<15, // RTC clock enable
	RCC_BDCR_RTCSEL = ((1UL<<2)-1) << 8, // RTC clock source selection
	RCC_BDCR_LSECSSD = 1UL<<6, // LSECSSD
	RCC_BDCR_LSECSSON = 1UL<<5, // LSECSSON
	RCC_BDCR_LSEDRV = ((1UL<<2)-1) << 3, // SE oscillator drive capability
	RCC_BDCR_LSEBYP = 1UL<<2, // LSE oscillator bypass
	RCC_BDCR_LSERDY = 1UL<<1, // LSE oscillator ready
	RCC_BDCR_LSEON = 1UL<<0, // LSE oscillator enable		
};
static inline void rcc_bdcr_set_rtcsel(uint32_t val) { RCC.BDCR = (RCC.BDCR & ~RCC_BDCR_RTCSEL) | ((val<<8) & RCC_BDCR_RTCSEL); }
static inline void rcc_bdcr_set_lsedrv(uint32_t val) { RCC.BDCR = (RCC.BDCR & ~RCC_BDCR_LSEDRV) | ((val<<3) & RCC_BDCR_LSEDRV); }
static inline uint32_t rcc_bdcr_get_rtcsel(void) { return (RCC.BDCR & RCC_BDCR_RTCSEL) >> 8 ; }
static inline uint32_t rcc_bdcr_get_lsedrv(void) { return (RCC.BDCR & RCC_BDCR_LSEDRV) >> 3 ; }

// RCC->CSR CSR
enum {
	RCC_CSR_LPWRSTF = 1UL<<31, // Low-power reset flag
	RCC_CSR_WWDGRSTF = 1UL<<30, // Window watchdog reset flag
	RCC_CSR_IWDGRSTF = 1UL<<29, // Independent window watchdog reset flag
	RCC_CSR_SFTRSTF = 1UL<<28, // Software reset flag
	RCC_CSR_BORRSTF = 1UL<<27, // BOR flag
	RCC_CSR_PINRSTF = 1UL<<26, // Pin reset flag
	RCC_CSR_OBLRSTF = 1UL<<25, // Option byte loader reset flag
	RCC_CSR_FIREWALLRSTF = 1UL<<24, // Firewall reset flag
	RCC_CSR_RMVF = 1UL<<23, // Remove reset flag
	RCC_CSR_MSISRANGE = ((1UL<<4)-1) << 8, // SI range after Standby mode
	RCC_CSR_LSIRDY = 1UL<<1, // LSI oscillator ready
	RCC_CSR_LSION = 1UL<<0, // LSI oscillator enable		
};
static inline void rcc_csr_set_msisrange(uint32_t val) { RCC.CSR = (RCC.CSR & ~RCC_CSR_MSISRANGE) | ((val<<8) & RCC_CSR_MSISRANGE); }
static inline uint32_t rcc_csr_get_msisrange(void) { return (RCC.CSR & RCC_CSR_MSISRANGE) >> 8 ; }

// RCC->CRRCR Clock recovery RC register
enum {
	RCC_CRRCR_HSI48CAL = ((1UL<<9)-1) << 7, // HSI48 clock calibration
	RCC_CRRCR_HSI48RDY = 1UL<<1, // HSI48 clock ready flag
	RCC_CRRCR_HSI48ON = 1UL<<0, // HSI48 clock enable		
};
static inline void rcc_crrcr_set_hsi48cal(uint32_t val) { RCC.CRRCR = (RCC.CRRCR & ~RCC_CRRCR_HSI48CAL) | ((val<<7) & RCC_CRRCR_HSI48CAL); }
static inline uint32_t rcc_crrcr_get_hsi48cal(void) { return (RCC.CRRCR & RCC_CRRCR_HSI48CAL) >> 7 ; }

/* Real-time clock
There is only one peripheral of type RTC. */
struct RTC_Type {
	__IO uint32_t TR; // @0 time register
	__IO uint32_t DR; // @4 date register
	__IO uint32_t CR; // @8 control register
	__IO uint32_t ISR; // @12 initialization and status register
	__IO uint32_t PRER; // @16 prescaler register
	__IO uint16_t WUTR; // @20 wakeup timer register
	 uint8_t RESERVED0[6]; // @22 
	__IO uint32_t ALRMAR; // @28 alarm A register
	__IO uint32_t ALRMBR; // @32 alarm B register
	__O uint8_t WPR; // @36 write protection register
	 uint8_t RESERVED1[3]; // @37 
	__I uint16_t SSR; // @40 sub second register
	 uint8_t RESERVED2[2]; // @42 
	__O uint32_t SHIFTR; // @44 shift control register
	__I uint32_t TSTR; // @48 time stamp time register
	__I uint16_t TSDR; // @52 time stamp date register
	 uint8_t RESERVED3[2]; // @54 
	__I uint16_t TSSSR; // @56 timestamp sub second register
	 uint8_t RESERVED4[2]; // @58 
	__IO uint16_t CALR; // @60 calibration register
	 uint8_t RESERVED5[2]; // @62 
	__IO uint32_t TAMPCR; // @64 tamper configuration register
	__IO uint32_t ALRMASSR; // @68 alarm A sub second register
	__IO uint32_t ALRMBSSR; // @72 alarm B sub second register
	__IO uint8_t OR; // @76 option register
	 uint8_t RESERVED6[3]; // @77 
	__IO uint32_t BKP0R; // @80 backup register
	__IO uint32_t BKP1R; // @84 backup register
	__IO uint32_t BKP2R; // @88 backup register
	__IO uint32_t BKP3R; // @92 backup register
	__IO uint32_t BKP4R; // @96 backup register
	__IO uint32_t BKP5R; // @100 backup register
	__IO uint32_t BKP6R; // @104 backup register
	__IO uint32_t BKP7R; // @108 backup register
	__IO uint32_t BKP8R; // @112 backup register
	__IO uint32_t BKP9R; // @116 backup register
	__IO uint32_t BKP10R; // @120 backup register
	__IO uint32_t BKP11R; // @124 backup register
	__IO uint32_t BKP12R; // @128 backup register
	__IO uint32_t BKP13R; // @132 backup register
	__IO uint32_t BKP14R; // @136 backup register
	__IO uint32_t BKP15R; // @140 backup register
	__IO uint32_t BKP16R; // @144 backup register
	__IO uint32_t BKP17R; // @148 backup register
	__IO uint32_t BKP18R; // @152 backup register
	__IO uint32_t BKP19R; // @156 backup register
	__IO uint32_t BKP20R; // @160 backup register
	__IO uint32_t BKP21R; // @164 backup register
	__IO uint32_t BKP22R; // @168 backup register
	__IO uint32_t BKP23R; // @172 backup register
	__IO uint32_t BKP24R; // @176 backup register
	__IO uint32_t BKP25R; // @180 backup register
	__IO uint32_t BKP26R; // @184 backup register
	__IO uint32_t BKP27R; // @188 backup register
	__IO uint32_t BKP28R; // @192 backup register
	__IO uint32_t BKP29R; // @196 backup register
	__IO uint32_t BKP30R; // @200 backup register
	__IO uint32_t BKP31R; // @204 backup register
};
extern struct RTC_Type	RTC;	// @0x40002800 

// RTC->TR time register
enum {
	RTC_TR_PM = 1UL<<22, // AM/PM notation
	RTC_TR_HT = ((1UL<<2)-1) << 20, // Hour tens in BCD format
	RTC_TR_HU = ((1UL<<4)-1) << 16, // Hour units in BCD format
	RTC_TR_MNT = ((1UL<<3)-1) << 12, // Minute tens in BCD format
	RTC_TR_MNU = ((1UL<<4)-1) << 8, // Minute units in BCD format
	RTC_TR_ST = ((1UL<<3)-1) << 4, // Second tens in BCD format
	RTC_TR_SU = ((1UL<<4)-1) << 0, // Second units in BCD format		
};
static inline void rtc_tr_set_ht(uint32_t val) { RTC.TR = (RTC.TR & ~RTC_TR_HT) | ((val<<20) & RTC_TR_HT); }
static inline void rtc_tr_set_hu(uint32_t val) { RTC.TR = (RTC.TR & ~RTC_TR_HU) | ((val<<16) & RTC_TR_HU); }
static inline void rtc_tr_set_mnt(uint32_t val) { RTC.TR = (RTC.TR & ~RTC_TR_MNT) | ((val<<12) & RTC_TR_MNT); }
static inline void rtc_tr_set_mnu(uint32_t val) { RTC.TR = (RTC.TR & ~RTC_TR_MNU) | ((val<<8) & RTC_TR_MNU); }
static inline void rtc_tr_set_st(uint32_t val) { RTC.TR = (RTC.TR & ~RTC_TR_ST) | ((val<<4) & RTC_TR_ST); }
static inline void rtc_tr_set_su(uint32_t val) { RTC.TR = (RTC.TR & ~RTC_TR_SU) | ((val<<0) & RTC_TR_SU); }
static inline uint32_t rtc_tr_get_ht(void) { return (RTC.TR & RTC_TR_HT) >> 20 ; }
static inline uint32_t rtc_tr_get_hu(void) { return (RTC.TR & RTC_TR_HU) >> 16 ; }
static inline uint32_t rtc_tr_get_mnt(void) { return (RTC.TR & RTC_TR_MNT) >> 12 ; }
static inline uint32_t rtc_tr_get_mnu(void) { return (RTC.TR & RTC_TR_MNU) >> 8 ; }
static inline uint32_t rtc_tr_get_st(void) { return (RTC.TR & RTC_TR_ST) >> 4 ; }
static inline uint32_t rtc_tr_get_su(void) { return (RTC.TR & RTC_TR_SU) >> 0 ; }

// RTC->DR date register
enum {
	RTC_DR_YT = ((1UL<<4)-1) << 20, // Year tens in BCD format
	RTC_DR_YU = ((1UL<<4)-1) << 16, // Year units in BCD format
	RTC_DR_WDU = ((1UL<<3)-1) << 13, // Week day units
	RTC_DR_MT = 1UL<<12, // Month tens in BCD format
	RTC_DR_MU = ((1UL<<4)-1) << 8, // Month units in BCD format
	RTC_DR_DT = ((1UL<<2)-1) << 4, // Date tens in BCD format
	RTC_DR_DU = ((1UL<<4)-1) << 0, // Date units in BCD format		
};
static inline void rtc_dr_set_yt(uint32_t val) { RTC.DR = (RTC.DR & ~RTC_DR_YT) | ((val<<20) & RTC_DR_YT); }
static inline void rtc_dr_set_yu(uint32_t val) { RTC.DR = (RTC.DR & ~RTC_DR_YU) | ((val<<16) & RTC_DR_YU); }
static inline void rtc_dr_set_wdu(uint32_t val) { RTC.DR = (RTC.DR & ~RTC_DR_WDU) | ((val<<13) & RTC_DR_WDU); }
static inline void rtc_dr_set_mu(uint32_t val) { RTC.DR = (RTC.DR & ~RTC_DR_MU) | ((val<<8) & RTC_DR_MU); }
static inline void rtc_dr_set_dt(uint32_t val) { RTC.DR = (RTC.DR & ~RTC_DR_DT) | ((val<<4) & RTC_DR_DT); }
static inline void rtc_dr_set_du(uint32_t val) { RTC.DR = (RTC.DR & ~RTC_DR_DU) | ((val<<0) & RTC_DR_DU); }
static inline uint32_t rtc_dr_get_yt(void) { return (RTC.DR & RTC_DR_YT) >> 20 ; }
static inline uint32_t rtc_dr_get_yu(void) { return (RTC.DR & RTC_DR_YU) >> 16 ; }
static inline uint32_t rtc_dr_get_wdu(void) { return (RTC.DR & RTC_DR_WDU) >> 13 ; }
static inline uint32_t rtc_dr_get_mu(void) { return (RTC.DR & RTC_DR_MU) >> 8 ; }
static inline uint32_t rtc_dr_get_dt(void) { return (RTC.DR & RTC_DR_DT) >> 4 ; }
static inline uint32_t rtc_dr_get_du(void) { return (RTC.DR & RTC_DR_DU) >> 0 ; }

// RTC->CR control register
enum {
	RTC_CR_ITSE = 1UL<<24, // timestamp on internal event enable
	RTC_CR_COE = 1UL<<23, // Calibration output enable
	RTC_CR_OSEL = ((1UL<<2)-1) << 21, // Output selection
	RTC_CR_POL = 1UL<<20, // Output polarity
	RTC_CR_COSEL = 1UL<<19, // Calibration output selection
	RTC_CR_BKP = 1UL<<18, // Backup
	RTC_CR_SUB1H = 1UL<<17, // Subtract 1 hour (winter time change)
	RTC_CR_ADD1H = 1UL<<16, // Add 1 hour (summer time change)
	RTC_CR_TSIE = 1UL<<15, // Time-stamp interrupt enable
	RTC_CR_WUTIE = 1UL<<14, // Wakeup timer interrupt enable
	RTC_CR_ALRBIE = 1UL<<13, // Alarm B interrupt enable
	RTC_CR_ALRAIE = 1UL<<12, // Alarm A interrupt enable
	RTC_CR_TSE = 1UL<<11, // Time stamp enable
	RTC_CR_WUTE = 1UL<<10, // Wakeup timer enable
	RTC_CR_ALRBE = 1UL<<9, // Alarm B enable
	RTC_CR_ALRAE = 1UL<<8, // Alarm A enable
	RTC_CR_FMT = 1UL<<6, // Hour format
	RTC_CR_BYPSHAD = 1UL<<5, // Bypass the shadow registers
	RTC_CR_REFCKON = 1UL<<4, // Reference clock detection enable (50 or 60 Hz)
	RTC_CR_TSEDGE = 1UL<<3, // Time-stamp event active edge
	RTC_CR_WCKSEL = ((1UL<<3)-1) << 0, // Wakeup clock selection		
};
static inline void rtc_cr_set_osel(uint32_t val) { RTC.CR = (RTC.CR & ~RTC_CR_OSEL) | ((val<<21) & RTC_CR_OSEL); }
static inline void rtc_cr_set_wcksel(uint32_t val) { RTC.CR = (RTC.CR & ~RTC_CR_WCKSEL) | ((val<<0) & RTC_CR_WCKSEL); }
static inline uint32_t rtc_cr_get_osel(void) { return (RTC.CR & RTC_CR_OSEL) >> 21 ; }
static inline uint32_t rtc_cr_get_wcksel(void) { return (RTC.CR & RTC_CR_WCKSEL) >> 0 ; }

// RTC->ISR initialization and status register
enum {
	RTC_ISR_RECALPF = 1UL<<16, // Recalibration pending Flag
	RTC_ISR_TAMP3F = 1UL<<15, // RTC_TAMP3 detection flag
	RTC_ISR_TAMP2F = 1UL<<14, // RTC_TAMP2 detection flag
	RTC_ISR_TAMP1F = 1UL<<13, // Tamper detection flag
	RTC_ISR_TSOVF = 1UL<<12, // Time-stamp overflow flag
	RTC_ISR_TSF = 1UL<<11, // Time-stamp flag
	RTC_ISR_WUTF = 1UL<<10, // Wakeup timer flag
	RTC_ISR_ALRBF = 1UL<<9, // Alarm B flag
	RTC_ISR_ALRAF = 1UL<<8, // Alarm A flag
	RTC_ISR_INIT = 1UL<<7, // Initialization mode
	RTC_ISR_INITF = 1UL<<6, // Initialization flag
	RTC_ISR_RSF = 1UL<<5, // Registers synchronization flag
	RTC_ISR_INITS = 1UL<<4, // Initialization status flag
	RTC_ISR_SHPF = 1UL<<3, // Shift operation pending
	RTC_ISR_WUTWF = 1UL<<2, // Wakeup timer write flag
	RTC_ISR_ALRBWF = 1UL<<1, // Alarm B write flag
	RTC_ISR_ALRAWF = 1UL<<0, // Alarm A write flag		
};

// RTC->PRER prescaler register
enum {
	RTC_PRER_PREDIV_A = ((1UL<<7)-1) << 16, // Asynchronous prescaler factor
	RTC_PRER_PREDIV_S = ((1UL<<15)-1) << 0, // Synchronous prescaler factor		
};
static inline void rtc_prer_set_prediv_a(uint32_t val) { RTC.PRER = (RTC.PRER & ~RTC_PRER_PREDIV_A) | ((val<<16) & RTC_PRER_PREDIV_A); }
static inline void rtc_prer_set_prediv_s(uint32_t val) { RTC.PRER = (RTC.PRER & ~RTC_PRER_PREDIV_S) | ((val<<0) & RTC_PRER_PREDIV_S); }
static inline uint32_t rtc_prer_get_prediv_a(void) { return (RTC.PRER & RTC_PRER_PREDIV_A) >> 16 ; }
static inline uint32_t rtc_prer_get_prediv_s(void) { return (RTC.PRER & RTC_PRER_PREDIV_S) >> 0 ; }

// RTC->ALRMAR alarm A register
enum {
	RTC_ALRMAR_MSK4 = 1UL<<31, // Alarm A date mask
	RTC_ALRMAR_WDSEL = 1UL<<30, // Week day selection
	RTC_ALRMAR_DT = ((1UL<<2)-1) << 28, // Date tens in BCD format
	RTC_ALRMAR_DU = ((1UL<<4)-1) << 24, // Date units or day in BCD format
	RTC_ALRMAR_MSK3 = 1UL<<23, // Alarm A hours mask
	RTC_ALRMAR_PM = 1UL<<22, // AM/PM notation
	RTC_ALRMAR_HT = ((1UL<<2)-1) << 20, // Hour tens in BCD format
	RTC_ALRMAR_HU = ((1UL<<4)-1) << 16, // Hour units in BCD format
	RTC_ALRMAR_MSK2 = 1UL<<15, // Alarm A minutes mask
	RTC_ALRMAR_MNT = ((1UL<<3)-1) << 12, // Minute tens in BCD format
	RTC_ALRMAR_MNU = ((1UL<<4)-1) << 8, // Minute units in BCD format
	RTC_ALRMAR_MSK1 = 1UL<<7, // Alarm A seconds mask
	RTC_ALRMAR_ST = ((1UL<<3)-1) << 4, // Second tens in BCD format
	RTC_ALRMAR_SU = ((1UL<<4)-1) << 0, // Second units in BCD format		
};
static inline void rtc_alrmar_set_dt(uint32_t val) { RTC.ALRMAR = (RTC.ALRMAR & ~RTC_ALRMAR_DT) | ((val<<28) & RTC_ALRMAR_DT); }
static inline void rtc_alrmar_set_du(uint32_t val) { RTC.ALRMAR = (RTC.ALRMAR & ~RTC_ALRMAR_DU) | ((val<<24) & RTC_ALRMAR_DU); }
static inline void rtc_alrmar_set_ht(uint32_t val) { RTC.ALRMAR = (RTC.ALRMAR & ~RTC_ALRMAR_HT) | ((val<<20) & RTC_ALRMAR_HT); }
static inline void rtc_alrmar_set_hu(uint32_t val) { RTC.ALRMAR = (RTC.ALRMAR & ~RTC_ALRMAR_HU) | ((val<<16) & RTC_ALRMAR_HU); }
static inline void rtc_alrmar_set_mnt(uint32_t val) { RTC.ALRMAR = (RTC.ALRMAR & ~RTC_ALRMAR_MNT) | ((val<<12) & RTC_ALRMAR_MNT); }
static inline void rtc_alrmar_set_mnu(uint32_t val) { RTC.ALRMAR = (RTC.ALRMAR & ~RTC_ALRMAR_MNU) | ((val<<8) & RTC_ALRMAR_MNU); }
static inline void rtc_alrmar_set_st(uint32_t val) { RTC.ALRMAR = (RTC.ALRMAR & ~RTC_ALRMAR_ST) | ((val<<4) & RTC_ALRMAR_ST); }
static inline void rtc_alrmar_set_su(uint32_t val) { RTC.ALRMAR = (RTC.ALRMAR & ~RTC_ALRMAR_SU) | ((val<<0) & RTC_ALRMAR_SU); }
static inline uint32_t rtc_alrmar_get_dt(void) { return (RTC.ALRMAR & RTC_ALRMAR_DT) >> 28 ; }
static inline uint32_t rtc_alrmar_get_du(void) { return (RTC.ALRMAR & RTC_ALRMAR_DU) >> 24 ; }
static inline uint32_t rtc_alrmar_get_ht(void) { return (RTC.ALRMAR & RTC_ALRMAR_HT) >> 20 ; }
static inline uint32_t rtc_alrmar_get_hu(void) { return (RTC.ALRMAR & RTC_ALRMAR_HU) >> 16 ; }
static inline uint32_t rtc_alrmar_get_mnt(void) { return (RTC.ALRMAR & RTC_ALRMAR_MNT) >> 12 ; }
static inline uint32_t rtc_alrmar_get_mnu(void) { return (RTC.ALRMAR & RTC_ALRMAR_MNU) >> 8 ; }
static inline uint32_t rtc_alrmar_get_st(void) { return (RTC.ALRMAR & RTC_ALRMAR_ST) >> 4 ; }
static inline uint32_t rtc_alrmar_get_su(void) { return (RTC.ALRMAR & RTC_ALRMAR_SU) >> 0 ; }

// RTC->ALRMBR alarm B register
enum {
	RTC_ALRMBR_MSK4 = 1UL<<31, // Alarm B date mask
	RTC_ALRMBR_WDSEL = 1UL<<30, // Week day selection
	RTC_ALRMBR_DT = ((1UL<<2)-1) << 28, // Date tens in BCD format
	RTC_ALRMBR_DU = ((1UL<<4)-1) << 24, // Date units or day in BCD format
	RTC_ALRMBR_MSK3 = 1UL<<23, // Alarm B hours mask
	RTC_ALRMBR_PM = 1UL<<22, // AM/PM notation
	RTC_ALRMBR_HT = ((1UL<<2)-1) << 20, // Hour tens in BCD format
	RTC_ALRMBR_HU = ((1UL<<4)-1) << 16, // Hour units in BCD format
	RTC_ALRMBR_MSK2 = 1UL<<15, // Alarm B minutes mask
	RTC_ALRMBR_MNT = ((1UL<<3)-1) << 12, // Minute tens in BCD format
	RTC_ALRMBR_MNU = ((1UL<<4)-1) << 8, // Minute units in BCD format
	RTC_ALRMBR_MSK1 = 1UL<<7, // Alarm B seconds mask
	RTC_ALRMBR_ST = ((1UL<<3)-1) << 4, // Second tens in BCD format
	RTC_ALRMBR_SU = ((1UL<<4)-1) << 0, // Second units in BCD format		
};
static inline void rtc_alrmbr_set_dt(uint32_t val) { RTC.ALRMBR = (RTC.ALRMBR & ~RTC_ALRMBR_DT) | ((val<<28) & RTC_ALRMBR_DT); }
static inline void rtc_alrmbr_set_du(uint32_t val) { RTC.ALRMBR = (RTC.ALRMBR & ~RTC_ALRMBR_DU) | ((val<<24) & RTC_ALRMBR_DU); }
static inline void rtc_alrmbr_set_ht(uint32_t val) { RTC.ALRMBR = (RTC.ALRMBR & ~RTC_ALRMBR_HT) | ((val<<20) & RTC_ALRMBR_HT); }
static inline void rtc_alrmbr_set_hu(uint32_t val) { RTC.ALRMBR = (RTC.ALRMBR & ~RTC_ALRMBR_HU) | ((val<<16) & RTC_ALRMBR_HU); }
static inline void rtc_alrmbr_set_mnt(uint32_t val) { RTC.ALRMBR = (RTC.ALRMBR & ~RTC_ALRMBR_MNT) | ((val<<12) & RTC_ALRMBR_MNT); }
static inline void rtc_alrmbr_set_mnu(uint32_t val) { RTC.ALRMBR = (RTC.ALRMBR & ~RTC_ALRMBR_MNU) | ((val<<8) & RTC_ALRMBR_MNU); }
static inline void rtc_alrmbr_set_st(uint32_t val) { RTC.ALRMBR = (RTC.ALRMBR & ~RTC_ALRMBR_ST) | ((val<<4) & RTC_ALRMBR_ST); }
static inline void rtc_alrmbr_set_su(uint32_t val) { RTC.ALRMBR = (RTC.ALRMBR & ~RTC_ALRMBR_SU) | ((val<<0) & RTC_ALRMBR_SU); }
static inline uint32_t rtc_alrmbr_get_dt(void) { return (RTC.ALRMBR & RTC_ALRMBR_DT) >> 28 ; }
static inline uint32_t rtc_alrmbr_get_du(void) { return (RTC.ALRMBR & RTC_ALRMBR_DU) >> 24 ; }
static inline uint32_t rtc_alrmbr_get_ht(void) { return (RTC.ALRMBR & RTC_ALRMBR_HT) >> 20 ; }
static inline uint32_t rtc_alrmbr_get_hu(void) { return (RTC.ALRMBR & RTC_ALRMBR_HU) >> 16 ; }
static inline uint32_t rtc_alrmbr_get_mnt(void) { return (RTC.ALRMBR & RTC_ALRMBR_MNT) >> 12 ; }
static inline uint32_t rtc_alrmbr_get_mnu(void) { return (RTC.ALRMBR & RTC_ALRMBR_MNU) >> 8 ; }
static inline uint32_t rtc_alrmbr_get_st(void) { return (RTC.ALRMBR & RTC_ALRMBR_ST) >> 4 ; }
static inline uint32_t rtc_alrmbr_get_su(void) { return (RTC.ALRMBR & RTC_ALRMBR_SU) >> 0 ; }

// RTC->SHIFTR shift control register
enum {
	RTC_SHIFTR_ADD1S = 1UL<<31, // Add one second
	RTC_SHIFTR_SUBFS = ((1UL<<15)-1) << 0, // Subtract a fraction of a second		
};
static inline void rtc_shiftr_set_subfs(uint32_t val) { RTC.SHIFTR = (RTC.SHIFTR & ~RTC_SHIFTR_SUBFS) | ((val<<0) & RTC_SHIFTR_SUBFS); }
static inline uint32_t rtc_shiftr_get_subfs(void) { return (RTC.SHIFTR & RTC_SHIFTR_SUBFS) >> 0 ; }

// RTC->TSTR time stamp time register
enum {
	RTC_TSTR_PM = 1UL<<22, // AM/PM notation
	RTC_TSTR_HT = ((1UL<<2)-1) << 20, // Hour tens in BCD format
	RTC_TSTR_HU = ((1UL<<4)-1) << 16, // Hour units in BCD format
	RTC_TSTR_MNT = ((1UL<<3)-1) << 12, // Minute tens in BCD format
	RTC_TSTR_MNU = ((1UL<<4)-1) << 8, // Minute units in BCD format
	RTC_TSTR_ST = ((1UL<<3)-1) << 4, // Second tens in BCD format
	RTC_TSTR_SU = ((1UL<<4)-1) << 0, // Second units in BCD format		
};
static inline uint32_t rtc_tstr_get_ht(void) { return (RTC.TSTR & RTC_TSTR_HT) >> 20 ; }
static inline uint32_t rtc_tstr_get_hu(void) { return (RTC.TSTR & RTC_TSTR_HU) >> 16 ; }
static inline uint32_t rtc_tstr_get_mnt(void) { return (RTC.TSTR & RTC_TSTR_MNT) >> 12 ; }
static inline uint32_t rtc_tstr_get_mnu(void) { return (RTC.TSTR & RTC_TSTR_MNU) >> 8 ; }
static inline uint32_t rtc_tstr_get_st(void) { return (RTC.TSTR & RTC_TSTR_ST) >> 4 ; }
static inline uint32_t rtc_tstr_get_su(void) { return (RTC.TSTR & RTC_TSTR_SU) >> 0 ; }

// RTC->TSDR time stamp date register
enum {
	RTC_TSDR_WDU = ((1UL<<3)-1) << 13, // Week day units
	RTC_TSDR_MT = 1UL<<12, // Month tens in BCD format
	RTC_TSDR_MU = ((1UL<<4)-1) << 8, // Month units in BCD format
	RTC_TSDR_DT = ((1UL<<2)-1) << 4, // Date tens in BCD format
	RTC_TSDR_DU = ((1UL<<4)-1) << 0, // Date units in BCD format		
};
static inline uint32_t rtc_tsdr_get_wdu(void) { return (RTC.TSDR & RTC_TSDR_WDU) >> 13 ; }
static inline uint32_t rtc_tsdr_get_mu(void) { return (RTC.TSDR & RTC_TSDR_MU) >> 8 ; }
static inline uint32_t rtc_tsdr_get_dt(void) { return (RTC.TSDR & RTC_TSDR_DT) >> 4 ; }
static inline uint32_t rtc_tsdr_get_du(void) { return (RTC.TSDR & RTC_TSDR_DU) >> 0 ; }

// RTC->CALR calibration register
enum {
	RTC_CALR_CALP = 1UL<<15, // Increase frequency of RTC by 488.5 ppm
	RTC_CALR_CALW8 = 1UL<<14, // Use an 8-second calibration cycle period
	RTC_CALR_CALW16 = 1UL<<13, // Use a 16-second calibration cycle period
	RTC_CALR_CALM = ((1UL<<9)-1) << 0, // Calibration minus		
};
static inline void rtc_calr_set_calm(uint32_t val) { RTC.CALR = (RTC.CALR & ~RTC_CALR_CALM) | ((val<<0) & RTC_CALR_CALM); }
static inline uint32_t rtc_calr_get_calm(void) { return (RTC.CALR & RTC_CALR_CALM) >> 0 ; }

// RTC->TAMPCR tamper configuration register
enum {
	RTC_TAMPCR_TAMP3MF = 1UL<<24, // Tamper 3 mask flag
	RTC_TAMPCR_TAMP3NOERASE = 1UL<<23, // Tamper 3 no erase
	RTC_TAMPCR_TAMP3IE = 1UL<<22, // Tamper 3 interrupt enable
	RTC_TAMPCR_TAMP2MF = 1UL<<21, // Tamper 2 mask flag
	RTC_TAMPCR_TAMP2NOERASE = 1UL<<20, // Tamper 2 no erase
	RTC_TAMPCR_TAMP2IE = 1UL<<19, // Tamper 2 interrupt enable
	RTC_TAMPCR_TAMP1MF = 1UL<<18, // Tamper 1 mask flag
	RTC_TAMPCR_TAMP1NOERASE = 1UL<<17, // Tamper 1 no erase
	RTC_TAMPCR_TAMP1IE = 1UL<<16, // Tamper 1 interrupt enable
	RTC_TAMPCR_TAMPPUDIS = 1UL<<15, // TAMPER pull-up disable
	RTC_TAMPCR_TAMPPRCH = ((1UL<<2)-1) << 13, // Tamper precharge duration
	RTC_TAMPCR_TAMPFLT = ((1UL<<2)-1) << 11, // Tamper filter count
	RTC_TAMPCR_TAMPFREQ = ((1UL<<3)-1) << 8, // Tamper sampling frequency
	RTC_TAMPCR_TAMPTS = 1UL<<7, // Activate timestamp on tamper detection event
	RTC_TAMPCR_TAMP3TRG = 1UL<<6, // Active level for tamper 3
	RTC_TAMPCR_TAMP3E = 1UL<<5, // Tamper 3 detection enable
	RTC_TAMPCR_TAMP2TRG = 1UL<<4, // Active level for tamper 2
	RTC_TAMPCR_TAMP2E = 1UL<<3, // Tamper 2 detection enable
	RTC_TAMPCR_TAMPIE = 1UL<<2, // Tamper interrupt enable
	RTC_TAMPCR_TAMP1TRG = 1UL<<1, // Active level for tamper 1
	RTC_TAMPCR_TAMP1E = 1UL<<0, // Tamper 1 detection enable		
};
static inline void rtc_tampcr_set_tampprch(uint32_t val) { RTC.TAMPCR = (RTC.TAMPCR & ~RTC_TAMPCR_TAMPPRCH) | ((val<<13) & RTC_TAMPCR_TAMPPRCH); }
static inline void rtc_tampcr_set_tampflt(uint32_t val) { RTC.TAMPCR = (RTC.TAMPCR & ~RTC_TAMPCR_TAMPFLT) | ((val<<11) & RTC_TAMPCR_TAMPFLT); }
static inline void rtc_tampcr_set_tampfreq(uint32_t val) { RTC.TAMPCR = (RTC.TAMPCR & ~RTC_TAMPCR_TAMPFREQ) | ((val<<8) & RTC_TAMPCR_TAMPFREQ); }
static inline uint32_t rtc_tampcr_get_tampprch(void) { return (RTC.TAMPCR & RTC_TAMPCR_TAMPPRCH) >> 13 ; }
static inline uint32_t rtc_tampcr_get_tampflt(void) { return (RTC.TAMPCR & RTC_TAMPCR_TAMPFLT) >> 11 ; }
static inline uint32_t rtc_tampcr_get_tampfreq(void) { return (RTC.TAMPCR & RTC_TAMPCR_TAMPFREQ) >> 8 ; }

// RTC->ALRMASSR alarm A sub second register
enum {
	RTC_ALRMASSR_MASKSS = ((1UL<<4)-1) << 24, // Mask the most-significant bits starting at this bit
	RTC_ALRMASSR_SS = ((1UL<<15)-1) << 0, // Sub seconds value		
};
static inline void rtc_alrmassr_set_maskss(uint32_t val) { RTC.ALRMASSR = (RTC.ALRMASSR & ~RTC_ALRMASSR_MASKSS) | ((val<<24) & RTC_ALRMASSR_MASKSS); }
static inline void rtc_alrmassr_set_ss(uint32_t val) { RTC.ALRMASSR = (RTC.ALRMASSR & ~RTC_ALRMASSR_SS) | ((val<<0) & RTC_ALRMASSR_SS); }
static inline uint32_t rtc_alrmassr_get_maskss(void) { return (RTC.ALRMASSR & RTC_ALRMASSR_MASKSS) >> 24 ; }
static inline uint32_t rtc_alrmassr_get_ss(void) { return (RTC.ALRMASSR & RTC_ALRMASSR_SS) >> 0 ; }

// RTC->ALRMBSSR alarm B sub second register
enum {
	RTC_ALRMBSSR_MASKSS = ((1UL<<4)-1) << 24, // Mask the most-significant bits starting at this bit
	RTC_ALRMBSSR_SS = ((1UL<<15)-1) << 0, // Sub seconds value		
};
static inline void rtc_alrmbssr_set_maskss(uint32_t val) { RTC.ALRMBSSR = (RTC.ALRMBSSR & ~RTC_ALRMBSSR_MASKSS) | ((val<<24) & RTC_ALRMBSSR_MASKSS); }
static inline void rtc_alrmbssr_set_ss(uint32_t val) { RTC.ALRMBSSR = (RTC.ALRMBSSR & ~RTC_ALRMBSSR_SS) | ((val<<0) & RTC_ALRMBSSR_SS); }
static inline uint32_t rtc_alrmbssr_get_maskss(void) { return (RTC.ALRMBSSR & RTC_ALRMBSSR_MASKSS) >> 24 ; }
static inline uint32_t rtc_alrmbssr_get_ss(void) { return (RTC.ALRMBSSR & RTC_ALRMBSSR_SS) >> 0 ; }

// RTC->OR option register
enum {
	RTC_OR_RTC_OUT_RMP = 1UL<<1, // RTC_OUT remap
	RTC_OR_RTC_ALARM_TYPE = 1UL<<0, // RTC_ALARM on PC13 output type		
};

/* System control block
There is only one peripheral of type SCB. */
struct SCB_Type {
	__I uint32_t CPUID; // @0 CPUID base register
	__IO uint32_t ICSR; // @4 Interrupt control and state register
	__IO uint32_t VTOR; // @8 Vector table offset register
	__IO uint32_t AIRCR; // @12 Application interrupt and reset control register
	__IO uint8_t SCR; // @16 System control register
	 uint8_t RESERVED0[3]; // @17 
	__IO uint16_t CCR; // @20 Configuration and control register
	 uint8_t RESERVED1[2]; // @22 
	__IO uint32_t SHPR1; // @24 System handler priority registers
	__IO uint32_t SHPR2; // @28 System handler priority registers
	__IO uint32_t SHPR3; // @32 System handler priority registers
	__IO uint32_t SHCSR; // @36 System handler control and state register
	__IO uint32_t CFSR_UFSR_BFSR_MMFSR; // @40 Configurable fault status register
	__IO uint32_t HFSR; // @44 Hard fault status register
	 uint8_t RESERVED2[4]; // @48 
	__IO uint32_t MMFAR; // @52 Memory management fault address register
	__IO uint32_t BFAR; // @56 Bus fault address register
	__IO uint32_t AFSR; // @60 Auxiliary fault status register
};
extern struct SCB_Type	SCB;	// @0xE000ED00 

// SCB->CPUID CPUID base register
enum {
	SCB_CPUID_IMPLEMENTER = ((1UL<<8)-1) << 24, // Implementer code
	SCB_CPUID_VARIANT = ((1UL<<4)-1) << 20, // Variant number
	SCB_CPUID_CONSTANT = ((1UL<<4)-1) << 16, // Reads as 0xF
	SCB_CPUID_PARTNO = ((1UL<<12)-1) << 4, // Part number of the processor
	SCB_CPUID_REVISION = ((1UL<<4)-1) << 0, // Revision number		
};
static inline uint32_t scb_cpuid_get_implementer(void) { return (SCB.CPUID & SCB_CPUID_IMPLEMENTER) >> 24 ; }
static inline uint32_t scb_cpuid_get_variant(void) { return (SCB.CPUID & SCB_CPUID_VARIANT) >> 20 ; }
static inline uint32_t scb_cpuid_get_constant(void) { return (SCB.CPUID & SCB_CPUID_CONSTANT) >> 16 ; }
static inline uint32_t scb_cpuid_get_partno(void) { return (SCB.CPUID & SCB_CPUID_PARTNO) >> 4 ; }
static inline uint32_t scb_cpuid_get_revision(void) { return (SCB.CPUID & SCB_CPUID_REVISION) >> 0 ; }

// SCB->ICSR Interrupt control and state register
enum {
	SCB_ICSR_NMIPENDSET = 1UL<<31, // NMI set-pending bit.
	SCB_ICSR_PENDSVSET = 1UL<<28, // PendSV set-pending bit
	SCB_ICSR_PENDSVCLR = 1UL<<27, // PendSV clear-pending bit
	SCB_ICSR_PENDSTSET = 1UL<<26, // SysTick exception set-pending bit
	SCB_ICSR_PENDSTCLR = 1UL<<25, // SysTick exception clear-pending bit
	SCB_ICSR_ISRPENDING = 1UL<<22, // Interrupt pending flag
	SCB_ICSR_VECTPENDING = ((1UL<<7)-1) << 12, // Pending vector
	SCB_ICSR_RETTOBASE = 1UL<<11, // Return to base level
	SCB_ICSR_VECTACTIVE = ((1UL<<9)-1) << 0, // Active vector		
};
static inline void scb_icsr_set_vectpending(uint32_t val) { SCB.ICSR = (SCB.ICSR & ~SCB_ICSR_VECTPENDING) | ((val<<12) & SCB_ICSR_VECTPENDING); }
static inline void scb_icsr_set_vectactive(uint32_t val) { SCB.ICSR = (SCB.ICSR & ~SCB_ICSR_VECTACTIVE) | ((val<<0) & SCB_ICSR_VECTACTIVE); }
static inline uint32_t scb_icsr_get_vectpending(void) { return (SCB.ICSR & SCB_ICSR_VECTPENDING) >> 12 ; }
static inline uint32_t scb_icsr_get_vectactive(void) { return (SCB.ICSR & SCB_ICSR_VECTACTIVE) >> 0 ; }

// SCB->VTOR Vector table offset register
enum {
	SCB_VTOR_TBLOFF = ((1UL<<21)-1) << 9, // Vector table base offset field		
};
static inline void scb_vtor_set_tbloff(uint32_t val) { SCB.VTOR = (SCB.VTOR & ~SCB_VTOR_TBLOFF) | ((val<<9) & SCB_VTOR_TBLOFF); }
static inline uint32_t scb_vtor_get_tbloff(void) { return (SCB.VTOR & SCB_VTOR_TBLOFF) >> 9 ; }

// SCB->AIRCR Application interrupt and reset control register
enum {
	SCB_AIRCR_VECTKEYSTAT = ((1UL<<16)-1) << 16, // Register key
	SCB_AIRCR_ENDIANESS = 1UL<<15, // ENDIANESS
	SCB_AIRCR_PRIGROUP = ((1UL<<3)-1) << 8, // PRIGROUP
	SCB_AIRCR_SYSRESETREQ = 1UL<<2, // SYSRESETREQ
	SCB_AIRCR_VECTCLRACTIVE = 1UL<<1, // VECTCLRACTIVE
	SCB_AIRCR_VECTRESET = 1UL<<0, // VECTRESET		
};
static inline void scb_aircr_set_vectkeystat(uint32_t val) { SCB.AIRCR = (SCB.AIRCR & ~SCB_AIRCR_VECTKEYSTAT) | ((val<<16) & SCB_AIRCR_VECTKEYSTAT); }
static inline void scb_aircr_set_prigroup(uint32_t val) { SCB.AIRCR = (SCB.AIRCR & ~SCB_AIRCR_PRIGROUP) | ((val<<8) & SCB_AIRCR_PRIGROUP); }
static inline uint32_t scb_aircr_get_vectkeystat(void) { return (SCB.AIRCR & SCB_AIRCR_VECTKEYSTAT) >> 16 ; }
static inline uint32_t scb_aircr_get_prigroup(void) { return (SCB.AIRCR & SCB_AIRCR_PRIGROUP) >> 8 ; }

// SCB->SCR System control register
enum {
	SCB_SCR_SEVEONPEND = 1UL<<4, // Send Event on Pending bit
	SCB_SCR_SLEEPDEEP = 1UL<<2, // SLEEPDEEP
	SCB_SCR_SLEEPONEXIT = 1UL<<1, // SLEEPONEXIT		
};

// SCB->CCR Configuration and control register
enum {
	SCB_CCR_STKALIGN = 1UL<<9, // STKALIGN
	SCB_CCR_BFHFNMIGN = 1UL<<8, // BFHFNMIGN
	SCB_CCR_DIV_0_TRP = 1UL<<4, // DIV_0_TRP
	SCB_CCR_UNALIGN__TRP = 1UL<<3, // UNALIGN_ TRP
	SCB_CCR_USERSETMPEND = 1UL<<1, // USERSETMPEND
	SCB_CCR_NONBASETHRDENA = 1UL<<0, // Configures how the processor enters Thread mode		
};

// SCB->SHPR1 System handler priority registers
enum {
	SCB_SHPR1_PRI_6 = ((1UL<<8)-1) << 16, // Priority of system handler 6
	SCB_SHPR1_PRI_5 = ((1UL<<8)-1) << 8, // Priority of system handler 5
	SCB_SHPR1_PRI_4 = ((1UL<<8)-1) << 0, // Priority of system handler 4		
};
static inline void scb_shpr1_set_pri_6(uint32_t val) { SCB.SHPR1 = (SCB.SHPR1 & ~SCB_SHPR1_PRI_6) | ((val<<16) & SCB_SHPR1_PRI_6); }
static inline void scb_shpr1_set_pri_5(uint32_t val) { SCB.SHPR1 = (SCB.SHPR1 & ~SCB_SHPR1_PRI_5) | ((val<<8) & SCB_SHPR1_PRI_5); }
static inline void scb_shpr1_set_pri_4(uint32_t val) { SCB.SHPR1 = (SCB.SHPR1 & ~SCB_SHPR1_PRI_4) | ((val<<0) & SCB_SHPR1_PRI_4); }
static inline uint32_t scb_shpr1_get_pri_6(void) { return (SCB.SHPR1 & SCB_SHPR1_PRI_6) >> 16 ; }
static inline uint32_t scb_shpr1_get_pri_5(void) { return (SCB.SHPR1 & SCB_SHPR1_PRI_5) >> 8 ; }
static inline uint32_t scb_shpr1_get_pri_4(void) { return (SCB.SHPR1 & SCB_SHPR1_PRI_4) >> 0 ; }

// SCB->SHPR2 System handler priority registers
enum {
	SCB_SHPR2_PRI_11 = ((1UL<<8)-1) << 24, // Priority of system handler 11		
};
static inline void scb_shpr2_set_pri_11(uint32_t val) { SCB.SHPR2 = (SCB.SHPR2 & ~SCB_SHPR2_PRI_11) | ((val<<24) & SCB_SHPR2_PRI_11); }
static inline uint32_t scb_shpr2_get_pri_11(void) { return (SCB.SHPR2 & SCB_SHPR2_PRI_11) >> 24 ; }

// SCB->SHPR3 System handler priority registers
enum {
	SCB_SHPR3_PRI_15 = ((1UL<<8)-1) << 24, // Priority of system handler 15
	SCB_SHPR3_PRI_14 = ((1UL<<8)-1) << 16, // Priority of system handler 14		
};
static inline void scb_shpr3_set_pri_15(uint32_t val) { SCB.SHPR3 = (SCB.SHPR3 & ~SCB_SHPR3_PRI_15) | ((val<<24) & SCB_SHPR3_PRI_15); }
static inline void scb_shpr3_set_pri_14(uint32_t val) { SCB.SHPR3 = (SCB.SHPR3 & ~SCB_SHPR3_PRI_14) | ((val<<16) & SCB_SHPR3_PRI_14); }
static inline uint32_t scb_shpr3_get_pri_15(void) { return (SCB.SHPR3 & SCB_SHPR3_PRI_15) >> 24 ; }
static inline uint32_t scb_shpr3_get_pri_14(void) { return (SCB.SHPR3 & SCB_SHPR3_PRI_14) >> 16 ; }

// SCB->SHCSR System handler control and state register
enum {
	SCB_SHCSR_USGFAULTENA = 1UL<<18, // Usage fault enable bit
	SCB_SHCSR_BUSFAULTENA = 1UL<<17, // Bus fault enable bit
	SCB_SHCSR_MEMFAULTENA = 1UL<<16, // Memory management fault enable bit
	SCB_SHCSR_SVCALLPENDED = 1UL<<15, // SVC call pending bit
	SCB_SHCSR_BUSFAULTPENDED = 1UL<<14, // Bus fault exception pending bit
	SCB_SHCSR_MEMFAULTPENDED = 1UL<<13, // Memory management fault exception pending bit
	SCB_SHCSR_USGFAULTPENDED = 1UL<<12, // Usage fault exception pending bit
	SCB_SHCSR_SYSTICKACT = 1UL<<11, // SysTick exception active bit
	SCB_SHCSR_PENDSVACT = 1UL<<10, // PendSV exception active bit
	SCB_SHCSR_MONITORACT = 1UL<<8, // Debug monitor active bit
	SCB_SHCSR_SVCALLACT = 1UL<<7, // SVC call active bit
	SCB_SHCSR_USGFAULTACT = 1UL<<3, // Usage fault exception active bit
	SCB_SHCSR_BUSFAULTACT = 1UL<<1, // Bus fault exception active bit
	SCB_SHCSR_MEMFAULTACT = 1UL<<0, // Memory management fault exception active bit		
};

// SCB->CFSR_UFSR_BFSR_MMFSR Configurable fault status register
enum {
	SCB_CFSR_UFSR_BFSR_MMFSR_DIVBYZERO = 1UL<<25, // Divide by zero usage fault
	SCB_CFSR_UFSR_BFSR_MMFSR_UNALIGNED = 1UL<<24, // Unaligned access usage fault
	SCB_CFSR_UFSR_BFSR_MMFSR_NOCP = 1UL<<19, // No coprocessor usage fault.
	SCB_CFSR_UFSR_BFSR_MMFSR_INVPC = 1UL<<18, // Invalid PC load usage fault
	SCB_CFSR_UFSR_BFSR_MMFSR_INVSTATE = 1UL<<17, // Invalid state usage fault
	SCB_CFSR_UFSR_BFSR_MMFSR_UNDEFINSTR = 1UL<<16, // Undefined instruction usage fault
	SCB_CFSR_UFSR_BFSR_MMFSR_BFARVALID = 1UL<<15, // Bus Fault Address Register (BFAR) valid flag
	SCB_CFSR_UFSR_BFSR_MMFSR_LSPERR = 1UL<<13, // Bus fault on floating-point lazy state preservation
	SCB_CFSR_UFSR_BFSR_MMFSR_STKERR = 1UL<<12, // Bus fault on stacking for exception entry
	SCB_CFSR_UFSR_BFSR_MMFSR_UNSTKERR = 1UL<<11, // Bus fault on unstacking for a return from exception
	SCB_CFSR_UFSR_BFSR_MMFSR_IMPRECISERR = 1UL<<10, // Imprecise data bus error
	SCB_CFSR_UFSR_BFSR_MMFSR_PRECISERR = 1UL<<9, // Precise data bus error
	SCB_CFSR_UFSR_BFSR_MMFSR_IBUSERR = 1UL<<8, // Instruction bus error
	SCB_CFSR_UFSR_BFSR_MMFSR_MMARVALID = 1UL<<7, // Memory Management Fault Address Register (MMAR) valid flag
	SCB_CFSR_UFSR_BFSR_MMFSR_MLSPERR = 1UL<<5, // MLSPERR
	SCB_CFSR_UFSR_BFSR_MMFSR_MSTKERR = 1UL<<4, // Memory manager fault on stacking for exception entry.
	SCB_CFSR_UFSR_BFSR_MMFSR_MUNSTKERR = 1UL<<3, // Memory manager fault on unstacking for a return from exception
	SCB_CFSR_UFSR_BFSR_MMFSR_IACCVIOL = 1UL<<1, // Instruction access violation flag		
};

// SCB->HFSR Hard fault status register
enum {
	SCB_HFSR_DEBUG_VT = 1UL<<31, // Reserved for Debug use
	SCB_HFSR_FORCED = 1UL<<30, // Forced hard fault
	SCB_HFSR_VECTTBL = 1UL<<1, // Vector table hard fault		
};

/* System control block ACTLR
There is only one peripheral of type SCB_ACTRL. */
struct SCB_ACTRL_Type {
	__IO uint16_t ACTRL; // @0 Auxiliary control register
};
extern struct SCB_ACTRL_Type	SCB_ACTRL;	// @0xE000E008 

// SCB_ACTRL->ACTRL Auxiliary control register
enum {
	SCB_ACTRL_ACTRL_DISOOFP = 1UL<<9, // DISOOFP
	SCB_ACTRL_ACTRL_DISFPCA = 1UL<<8, // DISFPCA
	SCB_ACTRL_ACTRL_DISFOLD = 1UL<<2, // DISFOLD
	SCB_ACTRL_ACTRL_DISDEFWBUF = 1UL<<1, // DISDEFWBUF
	SCB_ACTRL_ACTRL_DISMCYCINT = 1UL<<0, // DISMCYCINT		
};

/* Serial peripheral interface/Inter-IC sound */
struct SPI_Type {
	__IO uint16_t CR1; // @0 control register 1
	 uint8_t RESERVED0[2]; // @2 
	__IO uint16_t CR2; // @4 control register 2
	 uint8_t RESERVED1[2]; // @6 
	__IO uint16_t SR; // @8 status register
	 uint8_t RESERVED2[2]; // @10 
	__IO uint16_t DR; // @12 data register
	 uint8_t RESERVED3[2]; // @14 
	__IO uint16_t CRCPR; // @16 CRC polynomial register
	 uint8_t RESERVED4[2]; // @18 
	__I uint16_t RXCRCR; // @20 RX CRC register
	 uint8_t RESERVED5[2]; // @22 
	__I uint16_t TXCRCR; // @24 TX CRC register
};
extern struct SPI_Type	SPI1;	// @0x40013000 
extern struct SPI_Type 	SPI2;	// @0x40003800
extern struct SPI_Type 	SPI3;	// @0x40003C00

// SPI->CR1 control register 1
enum {
	SPI_CR1_BIDIMODE = 1UL<<15, // Bidirectional data mode enable
	SPI_CR1_BIDIOE = 1UL<<14, // Output enable in bidirectional mode
	SPI_CR1_CRCEN = 1UL<<13, // Hardware CRC calculation enable
	SPI_CR1_CRCNEXT = 1UL<<12, // CRC transfer next
	SPI_CR1_DFF = 1UL<<11, // Data frame format
	SPI_CR1_RXONLY = 1UL<<10, // Receive only
	SPI_CR1_SSM = 1UL<<9, // Software slave management
	SPI_CR1_SSI = 1UL<<8, // Internal slave select
	SPI_CR1_LSBFIRST = 1UL<<7, // Frame format
	SPI_CR1_SPE = 1UL<<6, // SPI enable
	SPI_CR1_BR = ((1UL<<3)-1) << 3, // Baud rate control
	SPI_CR1_MSTR = 1UL<<2, // Master selection
	SPI_CR1_CPOL = 1UL<<1, // Clock polarity
	SPI_CR1_CPHA = 1UL<<0, // Clock phase		
};
static inline void spi_cr1_set_br(struct SPI_Type* p, uint32_t val) { p->CR1 = (p->CR1 & ~SPI_CR1_BR) | ((val<<3) & SPI_CR1_BR); }
static inline uint32_t spi_cr1_get_br(struct SPI_Type* p) { return (p->CR1 & SPI_CR1_BR) >> 3 ; }

// SPI->CR2 control register 2
enum {
	SPI_CR2_LDMA_TX = 1UL<<14, // Last DMA transfer for transmission
	SPI_CR2_LDMA_RX = 1UL<<13, // Last DMA transfer for reception
	SPI_CR2_FRXTH = 1UL<<12, // FIFO reception threshold
	SPI_CR2_DS = ((1UL<<4)-1) << 8, // Data size
	SPI_CR2_TXEIE = 1UL<<7, // Tx buffer empty interrupt enable
	SPI_CR2_RXNEIE = 1UL<<6, // RX buffer not empty interrupt enable
	SPI_CR2_ERRIE = 1UL<<5, // Error interrupt enable
	SPI_CR2_FRF = 1UL<<4, // Frame format
	SPI_CR2_NSSP = 1UL<<3, // NSS pulse management
	SPI_CR2_SSOE = 1UL<<2, // SS output enable
	SPI_CR2_TXDMAEN = 1UL<<1, // Tx buffer DMA enable
	SPI_CR2_RXDMAEN = 1UL<<0, // Rx buffer DMA enable		
};
static inline void spi_cr2_set_ds(struct SPI_Type* p, uint32_t val) { p->CR2 = (p->CR2 & ~SPI_CR2_DS) | ((val<<8) & SPI_CR2_DS); }
static inline uint32_t spi_cr2_get_ds(struct SPI_Type* p) { return (p->CR2 & SPI_CR2_DS) >> 8 ; }

// SPI->SR status register
enum {
	SPI_SR_FTLVL = ((1UL<<2)-1) << 11, // FIFO transmission level
	SPI_SR_FRLVL = ((1UL<<2)-1) << 9, // FIFO reception level
	SPI_SR_TIFRFE = 1UL<<8, // TI frame format error
	SPI_SR_BSY = 1UL<<7, // Busy flag
	SPI_SR_OVR = 1UL<<6, // Overrun flag
	SPI_SR_MODF = 1UL<<5, // Mode fault
	SPI_SR_CRCERR = 1UL<<4, // CRC error flag
	SPI_SR_TXE = 1UL<<1, // Transmit buffer empty
	SPI_SR_RXNE = 1UL<<0, // Receive buffer not empty		
};
static inline void spi_sr_set_ftlvl(struct SPI_Type* p, uint32_t val) { p->SR = (p->SR & ~SPI_SR_FTLVL) | ((val<<11) & SPI_SR_FTLVL); }
static inline void spi_sr_set_frlvl(struct SPI_Type* p, uint32_t val) { p->SR = (p->SR & ~SPI_SR_FRLVL) | ((val<<9) & SPI_SR_FRLVL); }
static inline uint32_t spi_sr_get_ftlvl(struct SPI_Type* p) { return (p->SR & SPI_SR_FTLVL) >> 11 ; }
static inline uint32_t spi_sr_get_frlvl(struct SPI_Type* p) { return (p->SR & SPI_SR_FRLVL) >> 9 ; }



/* SysTick timer
There is only one peripheral of type STK. */
struct STK_Type {
	__IO uint32_t CTRL; // @0 SysTick control and status register
	__IO uint32_t LOAD; // @4 SysTick reload value register
	__IO uint32_t VAL; // @8 SysTick current value register
	__IO uint32_t CALIB; // @12 SysTick calibration value register
};
extern struct STK_Type	STK;	// @0xE000E010 

// STK->CTRL SysTick control and status register
enum {
	STK_CTRL_COUNTFLAG = 1UL<<16, // COUNTFLAG
	STK_CTRL_CLKSOURCE = 1UL<<2, // Clock source selection
	STK_CTRL_TICKINT = 1UL<<1, // SysTick exception request enable
	STK_CTRL_ENABLE = 1UL<<0, // Counter enable		
};

// STK->LOAD SysTick reload value register
enum {
	STK_LOAD_RELOAD = ((1UL<<24)-1) << 0, // RELOAD value		
};
static inline void stk_load_set_reload(uint32_t val) { STK.LOAD = (STK.LOAD & ~STK_LOAD_RELOAD) | ((val<<0) & STK_LOAD_RELOAD); }
static inline uint32_t stk_load_get_reload(void) { return (STK.LOAD & STK_LOAD_RELOAD) >> 0 ; }

// STK->VAL SysTick current value register
enum {
	STK_VAL_CURRENT = ((1UL<<24)-1) << 0, // Current counter value		
};
static inline void stk_val_set_current(uint32_t val) { STK.VAL = (STK.VAL & ~STK_VAL_CURRENT) | ((val<<0) & STK_VAL_CURRENT); }
static inline uint32_t stk_val_get_current(void) { return (STK.VAL & STK_VAL_CURRENT) >> 0 ; }

// STK->CALIB SysTick calibration value register
enum {
	STK_CALIB_NOREF = 1UL<<31, // NOREF flag. Reads as zero
	STK_CALIB_SKEW = 1UL<<30, // SKEW flag: Indicates whether the TENMS value is exact
	STK_CALIB_TENMS = ((1UL<<24)-1) << 0, // Calibration value		
};
static inline void stk_calib_set_tenms(uint32_t val) { STK.CALIB = (STK.CALIB & ~STK_CALIB_TENMS) | ((val<<0) & STK_CALIB_TENMS); }
static inline uint32_t stk_calib_get_tenms(void) { return (STK.CALIB & STK_CALIB_TENMS) >> 0 ; }

/* System configuration controller
There is only one peripheral of type SYSCFG. */
struct SYSCFG_Type {
	__IO uint16_t MEMRMP; // @0 memory remap register
	 uint8_t RESERVED0[2]; // @2 
	__IO uint32_t CFGR1; // @4 configuration register 1
	__IO uint16_t EXTICR1; // @8 external interrupt configuration register 1
	 uint8_t RESERVED1[2]; // @10 
	__IO uint16_t EXTICR2; // @12 external interrupt configuration register 2
	 uint8_t RESERVED2[2]; // @14 
	__IO uint16_t EXTICR3; // @16 external interrupt configuration register 3
	 uint8_t RESERVED3[2]; // @18 
	__IO uint16_t EXTICR4; // @20 external interrupt configuration register 4
	 uint8_t RESERVED4[2]; // @22 
	__IO uint8_t SCSR; // @24 SCSR
	 uint8_t RESERVED5[3]; // @25 
	__IO uint16_t CFGR2; // @28 CFGR2
	 uint8_t RESERVED6[2]; // @30 
	__O uint32_t SWPR; // @32 SWPR
	__O uint8_t SKR; // @36 SKR
};
extern struct SYSCFG_Type	SYSCFG;	// @0x40010000 

// SYSCFG->MEMRMP memory remap register
enum {
	SYSCFG_MEMRMP_FB_MODE = 1UL<<8, // Flash Bank mode selection
	SYSCFG_MEMRMP_QFS = 1UL<<3, // QUADSPI memory mapping swap
	SYSCFG_MEMRMP_MEM_MODE = ((1UL<<3)-1) << 0, // Memory mapping selection		
};
static inline void syscfg_memrmp_set_mem_mode(uint32_t val) { SYSCFG.MEMRMP = (SYSCFG.MEMRMP & ~SYSCFG_MEMRMP_MEM_MODE) | ((val<<0) & SYSCFG_MEMRMP_MEM_MODE); }
static inline uint32_t syscfg_memrmp_get_mem_mode(void) { return (SYSCFG.MEMRMP & SYSCFG_MEMRMP_MEM_MODE) >> 0 ; }

// SYSCFG->CFGR1 configuration register 1
enum {
	SYSCFG_CFGR1_FPU_IE = ((1UL<<6)-1) << 26, // Floating Point Unit interrupts enable bits
	SYSCFG_CFGR1_I2C3_FMP = 1UL<<22, // I2C3 Fast-mode Plus driving capability activation
	SYSCFG_CFGR1_I2C2_FMP = 1UL<<21, // I2C2 Fast-mode Plus driving capability activation
	SYSCFG_CFGR1_I2C1_FMP = 1UL<<20, // I2C1 Fast-mode Plus driving capability activation
	SYSCFG_CFGR1_I2C_PB9_FMP = 1UL<<19, // Fast-mode Plus (Fm+) driving capability activation on PB9
	SYSCFG_CFGR1_I2C_PB8_FMP = 1UL<<18, // Fast-mode Plus (Fm+) driving capability activation on PB8
	SYSCFG_CFGR1_I2C_PB7_FMP = 1UL<<17, // Fast-mode Plus (Fm+) driving capability activation on PB7
	SYSCFG_CFGR1_I2C_PB6_FMP = 1UL<<16, // Fast-mode Plus (Fm+) driving capability activation on PB6
	SYSCFG_CFGR1_BOOSTEN = 1UL<<8, // I/O analog switch voltage booster enable
	SYSCFG_CFGR1_FWDIS = 1UL<<0, // Firewall disable		
};
static inline void syscfg_cfgr1_set_fpu_ie(uint32_t val) { SYSCFG.CFGR1 = (SYSCFG.CFGR1 & ~SYSCFG_CFGR1_FPU_IE) | ((val<<26) & SYSCFG_CFGR1_FPU_IE); }
static inline uint32_t syscfg_cfgr1_get_fpu_ie(void) { return (SYSCFG.CFGR1 & SYSCFG_CFGR1_FPU_IE) >> 26 ; }

// SYSCFG->EXTICR1 external interrupt configuration register 1
enum {
	SYSCFG_EXTICR1_EXTI3 = ((1UL<<3)-1) << 12, // EXTI 3 configuration bits
	SYSCFG_EXTICR1_EXTI2 = ((1UL<<3)-1) << 8, // EXTI 2 configuration bits
	SYSCFG_EXTICR1_EXTI1 = ((1UL<<3)-1) << 4, // EXTI 1 configuration bits
	SYSCFG_EXTICR1_EXTI0 = ((1UL<<3)-1) << 0, // EXTI 0 configuration bits		
};
static inline void syscfg_exticr1_set_exti3(uint32_t val) { SYSCFG.EXTICR1 = (SYSCFG.EXTICR1 & ~SYSCFG_EXTICR1_EXTI3) | ((val<<12) & SYSCFG_EXTICR1_EXTI3); }
static inline void syscfg_exticr1_set_exti2(uint32_t val) { SYSCFG.EXTICR1 = (SYSCFG.EXTICR1 & ~SYSCFG_EXTICR1_EXTI2) | ((val<<8) & SYSCFG_EXTICR1_EXTI2); }
static inline void syscfg_exticr1_set_exti1(uint32_t val) { SYSCFG.EXTICR1 = (SYSCFG.EXTICR1 & ~SYSCFG_EXTICR1_EXTI1) | ((val<<4) & SYSCFG_EXTICR1_EXTI1); }
static inline void syscfg_exticr1_set_exti0(uint32_t val) { SYSCFG.EXTICR1 = (SYSCFG.EXTICR1 & ~SYSCFG_EXTICR1_EXTI0) | ((val<<0) & SYSCFG_EXTICR1_EXTI0); }
static inline uint32_t syscfg_exticr1_get_exti3(void) { return (SYSCFG.EXTICR1 & SYSCFG_EXTICR1_EXTI3) >> 12 ; }
static inline uint32_t syscfg_exticr1_get_exti2(void) { return (SYSCFG.EXTICR1 & SYSCFG_EXTICR1_EXTI2) >> 8 ; }
static inline uint32_t syscfg_exticr1_get_exti1(void) { return (SYSCFG.EXTICR1 & SYSCFG_EXTICR1_EXTI1) >> 4 ; }
static inline uint32_t syscfg_exticr1_get_exti0(void) { return (SYSCFG.EXTICR1 & SYSCFG_EXTICR1_EXTI0) >> 0 ; }

// SYSCFG->EXTICR2 external interrupt configuration register 2
enum {
	SYSCFG_EXTICR2_EXTI7 = ((1UL<<3)-1) << 12, // EXTI 7 configuration bits
	SYSCFG_EXTICR2_EXTI6 = ((1UL<<3)-1) << 8, // EXTI 6 configuration bits
	SYSCFG_EXTICR2_EXTI5 = ((1UL<<3)-1) << 4, // EXTI 5 configuration bits
	SYSCFG_EXTICR2_EXTI4 = ((1UL<<3)-1) << 0, // EXTI 4 configuration bits		
};
static inline void syscfg_exticr2_set_exti7(uint32_t val) { SYSCFG.EXTICR2 = (SYSCFG.EXTICR2 & ~SYSCFG_EXTICR2_EXTI7) | ((val<<12) & SYSCFG_EXTICR2_EXTI7); }
static inline void syscfg_exticr2_set_exti6(uint32_t val) { SYSCFG.EXTICR2 = (SYSCFG.EXTICR2 & ~SYSCFG_EXTICR2_EXTI6) | ((val<<8) & SYSCFG_EXTICR2_EXTI6); }
static inline void syscfg_exticr2_set_exti5(uint32_t val) { SYSCFG.EXTICR2 = (SYSCFG.EXTICR2 & ~SYSCFG_EXTICR2_EXTI5) | ((val<<4) & SYSCFG_EXTICR2_EXTI5); }
static inline void syscfg_exticr2_set_exti4(uint32_t val) { SYSCFG.EXTICR2 = (SYSCFG.EXTICR2 & ~SYSCFG_EXTICR2_EXTI4) | ((val<<0) & SYSCFG_EXTICR2_EXTI4); }
static inline uint32_t syscfg_exticr2_get_exti7(void) { return (SYSCFG.EXTICR2 & SYSCFG_EXTICR2_EXTI7) >> 12 ; }
static inline uint32_t syscfg_exticr2_get_exti6(void) { return (SYSCFG.EXTICR2 & SYSCFG_EXTICR2_EXTI6) >> 8 ; }
static inline uint32_t syscfg_exticr2_get_exti5(void) { return (SYSCFG.EXTICR2 & SYSCFG_EXTICR2_EXTI5) >> 4 ; }
static inline uint32_t syscfg_exticr2_get_exti4(void) { return (SYSCFG.EXTICR2 & SYSCFG_EXTICR2_EXTI4) >> 0 ; }

// SYSCFG->EXTICR3 external interrupt configuration register 3
enum {
	SYSCFG_EXTICR3_EXTI11 = ((1UL<<3)-1) << 12, // EXTI 11 configuration bits
	SYSCFG_EXTICR3_EXTI10 = ((1UL<<3)-1) << 8, // EXTI 10 configuration bits
	SYSCFG_EXTICR3_EXTI9 = ((1UL<<3)-1) << 4, // EXTI 9 configuration bits
	SYSCFG_EXTICR3_EXTI8 = ((1UL<<3)-1) << 0, // EXTI 8 configuration bits		
};
static inline void syscfg_exticr3_set_exti11(uint32_t val) { SYSCFG.EXTICR3 = (SYSCFG.EXTICR3 & ~SYSCFG_EXTICR3_EXTI11) | ((val<<12) & SYSCFG_EXTICR3_EXTI11); }
static inline void syscfg_exticr3_set_exti10(uint32_t val) { SYSCFG.EXTICR3 = (SYSCFG.EXTICR3 & ~SYSCFG_EXTICR3_EXTI10) | ((val<<8) & SYSCFG_EXTICR3_EXTI10); }
static inline void syscfg_exticr3_set_exti9(uint32_t val) { SYSCFG.EXTICR3 = (SYSCFG.EXTICR3 & ~SYSCFG_EXTICR3_EXTI9) | ((val<<4) & SYSCFG_EXTICR3_EXTI9); }
static inline void syscfg_exticr3_set_exti8(uint32_t val) { SYSCFG.EXTICR3 = (SYSCFG.EXTICR3 & ~SYSCFG_EXTICR3_EXTI8) | ((val<<0) & SYSCFG_EXTICR3_EXTI8); }
static inline uint32_t syscfg_exticr3_get_exti11(void) { return (SYSCFG.EXTICR3 & SYSCFG_EXTICR3_EXTI11) >> 12 ; }
static inline uint32_t syscfg_exticr3_get_exti10(void) { return (SYSCFG.EXTICR3 & SYSCFG_EXTICR3_EXTI10) >> 8 ; }
static inline uint32_t syscfg_exticr3_get_exti9(void) { return (SYSCFG.EXTICR3 & SYSCFG_EXTICR3_EXTI9) >> 4 ; }
static inline uint32_t syscfg_exticr3_get_exti8(void) { return (SYSCFG.EXTICR3 & SYSCFG_EXTICR3_EXTI8) >> 0 ; }

// SYSCFG->EXTICR4 external interrupt configuration register 4
enum {
	SYSCFG_EXTICR4_EXTI15 = ((1UL<<3)-1) << 12, // EXTI15 configuration bits
	SYSCFG_EXTICR4_EXTI14 = ((1UL<<3)-1) << 8, // EXTI14 configuration bits
	SYSCFG_EXTICR4_EXTI13 = ((1UL<<3)-1) << 4, // EXTI13 configuration bits
	SYSCFG_EXTICR4_EXTI12 = ((1UL<<3)-1) << 0, // EXTI12 configuration bits		
};
static inline void syscfg_exticr4_set_exti15(uint32_t val) { SYSCFG.EXTICR4 = (SYSCFG.EXTICR4 & ~SYSCFG_EXTICR4_EXTI15) | ((val<<12) & SYSCFG_EXTICR4_EXTI15); }
static inline void syscfg_exticr4_set_exti14(uint32_t val) { SYSCFG.EXTICR4 = (SYSCFG.EXTICR4 & ~SYSCFG_EXTICR4_EXTI14) | ((val<<8) & SYSCFG_EXTICR4_EXTI14); }
static inline void syscfg_exticr4_set_exti13(uint32_t val) { SYSCFG.EXTICR4 = (SYSCFG.EXTICR4 & ~SYSCFG_EXTICR4_EXTI13) | ((val<<4) & SYSCFG_EXTICR4_EXTI13); }
static inline void syscfg_exticr4_set_exti12(uint32_t val) { SYSCFG.EXTICR4 = (SYSCFG.EXTICR4 & ~SYSCFG_EXTICR4_EXTI12) | ((val<<0) & SYSCFG_EXTICR4_EXTI12); }
static inline uint32_t syscfg_exticr4_get_exti15(void) { return (SYSCFG.EXTICR4 & SYSCFG_EXTICR4_EXTI15) >> 12 ; }
static inline uint32_t syscfg_exticr4_get_exti14(void) { return (SYSCFG.EXTICR4 & SYSCFG_EXTICR4_EXTI14) >> 8 ; }
static inline uint32_t syscfg_exticr4_get_exti13(void) { return (SYSCFG.EXTICR4 & SYSCFG_EXTICR4_EXTI13) >> 4 ; }
static inline uint32_t syscfg_exticr4_get_exti12(void) { return (SYSCFG.EXTICR4 & SYSCFG_EXTICR4_EXTI12) >> 0 ; }

// SYSCFG->SCSR SCSR
enum {
	SYSCFG_SCSR_SRAM2BSY = 1UL<<1, // SRAM2 busy by erase operation
	SYSCFG_SCSR_SRAM2ER = 1UL<<0, // SRAM2 Erase		
};

// SYSCFG->CFGR2 CFGR2
enum {
	SYSCFG_CFGR2_SPF = 1UL<<8, // SRAM2 parity error flag
	SYSCFG_CFGR2_ECCL = 1UL<<3, // ECC Lock
	SYSCFG_CFGR2_PVDL = 1UL<<2, // PVD lock enable bit
	SYSCFG_CFGR2_SPL = 1UL<<1, // SRAM2 parity lock bit
	SYSCFG_CFGR2_CLL = 1UL<<0, // OCKUP (Hardfault) output enable bit		
};

/* Advanced-timers
There is only one peripheral of type TIM1. */
struct TIM1_Type {
	__IO uint16_t CR1; // @0 control register 1
	 uint8_t RESERVED0[2]; // @2 
	__IO uint16_t CR2; // @4 control register 2
	 uint8_t RESERVED1[2]; // @6 
	__IO uint16_t SMCR; // @8 slave mode control register
	 uint8_t RESERVED2[2]; // @10 
	__IO uint16_t DIER; // @12 DMA/Interrupt enable register
	 uint8_t RESERVED3[2]; // @14 
	__IO uint16_t SR; // @16 status register
	 uint8_t RESERVED4[2]; // @18 
	__O uint8_t EGR; // @20 event generation register
	 uint8_t RESERVED5[3]; // @21 
	union {  // @24
		__IO uint16_t CCMR1_Output; // capture/compare mode register 1 (output mode)
		__IO uint16_t CCMR1_Input; // capture/compare mode register 1 (input mode)
	};
	 uint8_t RESERVED6[2]; // @26 
	union {  // @28
		__IO uint16_t CCMR2_Output; // capture/compare mode register 2 (output mode)
		__IO uint16_t CCMR2_Input; // capture/compare mode register 2 (input mode)
	};
	 uint8_t RESERVED7[2]; // @30 
	__IO uint16_t CCER; // @32 capture/compare enable register
	 uint8_t RESERVED8[2]; // @34 
	__IO uint16_t CNT; // @36 counter
	 uint8_t RESERVED9[2]; // @38 
	__IO uint16_t PSC; // @40 prescaler
	 uint8_t RESERVED10[2]; // @42 
	__IO uint16_t ARR; // @44 auto-reload register
	 uint8_t RESERVED11[2]; // @46 
	__IO uint8_t RCR; // @48 repetition counter register
	 uint8_t RESERVED12[3]; // @49 
	__IO uint16_t CCR1; // @52 capture/compare register 1
	 uint8_t RESERVED13[2]; // @54 
	__IO uint16_t CCR2; // @56 capture/compare register 2
	 uint8_t RESERVED14[2]; // @58 
	__IO uint16_t CCR3; // @60 capture/compare register 3
	 uint8_t RESERVED15[2]; // @62 
	__IO uint16_t CCR4; // @64 capture/compare register 4
	 uint8_t RESERVED16[2]; // @66 
	__IO uint16_t BDTR; // @68 break and dead-time register
	 uint8_t RESERVED17[2]; // @70 
	__IO uint16_t DCR; // @72 DMA control register
	 uint8_t RESERVED18[2]; // @74 
	__IO uint16_t DMAR; // @76 DMA address for full transfer
	 uint8_t RESERVED19[2]; // @78 
	__IO uint8_t OR1; // @80 DMA address for full transfer
	 uint8_t RESERVED20[3]; // @81 
	__IO uint32_t CCMR3_Output; // @84 capture/compare mode register 2 (output mode)
	__IO uint32_t CCR5; // @88 capture/compare register 4
	__IO uint16_t CCR6; // @92 capture/compare register 4
	 uint8_t RESERVED21[2]; // @94 
	__IO uint32_t OR2; // @96 DMA address for full transfer
	__IO uint16_t OR3; // @100 DMA address for full transfer
};
extern struct TIM1_Type	TIM1;	// @0x40012C00 Also: TIM6_Type

// TIM1->CR1 control register 1
enum {
	TIM1_CR1_CKD = ((1UL<<2)-1) << 8, // Clock division
	TIM1_CR1_ARPE = 1UL<<7, // Auto-reload preload enable
	TIM1_CR1_CMS = ((1UL<<2)-1) << 5, // Center-aligned mode selection
	TIM1_CR1_DIR = 1UL<<4, // Direction
	TIM1_CR1_OPM = 1UL<<3, // One-pulse mode
	TIM1_CR1_URS = 1UL<<2, // Update request source
	TIM1_CR1_UDIS = 1UL<<1, // Update disable
	TIM1_CR1_CEN = 1UL<<0, // Counter enable		
};
static inline void tim1_cr1_set_ckd(uint32_t val) { TIM1.CR1 = (TIM1.CR1 & ~TIM1_CR1_CKD) | ((val<<8) & TIM1_CR1_CKD); }
static inline void tim1_cr1_set_cms(uint32_t val) { TIM1.CR1 = (TIM1.CR1 & ~TIM1_CR1_CMS) | ((val<<5) & TIM1_CR1_CMS); }
static inline uint32_t tim1_cr1_get_ckd(void) { return (TIM1.CR1 & TIM1_CR1_CKD) >> 8 ; }
static inline uint32_t tim1_cr1_get_cms(void) { return (TIM1.CR1 & TIM1_CR1_CMS) >> 5 ; }

// TIM1->CR2 control register 2
enum {
	TIM1_CR2_OIS4 = 1UL<<14, // Output Idle state 4
	TIM1_CR2_OIS3N = 1UL<<13, // Output Idle state 3
	TIM1_CR2_OIS3 = 1UL<<12, // Output Idle state 3
	TIM1_CR2_OIS2N = 1UL<<11, // Output Idle state 2
	TIM1_CR2_OIS2 = 1UL<<10, // Output Idle state 2
	TIM1_CR2_OIS1N = 1UL<<9, // Output Idle state 1
	TIM1_CR2_OIS1 = 1UL<<8, // Output Idle state 1
	TIM1_CR2_TI1S = 1UL<<7, // TI1 selection
	TIM1_CR2_MMS = ((1UL<<3)-1) << 4, // Master mode selection
	TIM1_CR2_CCDS = 1UL<<3, // Capture/compare DMA selection
	TIM1_CR2_CCUS = 1UL<<2, // Capture/compare control update selection
	TIM1_CR2_CCPC = 1UL<<0, // Capture/compare preloaded control		
};
static inline void tim1_cr2_set_mms(uint32_t val) { TIM1.CR2 = (TIM1.CR2 & ~TIM1_CR2_MMS) | ((val<<4) & TIM1_CR2_MMS); }
static inline uint32_t tim1_cr2_get_mms(void) { return (TIM1.CR2 & TIM1_CR2_MMS) >> 4 ; }

// TIM1->SMCR slave mode control register
enum {
	TIM1_SMCR_ETP = 1UL<<15, // External trigger polarity
	TIM1_SMCR_ECE = 1UL<<14, // External clock enable
	TIM1_SMCR_ETPS = ((1UL<<2)-1) << 12, // External trigger prescaler
	TIM1_SMCR_ETF = ((1UL<<4)-1) << 8, // External trigger filter
	TIM1_SMCR_MSM = 1UL<<7, // Master/Slave mode
	TIM1_SMCR_TS = ((1UL<<3)-1) << 4, // Trigger selection
	TIM1_SMCR_SMS = ((1UL<<3)-1) << 0, // Slave mode selection		
};
static inline void tim1_smcr_set_etps(uint32_t val) { TIM1.SMCR = (TIM1.SMCR & ~TIM1_SMCR_ETPS) | ((val<<12) & TIM1_SMCR_ETPS); }
static inline void tim1_smcr_set_etf(uint32_t val) { TIM1.SMCR = (TIM1.SMCR & ~TIM1_SMCR_ETF) | ((val<<8) & TIM1_SMCR_ETF); }
static inline void tim1_smcr_set_ts(uint32_t val) { TIM1.SMCR = (TIM1.SMCR & ~TIM1_SMCR_TS) | ((val<<4) & TIM1_SMCR_TS); }
static inline void tim1_smcr_set_sms(uint32_t val) { TIM1.SMCR = (TIM1.SMCR & ~TIM1_SMCR_SMS) | ((val<<0) & TIM1_SMCR_SMS); }
static inline uint32_t tim1_smcr_get_etps(void) { return (TIM1.SMCR & TIM1_SMCR_ETPS) >> 12 ; }
static inline uint32_t tim1_smcr_get_etf(void) { return (TIM1.SMCR & TIM1_SMCR_ETF) >> 8 ; }
static inline uint32_t tim1_smcr_get_ts(void) { return (TIM1.SMCR & TIM1_SMCR_TS) >> 4 ; }
static inline uint32_t tim1_smcr_get_sms(void) { return (TIM1.SMCR & TIM1_SMCR_SMS) >> 0 ; }

// TIM1->DIER DMA/Interrupt enable register
enum {
	TIM1_DIER_TDE = 1UL<<14, // Trigger DMA request enable
	TIM1_DIER_COMDE = 1UL<<13, // COM DMA request enable
	TIM1_DIER_CC4DE = 1UL<<12, // Capture/Compare 4 DMA request enable
	TIM1_DIER_CC3DE = 1UL<<11, // Capture/Compare 3 DMA request enable
	TIM1_DIER_CC2DE = 1UL<<10, // Capture/Compare 2 DMA request enable
	TIM1_DIER_CC1DE = 1UL<<9, // Capture/Compare 1 DMA request enable
	TIM1_DIER_UDE = 1UL<<8, // Update DMA request enable
	TIM1_DIER_BIE = 1UL<<7, // Break interrupt enable
	TIM1_DIER_TIE = 1UL<<6, // Trigger interrupt enable
	TIM1_DIER_COMIE = 1UL<<5, // COM interrupt enable
	TIM1_DIER_CC4IE = 1UL<<4, // Capture/Compare 4 interrupt enable
	TIM1_DIER_CC3IE = 1UL<<3, // Capture/Compare 3 interrupt enable
	TIM1_DIER_CC2IE = 1UL<<2, // Capture/Compare 2 interrupt enable
	TIM1_DIER_CC1IE = 1UL<<1, // Capture/Compare 1 interrupt enable
	TIM1_DIER_UIE = 1UL<<0, // Update interrupt enable		
};

// TIM1->SR status register
enum {
	TIM1_SR_CC4OF = 1UL<<12, // Capture/Compare 4 overcapture flag
	TIM1_SR_CC3OF = 1UL<<11, // Capture/Compare 3 overcapture flag
	TIM1_SR_CC2OF = 1UL<<10, // Capture/compare 2 overcapture flag
	TIM1_SR_CC1OF = 1UL<<9, // Capture/Compare 1 overcapture flag
	TIM1_SR_BIF = 1UL<<7, // Break interrupt flag
	TIM1_SR_TIF = 1UL<<6, // Trigger interrupt flag
	TIM1_SR_COMIF = 1UL<<5, // COM interrupt flag
	TIM1_SR_CC4IF = 1UL<<4, // Capture/Compare 4 interrupt flag
	TIM1_SR_CC3IF = 1UL<<3, // Capture/Compare 3 interrupt flag
	TIM1_SR_CC2IF = 1UL<<2, // Capture/Compare 2 interrupt flag
	TIM1_SR_CC1IF = 1UL<<1, // Capture/compare 1 interrupt flag
	TIM1_SR_UIF = 1UL<<0, // Update interrupt flag		
};

// TIM1->EGR event generation register
enum {
	TIM1_EGR_BG = 1UL<<7, // Break generation
	TIM1_EGR_TG = 1UL<<6, // Trigger generation
	TIM1_EGR_COMG = 1UL<<5, // Capture/Compare control update generation
	TIM1_EGR_CC4G = 1UL<<4, // Capture/compare 4 generation
	TIM1_EGR_CC3G = 1UL<<3, // Capture/compare 3 generation
	TIM1_EGR_CC2G = 1UL<<2, // Capture/compare 2 generation
	TIM1_EGR_CC1G = 1UL<<1, // Capture/compare 1 generation
	TIM1_EGR_UG = 1UL<<0, // Update generation		
};

// TIM1->CCMR1_Output capture/compare mode register 1 (output mode)
enum {
	TIM1_CCMR1_OUTPUT_OC2CE = 1UL<<15, // Output Compare 2 clear enable
	TIM1_CCMR1_OUTPUT_OC2M = ((1UL<<3)-1) << 12, // Output Compare 2 mode
	TIM1_CCMR1_OUTPUT_OC2PE = 1UL<<11, // Output Compare 2 preload enable
	TIM1_CCMR1_OUTPUT_OC2FE = 1UL<<10, // Output Compare 2 fast enable
	TIM1_CCMR1_OUTPUT_CC2S = ((1UL<<2)-1) << 8, // Capture/Compare 2 selection
	TIM1_CCMR1_OUTPUT_OC1CE = 1UL<<7, // Output Compare 1 clear enable
	TIM1_CCMR1_OUTPUT_OC1M = ((1UL<<3)-1) << 4, // Output Compare 1 mode
	TIM1_CCMR1_OUTPUT_OC1PE = 1UL<<3, // Output Compare 1 preload enable
	TIM1_CCMR1_OUTPUT_OC1FE = 1UL<<2, // Output Compare 1 fast enable
	TIM1_CCMR1_OUTPUT_CC1S = ((1UL<<2)-1) << 0, // Capture/Compare 1 selection		
};
static inline void tim1_ccmr1_output_set_oc2m(uint32_t val) { TIM1.CCMR1_Output = (TIM1.CCMR1_Output & ~TIM1_CCMR1_OUTPUT_OC2M) | ((val<<12) & TIM1_CCMR1_OUTPUT_OC2M); }
static inline void tim1_ccmr1_output_set_cc2s(uint32_t val) { TIM1.CCMR1_Output = (TIM1.CCMR1_Output & ~TIM1_CCMR1_OUTPUT_CC2S) | ((val<<8) & TIM1_CCMR1_OUTPUT_CC2S); }
static inline void tim1_ccmr1_output_set_oc1m(uint32_t val) { TIM1.CCMR1_Output = (TIM1.CCMR1_Output & ~TIM1_CCMR1_OUTPUT_OC1M) | ((val<<4) & TIM1_CCMR1_OUTPUT_OC1M); }
static inline void tim1_ccmr1_output_set_cc1s(uint32_t val) { TIM1.CCMR1_Output = (TIM1.CCMR1_Output & ~TIM1_CCMR1_OUTPUT_CC1S) | ((val<<0) & TIM1_CCMR1_OUTPUT_CC1S); }
static inline uint32_t tim1_ccmr1_output_get_oc2m(void) { return (TIM1.CCMR1_Output & TIM1_CCMR1_OUTPUT_OC2M) >> 12 ; }
static inline uint32_t tim1_ccmr1_output_get_cc2s(void) { return (TIM1.CCMR1_Output & TIM1_CCMR1_OUTPUT_CC2S) >> 8 ; }
static inline uint32_t tim1_ccmr1_output_get_oc1m(void) { return (TIM1.CCMR1_Output & TIM1_CCMR1_OUTPUT_OC1M) >> 4 ; }
static inline uint32_t tim1_ccmr1_output_get_cc1s(void) { return (TIM1.CCMR1_Output & TIM1_CCMR1_OUTPUT_CC1S) >> 0 ; }

// TIM1->CCMR2_Output capture/compare mode register 2 (output mode)
enum {
	TIM1_CCMR2_OUTPUT_OC4CE = 1UL<<15, // Output compare 4 clear enable
	TIM1_CCMR2_OUTPUT_OC4M = ((1UL<<3)-1) << 12, // Output compare 4 mode
	TIM1_CCMR2_OUTPUT_OC4PE = 1UL<<11, // Output compare 4 preload enable
	TIM1_CCMR2_OUTPUT_OC4FE = 1UL<<10, // Output compare 4 fast enable
	TIM1_CCMR2_OUTPUT_CC4S = ((1UL<<2)-1) << 8, // Capture/Compare 4 selection
	TIM1_CCMR2_OUTPUT_OC3CE = 1UL<<7, // Output compare 3 clear enable
	TIM1_CCMR2_OUTPUT_OC3M = ((1UL<<3)-1) << 4, // Output compare 3 mode
	TIM1_CCMR2_OUTPUT_OC3PE = 1UL<<3, // Output compare 3 preload enable
	TIM1_CCMR2_OUTPUT_OC3FE = 1UL<<2, // Output compare 3 fast enable
	TIM1_CCMR2_OUTPUT_CC3S = ((1UL<<2)-1) << 0, // Capture/Compare 3 selection		
};
static inline void tim1_ccmr2_output_set_oc4m(uint32_t val) { TIM1.CCMR2_Output = (TIM1.CCMR2_Output & ~TIM1_CCMR2_OUTPUT_OC4M) | ((val<<12) & TIM1_CCMR2_OUTPUT_OC4M); }
static inline void tim1_ccmr2_output_set_cc4s(uint32_t val) { TIM1.CCMR2_Output = (TIM1.CCMR2_Output & ~TIM1_CCMR2_OUTPUT_CC4S) | ((val<<8) & TIM1_CCMR2_OUTPUT_CC4S); }
static inline void tim1_ccmr2_output_set_oc3m(uint32_t val) { TIM1.CCMR2_Output = (TIM1.CCMR2_Output & ~TIM1_CCMR2_OUTPUT_OC3M) | ((val<<4) & TIM1_CCMR2_OUTPUT_OC3M); }
static inline void tim1_ccmr2_output_set_cc3s(uint32_t val) { TIM1.CCMR2_Output = (TIM1.CCMR2_Output & ~TIM1_CCMR2_OUTPUT_CC3S) | ((val<<0) & TIM1_CCMR2_OUTPUT_CC3S); }
static inline uint32_t tim1_ccmr2_output_get_oc4m(void) { return (TIM1.CCMR2_Output & TIM1_CCMR2_OUTPUT_OC4M) >> 12 ; }
static inline uint32_t tim1_ccmr2_output_get_cc4s(void) { return (TIM1.CCMR2_Output & TIM1_CCMR2_OUTPUT_CC4S) >> 8 ; }
static inline uint32_t tim1_ccmr2_output_get_oc3m(void) { return (TIM1.CCMR2_Output & TIM1_CCMR2_OUTPUT_OC3M) >> 4 ; }
static inline uint32_t tim1_ccmr2_output_get_cc3s(void) { return (TIM1.CCMR2_Output & TIM1_CCMR2_OUTPUT_CC3S) >> 0 ; }

// TIM1->CCER capture/compare enable register
enum {
	TIM1_CCER_CC4P = 1UL<<13, // Capture/Compare 3 output Polarity
	TIM1_CCER_CC4E = 1UL<<12, // Capture/Compare 4 output enable
	TIM1_CCER_CC3NP = 1UL<<11, // Capture/Compare 3 output Polarity
	TIM1_CCER_CC3NE = 1UL<<10, // Capture/Compare 3 complementary output enable
	TIM1_CCER_CC3P = 1UL<<9, // Capture/Compare 3 output Polarity
	TIM1_CCER_CC3E = 1UL<<8, // Capture/Compare 3 output enable
	TIM1_CCER_CC2NP = 1UL<<7, // Capture/Compare 2 output Polarity
	TIM1_CCER_CC2NE = 1UL<<6, // Capture/Compare 2 complementary output enable
	TIM1_CCER_CC2P = 1UL<<5, // Capture/Compare 2 output Polarity
	TIM1_CCER_CC2E = 1UL<<4, // Capture/Compare 2 output enable
	TIM1_CCER_CC1NP = 1UL<<3, // Capture/Compare 1 output Polarity
	TIM1_CCER_CC1NE = 1UL<<2, // Capture/Compare 1 complementary output enable
	TIM1_CCER_CC1P = 1UL<<1, // Capture/Compare 1 output Polarity
	TIM1_CCER_CC1E = 1UL<<0, // Capture/Compare 1 output enable		
};

// TIM1->BDTR break and dead-time register
enum {
	TIM1_BDTR_MOE = 1UL<<15, // Main output enable
	TIM1_BDTR_AOE = 1UL<<14, // Automatic output enable
	TIM1_BDTR_BKP = 1UL<<13, // Break polarity
	TIM1_BDTR_BKE = 1UL<<12, // Break enable
	TIM1_BDTR_OSSR = 1UL<<11, // Off-state selection for Run mode
	TIM1_BDTR_OSSI = 1UL<<10, // Off-state selection for Idle mode
	TIM1_BDTR_LOCK = ((1UL<<2)-1) << 8, // Lock configuration
	TIM1_BDTR_DTG = ((1UL<<8)-1) << 0, // Dead-time generator setup		
};
static inline void tim1_bdtr_set_lock(uint32_t val) { TIM1.BDTR = (TIM1.BDTR & ~TIM1_BDTR_LOCK) | ((val<<8) & TIM1_BDTR_LOCK); }
static inline void tim1_bdtr_set_dtg(uint32_t val) { TIM1.BDTR = (TIM1.BDTR & ~TIM1_BDTR_DTG) | ((val<<0) & TIM1_BDTR_DTG); }
static inline uint32_t tim1_bdtr_get_lock(void) { return (TIM1.BDTR & TIM1_BDTR_LOCK) >> 8 ; }
static inline uint32_t tim1_bdtr_get_dtg(void) { return (TIM1.BDTR & TIM1_BDTR_DTG) >> 0 ; }

// TIM1->DCR DMA control register
enum {
	TIM1_DCR_DBL = ((1UL<<5)-1) << 8, // DMA burst length
	TIM1_DCR_DBA = ((1UL<<5)-1) << 0, // DMA base address		
};
static inline void tim1_dcr_set_dbl(uint32_t val) { TIM1.DCR = (TIM1.DCR & ~TIM1_DCR_DBL) | ((val<<8) & TIM1_DCR_DBL); }
static inline void tim1_dcr_set_dba(uint32_t val) { TIM1.DCR = (TIM1.DCR & ~TIM1_DCR_DBA) | ((val<<0) & TIM1_DCR_DBA); }
static inline uint32_t tim1_dcr_get_dbl(void) { return (TIM1.DCR & TIM1_DCR_DBL) >> 8 ; }
static inline uint32_t tim1_dcr_get_dba(void) { return (TIM1.DCR & TIM1_DCR_DBA) >> 0 ; }

// TIM1->OR1 DMA address for full transfer
enum {
	TIM1_OR1_TI1_RMP = 1UL<<4, // Input Capture 1 remap
	TIM1_OR1_ETR_ADC3_RMP = ((1UL<<2)-1) << 2, // External trigger remap on ADC3 analog watchdog
	TIM1_OR1_ETR_ADC1_RMP = ((1UL<<2)-1) << 0, // External trigger remap on ADC1 analog watchdog		
};
static inline void tim1_or1_set_etr_adc3_rmp(uint32_t val) { TIM1.OR1 = (TIM1.OR1 & ~TIM1_OR1_ETR_ADC3_RMP) | ((val<<2) & TIM1_OR1_ETR_ADC3_RMP); }
static inline void tim1_or1_set_etr_adc1_rmp(uint32_t val) { TIM1.OR1 = (TIM1.OR1 & ~TIM1_OR1_ETR_ADC1_RMP) | ((val<<0) & TIM1_OR1_ETR_ADC1_RMP); }
static inline uint32_t tim1_or1_get_etr_adc3_rmp(void) { return (TIM1.OR1 & TIM1_OR1_ETR_ADC3_RMP) >> 2 ; }
static inline uint32_t tim1_or1_get_etr_adc1_rmp(void) { return (TIM1.OR1 & TIM1_OR1_ETR_ADC1_RMP) >> 0 ; }

// TIM1->CCMR3_Output capture/compare mode register 2 (output mode)
enum {
	TIM1_CCMR3_OUTPUT_OC6M_BIT3 = 1UL<<24, // Output Compare 6 mode bit 3
	TIM1_CCMR3_OUTPUT_OC5M_BIT3 = ((1UL<<3)-1) << 16, // Output Compare 5 mode bit 3
	TIM1_CCMR3_OUTPUT_OC6CE = 1UL<<15, // Output compare 6 clear enable
	TIM1_CCMR3_OUTPUT_OC6M = ((1UL<<3)-1) << 12, // Output compare 6 mode
	TIM1_CCMR3_OUTPUT_OC6PE = 1UL<<11, // Output compare 6 preload enable
	TIM1_CCMR3_OUTPUT_OC6FE = 1UL<<10, // Output compare 6 fast enable
	TIM1_CCMR3_OUTPUT_OC5CE = 1UL<<7, // Output compare 5 clear enable
	TIM1_CCMR3_OUTPUT_OC5M = ((1UL<<3)-1) << 4, // Output compare 5 mode
	TIM1_CCMR3_OUTPUT_OC5PE = 1UL<<3, // Output compare 5 preload enable
	TIM1_CCMR3_OUTPUT_OC5FE = 1UL<<2, // Output compare 5 fast enable		
};
static inline void tim1_ccmr3_output_set_oc5m_bit3(uint32_t val) { TIM1.CCMR3_Output = (TIM1.CCMR3_Output & ~TIM1_CCMR3_OUTPUT_OC5M_BIT3) | ((val<<16) & TIM1_CCMR3_OUTPUT_OC5M_BIT3); }
static inline void tim1_ccmr3_output_set_oc6m(uint32_t val) { TIM1.CCMR3_Output = (TIM1.CCMR3_Output & ~TIM1_CCMR3_OUTPUT_OC6M) | ((val<<12) & TIM1_CCMR3_OUTPUT_OC6M); }
static inline void tim1_ccmr3_output_set_oc5m(uint32_t val) { TIM1.CCMR3_Output = (TIM1.CCMR3_Output & ~TIM1_CCMR3_OUTPUT_OC5M) | ((val<<4) & TIM1_CCMR3_OUTPUT_OC5M); }
static inline uint32_t tim1_ccmr3_output_get_oc5m_bit3(void) { return (TIM1.CCMR3_Output & TIM1_CCMR3_OUTPUT_OC5M_BIT3) >> 16 ; }
static inline uint32_t tim1_ccmr3_output_get_oc6m(void) { return (TIM1.CCMR3_Output & TIM1_CCMR3_OUTPUT_OC6M) >> 12 ; }
static inline uint32_t tim1_ccmr3_output_get_oc5m(void) { return (TIM1.CCMR3_Output & TIM1_CCMR3_OUTPUT_OC5M) >> 4 ; }

// TIM1->CCR5 capture/compare register 4
enum {
	TIM1_CCR5_GC5C3 = 1UL<<31, // Group Channel 5 and Channel 3
	TIM1_CCR5_GC5C2 = 1UL<<30, // Group Channel 5 and Channel 2
	TIM1_CCR5_GC5C1 = 1UL<<29, // Group Channel 5 and Channel 1
	TIM1_CCR5_CCR5 = ((1UL<<16)-1) << 0, // Capture/Compare value		
};
static inline void tim1_ccr5_set_ccr5(uint32_t val) { TIM1.CCR5 = (TIM1.CCR5 & ~TIM1_CCR5_CCR5) | ((val<<0) & TIM1_CCR5_CCR5); }
static inline uint32_t tim1_ccr5_get_ccr5(void) { return (TIM1.CCR5 & TIM1_CCR5_CCR5) >> 0 ; }

// TIM1->OR2 DMA address for full transfer
enum {
	TIM1_OR2_ETRSEL = ((1UL<<3)-1) << 14, // ETR source selection
	TIM1_OR2_BKCMP2P = 1UL<<11, // BRK COMP2 input polarity
	TIM1_OR2_BKCMP1P = 1UL<<10, // BRK COMP1 input polarity
	TIM1_OR2_BKINP = 1UL<<9, // BRK BKIN input polarity
	TIM1_OR2_BKDFBK0E = 1UL<<8, // BRK DFSDM_BREAK0 enable
	TIM1_OR2_BKCMP2E = 1UL<<2, // BRK COMP2 enable
	TIM1_OR2_BKCMP1E = 1UL<<1, // BRK COMP1 enable
	TIM1_OR2_BKINE = 1UL<<0, // BRK BKIN input enable		
};
static inline void tim1_or2_set_etrsel(uint32_t val) { TIM1.OR2 = (TIM1.OR2 & ~TIM1_OR2_ETRSEL) | ((val<<14) & TIM1_OR2_ETRSEL); }
static inline uint32_t tim1_or2_get_etrsel(void) { return (TIM1.OR2 & TIM1_OR2_ETRSEL) >> 14 ; }

// TIM1->OR3 DMA address for full transfer
enum {
	TIM1_OR3_BK2CMP2P = 1UL<<11, // BRK2 COMP2 input polarity
	TIM1_OR3_BK2CMP1P = 1UL<<10, // BRK2 COMP1 input polarity
	TIM1_OR3_BK2INP = 1UL<<9, // BRK2 BKIN input polarity
	TIM1_OR3_BK2DFBK0E = 1UL<<8, // BRK2 DFSDM_BREAK0 enable
	TIM1_OR3_BK2CMP2E = 1UL<<2, // BRK2 COMP2 enable
	TIM1_OR3_BK2CMP1E = 1UL<<1, // BRK2 COMP1 enable
	TIM1_OR3_BK2INE = 1UL<<0, // BRK2 BKIN input enable		
};

// Valid Casts:
 
static inline struct TIM6_Type* TIM1_as_TIM6_Type(struct TIM1_Type* p) { return (struct TIM6_Type*)p; }


/* General purpose timers
There is only one peripheral of type TIM15. */
struct TIM15_Type {
	__IO uint16_t CR1; // @0 control register 1
	 uint8_t RESERVED0[2]; // @2 
	__IO uint16_t CR2; // @4 control register 2
	 uint8_t RESERVED1[6]; // @6 
	__IO uint16_t DIER; // @12 DMA/Interrupt enable register
	 uint8_t RESERVED2[2]; // @14 
	__IO uint16_t SR; // @16 status register
	 uint8_t RESERVED3[2]; // @18 
	__O uint8_t EGR; // @20 event generation register
	 uint8_t RESERVED4[3]; // @21 
	union {  // @24
		__IO uint32_t CCMR1_Output; // capture/compare mode register (output mode)
		__IO uint8_t CCMR1_Input; // capture/compare mode register 1 (input mode)
	};
	 uint8_t RESERVED5[4]; // @28 
	__IO uint8_t CCER; // @32 capture/compare enable register
	 uint8_t RESERVED6[3]; // @33 
	__IO uint32_t CNT; // @36 counter
	__IO uint16_t PSC; // @40 prescaler
	 uint8_t RESERVED7[2]; // @42 
	__IO uint16_t ARR; // @44 auto-reload register
	 uint8_t RESERVED8[2]; // @46 
	__IO uint8_t RCR; // @48 repetition counter register
	 uint8_t RESERVED9[3]; // @49 
	__IO uint16_t CCR1; // @52 capture/compare register 1
	 uint8_t RESERVED10[14]; // @54 
	__IO uint32_t BDTR; // @68 break and dead-time register
	__IO uint16_t DCR; // @72 DMA control register
	 uint8_t RESERVED11[2]; // @74 
	__IO uint16_t DMAR; // @76 DMA address for full transfer
};
extern struct TIM15_Type	TIM15;	// @0x40014000 

// TIM15->CR1 control register 1
enum {
	TIM15_CR1_UIFREMAP = 1UL<<11, // UIF status bit remapping
	TIM15_CR1_CKD = ((1UL<<2)-1) << 8, // Clock division
	TIM15_CR1_ARPE = 1UL<<7, // Auto-reload preload enable
	TIM15_CR1_OPM = 1UL<<3, // One-pulse mode
	TIM15_CR1_URS = 1UL<<2, // Update request source
	TIM15_CR1_UDIS = 1UL<<1, // Update disable
	TIM15_CR1_CEN = 1UL<<0, // Counter enable		
};
static inline void tim15_cr1_set_ckd(uint32_t val) { TIM15.CR1 = (TIM15.CR1 & ~TIM15_CR1_CKD) | ((val<<8) & TIM15_CR1_CKD); }
static inline uint32_t tim15_cr1_get_ckd(void) { return (TIM15.CR1 & TIM15_CR1_CKD) >> 8 ; }

// TIM15->CR2 control register 2
enum {
	TIM15_CR2_OIS1N = 1UL<<9, // Output Idle state 1
	TIM15_CR2_OIS1 = 1UL<<8, // Output Idle state 1
	TIM15_CR2_CCDS = 1UL<<3, // Capture/compare DMA selection
	TIM15_CR2_CCUS = 1UL<<2, // Capture/compare control update selection
	TIM15_CR2_CCPC = 1UL<<0, // Capture/compare preloaded control		
};

// TIM15->DIER DMA/Interrupt enable register
enum {
	TIM15_DIER_TDE = 1UL<<14, // Trigger DMA request enable
	TIM15_DIER_COMDE = 1UL<<13, // COM DMA request enable
	TIM15_DIER_CC1DE = 1UL<<9, // Capture/Compare 1 DMA request enable
	TIM15_DIER_UDE = 1UL<<8, // Update DMA request enable
	TIM15_DIER_BIE = 1UL<<7, // Break interrupt enable
	TIM15_DIER_TIE = 1UL<<6, // Trigger interrupt enable
	TIM15_DIER_COMIE = 1UL<<5, // COM interrupt enable
	TIM15_DIER_CC1IE = 1UL<<1, // Capture/Compare 1 interrupt enable
	TIM15_DIER_UIE = 1UL<<0, // Update interrupt enable		
};

// TIM15->SR status register
enum {
	TIM15_SR_CC1OF = 1UL<<9, // Capture/Compare 1 overcapture flag
	TIM15_SR_BIF = 1UL<<7, // Break interrupt flag
	TIM15_SR_TIF = 1UL<<6, // Trigger interrupt flag
	TIM15_SR_COMIF = 1UL<<5, // COM interrupt flag
	TIM15_SR_CC1IF = 1UL<<1, // Capture/compare 1 interrupt flag
	TIM15_SR_UIF = 1UL<<0, // Update interrupt flag		
};

// TIM15->EGR event generation register
enum {
	TIM15_EGR_BG = 1UL<<7, // Break generation
	TIM15_EGR_TG = 1UL<<6, // Trigger generation
	TIM15_EGR_COMG = 1UL<<5, // Capture/Compare control update generation
	TIM15_EGR_CC1G = 1UL<<1, // Capture/compare 1 generation
	TIM15_EGR_UG = 1UL<<0, // Update generation		
};

// TIM15->CCMR1_Output capture/compare mode register (output mode)
enum {
	TIM15_CCMR1_OUTPUT_OC1M_2 = 1UL<<16, // Output Compare 1 mode
	TIM15_CCMR1_OUTPUT_OC1M = ((1UL<<3)-1) << 4, // Output Compare 1 mode
	TIM15_CCMR1_OUTPUT_OC1PE = 1UL<<3, // Output Compare 1 preload enable
	TIM15_CCMR1_OUTPUT_OC1FE = 1UL<<2, // Output Compare 1 fast enable
	TIM15_CCMR1_OUTPUT_CC1S = ((1UL<<2)-1) << 0, // Capture/Compare 1 selection		
};
static inline void tim15_ccmr1_output_set_oc1m(uint32_t val) { TIM15.CCMR1_Output = (TIM15.CCMR1_Output & ~TIM15_CCMR1_OUTPUT_OC1M) | ((val<<4) & TIM15_CCMR1_OUTPUT_OC1M); }
static inline void tim15_ccmr1_output_set_cc1s(uint32_t val) { TIM15.CCMR1_Output = (TIM15.CCMR1_Output & ~TIM15_CCMR1_OUTPUT_CC1S) | ((val<<0) & TIM15_CCMR1_OUTPUT_CC1S); }
static inline uint32_t tim15_ccmr1_output_get_oc1m(void) { return (TIM15.CCMR1_Output & TIM15_CCMR1_OUTPUT_OC1M) >> 4 ; }
static inline uint32_t tim15_ccmr1_output_get_cc1s(void) { return (TIM15.CCMR1_Output & TIM15_CCMR1_OUTPUT_CC1S) >> 0 ; }

// TIM15->CCER capture/compare enable register
enum {
	TIM15_CCER_CC1NP = 1UL<<3, // Capture/Compare 1 output Polarity
	TIM15_CCER_CC1NE = 1UL<<2, // Capture/Compare 1 complementary output enable
	TIM15_CCER_CC1P = 1UL<<1, // Capture/Compare 1 output Polarity
	TIM15_CCER_CC1E = 1UL<<0, // Capture/Compare 1 output enable		
};

// TIM15->CNT counter
enum {
	TIM15_CNT_UIFCPY = 1UL<<31, // UIF Copy
	TIM15_CNT_CNT = ((1UL<<16)-1) << 0, // counter value		
};
static inline void tim15_cnt_set_cnt(uint32_t val) { TIM15.CNT = (TIM15.CNT & ~TIM15_CNT_CNT) | ((val<<0) & TIM15_CNT_CNT); }
static inline uint32_t tim15_cnt_get_cnt(void) { return (TIM15.CNT & TIM15_CNT_CNT) >> 0 ; }

// TIM15->BDTR break and dead-time register
enum {
	TIM15_BDTR_BKF = ((1UL<<4)-1) << 16, // Break filter
	TIM15_BDTR_MOE = 1UL<<15, // Main output enable
	TIM15_BDTR_AOE = 1UL<<14, // Automatic output enable
	TIM15_BDTR_BKP = 1UL<<13, // Break polarity
	TIM15_BDTR_BKE = 1UL<<12, // Break enable
	TIM15_BDTR_OSSR = 1UL<<11, // Off-state selection for Run mode
	TIM15_BDTR_OSSI = 1UL<<10, // Off-state selection for Idle mode
	TIM15_BDTR_LOCK = ((1UL<<2)-1) << 8, // Lock configuration
	TIM15_BDTR_DTG = ((1UL<<8)-1) << 0, // Dead-time generator setup		
};
static inline void tim15_bdtr_set_bkf(uint32_t val) { TIM15.BDTR = (TIM15.BDTR & ~TIM15_BDTR_BKF) | ((val<<16) & TIM15_BDTR_BKF); }
static inline void tim15_bdtr_set_lock(uint32_t val) { TIM15.BDTR = (TIM15.BDTR & ~TIM15_BDTR_LOCK) | ((val<<8) & TIM15_BDTR_LOCK); }
static inline void tim15_bdtr_set_dtg(uint32_t val) { TIM15.BDTR = (TIM15.BDTR & ~TIM15_BDTR_DTG) | ((val<<0) & TIM15_BDTR_DTG); }
static inline uint32_t tim15_bdtr_get_bkf(void) { return (TIM15.BDTR & TIM15_BDTR_BKF) >> 16 ; }
static inline uint32_t tim15_bdtr_get_lock(void) { return (TIM15.BDTR & TIM15_BDTR_LOCK) >> 8 ; }
static inline uint32_t tim15_bdtr_get_dtg(void) { return (TIM15.BDTR & TIM15_BDTR_DTG) >> 0 ; }

// TIM15->DCR DMA control register
enum {
	TIM15_DCR_DBL = ((1UL<<5)-1) << 8, // DMA burst length
	TIM15_DCR_DBA = ((1UL<<5)-1) << 0, // DMA base address		
};
static inline void tim15_dcr_set_dbl(uint32_t val) { TIM15.DCR = (TIM15.DCR & ~TIM15_DCR_DBL) | ((val<<8) & TIM15_DCR_DBL); }
static inline void tim15_dcr_set_dba(uint32_t val) { TIM15.DCR = (TIM15.DCR & ~TIM15_DCR_DBA) | ((val<<0) & TIM15_DCR_DBA); }
static inline uint32_t tim15_dcr_get_dbl(void) { return (TIM15.DCR & TIM15_DCR_DBL) >> 8 ; }
static inline uint32_t tim15_dcr_get_dba(void) { return (TIM15.DCR & TIM15_DCR_DBA) >> 0 ; }

/* General purpose timers
There is only one peripheral of type TIM16. */
struct TIM16_Type {
	__IO uint16_t CR1; // @0 control register 1
	 uint8_t RESERVED0[2]; // @2 
	__IO uint16_t CR2; // @4 control register 2
	 uint8_t RESERVED1[6]; // @6 
	__IO uint16_t DIER; // @12 DMA/Interrupt enable register
	 uint8_t RESERVED2[2]; // @14 
	__IO uint16_t SR; // @16 status register
	 uint8_t RESERVED3[2]; // @18 
	__O uint8_t EGR; // @20 event generation register
	 uint8_t RESERVED4[3]; // @21 
	union {  // @24
		__IO uint32_t CCMR1_Output; // capture/compare mode register (output mode)
		__IO uint8_t CCMR1_Input; // capture/compare mode register 1 (input mode)
	};
	 uint8_t RESERVED5[4]; // @28 
	__IO uint8_t CCER; // @32 capture/compare enable register
	 uint8_t RESERVED6[3]; // @33 
	__IO uint32_t CNT; // @36 counter
	__IO uint16_t PSC; // @40 prescaler
	 uint8_t RESERVED7[2]; // @42 
	__IO uint16_t ARR; // @44 auto-reload register
	 uint8_t RESERVED8[2]; // @46 
	__IO uint8_t RCR; // @48 repetition counter register
	 uint8_t RESERVED9[3]; // @49 
	__IO uint16_t CCR1; // @52 capture/compare register 1
	 uint8_t RESERVED10[14]; // @54 
	__IO uint32_t BDTR; // @68 break and dead-time register
	__IO uint16_t DCR; // @72 DMA control register
	 uint8_t RESERVED11[2]; // @74 
	__IO uint16_t DMAR; // @76 DMA address for full transfer
	 uint8_t RESERVED12[2]; // @78 
	__IO uint8_t OR1; // @80 TIM16 option register 1
	 uint8_t RESERVED13[15]; // @81 
	__IO uint16_t OR2; // @96 TIM17 option register 1
};
extern struct TIM16_Type	TIM16;	// @0x40014400 Also: TIM15_Type

// TIM16->CR1 control register 1
enum {
	TIM16_CR1_UIFREMAP = 1UL<<11, // UIF status bit remapping
	TIM16_CR1_CKD = ((1UL<<2)-1) << 8, // Clock division
	TIM16_CR1_ARPE = 1UL<<7, // Auto-reload preload enable
	TIM16_CR1_OPM = 1UL<<3, // One-pulse mode
	TIM16_CR1_URS = 1UL<<2, // Update request source
	TIM16_CR1_UDIS = 1UL<<1, // Update disable
	TIM16_CR1_CEN = 1UL<<0, // Counter enable		
};
static inline void tim16_cr1_set_ckd(uint32_t val) { TIM16.CR1 = (TIM16.CR1 & ~TIM16_CR1_CKD) | ((val<<8) & TIM16_CR1_CKD); }
static inline uint32_t tim16_cr1_get_ckd(void) { return (TIM16.CR1 & TIM16_CR1_CKD) >> 8 ; }

// TIM16->CR2 control register 2
enum {
	TIM16_CR2_OIS1N = 1UL<<9, // Output Idle state 1
	TIM16_CR2_OIS1 = 1UL<<8, // Output Idle state 1
	TIM16_CR2_CCDS = 1UL<<3, // Capture/compare DMA selection
	TIM16_CR2_CCUS = 1UL<<2, // Capture/compare control update selection
	TIM16_CR2_CCPC = 1UL<<0, // Capture/compare preloaded control		
};

// TIM16->DIER DMA/Interrupt enable register
enum {
	TIM16_DIER_TDE = 1UL<<14, // Trigger DMA request enable
	TIM16_DIER_COMDE = 1UL<<13, // COM DMA request enable
	TIM16_DIER_CC1DE = 1UL<<9, // Capture/Compare 1 DMA request enable
	TIM16_DIER_UDE = 1UL<<8, // Update DMA request enable
	TIM16_DIER_BIE = 1UL<<7, // Break interrupt enable
	TIM16_DIER_TIE = 1UL<<6, // Trigger interrupt enable
	TIM16_DIER_COMIE = 1UL<<5, // COM interrupt enable
	TIM16_DIER_CC1IE = 1UL<<1, // Capture/Compare 1 interrupt enable
	TIM16_DIER_UIE = 1UL<<0, // Update interrupt enable		
};

// TIM16->SR status register
enum {
	TIM16_SR_CC1OF = 1UL<<9, // Capture/Compare 1 overcapture flag
	TIM16_SR_BIF = 1UL<<7, // Break interrupt flag
	TIM16_SR_TIF = 1UL<<6, // Trigger interrupt flag
	TIM16_SR_COMIF = 1UL<<5, // COM interrupt flag
	TIM16_SR_CC1IF = 1UL<<1, // Capture/compare 1 interrupt flag
	TIM16_SR_UIF = 1UL<<0, // Update interrupt flag		
};

// TIM16->EGR event generation register
enum {
	TIM16_EGR_BG = 1UL<<7, // Break generation
	TIM16_EGR_TG = 1UL<<6, // Trigger generation
	TIM16_EGR_COMG = 1UL<<5, // Capture/Compare control update generation
	TIM16_EGR_CC1G = 1UL<<1, // Capture/compare 1 generation
	TIM16_EGR_UG = 1UL<<0, // Update generation		
};

// TIM16->CCMR1_Output capture/compare mode register (output mode)
enum {
	TIM16_CCMR1_OUTPUT_OC1M_2 = 1UL<<16, // Output Compare 1 mode
	TIM16_CCMR1_OUTPUT_OC1M = ((1UL<<3)-1) << 4, // Output Compare 1 mode
	TIM16_CCMR1_OUTPUT_OC1PE = 1UL<<3, // Output Compare 1 preload enable
	TIM16_CCMR1_OUTPUT_OC1FE = 1UL<<2, // Output Compare 1 fast enable
	TIM16_CCMR1_OUTPUT_CC1S = ((1UL<<2)-1) << 0, // Capture/Compare 1 selection		
};
static inline void tim16_ccmr1_output_set_oc1m(uint32_t val) { TIM16.CCMR1_Output = (TIM16.CCMR1_Output & ~TIM16_CCMR1_OUTPUT_OC1M) | ((val<<4) & TIM16_CCMR1_OUTPUT_OC1M); }
static inline void tim16_ccmr1_output_set_cc1s(uint32_t val) { TIM16.CCMR1_Output = (TIM16.CCMR1_Output & ~TIM16_CCMR1_OUTPUT_CC1S) | ((val<<0) & TIM16_CCMR1_OUTPUT_CC1S); }
static inline uint32_t tim16_ccmr1_output_get_oc1m(void) { return (TIM16.CCMR1_Output & TIM16_CCMR1_OUTPUT_OC1M) >> 4 ; }
static inline uint32_t tim16_ccmr1_output_get_cc1s(void) { return (TIM16.CCMR1_Output & TIM16_CCMR1_OUTPUT_CC1S) >> 0 ; }

// TIM16->CCER capture/compare enable register
enum {
	TIM16_CCER_CC1NP = 1UL<<3, // Capture/Compare 1 output Polarity
	TIM16_CCER_CC1NE = 1UL<<2, // Capture/Compare 1 complementary output enable
	TIM16_CCER_CC1P = 1UL<<1, // Capture/Compare 1 output Polarity
	TIM16_CCER_CC1E = 1UL<<0, // Capture/Compare 1 output enable		
};

// TIM16->CNT counter
enum {
	TIM16_CNT_UIFCPY = 1UL<<31, // UIF Copy
	TIM16_CNT_CNT = ((1UL<<16)-1) << 0, // counter value		
};
static inline void tim16_cnt_set_cnt(uint32_t val) { TIM16.CNT = (TIM16.CNT & ~TIM16_CNT_CNT) | ((val<<0) & TIM16_CNT_CNT); }
static inline uint32_t tim16_cnt_get_cnt(void) { return (TIM16.CNT & TIM16_CNT_CNT) >> 0 ; }

// TIM16->BDTR break and dead-time register
enum {
	TIM16_BDTR_BKF = ((1UL<<4)-1) << 16, // Break filter
	TIM16_BDTR_MOE = 1UL<<15, // Main output enable
	TIM16_BDTR_AOE = 1UL<<14, // Automatic output enable
	TIM16_BDTR_BKP = 1UL<<13, // Break polarity
	TIM16_BDTR_BKE = 1UL<<12, // Break enable
	TIM16_BDTR_OSSR = 1UL<<11, // Off-state selection for Run mode
	TIM16_BDTR_OSSI = 1UL<<10, // Off-state selection for Idle mode
	TIM16_BDTR_LOCK = ((1UL<<2)-1) << 8, // Lock configuration
	TIM16_BDTR_DTG = ((1UL<<8)-1) << 0, // Dead-time generator setup		
};
static inline void tim16_bdtr_set_bkf(uint32_t val) { TIM16.BDTR = (TIM16.BDTR & ~TIM16_BDTR_BKF) | ((val<<16) & TIM16_BDTR_BKF); }
static inline void tim16_bdtr_set_lock(uint32_t val) { TIM16.BDTR = (TIM16.BDTR & ~TIM16_BDTR_LOCK) | ((val<<8) & TIM16_BDTR_LOCK); }
static inline void tim16_bdtr_set_dtg(uint32_t val) { TIM16.BDTR = (TIM16.BDTR & ~TIM16_BDTR_DTG) | ((val<<0) & TIM16_BDTR_DTG); }
static inline uint32_t tim16_bdtr_get_bkf(void) { return (TIM16.BDTR & TIM16_BDTR_BKF) >> 16 ; }
static inline uint32_t tim16_bdtr_get_lock(void) { return (TIM16.BDTR & TIM16_BDTR_LOCK) >> 8 ; }
static inline uint32_t tim16_bdtr_get_dtg(void) { return (TIM16.BDTR & TIM16_BDTR_DTG) >> 0 ; }

// TIM16->DCR DMA control register
enum {
	TIM16_DCR_DBL = ((1UL<<5)-1) << 8, // DMA burst length
	TIM16_DCR_DBA = ((1UL<<5)-1) << 0, // DMA base address		
};
static inline void tim16_dcr_set_dbl(uint32_t val) { TIM16.DCR = (TIM16.DCR & ~TIM16_DCR_DBL) | ((val<<8) & TIM16_DCR_DBL); }
static inline void tim16_dcr_set_dba(uint32_t val) { TIM16.DCR = (TIM16.DCR & ~TIM16_DCR_DBA) | ((val<<0) & TIM16_DCR_DBA); }
static inline uint32_t tim16_dcr_get_dbl(void) { return (TIM16.DCR & TIM16_DCR_DBL) >> 8 ; }
static inline uint32_t tim16_dcr_get_dba(void) { return (TIM16.DCR & TIM16_DCR_DBA) >> 0 ; }

// TIM16->OR1 TIM16 option register 1
enum {
	TIM16_OR1_TI1_RMP = ((1UL<<2)-1) << 0, // Input capture 1 remap		
};
static inline void tim16_or1_set_ti1_rmp(uint32_t val) { TIM16.OR1 = (TIM16.OR1 & ~TIM16_OR1_TI1_RMP) | ((val<<0) & TIM16_OR1_TI1_RMP); }
static inline uint32_t tim16_or1_get_ti1_rmp(void) { return (TIM16.OR1 & TIM16_OR1_TI1_RMP) >> 0 ; }

// TIM16->OR2 TIM17 option register 1
enum {
	TIM16_OR2_BKCMP2P = 1UL<<11, // BRK COMP2 input polarit
	TIM16_OR2_BKCMP1P = 1UL<<10, // BRK COMP1 input polarity
	TIM16_OR2_BKINP = 1UL<<9, // BRK BKIN input polarity
	TIM16_OR2_BKDFBK1E = 1UL<<8, // BRK DFSDM_BREAK1 enable
	TIM16_OR2_BKCMP2E = 1UL<<2, // BRK COMP2 enable
	TIM16_OR2_BKCMP1E = 1UL<<1, // BRK COMP1 enable
	TIM16_OR2_BKINE = 1UL<<0, // BRK BKIN input enable		
};

// Valid Casts:
 
static inline struct TIM15_Type* TIM16_as_TIM15_Type(struct TIM16_Type* p) { return (struct TIM15_Type*)p; }


/* General-purpose-timers */
struct TIM2_Type {
	__IO uint16_t CR1; // @0 control register 1
	 uint8_t RESERVED0[2]; // @2 
	__IO uint8_t CR2; // @4 control register 2
	 uint8_t RESERVED1[3]; // @5 
	__IO uint16_t SMCR; // @8 slave mode control register
	 uint8_t RESERVED2[2]; // @10 
	__IO uint16_t DIER; // @12 DMA/Interrupt enable register
	 uint8_t RESERVED3[2]; // @14 
	__IO uint16_t SR; // @16 status register
	 uint8_t RESERVED4[2]; // @18 
	__O uint8_t EGR; // @20 event generation register
	 uint8_t RESERVED5[3]; // @21 
	union {  // @24
		__IO uint16_t CCMR1_Output; // capture/compare mode register 1 (output mode)
		__IO uint16_t CCMR1_Input; // capture/compare mode register 1 (input mode)
	};
	 uint8_t RESERVED6[2]; // @26 
	union {  // @28
		__IO uint16_t CCMR2_Output; // capture/compare mode register 2 (output mode)
		__IO uint16_t CCMR2_Input; // capture/compare mode register 2 (input mode)
	};
	 uint8_t RESERVED7[2]; // @30 
	__IO uint16_t CCER; // @32 capture/compare enable register
	 uint8_t RESERVED8[2]; // @34 
	__IO uint32_t CNT; // @36 counter
	__IO uint16_t PSC; // @40 prescaler
	 uint8_t RESERVED9[2]; // @42 
	__IO uint32_t ARR; // @44 auto-reload register
	 uint8_t RESERVED10[4]; // @48 
	__IO uint32_t CCR1; // @52 capture/compare register 1
	__IO uint32_t CCR2; // @56 capture/compare register 2
	__IO uint32_t CCR3; // @60 capture/compare register 3
	__IO uint32_t CCR4; // @64 capture/compare register 4
	 uint8_t RESERVED11[4]; // @68 
	__IO uint16_t DCR; // @72 DMA control register
	 uint8_t RESERVED12[2]; // @74 
	__IO uint16_t DMAR; // @76 DMA address for full transfer
	 uint8_t RESERVED13[2]; // @78 
	__IO uint8_t OR; // @80 TIM2 option register
};
extern struct TIM2_Type	TIM2;	// @0x40000000 
extern struct TIM2_Type 	TIM3;	// @0x40000400

// TIM2->CR1 control register 1
enum {
	TIM2_CR1_CKD = ((1UL<<2)-1) << 8, // Clock division
	TIM2_CR1_ARPE = 1UL<<7, // Auto-reload preload enable
	TIM2_CR1_CMS = ((1UL<<2)-1) << 5, // Center-aligned mode selection
	TIM2_CR1_DIR = 1UL<<4, // Direction
	TIM2_CR1_OPM = 1UL<<3, // One-pulse mode
	TIM2_CR1_URS = 1UL<<2, // Update request source
	TIM2_CR1_UDIS = 1UL<<1, // Update disable
	TIM2_CR1_CEN = 1UL<<0, // Counter enable		
};
static inline void tim2_cr1_set_ckd(struct TIM2_Type* p, uint32_t val) { p->CR1 = (p->CR1 & ~TIM2_CR1_CKD) | ((val<<8) & TIM2_CR1_CKD); }
static inline void tim2_cr1_set_cms(struct TIM2_Type* p, uint32_t val) { p->CR1 = (p->CR1 & ~TIM2_CR1_CMS) | ((val<<5) & TIM2_CR1_CMS); }
static inline uint32_t tim2_cr1_get_ckd(struct TIM2_Type* p) { return (p->CR1 & TIM2_CR1_CKD) >> 8 ; }
static inline uint32_t tim2_cr1_get_cms(struct TIM2_Type* p) { return (p->CR1 & TIM2_CR1_CMS) >> 5 ; }

// TIM2->CR2 control register 2
enum {
	TIM2_CR2_TI1S = 1UL<<7, // TI1 selection
	TIM2_CR2_MMS = ((1UL<<3)-1) << 4, // Master mode selection
	TIM2_CR2_CCDS = 1UL<<3, // Capture/compare DMA selection		
};
static inline void tim2_cr2_set_mms(struct TIM2_Type* p, uint32_t val) { p->CR2 = (p->CR2 & ~TIM2_CR2_MMS) | ((val<<4) & TIM2_CR2_MMS); }
static inline uint32_t tim2_cr2_get_mms(struct TIM2_Type* p) { return (p->CR2 & TIM2_CR2_MMS) >> 4 ; }

// TIM2->SMCR slave mode control register
enum {
	TIM2_SMCR_ETP = 1UL<<15, // External trigger polarity
	TIM2_SMCR_ECE = 1UL<<14, // External clock enable
	TIM2_SMCR_ETPS = ((1UL<<2)-1) << 12, // External trigger prescaler
	TIM2_SMCR_ETF = ((1UL<<4)-1) << 8, // External trigger filter
	TIM2_SMCR_MSM = 1UL<<7, // Master/Slave mode
	TIM2_SMCR_TS = ((1UL<<3)-1) << 4, // Trigger selection
	TIM2_SMCR_SMS = ((1UL<<3)-1) << 0, // Slave mode selection		
};
static inline void tim2_smcr_set_etps(struct TIM2_Type* p, uint32_t val) { p->SMCR = (p->SMCR & ~TIM2_SMCR_ETPS) | ((val<<12) & TIM2_SMCR_ETPS); }
static inline void tim2_smcr_set_etf(struct TIM2_Type* p, uint32_t val) { p->SMCR = (p->SMCR & ~TIM2_SMCR_ETF) | ((val<<8) & TIM2_SMCR_ETF); }
static inline void tim2_smcr_set_ts(struct TIM2_Type* p, uint32_t val) { p->SMCR = (p->SMCR & ~TIM2_SMCR_TS) | ((val<<4) & TIM2_SMCR_TS); }
static inline void tim2_smcr_set_sms(struct TIM2_Type* p, uint32_t val) { p->SMCR = (p->SMCR & ~TIM2_SMCR_SMS) | ((val<<0) & TIM2_SMCR_SMS); }
static inline uint32_t tim2_smcr_get_etps(struct TIM2_Type* p) { return (p->SMCR & TIM2_SMCR_ETPS) >> 12 ; }
static inline uint32_t tim2_smcr_get_etf(struct TIM2_Type* p) { return (p->SMCR & TIM2_SMCR_ETF) >> 8 ; }
static inline uint32_t tim2_smcr_get_ts(struct TIM2_Type* p) { return (p->SMCR & TIM2_SMCR_TS) >> 4 ; }
static inline uint32_t tim2_smcr_get_sms(struct TIM2_Type* p) { return (p->SMCR & TIM2_SMCR_SMS) >> 0 ; }

// TIM2->DIER DMA/Interrupt enable register
enum {
	TIM2_DIER_TDE = 1UL<<14, // Trigger DMA request enable
	TIM2_DIER_COMDE = 1UL<<13, // COM DMA request enable
	TIM2_DIER_CC4DE = 1UL<<12, // Capture/Compare 4 DMA request enable
	TIM2_DIER_CC3DE = 1UL<<11, // Capture/Compare 3 DMA request enable
	TIM2_DIER_CC2DE = 1UL<<10, // Capture/Compare 2 DMA request enable
	TIM2_DIER_CC1DE = 1UL<<9, // Capture/Compare 1 DMA request enable
	TIM2_DIER_UDE = 1UL<<8, // Update DMA request enable
	TIM2_DIER_TIE = 1UL<<6, // Trigger interrupt enable
	TIM2_DIER_CC4IE = 1UL<<4, // Capture/Compare 4 interrupt enable
	TIM2_DIER_CC3IE = 1UL<<3, // Capture/Compare 3 interrupt enable
	TIM2_DIER_CC2IE = 1UL<<2, // Capture/Compare 2 interrupt enable
	TIM2_DIER_CC1IE = 1UL<<1, // Capture/Compare 1 interrupt enable
	TIM2_DIER_UIE = 1UL<<0, // Update interrupt enable		
};

// TIM2->SR status register
enum {
	TIM2_SR_CC4OF = 1UL<<12, // Capture/Compare 4 overcapture flag
	TIM2_SR_CC3OF = 1UL<<11, // Capture/Compare 3 overcapture flag
	TIM2_SR_CC2OF = 1UL<<10, // Capture/compare 2 overcapture flag
	TIM2_SR_CC1OF = 1UL<<9, // Capture/Compare 1 overcapture flag
	TIM2_SR_TIF = 1UL<<6, // Trigger interrupt flag
	TIM2_SR_CC4IF = 1UL<<4, // Capture/Compare 4 interrupt flag
	TIM2_SR_CC3IF = 1UL<<3, // Capture/Compare 3 interrupt flag
	TIM2_SR_CC2IF = 1UL<<2, // Capture/Compare 2 interrupt flag
	TIM2_SR_CC1IF = 1UL<<1, // Capture/compare 1 interrupt flag
	TIM2_SR_UIF = 1UL<<0, // Update interrupt flag		
};

// TIM2->EGR event generation register
enum {
	TIM2_EGR_TG = 1UL<<6, // Trigger generation
	TIM2_EGR_CC4G = 1UL<<4, // Capture/compare 4 generation
	TIM2_EGR_CC3G = 1UL<<3, // Capture/compare 3 generation
	TIM2_EGR_CC2G = 1UL<<2, // Capture/compare 2 generation
	TIM2_EGR_CC1G = 1UL<<1, // Capture/compare 1 generation
	TIM2_EGR_UG = 1UL<<0, // Update generation		
};

// TIM2->CCMR1_Output capture/compare mode register 1 (output mode)
enum {
	TIM2_CCMR1_OUTPUT_OC2CE = 1UL<<15, // Output compare 2 clear enable
	TIM2_CCMR1_OUTPUT_OC2M = ((1UL<<3)-1) << 12, // Output compare 2 mode
	TIM2_CCMR1_OUTPUT_OC2PE = 1UL<<11, // Output compare 2 preload enable
	TIM2_CCMR1_OUTPUT_OC2FE = 1UL<<10, // Output compare 2 fast enable
	TIM2_CCMR1_OUTPUT_CC2S = ((1UL<<2)-1) << 8, // Capture/Compare 2 selection
	TIM2_CCMR1_OUTPUT_OC1CE = 1UL<<7, // Output compare 1 clear enable
	TIM2_CCMR1_OUTPUT_OC1M = ((1UL<<3)-1) << 4, // Output compare 1 mode
	TIM2_CCMR1_OUTPUT_OC1PE = 1UL<<3, // Output compare 1 preload enable
	TIM2_CCMR1_OUTPUT_OC1FE = 1UL<<2, // Output compare 1 fast enable
	TIM2_CCMR1_OUTPUT_CC1S = ((1UL<<2)-1) << 0, // Capture/Compare 1 selection		
};
static inline void tim2_ccmr1_output_set_oc2m(struct TIM2_Type* p, uint32_t val) { p->CCMR1_Output = (p->CCMR1_Output & ~TIM2_CCMR1_OUTPUT_OC2M) | ((val<<12) & TIM2_CCMR1_OUTPUT_OC2M); }
static inline void tim2_ccmr1_output_set_cc2s(struct TIM2_Type* p, uint32_t val) { p->CCMR1_Output = (p->CCMR1_Output & ~TIM2_CCMR1_OUTPUT_CC2S) | ((val<<8) & TIM2_CCMR1_OUTPUT_CC2S); }
static inline void tim2_ccmr1_output_set_oc1m(struct TIM2_Type* p, uint32_t val) { p->CCMR1_Output = (p->CCMR1_Output & ~TIM2_CCMR1_OUTPUT_OC1M) | ((val<<4) & TIM2_CCMR1_OUTPUT_OC1M); }
static inline void tim2_ccmr1_output_set_cc1s(struct TIM2_Type* p, uint32_t val) { p->CCMR1_Output = (p->CCMR1_Output & ~TIM2_CCMR1_OUTPUT_CC1S) | ((val<<0) & TIM2_CCMR1_OUTPUT_CC1S); }
static inline uint32_t tim2_ccmr1_output_get_oc2m(struct TIM2_Type* p) { return (p->CCMR1_Output & TIM2_CCMR1_OUTPUT_OC2M) >> 12 ; }
static inline uint32_t tim2_ccmr1_output_get_cc2s(struct TIM2_Type* p) { return (p->CCMR1_Output & TIM2_CCMR1_OUTPUT_CC2S) >> 8 ; }
static inline uint32_t tim2_ccmr1_output_get_oc1m(struct TIM2_Type* p) { return (p->CCMR1_Output & TIM2_CCMR1_OUTPUT_OC1M) >> 4 ; }
static inline uint32_t tim2_ccmr1_output_get_cc1s(struct TIM2_Type* p) { return (p->CCMR1_Output & TIM2_CCMR1_OUTPUT_CC1S) >> 0 ; }

// TIM2->CCMR2_Output capture/compare mode register 2 (output mode)
enum {
	TIM2_CCMR2_OUTPUT_OC4CE = 1UL<<15, // Output compare 4 clear enable
	TIM2_CCMR2_OUTPUT_OC4M = ((1UL<<3)-1) << 12, // Output compare 4 mode
	TIM2_CCMR2_OUTPUT_OC4PE = 1UL<<11, // Output compare 4 preload enable
	TIM2_CCMR2_OUTPUT_OC4FE = 1UL<<10, // Output compare 4 fast enable
	TIM2_CCMR2_OUTPUT_CC4S = ((1UL<<2)-1) << 8, // Capture/Compare 4 selection
	TIM2_CCMR2_OUTPUT_OC3CE = 1UL<<7, // Output compare 3 clear enable
	TIM2_CCMR2_OUTPUT_OC3M = ((1UL<<3)-1) << 4, // Output compare 3 mode
	TIM2_CCMR2_OUTPUT_OC3PE = 1UL<<3, // Output compare 3 preload enable
	TIM2_CCMR2_OUTPUT_OC3FE = 1UL<<2, // Output compare 3 fast enable
	TIM2_CCMR2_OUTPUT_CC3S = ((1UL<<2)-1) << 0, // Capture/Compare 3 selection		
};
static inline void tim2_ccmr2_output_set_oc4m(struct TIM2_Type* p, uint32_t val) { p->CCMR2_Output = (p->CCMR2_Output & ~TIM2_CCMR2_OUTPUT_OC4M) | ((val<<12) & TIM2_CCMR2_OUTPUT_OC4M); }
static inline void tim2_ccmr2_output_set_cc4s(struct TIM2_Type* p, uint32_t val) { p->CCMR2_Output = (p->CCMR2_Output & ~TIM2_CCMR2_OUTPUT_CC4S) | ((val<<8) & TIM2_CCMR2_OUTPUT_CC4S); }
static inline void tim2_ccmr2_output_set_oc3m(struct TIM2_Type* p, uint32_t val) { p->CCMR2_Output = (p->CCMR2_Output & ~TIM2_CCMR2_OUTPUT_OC3M) | ((val<<4) & TIM2_CCMR2_OUTPUT_OC3M); }
static inline void tim2_ccmr2_output_set_cc3s(struct TIM2_Type* p, uint32_t val) { p->CCMR2_Output = (p->CCMR2_Output & ~TIM2_CCMR2_OUTPUT_CC3S) | ((val<<0) & TIM2_CCMR2_OUTPUT_CC3S); }
static inline uint32_t tim2_ccmr2_output_get_oc4m(struct TIM2_Type* p) { return (p->CCMR2_Output & TIM2_CCMR2_OUTPUT_OC4M) >> 12 ; }
static inline uint32_t tim2_ccmr2_output_get_cc4s(struct TIM2_Type* p) { return (p->CCMR2_Output & TIM2_CCMR2_OUTPUT_CC4S) >> 8 ; }
static inline uint32_t tim2_ccmr2_output_get_oc3m(struct TIM2_Type* p) { return (p->CCMR2_Output & TIM2_CCMR2_OUTPUT_OC3M) >> 4 ; }
static inline uint32_t tim2_ccmr2_output_get_cc3s(struct TIM2_Type* p) { return (p->CCMR2_Output & TIM2_CCMR2_OUTPUT_CC3S) >> 0 ; }

// TIM2->CCER capture/compare enable register
enum {
	TIM2_CCER_CC4NP = 1UL<<15, // Capture/Compare 4 output Polarity
	TIM2_CCER_CC4P = 1UL<<13, // Capture/Compare 3 output Polarity
	TIM2_CCER_CC4E = 1UL<<12, // Capture/Compare 4 output enable
	TIM2_CCER_CC3NP = 1UL<<11, // Capture/Compare 3 output Polarity
	TIM2_CCER_CC3P = 1UL<<9, // Capture/Compare 3 output Polarity
	TIM2_CCER_CC3E = 1UL<<8, // Capture/Compare 3 output enable
	TIM2_CCER_CC2NP = 1UL<<7, // Capture/Compare 2 output Polarity
	TIM2_CCER_CC2P = 1UL<<5, // Capture/Compare 2 output Polarity
	TIM2_CCER_CC2E = 1UL<<4, // Capture/Compare 2 output enable
	TIM2_CCER_CC1NP = 1UL<<3, // Capture/Compare 1 output Polarity
	TIM2_CCER_CC1P = 1UL<<1, // Capture/Compare 1 output Polarity
	TIM2_CCER_CC1E = 1UL<<0, // Capture/Compare 1 output enable		
};

// TIM2->CNT counter
enum {
	TIM2_CNT_CNT_H = ((1UL<<16)-1) << 16, // High counter value (TIM2 only)
	TIM2_CNT_CNT_L = ((1UL<<16)-1) << 0, // Low counter value		
};
static inline void tim2_cnt_set_cnt_h(struct TIM2_Type* p, uint32_t val) { p->CNT = (p->CNT & ~TIM2_CNT_CNT_H) | ((val<<16) & TIM2_CNT_CNT_H); }
static inline void tim2_cnt_set_cnt_l(struct TIM2_Type* p, uint32_t val) { p->CNT = (p->CNT & ~TIM2_CNT_CNT_L) | ((val<<0) & TIM2_CNT_CNT_L); }
static inline uint32_t tim2_cnt_get_cnt_h(struct TIM2_Type* p) { return (p->CNT & TIM2_CNT_CNT_H) >> 16 ; }
static inline uint32_t tim2_cnt_get_cnt_l(struct TIM2_Type* p) { return (p->CNT & TIM2_CNT_CNT_L) >> 0 ; }

// TIM2->ARR auto-reload register
enum {
	TIM2_ARR_ARR_H = ((1UL<<16)-1) << 16, // High Auto-reload value (TIM2 only)
	TIM2_ARR_ARR_L = ((1UL<<16)-1) << 0, // Low Auto-reload value		
};
static inline void tim2_arr_set_arr_h(struct TIM2_Type* p, uint32_t val) { p->ARR = (p->ARR & ~TIM2_ARR_ARR_H) | ((val<<16) & TIM2_ARR_ARR_H); }
static inline void tim2_arr_set_arr_l(struct TIM2_Type* p, uint32_t val) { p->ARR = (p->ARR & ~TIM2_ARR_ARR_L) | ((val<<0) & TIM2_ARR_ARR_L); }
static inline uint32_t tim2_arr_get_arr_h(struct TIM2_Type* p) { return (p->ARR & TIM2_ARR_ARR_H) >> 16 ; }
static inline uint32_t tim2_arr_get_arr_l(struct TIM2_Type* p) { return (p->ARR & TIM2_ARR_ARR_L) >> 0 ; }

// TIM2->CCR1 capture/compare register 1
enum {
	TIM2_CCR1_CCR1_H = ((1UL<<16)-1) << 16, // High Capture/Compare 1 value (TIM2 only)
	TIM2_CCR1_CCR1_L = ((1UL<<16)-1) << 0, // Low Capture/Compare 1 value		
};
static inline void tim2_ccr1_set_ccr1_h(struct TIM2_Type* p, uint32_t val) { p->CCR1 = (p->CCR1 & ~TIM2_CCR1_CCR1_H) | ((val<<16) & TIM2_CCR1_CCR1_H); }
static inline void tim2_ccr1_set_ccr1_l(struct TIM2_Type* p, uint32_t val) { p->CCR1 = (p->CCR1 & ~TIM2_CCR1_CCR1_L) | ((val<<0) & TIM2_CCR1_CCR1_L); }
static inline uint32_t tim2_ccr1_get_ccr1_h(struct TIM2_Type* p) { return (p->CCR1 & TIM2_CCR1_CCR1_H) >> 16 ; }
static inline uint32_t tim2_ccr1_get_ccr1_l(struct TIM2_Type* p) { return (p->CCR1 & TIM2_CCR1_CCR1_L) >> 0 ; }

// TIM2->CCR2 capture/compare register 2
enum {
	TIM2_CCR2_CCR2_H = ((1UL<<16)-1) << 16, // High Capture/Compare 2 value (TIM2 only)
	TIM2_CCR2_CCR2_L = ((1UL<<16)-1) << 0, // Low Capture/Compare 2 value		
};
static inline void tim2_ccr2_set_ccr2_h(struct TIM2_Type* p, uint32_t val) { p->CCR2 = (p->CCR2 & ~TIM2_CCR2_CCR2_H) | ((val<<16) & TIM2_CCR2_CCR2_H); }
static inline void tim2_ccr2_set_ccr2_l(struct TIM2_Type* p, uint32_t val) { p->CCR2 = (p->CCR2 & ~TIM2_CCR2_CCR2_L) | ((val<<0) & TIM2_CCR2_CCR2_L); }
static inline uint32_t tim2_ccr2_get_ccr2_h(struct TIM2_Type* p) { return (p->CCR2 & TIM2_CCR2_CCR2_H) >> 16 ; }
static inline uint32_t tim2_ccr2_get_ccr2_l(struct TIM2_Type* p) { return (p->CCR2 & TIM2_CCR2_CCR2_L) >> 0 ; }

// TIM2->CCR3 capture/compare register 3
enum {
	TIM2_CCR3_CCR3_H = ((1UL<<16)-1) << 16, // High Capture/Compare value (TIM2 only)
	TIM2_CCR3_CCR3_L = ((1UL<<16)-1) << 0, // Low Capture/Compare value		
};
static inline void tim2_ccr3_set_ccr3_h(struct TIM2_Type* p, uint32_t val) { p->CCR3 = (p->CCR3 & ~TIM2_CCR3_CCR3_H) | ((val<<16) & TIM2_CCR3_CCR3_H); }
static inline void tim2_ccr3_set_ccr3_l(struct TIM2_Type* p, uint32_t val) { p->CCR3 = (p->CCR3 & ~TIM2_CCR3_CCR3_L) | ((val<<0) & TIM2_CCR3_CCR3_L); }
static inline uint32_t tim2_ccr3_get_ccr3_h(struct TIM2_Type* p) { return (p->CCR3 & TIM2_CCR3_CCR3_H) >> 16 ; }
static inline uint32_t tim2_ccr3_get_ccr3_l(struct TIM2_Type* p) { return (p->CCR3 & TIM2_CCR3_CCR3_L) >> 0 ; }

// TIM2->CCR4 capture/compare register 4
enum {
	TIM2_CCR4_CCR4_H = ((1UL<<16)-1) << 16, // High Capture/Compare value (TIM2 only)
	TIM2_CCR4_CCR4_L = ((1UL<<16)-1) << 0, // Low Capture/Compare value		
};
static inline void tim2_ccr4_set_ccr4_h(struct TIM2_Type* p, uint32_t val) { p->CCR4 = (p->CCR4 & ~TIM2_CCR4_CCR4_H) | ((val<<16) & TIM2_CCR4_CCR4_H); }
static inline void tim2_ccr4_set_ccr4_l(struct TIM2_Type* p, uint32_t val) { p->CCR4 = (p->CCR4 & ~TIM2_CCR4_CCR4_L) | ((val<<0) & TIM2_CCR4_CCR4_L); }
static inline uint32_t tim2_ccr4_get_ccr4_h(struct TIM2_Type* p) { return (p->CCR4 & TIM2_CCR4_CCR4_H) >> 16 ; }
static inline uint32_t tim2_ccr4_get_ccr4_l(struct TIM2_Type* p) { return (p->CCR4 & TIM2_CCR4_CCR4_L) >> 0 ; }

// TIM2->DCR DMA control register
enum {
	TIM2_DCR_DBL = ((1UL<<5)-1) << 8, // DMA burst length
	TIM2_DCR_DBA = ((1UL<<5)-1) << 0, // DMA base address		
};
static inline void tim2_dcr_set_dbl(struct TIM2_Type* p, uint32_t val) { p->DCR = (p->DCR & ~TIM2_DCR_DBL) | ((val<<8) & TIM2_DCR_DBL); }
static inline void tim2_dcr_set_dba(struct TIM2_Type* p, uint32_t val) { p->DCR = (p->DCR & ~TIM2_DCR_DBA) | ((val<<0) & TIM2_DCR_DBA); }
static inline uint32_t tim2_dcr_get_dbl(struct TIM2_Type* p) { return (p->DCR & TIM2_DCR_DBL) >> 8 ; }
static inline uint32_t tim2_dcr_get_dba(struct TIM2_Type* p) { return (p->DCR & TIM2_DCR_DBA) >> 0 ; }

// TIM2->OR TIM2 option register
enum {
	TIM2_OR_TI4_RMP = ((1UL<<2)-1) << 3, // Internal trigger
	TIM2_OR_ETR_RMP = ((1UL<<3)-1) << 0, // Timer2 ETR remap		
};
static inline void tim2_or_set_ti4_rmp(struct TIM2_Type* p, uint32_t val) { p->OR = (p->OR & ~TIM2_OR_TI4_RMP) | ((val<<3) & TIM2_OR_TI4_RMP); }
static inline void tim2_or_set_etr_rmp(struct TIM2_Type* p, uint32_t val) { p->OR = (p->OR & ~TIM2_OR_ETR_RMP) | ((val<<0) & TIM2_OR_ETR_RMP); }
static inline uint32_t tim2_or_get_ti4_rmp(struct TIM2_Type* p) { return (p->OR & TIM2_OR_TI4_RMP) >> 3 ; }
static inline uint32_t tim2_or_get_etr_rmp(struct TIM2_Type* p) { return (p->OR & TIM2_OR_ETR_RMP) >> 0 ; }


/* Basic-timers */
struct TIM6_Type {
	__IO uint8_t CR1; // @0 control register 1
	 uint8_t RESERVED0[3]; // @1 
	__IO uint8_t CR2; // @4 control register 2
	 uint8_t RESERVED1[7]; // @5 
	__IO uint16_t DIER; // @12 DMA/Interrupt enable register
	 uint8_t RESERVED2[2]; // @14 
	__IO uint8_t SR; // @16 status register
	 uint8_t RESERVED3[3]; // @17 
	__O uint8_t EGR; // @20 event generation register
	 uint8_t RESERVED4[15]; // @21 
	__IO uint16_t CNT; // @36 counter
	 uint8_t RESERVED5[2]; // @38 
	__IO uint16_t PSC; // @40 prescaler
	 uint8_t RESERVED6[2]; // @42 
	__IO uint16_t ARR; // @44 auto-reload register
};
extern struct TIM6_Type	TIM6;	// @0x40001000 
extern struct TIM6_Type 	TIM7;	// @0x40001400

// TIM6->CR1 control register 1
enum {
	TIM6_CR1_ARPE = 1UL<<7, // Auto-reload preload enable
	TIM6_CR1_OPM = 1UL<<3, // One-pulse mode
	TIM6_CR1_URS = 1UL<<2, // Update request source
	TIM6_CR1_UDIS = 1UL<<1, // Update disable
	TIM6_CR1_CEN = 1UL<<0, // Counter enable		
};

// TIM6->CR2 control register 2
enum {
	TIM6_CR2_MMS = ((1UL<<3)-1) << 4, // Master mode selection		
};
static inline void tim6_cr2_set_mms(struct TIM6_Type* p, uint32_t val) { p->CR2 = (p->CR2 & ~TIM6_CR2_MMS) | ((val<<4) & TIM6_CR2_MMS); }
static inline uint32_t tim6_cr2_get_mms(struct TIM6_Type* p) { return (p->CR2 & TIM6_CR2_MMS) >> 4 ; }

// TIM6->DIER DMA/Interrupt enable register
enum {
	TIM6_DIER_UDE = 1UL<<8, // Update DMA request enable
	TIM6_DIER_UIE = 1UL<<0, // Update interrupt enable		
};

// TIM6->SR status register
enum {
	TIM6_SR_UIF = 1UL<<0, // Update interrupt flag		
};

// TIM6->EGR event generation register
enum {
	TIM6_EGR_UG = 1UL<<0, // Update generation		
};



/* Universal synchronous asynchronous receiver transmitter */
struct UART_Type {
	__IO uint32_t CR1; // @0 Control register 1
	__IO uint32_t CR2; // @4 Control register 2
	__IO uint32_t CR3; // @8 Control register 3
	__IO uint16_t BRR; // @12 Baud rate register
	 uint8_t RESERVED0[2]; // @14 
	__IO uint16_t GTPR; // @16 Guard time and prescaler register
	 uint8_t RESERVED1[2]; // @18 
	__IO uint32_t RTOR; // @20 Receiver timeout register
	__O uint8_t RQR; // @24 Request register
	 uint8_t RESERVED2[3]; // @25 
	__I uint32_t ISR; // @28 Interrupt & status register
	__O uint32_t ICR; // @32 Interrupt flag clear register
	__I uint16_t RDR; // @36 Receive data register
	 uint8_t RESERVED3[2]; // @38 
	__IO uint16_t TDR; // @40 Transmit data register
};
extern struct UART_Type	USART1;	// @0x40013800 
extern struct UART_Type 	UART4;	// @0x40004C00
extern struct UART_Type 	USART2;	// @0x40004400
extern struct UART_Type 	USART3;	// @0x40004800

// UART->CR1 Control register 1
enum {
	UART_CR1_M1 = 1UL<<28, // Word length
	UART_CR1_EOBIE = 1UL<<27, // End of Block interrupt enable
	UART_CR1_RTOIE = 1UL<<26, // Receiver timeout interrupt enable
	UART_CR1_DEAT = ((1UL<<5)-1) << 21, // DEAT0
	UART_CR1_DEDT = ((1UL<<5)-1) << 16, // DEDT0
	UART_CR1_OVER8 = 1UL<<15, // Oversampling mode
	UART_CR1_CMIE = 1UL<<14, // Character match interrupt enable
	UART_CR1_MME = 1UL<<13, // Mute mode enable
	UART_CR1_M0 = 1UL<<12, // Word length
	UART_CR1_WAKE = 1UL<<11, // Receiver wakeup method
	UART_CR1_PCE = 1UL<<10, // Parity control enable
	UART_CR1_PS = 1UL<<9, // Parity selection
	UART_CR1_PEIE = 1UL<<8, // PE interrupt enable
	UART_CR1_TXEIE = 1UL<<7, // interrupt enable
	UART_CR1_TCIE = 1UL<<6, // Transmission complete interrupt enable
	UART_CR1_RXNEIE = 1UL<<5, // RXNE interrupt enable
	UART_CR1_IDLEIE = 1UL<<4, // IDLE interrupt enable
	UART_CR1_TE = 1UL<<3, // Transmitter enable
	UART_CR1_RE = 1UL<<2, // Receiver enable
	UART_CR1_UESM = 1UL<<1, // USART enable in Stop mode
	UART_CR1_UE = 1UL<<0, // USART enable		
};
static inline void uart_cr1_set_deat(struct UART_Type* p, uint32_t val) { p->CR1 = (p->CR1 & ~UART_CR1_DEAT) | ((val<<21) & UART_CR1_DEAT); }
static inline void uart_cr1_set_dedt(struct UART_Type* p, uint32_t val) { p->CR1 = (p->CR1 & ~UART_CR1_DEDT) | ((val<<16) & UART_CR1_DEDT); }
static inline uint32_t uart_cr1_get_deat(struct UART_Type* p) { return (p->CR1 & UART_CR1_DEAT) >> 21 ; }
static inline uint32_t uart_cr1_get_dedt(struct UART_Type* p) { return (p->CR1 & UART_CR1_DEDT) >> 16 ; }

// UART->CR2 Control register 2
enum {
	UART_CR2_ADD = ((1UL<<8)-1) << 24, // Address of the USART node
	UART_CR2_RTOEN = 1UL<<23, // Receiver timeout enable
	UART_CR2_ABRMOD = ((1UL<<2)-1) << 21, // Auto baud rate mode
	UART_CR2_ABREN = 1UL<<20, // Auto baud rate enable
	UART_CR2_MSBFIRST = 1UL<<19, // Most significant bit first
	UART_CR2_TAINV = 1UL<<18, // Binary data inversion
	UART_CR2_TXINV = 1UL<<17, // TX pin active level inversion
	UART_CR2_RXINV = 1UL<<16, // RX pin active level inversion
	UART_CR2_SWAP = 1UL<<15, // Swap TX/RX pins
	UART_CR2_LINEN = 1UL<<14, // LIN mode enable
	UART_CR2_STOP = ((1UL<<2)-1) << 12, // STOP bits
	UART_CR2_CLKEN = 1UL<<11, // Clock enable
	UART_CR2_CPOL = 1UL<<10, // Clock polarity
	UART_CR2_CPHA = 1UL<<9, // Clock phase
	UART_CR2_LBCL = 1UL<<8, // Last bit clock pulse
	UART_CR2_LBDIE = 1UL<<6, // LIN break detection interrupt enable
	UART_CR2_LBDL = 1UL<<5, // LIN break detection length
	UART_CR2_ADDM7 = 1UL<<4, // 7-bit Address Detection/4-bit Address Detection		
};
static inline void uart_cr2_set_add(struct UART_Type* p, uint32_t val) { p->CR2 = (p->CR2 & ~UART_CR2_ADD) | ((val<<24) & UART_CR2_ADD); }
static inline void uart_cr2_set_abrmod(struct UART_Type* p, uint32_t val) { p->CR2 = (p->CR2 & ~UART_CR2_ABRMOD) | ((val<<21) & UART_CR2_ABRMOD); }
static inline void uart_cr2_set_stop(struct UART_Type* p, uint32_t val) { p->CR2 = (p->CR2 & ~UART_CR2_STOP) | ((val<<12) & UART_CR2_STOP); }
static inline uint32_t uart_cr2_get_add(struct UART_Type* p) { return (p->CR2 & UART_CR2_ADD) >> 24 ; }
static inline uint32_t uart_cr2_get_abrmod(struct UART_Type* p) { return (p->CR2 & UART_CR2_ABRMOD) >> 21 ; }
static inline uint32_t uart_cr2_get_stop(struct UART_Type* p) { return (p->CR2 & UART_CR2_STOP) >> 12 ; }

// UART->CR3 Control register 3
enum {
	UART_CR3_WUFIE = 1UL<<22, // Wakeup from Stop mode interrupt enable
	UART_CR3_WUS = ((1UL<<2)-1) << 20, // Wakeup from Stop mode interrupt flag selection
	UART_CR3_SCARCNT = ((1UL<<3)-1) << 17, // Smartcard auto-retry count
	UART_CR3_DEP = 1UL<<15, // Driver enable polarity selection
	UART_CR3_DEM = 1UL<<14, // Driver enable mode
	UART_CR3_DDRE = 1UL<<13, // DMA Disable on Reception Error
	UART_CR3_OVRDIS = 1UL<<12, // Overrun Disable
	UART_CR3_ONEBIT = 1UL<<11, // One sample bit method enable
	UART_CR3_CTSIE = 1UL<<10, // CTS interrupt enable
	UART_CR3_CTSE = 1UL<<9, // CTS enable
	UART_CR3_RTSE = 1UL<<8, // RTS enable
	UART_CR3_DMAT = 1UL<<7, // DMA enable transmitter
	UART_CR3_DMAR = 1UL<<6, // DMA enable receiver
	UART_CR3_SCEN = 1UL<<5, // Smartcard mode enable
	UART_CR3_NACK = 1UL<<4, // Smartcard NACK enable
	UART_CR3_HDSEL = 1UL<<3, // Half-duplex selection
	UART_CR3_IRLP = 1UL<<2, // Ir low-power
	UART_CR3_IREN = 1UL<<1, // Ir mode enable
	UART_CR3_EIE = 1UL<<0, // Error interrupt enable		
};
static inline void uart_cr3_set_wus(struct UART_Type* p, uint32_t val) { p->CR3 = (p->CR3 & ~UART_CR3_WUS) | ((val<<20) & UART_CR3_WUS); }
static inline void uart_cr3_set_scarcnt(struct UART_Type* p, uint32_t val) { p->CR3 = (p->CR3 & ~UART_CR3_SCARCNT) | ((val<<17) & UART_CR3_SCARCNT); }
static inline uint32_t uart_cr3_get_wus(struct UART_Type* p) { return (p->CR3 & UART_CR3_WUS) >> 20 ; }
static inline uint32_t uart_cr3_get_scarcnt(struct UART_Type* p) { return (p->CR3 & UART_CR3_SCARCNT) >> 17 ; }

// UART->BRR Baud rate register
enum {
	UART_BRR_DIV_MANTISSA = ((1UL<<12)-1) << 4, // DIV_Mantissa
	UART_BRR_DIV_FRACTION = ((1UL<<4)-1) << 0, // DIV_Fraction		
};
static inline void uart_brr_set_div_mantissa(struct UART_Type* p, uint32_t val) { p->BRR = (p->BRR & ~UART_BRR_DIV_MANTISSA) | ((val<<4) & UART_BRR_DIV_MANTISSA); }
static inline void uart_brr_set_div_fraction(struct UART_Type* p, uint32_t val) { p->BRR = (p->BRR & ~UART_BRR_DIV_FRACTION) | ((val<<0) & UART_BRR_DIV_FRACTION); }
static inline uint32_t uart_brr_get_div_mantissa(struct UART_Type* p) { return (p->BRR & UART_BRR_DIV_MANTISSA) >> 4 ; }
static inline uint32_t uart_brr_get_div_fraction(struct UART_Type* p) { return (p->BRR & UART_BRR_DIV_FRACTION) >> 0 ; }

// UART->GTPR Guard time and prescaler register
enum {
	UART_GTPR_GT = ((1UL<<8)-1) << 8, // Guard time value
	UART_GTPR_PSC = ((1UL<<8)-1) << 0, // Prescaler value		
};
static inline void uart_gtpr_set_gt(struct UART_Type* p, uint32_t val) { p->GTPR = (p->GTPR & ~UART_GTPR_GT) | ((val<<8) & UART_GTPR_GT); }
static inline void uart_gtpr_set_psc(struct UART_Type* p, uint32_t val) { p->GTPR = (p->GTPR & ~UART_GTPR_PSC) | ((val<<0) & UART_GTPR_PSC); }
static inline uint32_t uart_gtpr_get_gt(struct UART_Type* p) { return (p->GTPR & UART_GTPR_GT) >> 8 ; }
static inline uint32_t uart_gtpr_get_psc(struct UART_Type* p) { return (p->GTPR & UART_GTPR_PSC) >> 0 ; }

// UART->RTOR Receiver timeout register
enum {
	UART_RTOR_BLEN = ((1UL<<8)-1) << 24, // Block Length
	UART_RTOR_RTO = ((1UL<<24)-1) << 0, // Receiver timeout value		
};
static inline void uart_rtor_set_blen(struct UART_Type* p, uint32_t val) { p->RTOR = (p->RTOR & ~UART_RTOR_BLEN) | ((val<<24) & UART_RTOR_BLEN); }
static inline void uart_rtor_set_rto(struct UART_Type* p, uint32_t val) { p->RTOR = (p->RTOR & ~UART_RTOR_RTO) | ((val<<0) & UART_RTOR_RTO); }
static inline uint32_t uart_rtor_get_blen(struct UART_Type* p) { return (p->RTOR & UART_RTOR_BLEN) >> 24 ; }
static inline uint32_t uart_rtor_get_rto(struct UART_Type* p) { return (p->RTOR & UART_RTOR_RTO) >> 0 ; }

// UART->RQR Request register
enum {
	UART_RQR_TXFRQ = 1UL<<4, // Transmit data flush request
	UART_RQR_RXFRQ = 1UL<<3, // Receive data flush request
	UART_RQR_MMRQ = 1UL<<2, // Mute mode request
	UART_RQR_SBKRQ = 1UL<<1, // Send break request
	UART_RQR_ABRRQ = 1UL<<0, // Auto baud rate request		
};

// UART->ISR Interrupt & status register
enum {
	UART_ISR_TCBGT = 1UL<<25, // Transmission complete before guard time completion
	UART_ISR_REACK = 1UL<<22, // REACK
	UART_ISR_TEACK = 1UL<<21, // TEACK
	UART_ISR_WUF = 1UL<<20, // WUF
	UART_ISR_RWU = 1UL<<19, // RWU
	UART_ISR_SBKF = 1UL<<18, // SBKF
	UART_ISR_CMF = 1UL<<17, // CMF
	UART_ISR_BUSY = 1UL<<16, // BUSY
	UART_ISR_ABRF = 1UL<<15, // ABRF
	UART_ISR_ABRE = 1UL<<14, // ABRE
	UART_ISR_EOBF = 1UL<<12, // EOBF
	UART_ISR_RTOF = 1UL<<11, // RTOF
	UART_ISR_CTS = 1UL<<10, // CTS
	UART_ISR_CTSIF = 1UL<<9, // CTSIF
	UART_ISR_LBDF = 1UL<<8, // LBDF
	UART_ISR_TXE = 1UL<<7, // TXE
	UART_ISR_TC = 1UL<<6, // TC
	UART_ISR_RXNE = 1UL<<5, // RXNE
	UART_ISR_IDLE = 1UL<<4, // IDLE
	UART_ISR_ORE = 1UL<<3, // ORE
	UART_ISR_NF = 1UL<<2, // NF
	UART_ISR_FE = 1UL<<1, // FE
	UART_ISR_PE = 1UL<<0, // PE		
};

// UART->ICR Interrupt flag clear register
enum {
	UART_ICR_WUCF = 1UL<<20, // Wakeup from Stop mode clear flag
	UART_ICR_CMCF = 1UL<<17, // Character match clear flag
	UART_ICR_EOBCF = 1UL<<12, // End of block clear flag
	UART_ICR_RTOCF = 1UL<<11, // Receiver timeout clear flag
	UART_ICR_CTSCF = 1UL<<9, // CTS clear flag
	UART_ICR_LBDCF = 1UL<<8, // LIN break detection clear flag
	UART_ICR_TCCF = 1UL<<6, // Transmission complete clear flag
	UART_ICR_IDLECF = 1UL<<4, // Idle line detected clear flag
	UART_ICR_ORECF = 1UL<<3, // Overrun error clear flag
	UART_ICR_NCF = 1UL<<2, // Noise detected clear flag
	UART_ICR_FECF = 1UL<<1, // Framing error clear flag
	UART_ICR_PECF = 1UL<<0, // Parity error clear flag		
};

// UART->RDR Receive data register
enum {
	UART_RDR_RDR = ((1UL<<9)-1) << 0, // Receive data value		
};
static inline uint32_t uart_rdr_get_rdr(struct UART_Type* p) { return (p->RDR & UART_RDR_RDR) >> 0 ; }

// UART->TDR Transmit data register
enum {
	UART_TDR_TDR = ((1UL<<9)-1) << 0, // Transmit data value		
};
static inline void uart_tdr_set_tdr(struct UART_Type* p, uint32_t val) { p->TDR = (p->TDR & ~UART_TDR_TDR) | ((val<<0) & UART_TDR_TDR); }
static inline uint32_t uart_tdr_get_tdr(struct UART_Type* p) { return (p->TDR & UART_TDR_TDR) >> 0 ; }



/* Voltage reference buffer
There is only one peripheral of type VREFBUF. */
struct VREFBUF_Type {
	__IO uint8_t CSR; // @0 VREF control and status register
	 uint8_t RESERVED0[3]; // @1 
	__IO uint8_t CCR; // @4 calibration control register
};
extern struct VREFBUF_Type	VREFBUF;	// @0x40010030 

// VREFBUF->CSR VREF control and status register
enum {
	VREFBUF_CSR_VRR = 1UL<<3, // Voltage reference buffer ready
	VREFBUF_CSR_VRS = 1UL<<2, // Voltage reference scale
	VREFBUF_CSR_HIZ = 1UL<<1, // High impedance mode
	VREFBUF_CSR_ENVR = 1UL<<0, // Voltage reference buffer enable		
};

// VREFBUF->CCR calibration control register
enum {
	VREFBUF_CCR_TRIM = ((1UL<<6)-1) << 0, // Trimming code		
};
static inline void vrefbuf_ccr_set_trim(uint32_t val) { VREFBUF.CCR = (VREFBUF.CCR & ~VREFBUF_CCR_TRIM) | ((val<<0) & VREFBUF_CCR_TRIM); }
static inline uint32_t vrefbuf_ccr_get_trim(void) { return (VREFBUF.CCR & VREFBUF_CCR_TRIM) >> 0 ; }

/* System window watchdog
There is only one peripheral of type WWDG. */
struct WWDG_Type {
	__IO uint8_t CR; // @0 Control register
	 uint8_t RESERVED0[3]; // @1 
	__IO uint16_t CFR; // @4 Configuration register
	 uint8_t RESERVED1[2]; // @6 
	__IO uint8_t SR; // @8 Status register
};
extern struct WWDG_Type	WWDG;	// @0x40002C00 

// WWDG->CR Control register
enum {
	WWDG_CR_WDGA = 1UL<<7, // Activation bit
	WWDG_CR_T = ((1UL<<7)-1) << 0, // 7-bit counter (MSB to LSB)		
};
static inline void wwdg_cr_set_t(uint32_t val) { WWDG.CR = (WWDG.CR & ~WWDG_CR_T) | ((val<<0) & WWDG_CR_T); }
static inline uint32_t wwdg_cr_get_t(void) { return (WWDG.CR & WWDG_CR_T) >> 0 ; }

// WWDG->CFR Configuration register
enum {
	WWDG_CFR_EWI = 1UL<<9, // Early wakeup interrupt
	WWDG_CFR_WDGTB = ((1UL<<2)-1) << 7, // Timer base
	WWDG_CFR_W = ((1UL<<7)-1) << 0, // 7-bit window value		
};
static inline void wwdg_cfr_set_wdgtb(uint32_t val) { WWDG.CFR = (WWDG.CFR & ~WWDG_CFR_WDGTB) | ((val<<7) & WWDG_CFR_WDGTB); }
static inline void wwdg_cfr_set_w(uint32_t val) { WWDG.CFR = (WWDG.CFR & ~WWDG_CFR_W) | ((val<<0) & WWDG_CFR_W); }
static inline uint32_t wwdg_cfr_get_wdgtb(void) { return (WWDG.CFR & WWDG_CFR_WDGTB) >> 7 ; }
static inline uint32_t wwdg_cfr_get_w(void) { return (WWDG.CFR & WWDG_CFR_W) >> 0 ; }

// WWDG->SR Status register
enum {
	WWDG_SR_EWIF = 1UL<<0, // Early wakeup interrupt flag		
};


#undef __I
#undef __O
#undef __IO
