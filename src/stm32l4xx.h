#pragma once

// Generated enums and structures for device STM32L4xx version 1.6
// Generated by genstruct, DO NOT EDIT.

#include <stdint.h>

enum IRQn_Type {
	None_IRQn  = -16, // 0 position of estack reset pointer
	Reset_IRQn = -15, // 1 Reset, not a real IRQ           

	//  Cortex-CM4 Processor Exceptions Numbers 
	NonMaskableInt_IRQn   = -14, // 2 Non Maskable Interrupt                           
	Reserved_3_IRQn       = -13,
	MemoryManagement_IRQn = -12, // 4 Memory Management Interrupt            
	BusFault_IRQn         = -11, // 5 Bus Fault Interrupt                    
	UsageFault_IRQn       = -10, // 6 Usage Fault Interrupt                  
	Reserved_7_IRQn       = -9,
	Reserved_8_IRQn       = -8,
	Reserved_9_IRQn       = -7,
	Reserved_10_IRQn      = -6,
	SVCall_IRQn           = -5, // 11 SV Call Interrupt                     
	DebugMonitor_IRQn     = -4, // 12 Debug Monitor Interrupt               
	Reserved_13_IRQn      = -3,
	PendSV_IRQn           = -2, // 14 Pend SV Interrupt                     
	SysTick_IRQn          = -1, // 15 System Tick Interrupt                 

	//  Device specific Interrupt Numbers
	WWDG_IRQn = 0, // Window Watchdog interrupt
	PVD_PVM_IRQn = 1, // PVD through EXTI line detection
	RTC_TAMP_STAMP_IRQn = 2, // Tamper and TimeStamp interrupts
	RTC_WKUP_IRQn = 3, // RTC Tamper or TimeStamp /CSS on LSE through EXTI line 19 interrupts
	FLASH_IRQn = 4, // Flash global interrupt
	RCC_IRQn = 5, // RCC global interrupt
	EXTI0_IRQn = 6, // EXTI Line 0 interrupt
	EXTI1_IRQn = 7, // EXTI Line 1 interrupt
	EXTI2_IRQn = 8, // EXTI Line 2 interrupt
	EXTI3_IRQn = 9, // EXTI Line 3 interrupt
	EXTI4_IRQn = 10, // EXTI Line4 interrupt
	DMA1_CH1_IRQn = 11, // DMA1 Channel1 global interrupt
	DMA1_CH2_IRQn = 12, // DMA1 Channel2 global interrupt
	DMA1_CH3_IRQn = 13, // DMA1 Channel3 interrupt
	DMA1_CH4_IRQn = 14, // DMA1 Channel4 interrupt
	DMA1_CH5_IRQn = 15, // DMA1 Channel5 interrupt
	DMA1_CH6_IRQn = 16, // DMA1 Channel6 interrupt
	DMA1_CH7_IRQn = 17, // DMA1 Channel 7 interrupt
	ADC1_IRQn = 18, // ADC1 and ADC2 global interrupt
	CAN1_TX_IRQn = 19, // CAN1 TX interrupts
	CAN1_RX0_IRQn = 20, // CAN1 RX0 interrupts
	CAN1_RX1_IRQn = 21, // CAN1 RX1 interrupts
	CAN1_SCE_IRQn = 22, // CAN1 SCE interrupt
	EXTI9_5_IRQn = 23, // EXTI Line5 to Line9 interrupts
	TIM1_BRK_TIM15_IRQn = 24, // Timer 15 global interrupt
	TIM1_UP_TIM16_IRQn = 25, // Timer 16 global interrupt
	TIM1_TRG_COM_IRQn = 26, // TIM1 trigger and commutation interrupt
	TIM1_CC_IRQn = 27, // TIM1 Capture Compare interrupt
	TIM2_IRQn = 28, // TIM2 global interrupt
	TIM3_IRQn = 29, // TIM3 global interrupt
	I2C1_EV_IRQn = 31, // I2C1 event interrupt
	I2C1_ER_IRQn = 32, // I2C1 error interrupt
	I2C2_EV_IRQn = 33, // I2C2 event interrupt
	I2C2_ER_IRQn = 34, // I2C2 error interrupt
	SPI1_IRQn = 35, // SPI1 global interrupt
	SPI2_IRQn = 36, // SPI2 global interrupt
	USART1_IRQn = 37, // USART1 global interrupt
	USART2_IRQn = 38, // USART2 global interrupt
	USART3_IRQn = 39, // USART2 global interrupt
	EXTI15_10_IRQn = 40, // EXTI Lines 10 to 15 interrupts
	RTC_ALARM_IRQn = 41, // RTC alarms through EXTI line 18 interrupts
	DFSDM1_FLT3_IRQn = 42, // DFSDM1_FLT3 global interrupt
	SDMMC1_IRQn = 49, // SDMMC global Interrupt
	SPI3_IRQn = 51, // SPI3 global Interrupt
	UART4_IRQn = 52, // UART4 global Interrupt
	TIM6_DACUNDER_IRQn = 54, // TIM6 global and DAC1 and 2 underrun error interrupts
	TIM7_IRQn = 55, // TIM7 global interrupt
	DMA2_CH1_IRQn = 56, // DMA2 Channel 1 global Interrupt
	DMA2_CH2_IRQn = 57, // DMA2 Channel 2 global Interrupt
	DMA2_CH3_IRQn = 58, // DMA2 Channel 3 global Interrupt
	DMA2_CH4_IRQn = 59, // DMA2 Channel 4 global Interrupt
	DMA2_CH5_IRQn = 60, // DMA2 Channel 5 global Interrupt
	DFSDM1_IRQn = 61, // DFSDM1_FLT0 global interrupt
	DFSDM2_IRQn = 62, // DFSDM1_FLT1 global interrupt
	DFSDM1_FLT2_IRQn = 63, // DFSDM1_FLT2 global interrupt
	COMP_IRQn = 64, // COMP1 and COMP2 interrupts
	LPTIM1_IRQn = 65, // LP TIM1 interrupt
	LPTIM2_IRQn = 66, // LP TIM2 interrupt
	USB_FS_IRQn = 67, // USB event interrupt through EXTI
	DMA2_CH6_IRQn = 68, // DMA2 Channel 6 global Interrupt
	DMA2_CH7_IRQn = 69, // DMA2 Channel 7 global Interrupt
	LPUART1_IRQn = 70, // LPUART1 global interrupt
	QUADSPI_IRQn = 71, // Quad SPI global interrupt
	I2C3_EV_IRQn = 72, // I2C3 event interrupt
	I2C3_ER_IRQn = 73, // I2C3 error interrupt
	SAI1_IRQn = 74, // SAI1 global interrupt
	SWPMI1_IRQn = 76, // SWPMI1 global interrupt
	TSC_IRQn = 77, // TSC global interrupt
	LCD_IRQn = 78, // LCD global interrupt
	AES_IRQn = 79, // AES global interrupt
	RNG_IRQn = 80, // RNG global interrupt
	FPU_IRQn = 81, // Floating point interrupt
	CRS_IRQn = 82, // CRS interrupt
	I2C4_EV_IRQn = 83, // I2C4 event interrupt, wakeup through EXTI
	I2C4_ER_IRQn = 84, // I2C4 error interrupt
};


#define __I volatile const // 'read only' permissions
#define __O volatile       // 'write only' permissions
#define __IO volatile      // 'read / write' permissions


/* Analog-to-Digital Converter */
struct ADC_Type {
	__IO uint16_t ISR; // @0 interrupt and status register
	 uint8_t RESERVED0[2]; // @2 
	__IO uint16_t IER; // @4 interrupt enable register
	 uint8_t RESERVED1[2]; // @6 
	__IO uint32_t CR; // @8 control register
	__IO uint32_t CFGR; // @12 configuration register
	__IO uint16_t CFGR2; // @16 configuration register
	 uint8_t RESERVED2[2]; // @18 
	__IO uint32_t SMPR1; // @20 sample time register 1
	__IO uint32_t SMPR2; // @24 sample time register 2
	 uint8_t RESERVED3[4]; // @28 
	__IO uint32_t TR1; // @32 watchdog threshold register 1
	__IO uint32_t TR2; // @36 watchdog threshold register
	__IO uint32_t TR3; // @40 watchdog threshold register 3
	 uint8_t RESERVED4[4]; // @44 
	__IO uint32_t SQR1; // @48 regular sequence register 1
	__IO uint32_t SQR2; // @52 regular sequence register 2
	__IO uint32_t SQR3; // @56 regular sequence register 3
	__IO uint16_t SQR4; // @60 regular sequence register 4
	 uint8_t RESERVED5[2]; // @62 
	__I uint16_t DR; // @64 regular Data Register
	 uint8_t RESERVED6[10]; // @66 
	__IO uint32_t JSQR; // @76 injected sequence register
	 uint8_t RESERVED7[16]; // @80 
	__IO uint32_t OFR1; // @96 offset register 1
	__IO uint32_t OFR2; // @100 offset register 2
	__IO uint32_t OFR3; // @104 offset register 3
	__IO uint32_t OFR4; // @108 offset register 4
	 uint8_t RESERVED8[16]; // @112 
	__I uint16_t JDR1; // @128 injected data register 1
	 uint8_t RESERVED9[2]; // @130 
	__I uint16_t JDR2; // @132 injected data register 2
	 uint8_t RESERVED10[2]; // @134 
	__I uint16_t JDR3; // @136 injected data register 3
	 uint8_t RESERVED11[2]; // @138 
	__I uint16_t JDR4; // @140 injected data register 4
	 uint8_t RESERVED12[18]; // @142 
	__IO uint32_t AWD2CR; // @160 Analog Watchdog 2 Configuration Register
	__IO uint32_t AWD3CR; // @164 Analog Watchdog 3 Configuration Register
	 uint8_t RESERVED13[8]; // @168 
	__IO uint32_t DIFSEL; // @176 Differential Mode Selection Register 2
	__IO uint32_t CALFACT; // @180 Calibration Factors
};

// ADC->ISR interrupt and status register
enum {
	ADC_ISR_JQOVF = 1UL<<10, // JQOVF
	ADC_ISR_AWD3 = 1UL<<9, // AWD3
	ADC_ISR_AWD2 = 1UL<<8, // AWD2
	ADC_ISR_AWD1 = 1UL<<7, // AWD1
	ADC_ISR_JEOS = 1UL<<6, // JEOS
	ADC_ISR_JEOC = 1UL<<5, // JEOC
	ADC_ISR_OVR = 1UL<<4, // OVR
	ADC_ISR_EOS = 1UL<<3, // EOS
	ADC_ISR_EOC = 1UL<<2, // EOC
	ADC_ISR_EOSMP = 1UL<<1, // EOSMP
	ADC_ISR_ADRDY = 1UL<<0, // ADRDY		
};

// ADC->IER interrupt enable register
enum {
	ADC_IER_JQOVFIE = 1UL<<10, // JQOVFIE
	ADC_IER_AWD3IE = 1UL<<9, // AWD3IE
	ADC_IER_AWD2IE = 1UL<<8, // AWD2IE
	ADC_IER_AWD1IE = 1UL<<7, // AWD1IE
	ADC_IER_JEOSIE = 1UL<<6, // JEOSIE
	ADC_IER_JEOCIE = 1UL<<5, // JEOCIE
	ADC_IER_OVRIE = 1UL<<4, // OVRIE
	ADC_IER_EOSIE = 1UL<<3, // EOSIE
	ADC_IER_EOCIE = 1UL<<2, // EOCIE
	ADC_IER_EOSMPIE = 1UL<<1, // EOSMPIE
	ADC_IER_ADRDYIE = 1UL<<0, // ADRDYIE		
};

// ADC->CR control register
enum {
	ADC_CR_ADCAL = 1UL<<31, // ADCAL
	ADC_CR_ADCALDIF = 1UL<<30, // ADCALDIF
	ADC_CR_DEEPPWD = 1UL<<29, // DEEPPWD
	ADC_CR_ADVREGEN = 1UL<<28, // ADVREGEN
	ADC_CR_JADSTP = 1UL<<5, // JADSTP
	ADC_CR_ADSTP = 1UL<<4, // ADSTP
	ADC_CR_JADSTART = 1UL<<3, // JADSTART
	ADC_CR_ADSTART = 1UL<<2, // ADSTART
	ADC_CR_ADDIS = 1UL<<1, // ADDIS
	ADC_CR_ADEN = 1UL<<0, // ADEN		
};

// ADC->CFGR configuration register
enum {
	ADC_CFGR_AWDCH1CH = ((1UL<<5)-1) << 26, // AWDCH1CH
	ADC_CFGR_JAUTO = 1UL<<25, // JAUTO
	ADC_CFGR_JAWD1EN = 1UL<<24, // JAWD1EN
	ADC_CFGR_AWD1EN = 1UL<<23, // AWD1EN
	ADC_CFGR_AWD1SGL = 1UL<<22, // AWD1SGL
	ADC_CFGR_JQM = 1UL<<21, // JQM
	ADC_CFGR_JDISCEN = 1UL<<20, // JDISCEN
	ADC_CFGR_DISCNUM = ((1UL<<3)-1) << 17, // DISCNUM
	ADC_CFGR_DISCEN = 1UL<<16, // DISCEN
	ADC_CFGR_AUTOFF = 1UL<<15, // AUTOFF
	ADC_CFGR_AUTDLY = 1UL<<14, // AUTDLY
	ADC_CFGR_CONT = 1UL<<13, // CONT
	ADC_CFGR_OVRMOD = 1UL<<12, // OVRMOD
	ADC_CFGR_EXTEN = ((1UL<<2)-1) << 10, // EXTEN
	ADC_CFGR_EXTSEL = ((1UL<<4)-1) << 6, // EXTSEL
	ADC_CFGR_ALIGN = 1UL<<5, // ALIGN
	ADC_CFGR_RES = ((1UL<<2)-1) << 3, // RES
	ADC_CFGR_DMACFG = 1UL<<1, // DMACFG
	ADC_CFGR_DMAEN = 1UL<<0, // DMAEN		
};
inline void adc_cfgr_set_awdch1ch(struct ADC_Type* p, uint32_t val) { p->CFGR = (p->CFGR & ~ADC_CFGR_AWDCH1CH) | ((val<<26) & ADC_CFGR_AWDCH1CH); }
inline void adc_cfgr_set_discnum(struct ADC_Type* p, uint32_t val) { p->CFGR = (p->CFGR & ~ADC_CFGR_DISCNUM) | ((val<<17) & ADC_CFGR_DISCNUM); }
inline void adc_cfgr_set_exten(struct ADC_Type* p, uint32_t val) { p->CFGR = (p->CFGR & ~ADC_CFGR_EXTEN) | ((val<<10) & ADC_CFGR_EXTEN); }
inline void adc_cfgr_set_extsel(struct ADC_Type* p, uint32_t val) { p->CFGR = (p->CFGR & ~ADC_CFGR_EXTSEL) | ((val<<6) & ADC_CFGR_EXTSEL); }
inline void adc_cfgr_set_res(struct ADC_Type* p, uint32_t val) { p->CFGR = (p->CFGR & ~ADC_CFGR_RES) | ((val<<3) & ADC_CFGR_RES); }
inline uint32_t adc_cfgr_get_awdch1ch(struct ADC_Type* p) { return (p->CFGR & ADC_CFGR_AWDCH1CH) >> 26 ; }
inline uint32_t adc_cfgr_get_discnum(struct ADC_Type* p) { return (p->CFGR & ADC_CFGR_DISCNUM) >> 17 ; }
inline uint32_t adc_cfgr_get_exten(struct ADC_Type* p) { return (p->CFGR & ADC_CFGR_EXTEN) >> 10 ; }
inline uint32_t adc_cfgr_get_extsel(struct ADC_Type* p) { return (p->CFGR & ADC_CFGR_EXTSEL) >> 6 ; }
inline uint32_t adc_cfgr_get_res(struct ADC_Type* p) { return (p->CFGR & ADC_CFGR_RES) >> 3 ; }

// ADC->CFGR2 configuration register
enum {
	ADC_CFGR2_ROVSM = 1UL<<10, // EXTEN
	ADC_CFGR2_TOVS = 1UL<<9, // EXTSEL
	ADC_CFGR2_OVSS = ((1UL<<4)-1) << 5, // ALIGN
	ADC_CFGR2_OVSR = ((1UL<<3)-1) << 2, // RES
	ADC_CFGR2_JOVSE = 1UL<<1, // DMACFG
	ADC_CFGR2_ROVSE = 1UL<<0, // DMAEN		
};
inline void adc_cfgr2_set_ovss(struct ADC_Type* p, uint32_t val) { p->CFGR2 = (p->CFGR2 & ~ADC_CFGR2_OVSS) | ((val<<5) & ADC_CFGR2_OVSS); }
inline void adc_cfgr2_set_ovsr(struct ADC_Type* p, uint32_t val) { p->CFGR2 = (p->CFGR2 & ~ADC_CFGR2_OVSR) | ((val<<2) & ADC_CFGR2_OVSR); }
inline uint32_t adc_cfgr2_get_ovss(struct ADC_Type* p) { return (p->CFGR2 & ADC_CFGR2_OVSS) >> 5 ; }
inline uint32_t adc_cfgr2_get_ovsr(struct ADC_Type* p) { return (p->CFGR2 & ADC_CFGR2_OVSR) >> 2 ; }

// ADC->SMPR1 sample time register 1
enum {
	ADC_SMPR1_SMP9 = ((1UL<<3)-1) << 27, // SMP9
	ADC_SMPR1_SMP8 = ((1UL<<3)-1) << 24, // SMP8
	ADC_SMPR1_SMP7 = ((1UL<<3)-1) << 21, // SMP7
	ADC_SMPR1_SMP6 = ((1UL<<3)-1) << 18, // SMP6
	ADC_SMPR1_SMP5 = ((1UL<<3)-1) << 15, // SMP5
	ADC_SMPR1_SMP4 = ((1UL<<3)-1) << 12, // SMP4
	ADC_SMPR1_SMP3 = ((1UL<<3)-1) << 9, // SMP3
	ADC_SMPR1_SMP2 = ((1UL<<3)-1) << 6, // SMP2
	ADC_SMPR1_SMP1 = ((1UL<<3)-1) << 3, // SMP1		
	ADC_SMPR1_SMP0 = ((1UL<<3)-1) << 0, // SMP0		

};
inline void adc_smpr1_set_smp9(struct ADC_Type* p, uint32_t val) { p->SMPR1 = (p->SMPR1 & ~ADC_SMPR1_SMP9) | ((val<<27) & ADC_SMPR1_SMP9); }
inline void adc_smpr1_set_smp8(struct ADC_Type* p, uint32_t val) { p->SMPR1 = (p->SMPR1 & ~ADC_SMPR1_SMP8) | ((val<<24) & ADC_SMPR1_SMP8); }
inline void adc_smpr1_set_smp7(struct ADC_Type* p, uint32_t val) { p->SMPR1 = (p->SMPR1 & ~ADC_SMPR1_SMP7) | ((val<<21) & ADC_SMPR1_SMP7); }
inline void adc_smpr1_set_smp6(struct ADC_Type* p, uint32_t val) { p->SMPR1 = (p->SMPR1 & ~ADC_SMPR1_SMP6) | ((val<<18) & ADC_SMPR1_SMP6); }
inline void adc_smpr1_set_smp5(struct ADC_Type* p, uint32_t val) { p->SMPR1 = (p->SMPR1 & ~ADC_SMPR1_SMP5) | ((val<<15) & ADC_SMPR1_SMP5); }
inline void adc_smpr1_set_smp4(struct ADC_Type* p, uint32_t val) { p->SMPR1 = (p->SMPR1 & ~ADC_SMPR1_SMP4) | ((val<<12) & ADC_SMPR1_SMP4); }
inline void adc_smpr1_set_smp3(struct ADC_Type* p, uint32_t val) { p->SMPR1 = (p->SMPR1 & ~ADC_SMPR1_SMP3) | ((val<<9) & ADC_SMPR1_SMP3); }
inline void adc_smpr1_set_smp2(struct ADC_Type* p, uint32_t val) { p->SMPR1 = (p->SMPR1 & ~ADC_SMPR1_SMP2) | ((val<<6) & ADC_SMPR1_SMP2); }
inline void adc_smpr1_set_smp1(struct ADC_Type* p, uint32_t val) { p->SMPR1 = (p->SMPR1 & ~ADC_SMPR1_SMP1) | ((val<<3) & ADC_SMPR1_SMP1); }
inline void adc_smpr1_set_smp0(struct ADC_Type* p, uint32_t val) { p->SMPR1 = (p->SMPR1 & ~ADC_SMPR1_SMP0) | ((val<<3) & ADC_SMPR1_SMP0); }
inline uint32_t adc_smpr1_get_smp9(struct ADC_Type* p) { return (p->SMPR1 & ADC_SMPR1_SMP9) >> 27 ; }
inline uint32_t adc_smpr1_get_smp8(struct ADC_Type* p) { return (p->SMPR1 & ADC_SMPR1_SMP8) >> 24 ; }
inline uint32_t adc_smpr1_get_smp7(struct ADC_Type* p) { return (p->SMPR1 & ADC_SMPR1_SMP7) >> 21 ; }
inline uint32_t adc_smpr1_get_smp6(struct ADC_Type* p) { return (p->SMPR1 & ADC_SMPR1_SMP6) >> 18 ; }
inline uint32_t adc_smpr1_get_smp5(struct ADC_Type* p) { return (p->SMPR1 & ADC_SMPR1_SMP5) >> 15 ; }
inline uint32_t adc_smpr1_get_smp4(struct ADC_Type* p) { return (p->SMPR1 & ADC_SMPR1_SMP4) >> 12 ; }
inline uint32_t adc_smpr1_get_smp3(struct ADC_Type* p) { return (p->SMPR1 & ADC_SMPR1_SMP3) >> 9 ; }
inline uint32_t adc_smpr1_get_smp2(struct ADC_Type* p) { return (p->SMPR1 & ADC_SMPR1_SMP2) >> 6 ; }
inline uint32_t adc_smpr1_get_smp1(struct ADC_Type* p) { return (p->SMPR1 & ADC_SMPR1_SMP1) >> 3 ; }
inline uint32_t adc_smpr1_get_smp0(struct ADC_Type* p) { return (p->SMPR1 & ADC_SMPR1_SMP0) >> 3 ; }

// ADC->SMPR2 sample time register 2
enum {
	ADC_SMPR2_SMP18 = ((1UL<<3)-1) << 24, // SMP18
	ADC_SMPR2_SMP17 = ((1UL<<3)-1) << 21, // SMP17
	ADC_SMPR2_SMP16 = ((1UL<<3)-1) << 18, // SMP16
	ADC_SMPR2_SMP15 = ((1UL<<3)-1) << 15, // SMP15
	ADC_SMPR2_SMP14 = ((1UL<<3)-1) << 12, // SMP14
	ADC_SMPR2_SMP13 = ((1UL<<3)-1) << 9, // SMP13
	ADC_SMPR2_SMP12 = ((1UL<<3)-1) << 6, // SMP12
	ADC_SMPR2_SMP11 = ((1UL<<3)-1) << 3, // SMP11
	ADC_SMPR2_SMP10 = ((1UL<<3)-1) << 0, // SMP10		
};
inline void adc_smpr2_set_smp18(struct ADC_Type* p, uint32_t val) { p->SMPR2 = (p->SMPR2 & ~ADC_SMPR2_SMP18) | ((val<<24) & ADC_SMPR2_SMP18); }
inline void adc_smpr2_set_smp17(struct ADC_Type* p, uint32_t val) { p->SMPR2 = (p->SMPR2 & ~ADC_SMPR2_SMP17) | ((val<<21) & ADC_SMPR2_SMP17); }
inline void adc_smpr2_set_smp16(struct ADC_Type* p, uint32_t val) { p->SMPR2 = (p->SMPR2 & ~ADC_SMPR2_SMP16) | ((val<<18) & ADC_SMPR2_SMP16); }
inline void adc_smpr2_set_smp15(struct ADC_Type* p, uint32_t val) { p->SMPR2 = (p->SMPR2 & ~ADC_SMPR2_SMP15) | ((val<<15) & ADC_SMPR2_SMP15); }
inline void adc_smpr2_set_smp14(struct ADC_Type* p, uint32_t val) { p->SMPR2 = (p->SMPR2 & ~ADC_SMPR2_SMP14) | ((val<<12) & ADC_SMPR2_SMP14); }
inline void adc_smpr2_set_smp13(struct ADC_Type* p, uint32_t val) { p->SMPR2 = (p->SMPR2 & ~ADC_SMPR2_SMP13) | ((val<<9) & ADC_SMPR2_SMP13); }
inline void adc_smpr2_set_smp12(struct ADC_Type* p, uint32_t val) { p->SMPR2 = (p->SMPR2 & ~ADC_SMPR2_SMP12) | ((val<<6) & ADC_SMPR2_SMP12); }
inline void adc_smpr2_set_smp11(struct ADC_Type* p, uint32_t val) { p->SMPR2 = (p->SMPR2 & ~ADC_SMPR2_SMP11) | ((val<<3) & ADC_SMPR2_SMP11); }
inline void adc_smpr2_set_smp10(struct ADC_Type* p, uint32_t val) { p->SMPR2 = (p->SMPR2 & ~ADC_SMPR2_SMP10) | ((val<<0) & ADC_SMPR2_SMP10); }
inline uint32_t adc_smpr2_get_smp18(struct ADC_Type* p) { return (p->SMPR2 & ADC_SMPR2_SMP18) >> 24 ; }
inline uint32_t adc_smpr2_get_smp17(struct ADC_Type* p) { return (p->SMPR2 & ADC_SMPR2_SMP17) >> 21 ; }
inline uint32_t adc_smpr2_get_smp16(struct ADC_Type* p) { return (p->SMPR2 & ADC_SMPR2_SMP16) >> 18 ; }
inline uint32_t adc_smpr2_get_smp15(struct ADC_Type* p) { return (p->SMPR2 & ADC_SMPR2_SMP15) >> 15 ; }
inline uint32_t adc_smpr2_get_smp14(struct ADC_Type* p) { return (p->SMPR2 & ADC_SMPR2_SMP14) >> 12 ; }
inline uint32_t adc_smpr2_get_smp13(struct ADC_Type* p) { return (p->SMPR2 & ADC_SMPR2_SMP13) >> 9 ; }
inline uint32_t adc_smpr2_get_smp12(struct ADC_Type* p) { return (p->SMPR2 & ADC_SMPR2_SMP12) >> 6 ; }
inline uint32_t adc_smpr2_get_smp11(struct ADC_Type* p) { return (p->SMPR2 & ADC_SMPR2_SMP11) >> 3 ; }
inline uint32_t adc_smpr2_get_smp10(struct ADC_Type* p) { return (p->SMPR2 & ADC_SMPR2_SMP10) >> 0 ; }

// ADC->TR1 watchdog threshold register 1
enum {
	ADC_TR1_HT1 = ((1UL<<12)-1) << 16, // HT1
	ADC_TR1_LT1 = ((1UL<<12)-1) << 0, // LT1		
};
inline void adc_tr1_set_ht1(struct ADC_Type* p, uint32_t val) { p->TR1 = (p->TR1 & ~ADC_TR1_HT1) | ((val<<16) & ADC_TR1_HT1); }
inline void adc_tr1_set_lt1(struct ADC_Type* p, uint32_t val) { p->TR1 = (p->TR1 & ~ADC_TR1_LT1) | ((val<<0) & ADC_TR1_LT1); }
inline uint32_t adc_tr1_get_ht1(struct ADC_Type* p) { return (p->TR1 & ADC_TR1_HT1) >> 16 ; }
inline uint32_t adc_tr1_get_lt1(struct ADC_Type* p) { return (p->TR1 & ADC_TR1_LT1) >> 0 ; }

// ADC->TR2 watchdog threshold register
enum {
	ADC_TR2_HT2 = ((1UL<<8)-1) << 16, // HT2
	ADC_TR2_LT2 = ((1UL<<8)-1) << 0, // LT2		
};
inline void adc_tr2_set_ht2(struct ADC_Type* p, uint32_t val) { p->TR2 = (p->TR2 & ~ADC_TR2_HT2) | ((val<<16) & ADC_TR2_HT2); }
inline void adc_tr2_set_lt2(struct ADC_Type* p, uint32_t val) { p->TR2 = (p->TR2 & ~ADC_TR2_LT2) | ((val<<0) & ADC_TR2_LT2); }
inline uint32_t adc_tr2_get_ht2(struct ADC_Type* p) { return (p->TR2 & ADC_TR2_HT2) >> 16 ; }
inline uint32_t adc_tr2_get_lt2(struct ADC_Type* p) { return (p->TR2 & ADC_TR2_LT2) >> 0 ; }

// ADC->TR3 watchdog threshold register 3
enum {
	ADC_TR3_HT3 = ((1UL<<8)-1) << 16, // HT3
	ADC_TR3_LT3 = ((1UL<<8)-1) << 0, // LT3		
};
inline void adc_tr3_set_ht3(struct ADC_Type* p, uint32_t val) { p->TR3 = (p->TR3 & ~ADC_TR3_HT3) | ((val<<16) & ADC_TR3_HT3); }
inline void adc_tr3_set_lt3(struct ADC_Type* p, uint32_t val) { p->TR3 = (p->TR3 & ~ADC_TR3_LT3) | ((val<<0) & ADC_TR3_LT3); }
inline uint32_t adc_tr3_get_ht3(struct ADC_Type* p) { return (p->TR3 & ADC_TR3_HT3) >> 16 ; }
inline uint32_t adc_tr3_get_lt3(struct ADC_Type* p) { return (p->TR3 & ADC_TR3_LT3) >> 0 ; }

// ADC->SQR1 regular sequence register 1
enum {
	ADC_SQR1_SQ4 = ((1UL<<5)-1) << 24, // SQ4
	ADC_SQR1_SQ3 = ((1UL<<5)-1) << 18, // SQ3
	ADC_SQR1_SQ2 = ((1UL<<5)-1) << 12, // SQ2
	ADC_SQR1_SQ1 = ((1UL<<5)-1) << 6, // SQ1
	ADC_SQR1_L3 = ((1UL<<4)-1) << 0, // L3		
};
inline void adc_sqr1_set_sq4(struct ADC_Type* p, uint32_t val) { p->SQR1 = (p->SQR1 & ~ADC_SQR1_SQ4) | ((val<<24) & ADC_SQR1_SQ4); }
inline void adc_sqr1_set_sq3(struct ADC_Type* p, uint32_t val) { p->SQR1 = (p->SQR1 & ~ADC_SQR1_SQ3) | ((val<<18) & ADC_SQR1_SQ3); }
inline void adc_sqr1_set_sq2(struct ADC_Type* p, uint32_t val) { p->SQR1 = (p->SQR1 & ~ADC_SQR1_SQ2) | ((val<<12) & ADC_SQR1_SQ2); }
inline void adc_sqr1_set_sq1(struct ADC_Type* p, uint32_t val) { p->SQR1 = (p->SQR1 & ~ADC_SQR1_SQ1) | ((val<<6) & ADC_SQR1_SQ1); }
inline void adc_sqr1_set_l3(struct ADC_Type* p, uint32_t val) { p->SQR1 = (p->SQR1 & ~ADC_SQR1_L3) | ((val<<0) & ADC_SQR1_L3); }
inline uint32_t adc_sqr1_get_sq4(struct ADC_Type* p) { return (p->SQR1 & ADC_SQR1_SQ4) >> 24 ; }
inline uint32_t adc_sqr1_get_sq3(struct ADC_Type* p) { return (p->SQR1 & ADC_SQR1_SQ3) >> 18 ; }
inline uint32_t adc_sqr1_get_sq2(struct ADC_Type* p) { return (p->SQR1 & ADC_SQR1_SQ2) >> 12 ; }
inline uint32_t adc_sqr1_get_sq1(struct ADC_Type* p) { return (p->SQR1 & ADC_SQR1_SQ1) >> 6 ; }
inline uint32_t adc_sqr1_get_l3(struct ADC_Type* p) { return (p->SQR1 & ADC_SQR1_L3) >> 0 ; }

// ADC->SQR2 regular sequence register 2
enum {
	ADC_SQR2_SQ9 = ((1UL<<5)-1) << 24, // SQ9
	ADC_SQR2_SQ8 = ((1UL<<5)-1) << 18, // SQ8
	ADC_SQR2_SQ7 = ((1UL<<5)-1) << 12, // SQ7
	ADC_SQR2_SQ6 = ((1UL<<5)-1) << 6, // SQ6
	ADC_SQR2_SQ5 = ((1UL<<5)-1) << 0, // SQ5		
};
inline void adc_sqr2_set_sq9(struct ADC_Type* p, uint32_t val) { p->SQR2 = (p->SQR2 & ~ADC_SQR2_SQ9) | ((val<<24) & ADC_SQR2_SQ9); }
inline void adc_sqr2_set_sq8(struct ADC_Type* p, uint32_t val) { p->SQR2 = (p->SQR2 & ~ADC_SQR2_SQ8) | ((val<<18) & ADC_SQR2_SQ8); }
inline void adc_sqr2_set_sq7(struct ADC_Type* p, uint32_t val) { p->SQR2 = (p->SQR2 & ~ADC_SQR2_SQ7) | ((val<<12) & ADC_SQR2_SQ7); }
inline void adc_sqr2_set_sq6(struct ADC_Type* p, uint32_t val) { p->SQR2 = (p->SQR2 & ~ADC_SQR2_SQ6) | ((val<<6) & ADC_SQR2_SQ6); }
inline void adc_sqr2_set_sq5(struct ADC_Type* p, uint32_t val) { p->SQR2 = (p->SQR2 & ~ADC_SQR2_SQ5) | ((val<<0) & ADC_SQR2_SQ5); }
inline uint32_t adc_sqr2_get_sq9(struct ADC_Type* p) { return (p->SQR2 & ADC_SQR2_SQ9) >> 24 ; }
inline uint32_t adc_sqr2_get_sq8(struct ADC_Type* p) { return (p->SQR2 & ADC_SQR2_SQ8) >> 18 ; }
inline uint32_t adc_sqr2_get_sq7(struct ADC_Type* p) { return (p->SQR2 & ADC_SQR2_SQ7) >> 12 ; }
inline uint32_t adc_sqr2_get_sq6(struct ADC_Type* p) { return (p->SQR2 & ADC_SQR2_SQ6) >> 6 ; }
inline uint32_t adc_sqr2_get_sq5(struct ADC_Type* p) { return (p->SQR2 & ADC_SQR2_SQ5) >> 0 ; }

// ADC->SQR3 regular sequence register 3
enum {
	ADC_SQR3_SQ14 = ((1UL<<5)-1) << 24, // SQ14
	ADC_SQR3_SQ13 = ((1UL<<5)-1) << 18, // SQ13
	ADC_SQR3_SQ12 = ((1UL<<5)-1) << 12, // SQ12
	ADC_SQR3_SQ11 = ((1UL<<5)-1) << 6, // SQ11
	ADC_SQR3_SQ10 = ((1UL<<5)-1) << 0, // SQ10		
};
inline void adc_sqr3_set_sq14(struct ADC_Type* p, uint32_t val) { p->SQR3 = (p->SQR3 & ~ADC_SQR3_SQ14) | ((val<<24) & ADC_SQR3_SQ14); }
inline void adc_sqr3_set_sq13(struct ADC_Type* p, uint32_t val) { p->SQR3 = (p->SQR3 & ~ADC_SQR3_SQ13) | ((val<<18) & ADC_SQR3_SQ13); }
inline void adc_sqr3_set_sq12(struct ADC_Type* p, uint32_t val) { p->SQR3 = (p->SQR3 & ~ADC_SQR3_SQ12) | ((val<<12) & ADC_SQR3_SQ12); }
inline void adc_sqr3_set_sq11(struct ADC_Type* p, uint32_t val) { p->SQR3 = (p->SQR3 & ~ADC_SQR3_SQ11) | ((val<<6) & ADC_SQR3_SQ11); }
inline void adc_sqr3_set_sq10(struct ADC_Type* p, uint32_t val) { p->SQR3 = (p->SQR3 & ~ADC_SQR3_SQ10) | ((val<<0) & ADC_SQR3_SQ10); }
inline uint32_t adc_sqr3_get_sq14(struct ADC_Type* p) { return (p->SQR3 & ADC_SQR3_SQ14) >> 24 ; }
inline uint32_t adc_sqr3_get_sq13(struct ADC_Type* p) { return (p->SQR3 & ADC_SQR3_SQ13) >> 18 ; }
inline uint32_t adc_sqr3_get_sq12(struct ADC_Type* p) { return (p->SQR3 & ADC_SQR3_SQ12) >> 12 ; }
inline uint32_t adc_sqr3_get_sq11(struct ADC_Type* p) { return (p->SQR3 & ADC_SQR3_SQ11) >> 6 ; }
inline uint32_t adc_sqr3_get_sq10(struct ADC_Type* p) { return (p->SQR3 & ADC_SQR3_SQ10) >> 0 ; }

// ADC->SQR4 regular sequence register 4
enum {
	ADC_SQR4_SQ16 = ((1UL<<5)-1) << 6, // SQ16
	ADC_SQR4_SQ15 = ((1UL<<5)-1) << 0, // SQ15		
};
inline void adc_sqr4_set_sq16(struct ADC_Type* p, uint32_t val) { p->SQR4 = (p->SQR4 & ~ADC_SQR4_SQ16) | ((val<<6) & ADC_SQR4_SQ16); }
inline void adc_sqr4_set_sq15(struct ADC_Type* p, uint32_t val) { p->SQR4 = (p->SQR4 & ~ADC_SQR4_SQ15) | ((val<<0) & ADC_SQR4_SQ15); }
inline uint32_t adc_sqr4_get_sq16(struct ADC_Type* p) { return (p->SQR4 & ADC_SQR4_SQ16) >> 6 ; }
inline uint32_t adc_sqr4_get_sq15(struct ADC_Type* p) { return (p->SQR4 & ADC_SQR4_SQ15) >> 0 ; }

// ADC->JSQR injected sequence register
enum {
	ADC_JSQR_JSQ4 = ((1UL<<5)-1) << 26, // JSQ4
	ADC_JSQR_JSQ3 = ((1UL<<5)-1) << 20, // JSQ3
	ADC_JSQR_JSQ2 = ((1UL<<5)-1) << 14, // JSQ2
	ADC_JSQR_JSQ1 = ((1UL<<5)-1) << 8, // JSQ1
	ADC_JSQR_JEXTEN = ((1UL<<2)-1) << 6, // JEXTEN
	ADC_JSQR_JEXTSEL = ((1UL<<4)-1) << 2, // JEXTSEL
	ADC_JSQR_JL = ((1UL<<2)-1) << 0, // JL		
};
inline void adc_jsqr_set_jsq4(struct ADC_Type* p, uint32_t val) { p->JSQR = (p->JSQR & ~ADC_JSQR_JSQ4) | ((val<<26) & ADC_JSQR_JSQ4); }
inline void adc_jsqr_set_jsq3(struct ADC_Type* p, uint32_t val) { p->JSQR = (p->JSQR & ~ADC_JSQR_JSQ3) | ((val<<20) & ADC_JSQR_JSQ3); }
inline void adc_jsqr_set_jsq2(struct ADC_Type* p, uint32_t val) { p->JSQR = (p->JSQR & ~ADC_JSQR_JSQ2) | ((val<<14) & ADC_JSQR_JSQ2); }
inline void adc_jsqr_set_jsq1(struct ADC_Type* p, uint32_t val) { p->JSQR = (p->JSQR & ~ADC_JSQR_JSQ1) | ((val<<8) & ADC_JSQR_JSQ1); }
inline void adc_jsqr_set_jexten(struct ADC_Type* p, uint32_t val) { p->JSQR = (p->JSQR & ~ADC_JSQR_JEXTEN) | ((val<<6) & ADC_JSQR_JEXTEN); }
inline void adc_jsqr_set_jextsel(struct ADC_Type* p, uint32_t val) { p->JSQR = (p->JSQR & ~ADC_JSQR_JEXTSEL) | ((val<<2) & ADC_JSQR_JEXTSEL); }
inline void adc_jsqr_set_jl(struct ADC_Type* p, uint32_t val) { p->JSQR = (p->JSQR & ~ADC_JSQR_JL) | ((val<<0) & ADC_JSQR_JL); }
inline uint32_t adc_jsqr_get_jsq4(struct ADC_Type* p) { return (p->JSQR & ADC_JSQR_JSQ4) >> 26 ; }
inline uint32_t adc_jsqr_get_jsq3(struct ADC_Type* p) { return (p->JSQR & ADC_JSQR_JSQ3) >> 20 ; }
inline uint32_t adc_jsqr_get_jsq2(struct ADC_Type* p) { return (p->JSQR & ADC_JSQR_JSQ2) >> 14 ; }
inline uint32_t adc_jsqr_get_jsq1(struct ADC_Type* p) { return (p->JSQR & ADC_JSQR_JSQ1) >> 8 ; }
inline uint32_t adc_jsqr_get_jexten(struct ADC_Type* p) { return (p->JSQR & ADC_JSQR_JEXTEN) >> 6 ; }
inline uint32_t adc_jsqr_get_jextsel(struct ADC_Type* p) { return (p->JSQR & ADC_JSQR_JEXTSEL) >> 2 ; }
inline uint32_t adc_jsqr_get_jl(struct ADC_Type* p) { return (p->JSQR & ADC_JSQR_JL) >> 0 ; }

// ADC->OFR1 offset register 1
enum {
	ADC_OFR1_OFFSET1_EN = 1UL<<31, // OFFSET1_EN
	ADC_OFR1_OFFSET1_CH = ((1UL<<5)-1) << 26, // OFFSET1_CH
	ADC_OFR1_OFFSET1 = ((1UL<<12)-1) << 0, // OFFSET1		
};
inline void adc_ofr1_set_offset1_ch(struct ADC_Type* p, uint32_t val) { p->OFR1 = (p->OFR1 & ~ADC_OFR1_OFFSET1_CH) | ((val<<26) & ADC_OFR1_OFFSET1_CH); }
inline void adc_ofr1_set_offset1(struct ADC_Type* p, uint32_t val) { p->OFR1 = (p->OFR1 & ~ADC_OFR1_OFFSET1) | ((val<<0) & ADC_OFR1_OFFSET1); }
inline uint32_t adc_ofr1_get_offset1_ch(struct ADC_Type* p) { return (p->OFR1 & ADC_OFR1_OFFSET1_CH) >> 26 ; }
inline uint32_t adc_ofr1_get_offset1(struct ADC_Type* p) { return (p->OFR1 & ADC_OFR1_OFFSET1) >> 0 ; }

// ADC->OFR2 offset register 2
enum {
	ADC_OFR2_OFFSET2_EN = 1UL<<31, // OFFSET2_EN
	ADC_OFR2_OFFSET2_CH = ((1UL<<5)-1) << 26, // OFFSET2_CH
	ADC_OFR2_OFFSET2 = ((1UL<<12)-1) << 0, // OFFSET2		
};
inline void adc_ofr2_set_offset2_ch(struct ADC_Type* p, uint32_t val) { p->OFR2 = (p->OFR2 & ~ADC_OFR2_OFFSET2_CH) | ((val<<26) & ADC_OFR2_OFFSET2_CH); }
inline void adc_ofr2_set_offset2(struct ADC_Type* p, uint32_t val) { p->OFR2 = (p->OFR2 & ~ADC_OFR2_OFFSET2) | ((val<<0) & ADC_OFR2_OFFSET2); }
inline uint32_t adc_ofr2_get_offset2_ch(struct ADC_Type* p) { return (p->OFR2 & ADC_OFR2_OFFSET2_CH) >> 26 ; }
inline uint32_t adc_ofr2_get_offset2(struct ADC_Type* p) { return (p->OFR2 & ADC_OFR2_OFFSET2) >> 0 ; }

// ADC->OFR3 offset register 3
enum {
	ADC_OFR3_OFFSET3_EN = 1UL<<31, // OFFSET3_EN
	ADC_OFR3_OFFSET3_CH = ((1UL<<5)-1) << 26, // OFFSET3_CH
	ADC_OFR3_OFFSET3 = ((1UL<<12)-1) << 0, // OFFSET3		
};
inline void adc_ofr3_set_offset3_ch(struct ADC_Type* p, uint32_t val) { p->OFR3 = (p->OFR3 & ~ADC_OFR3_OFFSET3_CH) | ((val<<26) & ADC_OFR3_OFFSET3_CH); }
inline void adc_ofr3_set_offset3(struct ADC_Type* p, uint32_t val) { p->OFR3 = (p->OFR3 & ~ADC_OFR3_OFFSET3) | ((val<<0) & ADC_OFR3_OFFSET3); }
inline uint32_t adc_ofr3_get_offset3_ch(struct ADC_Type* p) { return (p->OFR3 & ADC_OFR3_OFFSET3_CH) >> 26 ; }
inline uint32_t adc_ofr3_get_offset3(struct ADC_Type* p) { return (p->OFR3 & ADC_OFR3_OFFSET3) >> 0 ; }

// ADC->OFR4 offset register 4
enum {
	ADC_OFR4_OFFSET4_EN = 1UL<<31, // OFFSET4_EN
	ADC_OFR4_OFFSET4_CH = ((1UL<<5)-1) << 26, // OFFSET4_CH
	ADC_OFR4_OFFSET4 = ((1UL<<12)-1) << 0, // OFFSET4		
};
inline void adc_ofr4_set_offset4_ch(struct ADC_Type* p, uint32_t val) { p->OFR4 = (p->OFR4 & ~ADC_OFR4_OFFSET4_CH) | ((val<<26) & ADC_OFR4_OFFSET4_CH); }
inline void adc_ofr4_set_offset4(struct ADC_Type* p, uint32_t val) { p->OFR4 = (p->OFR4 & ~ADC_OFR4_OFFSET4) | ((val<<0) & ADC_OFR4_OFFSET4); }
inline uint32_t adc_ofr4_get_offset4_ch(struct ADC_Type* p) { return (p->OFR4 & ADC_OFR4_OFFSET4_CH) >> 26 ; }
inline uint32_t adc_ofr4_get_offset4(struct ADC_Type* p) { return (p->OFR4 & ADC_OFR4_OFFSET4) >> 0 ; }

// ADC->AWD2CR Analog Watchdog 2 Configuration Register
enum {
	ADC_AWD2CR_AWD2CH = ((1UL<<18)-1) << 1, // AWD2CH		
};
inline void adc_awd2cr_set_awd2ch(struct ADC_Type* p, uint32_t val) { p->AWD2CR = (p->AWD2CR & ~ADC_AWD2CR_AWD2CH) | ((val<<1) & ADC_AWD2CR_AWD2CH); }
inline uint32_t adc_awd2cr_get_awd2ch(struct ADC_Type* p) { return (p->AWD2CR & ADC_AWD2CR_AWD2CH) >> 1 ; }

// ADC->AWD3CR Analog Watchdog 3 Configuration Register
enum {
	ADC_AWD3CR_AWD3CH = ((1UL<<18)-1) << 1, // AWD3CH		
};
inline void adc_awd3cr_set_awd3ch(struct ADC_Type* p, uint32_t val) { p->AWD3CR = (p->AWD3CR & ~ADC_AWD3CR_AWD3CH) | ((val<<1) & ADC_AWD3CR_AWD3CH); }
inline uint32_t adc_awd3cr_get_awd3ch(struct ADC_Type* p) { return (p->AWD3CR & ADC_AWD3CR_AWD3CH) >> 1 ; }

// ADC->DIFSEL Differential Mode Selection Register 2
enum {
	ADC_DIFSEL_DIFSEL_16_18 = ((1UL<<3)-1) << 16, // Differential mode for channels 18 to 16
	ADC_DIFSEL_DIFSEL_1_15 = ((1UL<<15)-1) << 1, // Differential mode for channels 15 to 1		
};
inline void adc_difsel_set_difsel_16_18(struct ADC_Type* p, uint32_t val) { p->DIFSEL = (p->DIFSEL & ~ADC_DIFSEL_DIFSEL_16_18) | ((val<<16) & ADC_DIFSEL_DIFSEL_16_18); }
inline void adc_difsel_set_difsel_1_15(struct ADC_Type* p, uint32_t val) { p->DIFSEL = (p->DIFSEL & ~ADC_DIFSEL_DIFSEL_1_15) | ((val<<1) & ADC_DIFSEL_DIFSEL_1_15); }
inline uint32_t adc_difsel_get_difsel_16_18(struct ADC_Type* p) { return (p->DIFSEL & ADC_DIFSEL_DIFSEL_16_18) >> 16 ; }
inline uint32_t adc_difsel_get_difsel_1_15(struct ADC_Type* p) { return (p->DIFSEL & ADC_DIFSEL_DIFSEL_1_15) >> 1 ; }

// ADC->CALFACT Calibration Factors
enum {
	ADC_CALFACT_CALFACT_D = ((1UL<<7)-1) << 16, // CALFACT_D
	ADC_CALFACT_CALFACT_S = ((1UL<<7)-1) << 0, // CALFACT_S		
};
inline void adc_calfact_set_calfact_d(struct ADC_Type* p, uint32_t val) { p->CALFACT = (p->CALFACT & ~ADC_CALFACT_CALFACT_D) | ((val<<16) & ADC_CALFACT_CALFACT_D); }
inline void adc_calfact_set_calfact_s(struct ADC_Type* p, uint32_t val) { p->CALFACT = (p->CALFACT & ~ADC_CALFACT_CALFACT_S) | ((val<<0) & ADC_CALFACT_CALFACT_S); }
inline uint32_t adc_calfact_get_calfact_d(struct ADC_Type* p) { return (p->CALFACT & ADC_CALFACT_CALFACT_D) >> 16 ; }
inline uint32_t adc_calfact_get_calfact_s(struct ADC_Type* p) { return (p->CALFACT & ADC_CALFACT_CALFACT_S) >> 0 ; }

/* Analog-to-Digital Converter */
struct ADC12_Common_Type {
	__I uint32_t CSR; // @0 ADC Common status register
	 uint8_t RESERVED0[4]; // @4 
	__IO uint32_t CCR; // @8 ADC common control register
	__I uint32_t CDR; // @12 ADC common regular data register for dual and triple modes
};

// ADC12_Common->CSR ADC Common status register
enum {
	ADC12_COMMON_CSR_JQOVF_SLV = 1UL<<26, // Injected Context Queue Overflow flag of the slave ADC
	ADC12_COMMON_CSR_AWD3_SLV = 1UL<<25, // Analog watchdog 3 flag of the slave ADC
	ADC12_COMMON_CSR_AWD2_SLV = 1UL<<24, // Analog watchdog 2 flag of the slave ADC
	ADC12_COMMON_CSR_AWD1_SLV = 1UL<<23, // Analog watchdog 1 flag of the slave ADC
	ADC12_COMMON_CSR_JEOS_SLV = 1UL<<22, // End of injected sequence flag of the slave ADC
	ADC12_COMMON_CSR_JEOC_SLV = 1UL<<21, // End of injected conversion flag of the slave ADC
	ADC12_COMMON_CSR_OVR_SLV = 1UL<<20, // Overrun flag of the slave ADC
	ADC12_COMMON_CSR_EOS_SLV = 1UL<<19, // End of regular sequence flag of the slave ADC
	ADC12_COMMON_CSR_EOC_SLV = 1UL<<18, // End of regular conversion of the slave ADC
	ADC12_COMMON_CSR_EOSMP_SLV = 1UL<<17, // EOSMP_SLV
	ADC12_COMMON_CSR_ADRDY_SLV = 1UL<<16, // ADRDY_SLV
	ADC12_COMMON_CSR_JQOVF_MST = 1UL<<10, // JQOVF_MST
	ADC12_COMMON_CSR_AWD3_MST = 1UL<<9, // AWD3_MST
	ADC12_COMMON_CSR_AWD2_MST = 1UL<<8, // AWD2_MST
	ADC12_COMMON_CSR_AWD1_MST = 1UL<<7, // AWD1_MST
	ADC12_COMMON_CSR_JEOS_MST = 1UL<<6, // JEOS_MST
	ADC12_COMMON_CSR_JEOC_MST = 1UL<<5, // JEOC_MST
	ADC12_COMMON_CSR_OVR_MST = 1UL<<4, // OVR_MST
	ADC12_COMMON_CSR_EOS_MST = 1UL<<3, // EOS_MST
	ADC12_COMMON_CSR_EOC_MST = 1UL<<2, // EOC_MST
	ADC12_COMMON_CSR_EOSMP_MST = 1UL<<1, // EOSMP_MST
	ADC12_COMMON_CSR_ADDRDY_MST = 1UL<<0, // ADDRDY_MST		
};

// ADC12_Common->CCR ADC common control register
enum {
	ADC12_COMMON_CCR_VBATSEL = 1UL<<24, // VBAT selection
	ADC12_COMMON_CCR_VSENSESEL = 1UL<<23, // VTS selection
	ADC12_COMMON_CCR_VREFEN = 1UL<<22, // VREFINT enable
	ADC12_COMMON_CCR_PRESC = ((1UL<<4)-1) << 18, // ADC prescaler
	ADC12_COMMON_CCR_CKMODE = ((1UL<<2)-1) << 16, // ADC clock mode
	ADC12_COMMON_CCR_MDMA = ((1UL<<2)-1) << 14, // Direct memory access mode for multi ADC mode
	ADC12_COMMON_CCR_DMACFG = 1UL<<13, // DMA configuration (for multi-ADC mode)
	ADC12_COMMON_CCR_DELAY = ((1UL<<4)-1) << 8, // Delay between 2 sampling phases
	ADC12_COMMON_CCR_DUAL = ((1UL<<5)-1) << 0, // Dual ADC mode selection		
};
inline void adc12_common_ccr_set_presc(struct ADC12_Common_Type* p, uint32_t val) { p->CCR = (p->CCR & ~ADC12_COMMON_CCR_PRESC) | ((val<<18) & ADC12_COMMON_CCR_PRESC); }
inline void adc12_common_ccr_set_ckmode(struct ADC12_Common_Type* p, uint32_t val) { p->CCR = (p->CCR & ~ADC12_COMMON_CCR_CKMODE) | ((val<<16) & ADC12_COMMON_CCR_CKMODE); }
inline void adc12_common_ccr_set_mdma(struct ADC12_Common_Type* p, uint32_t val) { p->CCR = (p->CCR & ~ADC12_COMMON_CCR_MDMA) | ((val<<14) & ADC12_COMMON_CCR_MDMA); }
inline void adc12_common_ccr_set_delay(struct ADC12_Common_Type* p, uint32_t val) { p->CCR = (p->CCR & ~ADC12_COMMON_CCR_DELAY) | ((val<<8) & ADC12_COMMON_CCR_DELAY); }
inline void adc12_common_ccr_set_dual(struct ADC12_Common_Type* p, uint32_t val) { p->CCR = (p->CCR & ~ADC12_COMMON_CCR_DUAL) | ((val<<0) & ADC12_COMMON_CCR_DUAL); }
inline uint32_t adc12_common_ccr_get_presc(struct ADC12_Common_Type* p) { return (p->CCR & ADC12_COMMON_CCR_PRESC) >> 18 ; }
inline uint32_t adc12_common_ccr_get_ckmode(struct ADC12_Common_Type* p) { return (p->CCR & ADC12_COMMON_CCR_CKMODE) >> 16 ; }
inline uint32_t adc12_common_ccr_get_mdma(struct ADC12_Common_Type* p) { return (p->CCR & ADC12_COMMON_CCR_MDMA) >> 14 ; }
inline uint32_t adc12_common_ccr_get_delay(struct ADC12_Common_Type* p) { return (p->CCR & ADC12_COMMON_CCR_DELAY) >> 8 ; }
inline uint32_t adc12_common_ccr_get_dual(struct ADC12_Common_Type* p) { return (p->CCR & ADC12_COMMON_CCR_DUAL) >> 0 ; }

// ADC12_Common->CDR ADC common regular data register for dual and triple modes
enum {
	ADC12_COMMON_CDR_RDATA_SLV = ((1UL<<16)-1) << 16, // Regular data of the slave ADC
	ADC12_COMMON_CDR_RDATA_MST = ((1UL<<16)-1) << 0, // Regular data of the master ADC		
};
inline uint32_t adc12_common_cdr_get_rdata_slv(struct ADC12_Common_Type* p) { return (p->CDR & ADC12_COMMON_CDR_RDATA_SLV) >> 16 ; }
inline uint32_t adc12_common_cdr_get_rdata_mst(struct ADC12_Common_Type* p) { return (p->CDR & ADC12_COMMON_CDR_RDATA_MST) >> 0 ; }

/* Advanced encryption standard hardware accelerator */
struct AES_Type {
	__IO uint16_t CR; // @0 control register
	 uint8_t RESERVED0[2]; // @2 
	__I uint8_t SR; // @4 status register
	 uint8_t RESERVED1[3]; // @5 
	__IO uint32_t DINR; // @8 data input register
	__I uint32_t DOUTR; // @12 data output register
	__IO uint32_t KEYR0; // @16 key register 0
	__IO uint32_t KEYR1; // @20 key register 1
	__IO uint32_t KEYR2; // @24 key register 2
	__IO uint32_t KEYR3; // @28 key register 3
	__IO uint32_t IVR0; // @32 initialization vector register 0
	__IO uint32_t IVR1; // @36 initialization vector register 1
	__IO uint32_t IVR2; // @40 initialization vector register 2
	__IO uint32_t IVR3; // @44 initialization vector register 3
};

// AES->CR control register
enum {
	AES_CR_DMAOUTEN = 1UL<<12, // Enable DMA management of data output phase
	AES_CR_DMAINEN = 1UL<<11, // Enable DMA management of data input phase
	AES_CR_ERRIE = 1UL<<10, // Error interrupt enable
	AES_CR_CCFIE = 1UL<<9, // CCF flag interrupt enable
	AES_CR_ERRC = 1UL<<8, // Error clear
	AES_CR_CCFC = 1UL<<7, // Computation Complete Flag Clear
	AES_CR_CHMOD = ((1UL<<2)-1) << 5, // AES chaining mode
	AES_CR_MODE = ((1UL<<2)-1) << 3, // AES operating mode
	AES_CR_DATATYPE = ((1UL<<2)-1) << 1, // Data type selection (for data in and data out to/from the cryptographic block)
	AES_CR_EN = 1UL<<0, // AES enable		
};
inline void aes_cr_set_chmod(struct AES_Type* p, uint32_t val) { p->CR = (p->CR & ~AES_CR_CHMOD) | ((val<<5) & AES_CR_CHMOD); }
inline void aes_cr_set_mode(struct AES_Type* p, uint32_t val) { p->CR = (p->CR & ~AES_CR_MODE) | ((val<<3) & AES_CR_MODE); }
inline void aes_cr_set_datatype(struct AES_Type* p, uint32_t val) { p->CR = (p->CR & ~AES_CR_DATATYPE) | ((val<<1) & AES_CR_DATATYPE); }
inline uint32_t aes_cr_get_chmod(struct AES_Type* p) { return (p->CR & AES_CR_CHMOD) >> 5 ; }
inline uint32_t aes_cr_get_mode(struct AES_Type* p) { return (p->CR & AES_CR_MODE) >> 3 ; }
inline uint32_t aes_cr_get_datatype(struct AES_Type* p) { return (p->CR & AES_CR_DATATYPE) >> 1 ; }

// AES->SR status register
enum {
	AES_SR_WRERR = 1UL<<2, // Write error flag
	AES_SR_RDERR = 1UL<<1, // Read error flag
	AES_SR_CCF = 1UL<<0, // Computation complete flag		
};

/* Controller area network */
struct CAN_Type {
	__IO uint32_t MCR; // @0 master control register
	__IO uint16_t MSR; // @4 master status register
	 uint8_t RESERVED0[2]; // @6 
	__IO uint32_t TSR; // @8 transmit status register
	__IO uint8_t RF0R; // @12 receive FIFO 0 register
	 uint8_t RESERVED1[3]; // @13 
	__IO uint8_t RF1R; // @16 receive FIFO 1 register
	 uint8_t RESERVED2[3]; // @17 
	__IO uint32_t IER; // @20 interrupt enable register
	__IO uint32_t ESR; // @24 interrupt enable register
	__IO uint32_t BTR; // @28 bit timing register
	 uint8_t RESERVED3[352]; // @32 
	__IO uint32_t TI0R; // @384 TX mailbox identifier register
	__IO uint32_t TDT0R; // @388 mailbox data length control and time stamp register
	__IO uint32_t TDL0R; // @392 mailbox data low register
	__IO uint32_t TDH0R; // @396 mailbox data high register
	__IO uint32_t TI1R; // @400 mailbox identifier register
	__IO uint32_t TDT1R; // @404 mailbox data length control and time stamp register
	__IO uint32_t TDL1R; // @408 mailbox data low register
	__IO uint32_t TDH1R; // @412 mailbox data high register
	__IO uint32_t TI2R; // @416 mailbox identifier register
	__IO uint32_t TDT2R; // @420 mailbox data length control and time stamp register
	__IO uint32_t TDL2R; // @424 mailbox data low register
	__IO uint32_t TDH2R; // @428 mailbox data high register
	__I uint32_t RI0R; // @432 receive FIFO mailbox identifier register
	__I uint32_t RDT0R; // @436 mailbox data high register
	__I uint32_t RDL0R; // @440 mailbox data high register
	__I uint32_t RDH0R; // @444 receive FIFO mailbox data high register
	__I uint32_t RI1R; // @448 mailbox data high register
	__I uint32_t RDT1R; // @452 mailbox data high register
	__I uint32_t RDL1R; // @456 mailbox data high register
	__I uint32_t RDH1R; // @460 mailbox data high register
	 uint8_t RESERVED4[48]; // @464 
	__IO uint8_t FMR; // @512 filter master register
	 uint8_t RESERVED5[3]; // @513 
	__IO uint16_t FM1R; // @516 filter mode register
	 uint8_t RESERVED6[6]; // @518 
	__IO uint16_t FS1R; // @524 filter scale register
	 uint8_t RESERVED7[6]; // @526 
	__IO uint16_t FFA1R; // @532 filter FIFO assignment register
	 uint8_t RESERVED8[6]; // @534 
	__IO uint16_t FA1R; // @540 filter activation register
	 uint8_t RESERVED9[34]; // @542 
	__IO uint32_t F0R1; // @576 Filter bank 0 register 1
	__IO uint32_t F0R2; // @580 Filter bank 0 register 2
	__IO uint32_t F1R1; // @584 Filter bank 1 register 1
	__IO uint32_t F1R2; // @588 Filter bank 1 register 2
	__IO uint32_t F2R1; // @592 Filter bank 2 register 1
	__IO uint32_t F2R2; // @596 Filter bank 2 register 2
	__IO uint32_t F3R1; // @600 Filter bank 3 register 1
	__IO uint32_t F3R2; // @604 Filter bank 3 register 2
	__IO uint32_t F4R1; // @608 Filter bank 4 register 1
	__IO uint32_t F4R2; // @612 Filter bank 4 register 2
	__IO uint32_t F5R1; // @616 Filter bank 5 register 1
	__IO uint32_t F5R2; // @620 Filter bank 5 register 2
	__IO uint32_t F6R1; // @624 Filter bank 6 register 1
	__IO uint32_t F6R2; // @628 Filter bank 6 register 2
	__IO uint32_t F7R1; // @632 Filter bank 7 register 1
	__IO uint32_t F7R2; // @636 Filter bank 7 register 2
	__IO uint32_t F8R1; // @640 Filter bank 8 register 1
	__IO uint32_t F8R2; // @644 Filter bank 8 register 2
	__IO uint32_t F9R1; // @648 Filter bank 9 register 1
	__IO uint32_t F9R2; // @652 Filter bank 9 register 2
	__IO uint32_t F10R1; // @656 Filter bank 10 register 1
	__IO uint32_t F10R2; // @660 Filter bank 10 register 2
	__IO uint32_t F11R1; // @664 Filter bank 11 register 1
	__IO uint32_t F11R2; // @668 Filter bank 11 register 2
	__IO uint32_t F12R1; // @672 Filter bank 4 register 1
	__IO uint32_t F12R2; // @676 Filter bank 12 register 2
	__IO uint32_t F13R1; // @680 Filter bank 13 register 1
	__IO uint32_t F13R2; // @684 Filter bank 13 register 2
	__IO uint32_t F14R1; // @688 Filter bank 14 register 1
	__IO uint32_t F14R2; // @692 Filter bank 14 register 2
	__IO uint32_t F15R1; // @696 Filter bank 15 register 1
	__IO uint32_t F15R2; // @700 Filter bank 15 register 2
	__IO uint32_t F16R1; // @704 Filter bank 16 register 1
	__IO uint32_t F16R2; // @708 Filter bank 16 register 2
	__IO uint32_t F17R1; // @712 Filter bank 17 register 1
	__IO uint32_t F17R2; // @716 Filter bank 17 register 2
	__IO uint32_t F18R1; // @720 Filter bank 18 register 1
	__IO uint32_t F18R2; // @724 Filter bank 18 register 2
	__IO uint32_t F19R1; // @728 Filter bank 19 register 1
	__IO uint32_t F19R2; // @732 Filter bank 19 register 2
	__IO uint32_t F20R1; // @736 Filter bank 20 register 1
	__IO uint32_t F20R2; // @740 Filter bank 20 register 2
	__IO uint32_t F21R1; // @744 Filter bank 21 register 1
	__IO uint32_t F21R2; // @748 Filter bank 21 register 2
	__IO uint32_t F22R1; // @752 Filter bank 22 register 1
	__IO uint32_t F22R2; // @756 Filter bank 22 register 2
	__IO uint32_t F23R1; // @760 Filter bank 23 register 1
	__IO uint32_t F23R2; // @764 Filter bank 23 register 2
	__IO uint32_t F24R1; // @768 Filter bank 24 register 1
	__IO uint32_t F24R2; // @772 Filter bank 24 register 2
	__IO uint32_t F25R1; // @776 Filter bank 25 register 1
	__IO uint32_t F25R2; // @780 Filter bank 25 register 2
	__IO uint32_t F26R1; // @784 Filter bank 26 register 1
	__IO uint32_t F26R2; // @788 Filter bank 26 register 2
	__IO uint32_t F27R1; // @792 Filter bank 27 register 1
	__IO uint32_t F27R2; // @796 Filter bank 27 register 2
};

// CAN->MCR master control register
enum {
	CAN_MCR_DBF = 1UL<<16, // DBF
	CAN_MCR_RESET = 1UL<<15, // RESET
	CAN_MCR_TTCM = 1UL<<7, // TTCM
	CAN_MCR_ABOM = 1UL<<6, // ABOM
	CAN_MCR_AWUM = 1UL<<5, // AWUM
	CAN_MCR_NART = 1UL<<4, // NART
	CAN_MCR_RFLM = 1UL<<3, // RFLM
	CAN_MCR_TXFP = 1UL<<2, // TXFP
	CAN_MCR_SLEEP = 1UL<<1, // SLEEP
	CAN_MCR_INRQ = 1UL<<0, // INRQ		
};

// CAN->MSR master status register
enum {
	CAN_MSR_RX = 1UL<<11, // RX
	CAN_MSR_SAMP = 1UL<<10, // SAMP
	CAN_MSR_RXM = 1UL<<9, // RXM
	CAN_MSR_TXM = 1UL<<8, // TXM
	CAN_MSR_SLAKI = 1UL<<4, // SLAKI
	CAN_MSR_WKUI = 1UL<<3, // WKUI
	CAN_MSR_ERRI = 1UL<<2, // ERRI
	CAN_MSR_SLAK = 1UL<<1, // SLAK
	CAN_MSR_INAK = 1UL<<0, // INAK		
};

// CAN->TSR transmit status register
enum {
	CAN_TSR_LOW2 = 1UL<<31, // Lowest priority flag for mailbox 2
	CAN_TSR_LOW1 = 1UL<<30, // Lowest priority flag for mailbox 1
	CAN_TSR_LOW0 = 1UL<<29, // Lowest priority flag for mailbox 0
	CAN_TSR_TME2 = 1UL<<28, // Lowest priority flag for mailbox 2
	CAN_TSR_TME1 = 1UL<<27, // Lowest priority flag for mailbox 1
	CAN_TSR_TME0 = 1UL<<26, // Lowest priority flag for mailbox 0
	CAN_TSR_CODE = ((1UL<<2)-1) << 24, // CODE
	CAN_TSR_ABRQ2 = 1UL<<23, // ABRQ2
	CAN_TSR_TERR2 = 1UL<<19, // TERR2
	CAN_TSR_ALST2 = 1UL<<18, // ALST2
	CAN_TSR_TXOK2 = 1UL<<17, // TXOK2
	CAN_TSR_RQCP2 = 1UL<<16, // RQCP2
	CAN_TSR_ABRQ1 = 1UL<<15, // ABRQ1
	CAN_TSR_TERR1 = 1UL<<11, // TERR1
	CAN_TSR_ALST1 = 1UL<<10, // ALST1
	CAN_TSR_TXOK1 = 1UL<<9, // TXOK1
	CAN_TSR_RQCP1 = 1UL<<8, // RQCP1
	CAN_TSR_ABRQ0 = 1UL<<7, // ABRQ0
	CAN_TSR_TERR0 = 1UL<<3, // TERR0
	CAN_TSR_ALST0 = 1UL<<2, // ALST0
	CAN_TSR_TXOK0 = 1UL<<1, // TXOK0
	CAN_TSR_RQCP0 = 1UL<<0, // RQCP0		
};
inline void can_tsr_set_code(struct CAN_Type* p, uint32_t val) { p->TSR = (p->TSR & ~CAN_TSR_CODE) | ((val<<24) & CAN_TSR_CODE); }
inline uint32_t can_tsr_get_code(struct CAN_Type* p) { return (p->TSR & CAN_TSR_CODE) >> 24 ; }

// CAN->RF0R receive FIFO 0 register
enum {
	CAN_RF0R_RFOM0 = 1UL<<5, // RFOM0
	CAN_RF0R_FOVR0 = 1UL<<4, // FOVR0
	CAN_RF0R_FULL0 = 1UL<<3, // FULL0
	CAN_RF0R_FMP0 = ((1UL<<2)-1) << 0, // FMP0		
};
inline void can_rf0r_set_fmp0(struct CAN_Type* p, uint32_t val) { p->RF0R = (p->RF0R & ~CAN_RF0R_FMP0) | ((val<<0) & CAN_RF0R_FMP0); }
inline uint32_t can_rf0r_get_fmp0(struct CAN_Type* p) { return (p->RF0R & CAN_RF0R_FMP0) >> 0 ; }

// CAN->RF1R receive FIFO 1 register
enum {
	CAN_RF1R_RFOM1 = 1UL<<5, // RFOM1
	CAN_RF1R_FOVR1 = 1UL<<4, // FOVR1
	CAN_RF1R_FULL1 = 1UL<<3, // FULL1
	CAN_RF1R_FMP1 = ((1UL<<2)-1) << 0, // FMP1		
};
inline void can_rf1r_set_fmp1(struct CAN_Type* p, uint32_t val) { p->RF1R = (p->RF1R & ~CAN_RF1R_FMP1) | ((val<<0) & CAN_RF1R_FMP1); }
inline uint32_t can_rf1r_get_fmp1(struct CAN_Type* p) { return (p->RF1R & CAN_RF1R_FMP1) >> 0 ; }

// CAN->IER interrupt enable register
enum {
	CAN_IER_SLKIE = 1UL<<17, // SLKIE
	CAN_IER_WKUIE = 1UL<<16, // WKUIE
	CAN_IER_ERRIE = 1UL<<15, // ERRIE
	CAN_IER_LECIE = 1UL<<11, // LECIE
	CAN_IER_BOFIE = 1UL<<10, // BOFIE
	CAN_IER_EPVIE = 1UL<<9, // EPVIE
	CAN_IER_EWGIE = 1UL<<8, // EWGIE
	CAN_IER_FOVIE1 = 1UL<<6, // FOVIE1
	CAN_IER_FFIE1 = 1UL<<5, // FFIE1
	CAN_IER_FMPIE1 = 1UL<<4, // FMPIE1
	CAN_IER_FOVIE0 = 1UL<<3, // FOVIE0
	CAN_IER_FFIE0 = 1UL<<2, // FFIE0
	CAN_IER_FMPIE0 = 1UL<<1, // FMPIE0
	CAN_IER_TMEIE = 1UL<<0, // TMEIE		
};

// CAN->ESR interrupt enable register
enum {
	CAN_ESR_REC = ((1UL<<8)-1) << 24, // REC
	CAN_ESR_TEC = ((1UL<<8)-1) << 16, // TEC
	CAN_ESR_LEC = ((1UL<<3)-1) << 4, // LEC
	CAN_ESR_BOFF = 1UL<<2, // BOFF
	CAN_ESR_EPVF = 1UL<<1, // EPVF
	CAN_ESR_EWGF = 1UL<<0, // EWGF		
};
inline void can_esr_set_rec(struct CAN_Type* p, uint32_t val) { p->ESR = (p->ESR & ~CAN_ESR_REC) | ((val<<24) & CAN_ESR_REC); }
inline void can_esr_set_tec(struct CAN_Type* p, uint32_t val) { p->ESR = (p->ESR & ~CAN_ESR_TEC) | ((val<<16) & CAN_ESR_TEC); }
inline void can_esr_set_lec(struct CAN_Type* p, uint32_t val) { p->ESR = (p->ESR & ~CAN_ESR_LEC) | ((val<<4) & CAN_ESR_LEC); }
inline uint32_t can_esr_get_rec(struct CAN_Type* p) { return (p->ESR & CAN_ESR_REC) >> 24 ; }
inline uint32_t can_esr_get_tec(struct CAN_Type* p) { return (p->ESR & CAN_ESR_TEC) >> 16 ; }
inline uint32_t can_esr_get_lec(struct CAN_Type* p) { return (p->ESR & CAN_ESR_LEC) >> 4 ; }

// CAN->BTR bit timing register
enum {
	CAN_BTR_SILM = 1UL<<31, // SILM
	CAN_BTR_LBKM = 1UL<<30, // LBKM
	CAN_BTR_SJW = ((1UL<<2)-1) << 24, // SJW
	CAN_BTR_TS2 = ((1UL<<3)-1) << 20, // TS2
	CAN_BTR_TS1 = ((1UL<<4)-1) << 16, // TS1
	CAN_BTR_BRP = ((1UL<<10)-1) << 0, // BRP		
};
inline void can_btr_set_sjw(struct CAN_Type* p, uint32_t val) { p->BTR = (p->BTR & ~CAN_BTR_SJW) | ((val<<24) & CAN_BTR_SJW); }
inline void can_btr_set_ts2(struct CAN_Type* p, uint32_t val) { p->BTR = (p->BTR & ~CAN_BTR_TS2) | ((val<<20) & CAN_BTR_TS2); }
inline void can_btr_set_ts1(struct CAN_Type* p, uint32_t val) { p->BTR = (p->BTR & ~CAN_BTR_TS1) | ((val<<16) & CAN_BTR_TS1); }
inline void can_btr_set_brp(struct CAN_Type* p, uint32_t val) { p->BTR = (p->BTR & ~CAN_BTR_BRP) | ((val<<0) & CAN_BTR_BRP); }
inline uint32_t can_btr_get_sjw(struct CAN_Type* p) { return (p->BTR & CAN_BTR_SJW) >> 24 ; }
inline uint32_t can_btr_get_ts2(struct CAN_Type* p) { return (p->BTR & CAN_BTR_TS2) >> 20 ; }
inline uint32_t can_btr_get_ts1(struct CAN_Type* p) { return (p->BTR & CAN_BTR_TS1) >> 16 ; }
inline uint32_t can_btr_get_brp(struct CAN_Type* p) { return (p->BTR & CAN_BTR_BRP) >> 0 ; }

// CAN->TI0R TX mailbox identifier register
enum {
	CAN_TI0R_STID = ((1UL<<11)-1) << 21, // STID
	CAN_TI0R_EXID = ((1UL<<18)-1) << 3, // EXID
	CAN_TI0R_IDE = 1UL<<2, // IDE
	CAN_TI0R_RTR = 1UL<<1, // RTR
	CAN_TI0R_TXRQ = 1UL<<0, // TXRQ		
};
inline void can_ti0r_set_stid(struct CAN_Type* p, uint32_t val) { p->TI0R = (p->TI0R & ~CAN_TI0R_STID) | ((val<<21) & CAN_TI0R_STID); }
inline void can_ti0r_set_exid(struct CAN_Type* p, uint32_t val) { p->TI0R = (p->TI0R & ~CAN_TI0R_EXID) | ((val<<3) & CAN_TI0R_EXID); }
inline uint32_t can_ti0r_get_stid(struct CAN_Type* p) { return (p->TI0R & CAN_TI0R_STID) >> 21 ; }
inline uint32_t can_ti0r_get_exid(struct CAN_Type* p) { return (p->TI0R & CAN_TI0R_EXID) >> 3 ; }

// CAN->TDT0R mailbox data length control and time stamp register
enum {
	CAN_TDT0R_TIME = ((1UL<<16)-1) << 16, // TIME
	CAN_TDT0R_TGT = 1UL<<8, // TGT
	CAN_TDT0R_DLC = ((1UL<<4)-1) << 0, // DLC		
};
inline void can_tdt0r_set_time(struct CAN_Type* p, uint32_t val) { p->TDT0R = (p->TDT0R & ~CAN_TDT0R_TIME) | ((val<<16) & CAN_TDT0R_TIME); }
inline void can_tdt0r_set_dlc(struct CAN_Type* p, uint32_t val) { p->TDT0R = (p->TDT0R & ~CAN_TDT0R_DLC) | ((val<<0) & CAN_TDT0R_DLC); }
inline uint32_t can_tdt0r_get_time(struct CAN_Type* p) { return (p->TDT0R & CAN_TDT0R_TIME) >> 16 ; }
inline uint32_t can_tdt0r_get_dlc(struct CAN_Type* p) { return (p->TDT0R & CAN_TDT0R_DLC) >> 0 ; }

// CAN->TDL0R mailbox data low register
enum {
	CAN_TDL0R_DATA3 = ((1UL<<8)-1) << 24, // DATA3
	CAN_TDL0R_DATA2 = ((1UL<<8)-1) << 16, // DATA2
	CAN_TDL0R_DATA1 = ((1UL<<8)-1) << 8, // DATA1
	CAN_TDL0R_DATA0 = ((1UL<<8)-1) << 0, // DATA0		
};
inline void can_tdl0r_set_data3(struct CAN_Type* p, uint32_t val) { p->TDL0R = (p->TDL0R & ~CAN_TDL0R_DATA3) | ((val<<24) & CAN_TDL0R_DATA3); }
inline void can_tdl0r_set_data2(struct CAN_Type* p, uint32_t val) { p->TDL0R = (p->TDL0R & ~CAN_TDL0R_DATA2) | ((val<<16) & CAN_TDL0R_DATA2); }
inline void can_tdl0r_set_data1(struct CAN_Type* p, uint32_t val) { p->TDL0R = (p->TDL0R & ~CAN_TDL0R_DATA1) | ((val<<8) & CAN_TDL0R_DATA1); }
inline void can_tdl0r_set_data0(struct CAN_Type* p, uint32_t val) { p->TDL0R = (p->TDL0R & ~CAN_TDL0R_DATA0) | ((val<<0) & CAN_TDL0R_DATA0); }
inline uint32_t can_tdl0r_get_data3(struct CAN_Type* p) { return (p->TDL0R & CAN_TDL0R_DATA3) >> 24 ; }
inline uint32_t can_tdl0r_get_data2(struct CAN_Type* p) { return (p->TDL0R & CAN_TDL0R_DATA2) >> 16 ; }
inline uint32_t can_tdl0r_get_data1(struct CAN_Type* p) { return (p->TDL0R & CAN_TDL0R_DATA1) >> 8 ; }
inline uint32_t can_tdl0r_get_data0(struct CAN_Type* p) { return (p->TDL0R & CAN_TDL0R_DATA0) >> 0 ; }

// CAN->TDH0R mailbox data high register
enum {
	CAN_TDH0R_DATA7 = ((1UL<<8)-1) << 24, // DATA7
	CAN_TDH0R_DATA6 = ((1UL<<8)-1) << 16, // DATA6
	CAN_TDH0R_DATA5 = ((1UL<<8)-1) << 8, // DATA5
	CAN_TDH0R_DATA4 = ((1UL<<8)-1) << 0, // DATA4		
};
inline void can_tdh0r_set_data7(struct CAN_Type* p, uint32_t val) { p->TDH0R = (p->TDH0R & ~CAN_TDH0R_DATA7) | ((val<<24) & CAN_TDH0R_DATA7); }
inline void can_tdh0r_set_data6(struct CAN_Type* p, uint32_t val) { p->TDH0R = (p->TDH0R & ~CAN_TDH0R_DATA6) | ((val<<16) & CAN_TDH0R_DATA6); }
inline void can_tdh0r_set_data5(struct CAN_Type* p, uint32_t val) { p->TDH0R = (p->TDH0R & ~CAN_TDH0R_DATA5) | ((val<<8) & CAN_TDH0R_DATA5); }
inline void can_tdh0r_set_data4(struct CAN_Type* p, uint32_t val) { p->TDH0R = (p->TDH0R & ~CAN_TDH0R_DATA4) | ((val<<0) & CAN_TDH0R_DATA4); }
inline uint32_t can_tdh0r_get_data7(struct CAN_Type* p) { return (p->TDH0R & CAN_TDH0R_DATA7) >> 24 ; }
inline uint32_t can_tdh0r_get_data6(struct CAN_Type* p) { return (p->TDH0R & CAN_TDH0R_DATA6) >> 16 ; }
inline uint32_t can_tdh0r_get_data5(struct CAN_Type* p) { return (p->TDH0R & CAN_TDH0R_DATA5) >> 8 ; }
inline uint32_t can_tdh0r_get_data4(struct CAN_Type* p) { return (p->TDH0R & CAN_TDH0R_DATA4) >> 0 ; }

// CAN->TI1R mailbox identifier register
enum {
	CAN_TI1R_STID = ((1UL<<11)-1) << 21, // STID
	CAN_TI1R_EXID = ((1UL<<18)-1) << 3, // EXID
	CAN_TI1R_IDE = 1UL<<2, // IDE
	CAN_TI1R_RTR = 1UL<<1, // RTR
	CAN_TI1R_TXRQ = 1UL<<0, // TXRQ		
};
inline void can_ti1r_set_stid(struct CAN_Type* p, uint32_t val) { p->TI1R = (p->TI1R & ~CAN_TI1R_STID) | ((val<<21) & CAN_TI1R_STID); }
inline void can_ti1r_set_exid(struct CAN_Type* p, uint32_t val) { p->TI1R = (p->TI1R & ~CAN_TI1R_EXID) | ((val<<3) & CAN_TI1R_EXID); }
inline uint32_t can_ti1r_get_stid(struct CAN_Type* p) { return (p->TI1R & CAN_TI1R_STID) >> 21 ; }
inline uint32_t can_ti1r_get_exid(struct CAN_Type* p) { return (p->TI1R & CAN_TI1R_EXID) >> 3 ; }

// CAN->TDT1R mailbox data length control and time stamp register
enum {
	CAN_TDT1R_TIME = ((1UL<<16)-1) << 16, // TIME
	CAN_TDT1R_TGT = 1UL<<8, // TGT
	CAN_TDT1R_DLC = ((1UL<<4)-1) << 0, // DLC		
};
inline void can_tdt1r_set_time(struct CAN_Type* p, uint32_t val) { p->TDT1R = (p->TDT1R & ~CAN_TDT1R_TIME) | ((val<<16) & CAN_TDT1R_TIME); }
inline void can_tdt1r_set_dlc(struct CAN_Type* p, uint32_t val) { p->TDT1R = (p->TDT1R & ~CAN_TDT1R_DLC) | ((val<<0) & CAN_TDT1R_DLC); }
inline uint32_t can_tdt1r_get_time(struct CAN_Type* p) { return (p->TDT1R & CAN_TDT1R_TIME) >> 16 ; }
inline uint32_t can_tdt1r_get_dlc(struct CAN_Type* p) { return (p->TDT1R & CAN_TDT1R_DLC) >> 0 ; }

// CAN->TDL1R mailbox data low register
enum {
	CAN_TDL1R_DATA3 = ((1UL<<8)-1) << 24, // DATA3
	CAN_TDL1R_DATA2 = ((1UL<<8)-1) << 16, // DATA2
	CAN_TDL1R_DATA1 = ((1UL<<8)-1) << 8, // DATA1
	CAN_TDL1R_DATA0 = ((1UL<<8)-1) << 0, // DATA0		
};
inline void can_tdl1r_set_data3(struct CAN_Type* p, uint32_t val) { p->TDL1R = (p->TDL1R & ~CAN_TDL1R_DATA3) | ((val<<24) & CAN_TDL1R_DATA3); }
inline void can_tdl1r_set_data2(struct CAN_Type* p, uint32_t val) { p->TDL1R = (p->TDL1R & ~CAN_TDL1R_DATA2) | ((val<<16) & CAN_TDL1R_DATA2); }
inline void can_tdl1r_set_data1(struct CAN_Type* p, uint32_t val) { p->TDL1R = (p->TDL1R & ~CAN_TDL1R_DATA1) | ((val<<8) & CAN_TDL1R_DATA1); }
inline void can_tdl1r_set_data0(struct CAN_Type* p, uint32_t val) { p->TDL1R = (p->TDL1R & ~CAN_TDL1R_DATA0) | ((val<<0) & CAN_TDL1R_DATA0); }
inline uint32_t can_tdl1r_get_data3(struct CAN_Type* p) { return (p->TDL1R & CAN_TDL1R_DATA3) >> 24 ; }
inline uint32_t can_tdl1r_get_data2(struct CAN_Type* p) { return (p->TDL1R & CAN_TDL1R_DATA2) >> 16 ; }
inline uint32_t can_tdl1r_get_data1(struct CAN_Type* p) { return (p->TDL1R & CAN_TDL1R_DATA1) >> 8 ; }
inline uint32_t can_tdl1r_get_data0(struct CAN_Type* p) { return (p->TDL1R & CAN_TDL1R_DATA0) >> 0 ; }

// CAN->TDH1R mailbox data high register
enum {
	CAN_TDH1R_DATA7 = ((1UL<<8)-1) << 24, // DATA7
	CAN_TDH1R_DATA6 = ((1UL<<8)-1) << 16, // DATA6
	CAN_TDH1R_DATA5 = ((1UL<<8)-1) << 8, // DATA5
	CAN_TDH1R_DATA4 = ((1UL<<8)-1) << 0, // DATA4		
};
inline void can_tdh1r_set_data7(struct CAN_Type* p, uint32_t val) { p->TDH1R = (p->TDH1R & ~CAN_TDH1R_DATA7) | ((val<<24) & CAN_TDH1R_DATA7); }
inline void can_tdh1r_set_data6(struct CAN_Type* p, uint32_t val) { p->TDH1R = (p->TDH1R & ~CAN_TDH1R_DATA6) | ((val<<16) & CAN_TDH1R_DATA6); }
inline void can_tdh1r_set_data5(struct CAN_Type* p, uint32_t val) { p->TDH1R = (p->TDH1R & ~CAN_TDH1R_DATA5) | ((val<<8) & CAN_TDH1R_DATA5); }
inline void can_tdh1r_set_data4(struct CAN_Type* p, uint32_t val) { p->TDH1R = (p->TDH1R & ~CAN_TDH1R_DATA4) | ((val<<0) & CAN_TDH1R_DATA4); }
inline uint32_t can_tdh1r_get_data7(struct CAN_Type* p) { return (p->TDH1R & CAN_TDH1R_DATA7) >> 24 ; }
inline uint32_t can_tdh1r_get_data6(struct CAN_Type* p) { return (p->TDH1R & CAN_TDH1R_DATA6) >> 16 ; }
inline uint32_t can_tdh1r_get_data5(struct CAN_Type* p) { return (p->TDH1R & CAN_TDH1R_DATA5) >> 8 ; }
inline uint32_t can_tdh1r_get_data4(struct CAN_Type* p) { return (p->TDH1R & CAN_TDH1R_DATA4) >> 0 ; }

// CAN->TI2R mailbox identifier register
enum {
	CAN_TI2R_STID = ((1UL<<11)-1) << 21, // STID
	CAN_TI2R_EXID = ((1UL<<18)-1) << 3, // EXID
	CAN_TI2R_IDE = 1UL<<2, // IDE
	CAN_TI2R_RTR = 1UL<<1, // RTR
	CAN_TI2R_TXRQ = 1UL<<0, // TXRQ		
};
inline void can_ti2r_set_stid(struct CAN_Type* p, uint32_t val) { p->TI2R = (p->TI2R & ~CAN_TI2R_STID) | ((val<<21) & CAN_TI2R_STID); }
inline void can_ti2r_set_exid(struct CAN_Type* p, uint32_t val) { p->TI2R = (p->TI2R & ~CAN_TI2R_EXID) | ((val<<3) & CAN_TI2R_EXID); }
inline uint32_t can_ti2r_get_stid(struct CAN_Type* p) { return (p->TI2R & CAN_TI2R_STID) >> 21 ; }
inline uint32_t can_ti2r_get_exid(struct CAN_Type* p) { return (p->TI2R & CAN_TI2R_EXID) >> 3 ; }

// CAN->TDT2R mailbox data length control and time stamp register
enum {
	CAN_TDT2R_TIME = ((1UL<<16)-1) << 16, // TIME
	CAN_TDT2R_TGT = 1UL<<8, // TGT
	CAN_TDT2R_DLC = ((1UL<<4)-1) << 0, // DLC		
};
inline void can_tdt2r_set_time(struct CAN_Type* p, uint32_t val) { p->TDT2R = (p->TDT2R & ~CAN_TDT2R_TIME) | ((val<<16) & CAN_TDT2R_TIME); }
inline void can_tdt2r_set_dlc(struct CAN_Type* p, uint32_t val) { p->TDT2R = (p->TDT2R & ~CAN_TDT2R_DLC) | ((val<<0) & CAN_TDT2R_DLC); }
inline uint32_t can_tdt2r_get_time(struct CAN_Type* p) { return (p->TDT2R & CAN_TDT2R_TIME) >> 16 ; }
inline uint32_t can_tdt2r_get_dlc(struct CAN_Type* p) { return (p->TDT2R & CAN_TDT2R_DLC) >> 0 ; }

// CAN->TDL2R mailbox data low register
enum {
	CAN_TDL2R_DATA3 = ((1UL<<8)-1) << 24, // DATA3
	CAN_TDL2R_DATA2 = ((1UL<<8)-1) << 16, // DATA2
	CAN_TDL2R_DATA1 = ((1UL<<8)-1) << 8, // DATA1
	CAN_TDL2R_DATA0 = ((1UL<<8)-1) << 0, // DATA0		
};
inline void can_tdl2r_set_data3(struct CAN_Type* p, uint32_t val) { p->TDL2R = (p->TDL2R & ~CAN_TDL2R_DATA3) | ((val<<24) & CAN_TDL2R_DATA3); }
inline void can_tdl2r_set_data2(struct CAN_Type* p, uint32_t val) { p->TDL2R = (p->TDL2R & ~CAN_TDL2R_DATA2) | ((val<<16) & CAN_TDL2R_DATA2); }
inline void can_tdl2r_set_data1(struct CAN_Type* p, uint32_t val) { p->TDL2R = (p->TDL2R & ~CAN_TDL2R_DATA1) | ((val<<8) & CAN_TDL2R_DATA1); }
inline void can_tdl2r_set_data0(struct CAN_Type* p, uint32_t val) { p->TDL2R = (p->TDL2R & ~CAN_TDL2R_DATA0) | ((val<<0) & CAN_TDL2R_DATA0); }
inline uint32_t can_tdl2r_get_data3(struct CAN_Type* p) { return (p->TDL2R & CAN_TDL2R_DATA3) >> 24 ; }
inline uint32_t can_tdl2r_get_data2(struct CAN_Type* p) { return (p->TDL2R & CAN_TDL2R_DATA2) >> 16 ; }
inline uint32_t can_tdl2r_get_data1(struct CAN_Type* p) { return (p->TDL2R & CAN_TDL2R_DATA1) >> 8 ; }
inline uint32_t can_tdl2r_get_data0(struct CAN_Type* p) { return (p->TDL2R & CAN_TDL2R_DATA0) >> 0 ; }

// CAN->TDH2R mailbox data high register
enum {
	CAN_TDH2R_DATA7 = ((1UL<<8)-1) << 24, // DATA7
	CAN_TDH2R_DATA6 = ((1UL<<8)-1) << 16, // DATA6
	CAN_TDH2R_DATA5 = ((1UL<<8)-1) << 8, // DATA5
	CAN_TDH2R_DATA4 = ((1UL<<8)-1) << 0, // DATA4		
};
inline void can_tdh2r_set_data7(struct CAN_Type* p, uint32_t val) { p->TDH2R = (p->TDH2R & ~CAN_TDH2R_DATA7) | ((val<<24) & CAN_TDH2R_DATA7); }
inline void can_tdh2r_set_data6(struct CAN_Type* p, uint32_t val) { p->TDH2R = (p->TDH2R & ~CAN_TDH2R_DATA6) | ((val<<16) & CAN_TDH2R_DATA6); }
inline void can_tdh2r_set_data5(struct CAN_Type* p, uint32_t val) { p->TDH2R = (p->TDH2R & ~CAN_TDH2R_DATA5) | ((val<<8) & CAN_TDH2R_DATA5); }
inline void can_tdh2r_set_data4(struct CAN_Type* p, uint32_t val) { p->TDH2R = (p->TDH2R & ~CAN_TDH2R_DATA4) | ((val<<0) & CAN_TDH2R_DATA4); }
inline uint32_t can_tdh2r_get_data7(struct CAN_Type* p) { return (p->TDH2R & CAN_TDH2R_DATA7) >> 24 ; }
inline uint32_t can_tdh2r_get_data6(struct CAN_Type* p) { return (p->TDH2R & CAN_TDH2R_DATA6) >> 16 ; }
inline uint32_t can_tdh2r_get_data5(struct CAN_Type* p) { return (p->TDH2R & CAN_TDH2R_DATA5) >> 8 ; }
inline uint32_t can_tdh2r_get_data4(struct CAN_Type* p) { return (p->TDH2R & CAN_TDH2R_DATA4) >> 0 ; }

// CAN->RI0R receive FIFO mailbox identifier register
enum {
	CAN_RI0R_STID = ((1UL<<11)-1) << 21, // STID
	CAN_RI0R_EXID = ((1UL<<18)-1) << 3, // EXID
	CAN_RI0R_IDE = 1UL<<2, // IDE
	CAN_RI0R_RTR = 1UL<<1, // RTR		
};
inline uint32_t can_ri0r_get_stid(struct CAN_Type* p) { return (p->RI0R & CAN_RI0R_STID) >> 21 ; }
inline uint32_t can_ri0r_get_exid(struct CAN_Type* p) { return (p->RI0R & CAN_RI0R_EXID) >> 3 ; }

// CAN->RDT0R mailbox data high register
enum {
	CAN_RDT0R_TIME = ((1UL<<16)-1) << 16, // TIME
	CAN_RDT0R_FMI = ((1UL<<8)-1) << 8, // FMI
	CAN_RDT0R_DLC = ((1UL<<4)-1) << 0, // DLC		
};
inline uint32_t can_rdt0r_get_time(struct CAN_Type* p) { return (p->RDT0R & CAN_RDT0R_TIME) >> 16 ; }
inline uint32_t can_rdt0r_get_fmi(struct CAN_Type* p) { return (p->RDT0R & CAN_RDT0R_FMI) >> 8 ; }
inline uint32_t can_rdt0r_get_dlc(struct CAN_Type* p) { return (p->RDT0R & CAN_RDT0R_DLC) >> 0 ; }

// CAN->RDL0R mailbox data high register
enum {
	CAN_RDL0R_DATA3 = ((1UL<<8)-1) << 24, // DATA3
	CAN_RDL0R_DATA2 = ((1UL<<8)-1) << 16, // DATA2
	CAN_RDL0R_DATA1 = ((1UL<<8)-1) << 8, // DATA1
	CAN_RDL0R_DATA0 = ((1UL<<8)-1) << 0, // DATA0		
};
inline uint32_t can_rdl0r_get_data3(struct CAN_Type* p) { return (p->RDL0R & CAN_RDL0R_DATA3) >> 24 ; }
inline uint32_t can_rdl0r_get_data2(struct CAN_Type* p) { return (p->RDL0R & CAN_RDL0R_DATA2) >> 16 ; }
inline uint32_t can_rdl0r_get_data1(struct CAN_Type* p) { return (p->RDL0R & CAN_RDL0R_DATA1) >> 8 ; }
inline uint32_t can_rdl0r_get_data0(struct CAN_Type* p) { return (p->RDL0R & CAN_RDL0R_DATA0) >> 0 ; }

// CAN->RDH0R receive FIFO mailbox data high register
enum {
	CAN_RDH0R_DATA7 = ((1UL<<8)-1) << 24, // DATA7
	CAN_RDH0R_DATA6 = ((1UL<<8)-1) << 16, // DATA6
	CAN_RDH0R_DATA5 = ((1UL<<8)-1) << 8, // DATA5
	CAN_RDH0R_DATA4 = ((1UL<<8)-1) << 0, // DATA4		
};
inline uint32_t can_rdh0r_get_data7(struct CAN_Type* p) { return (p->RDH0R & CAN_RDH0R_DATA7) >> 24 ; }
inline uint32_t can_rdh0r_get_data6(struct CAN_Type* p) { return (p->RDH0R & CAN_RDH0R_DATA6) >> 16 ; }
inline uint32_t can_rdh0r_get_data5(struct CAN_Type* p) { return (p->RDH0R & CAN_RDH0R_DATA5) >> 8 ; }
inline uint32_t can_rdh0r_get_data4(struct CAN_Type* p) { return (p->RDH0R & CAN_RDH0R_DATA4) >> 0 ; }

// CAN->RI1R mailbox data high register
enum {
	CAN_RI1R_STID = ((1UL<<11)-1) << 21, // STID
	CAN_RI1R_EXID = ((1UL<<18)-1) << 3, // EXID
	CAN_RI1R_IDE = 1UL<<2, // IDE
	CAN_RI1R_RTR = 1UL<<1, // RTR		
};
inline uint32_t can_ri1r_get_stid(struct CAN_Type* p) { return (p->RI1R & CAN_RI1R_STID) >> 21 ; }
inline uint32_t can_ri1r_get_exid(struct CAN_Type* p) { return (p->RI1R & CAN_RI1R_EXID) >> 3 ; }

// CAN->RDT1R mailbox data high register
enum {
	CAN_RDT1R_TIME = ((1UL<<16)-1) << 16, // TIME
	CAN_RDT1R_FMI = ((1UL<<8)-1) << 8, // FMI
	CAN_RDT1R_DLC = ((1UL<<4)-1) << 0, // DLC		
};
inline uint32_t can_rdt1r_get_time(struct CAN_Type* p) { return (p->RDT1R & CAN_RDT1R_TIME) >> 16 ; }
inline uint32_t can_rdt1r_get_fmi(struct CAN_Type* p) { return (p->RDT1R & CAN_RDT1R_FMI) >> 8 ; }
inline uint32_t can_rdt1r_get_dlc(struct CAN_Type* p) { return (p->RDT1R & CAN_RDT1R_DLC) >> 0 ; }

// CAN->RDL1R mailbox data high register
enum {
	CAN_RDL1R_DATA3 = ((1UL<<8)-1) << 24, // DATA3
	CAN_RDL1R_DATA2 = ((1UL<<8)-1) << 16, // DATA2
	CAN_RDL1R_DATA1 = ((1UL<<8)-1) << 8, // DATA1
	CAN_RDL1R_DATA0 = ((1UL<<8)-1) << 0, // DATA0		
};
inline uint32_t can_rdl1r_get_data3(struct CAN_Type* p) { return (p->RDL1R & CAN_RDL1R_DATA3) >> 24 ; }
inline uint32_t can_rdl1r_get_data2(struct CAN_Type* p) { return (p->RDL1R & CAN_RDL1R_DATA2) >> 16 ; }
inline uint32_t can_rdl1r_get_data1(struct CAN_Type* p) { return (p->RDL1R & CAN_RDL1R_DATA1) >> 8 ; }
inline uint32_t can_rdl1r_get_data0(struct CAN_Type* p) { return (p->RDL1R & CAN_RDL1R_DATA0) >> 0 ; }

// CAN->RDH1R mailbox data high register
enum {
	CAN_RDH1R_DATA7 = ((1UL<<8)-1) << 24, // DATA7
	CAN_RDH1R_DATA6 = ((1UL<<8)-1) << 16, // DATA6
	CAN_RDH1R_DATA5 = ((1UL<<8)-1) << 8, // DATA5
	CAN_RDH1R_DATA4 = ((1UL<<8)-1) << 0, // DATA4		
};
inline uint32_t can_rdh1r_get_data7(struct CAN_Type* p) { return (p->RDH1R & CAN_RDH1R_DATA7) >> 24 ; }
inline uint32_t can_rdh1r_get_data6(struct CAN_Type* p) { return (p->RDH1R & CAN_RDH1R_DATA6) >> 16 ; }
inline uint32_t can_rdh1r_get_data5(struct CAN_Type* p) { return (p->RDH1R & CAN_RDH1R_DATA5) >> 8 ; }
inline uint32_t can_rdh1r_get_data4(struct CAN_Type* p) { return (p->RDH1R & CAN_RDH1R_DATA4) >> 0 ; }

// CAN->FMR filter master register
enum {
	CAN_FMR_FINIT = 1UL<<0, // Filter initialization mode		
};

// CAN->FM1R filter mode register
enum {
	CAN_FM1R_FBMX  = ((1UL<<14)-1) << 0, // Merged Filter mode		
};
inline void can_fm1r_set_fbmx (struct CAN_Type* p, uint32_t val) { p->FM1R = (p->FM1R & ~CAN_FM1R_FBMX ) | ((val<<0) & CAN_FM1R_FBMX ); }
inline uint32_t can_fm1r_get_fbmx (struct CAN_Type* p) { return (p->FM1R & CAN_FM1R_FBMX ) >> 0 ; }

// CAN->FS1R filter scale register
enum {
	CAN_FS1R_FSCX  = ((1UL<<14)-1) << 0, // Merged Filter scale configuration		
};
inline void can_fs1r_set_fscx (struct CAN_Type* p, uint32_t val) { p->FS1R = (p->FS1R & ~CAN_FS1R_FSCX ) | ((val<<0) & CAN_FS1R_FSCX ); }
inline uint32_t can_fs1r_get_fscx (struct CAN_Type* p) { return (p->FS1R & CAN_FS1R_FSCX ) >> 0 ; }

// CAN->FFA1R filter FIFO assignment register
enum {
	CAN_FFA1R_FFAX  = ((1UL<<14)-1) << 0, // Merged Filter FIFO assignment for filter 13		
};
inline void can_ffa1r_set_ffax (struct CAN_Type* p, uint32_t val) { p->FFA1R = (p->FFA1R & ~CAN_FFA1R_FFAX ) | ((val<<0) & CAN_FFA1R_FFAX ); }
inline uint32_t can_ffa1r_get_ffax (struct CAN_Type* p) { return (p->FFA1R & CAN_FFA1R_FFAX ) >> 0 ; }

// CAN->FA1R filter activation register
enum {
	CAN_FA1R_FACTX  = ((1UL<<14)-1) << 0, // Merged Filter active		
};
inline void can_fa1r_set_factx (struct CAN_Type* p, uint32_t val) { p->FA1R = (p->FA1R & ~CAN_FA1R_FACTX ) | ((val<<0) & CAN_FA1R_FACTX ); }
inline uint32_t can_fa1r_get_factx (struct CAN_Type* p) { return (p->FA1R & CAN_FA1R_FACTX ) >> 0 ; }

/* Comparator */
struct COMP_Type {
	__IO uint32_t COMP1_CSR; // @0 Comparator 1 control and status register
	__IO uint32_t COMP2_CSR; // @4 Comparator 2 control and status register
};

// COMP->COMP1_CSR Comparator 1 control and status register
enum {
	COMP_COMP1_CSR_COMP1_LOCK = 1UL<<31, // COMP1_CSR register lock bit
	COMP_COMP1_CSR_COMP1_VALUE = 1UL<<30, // Comparator 1 output status bit
	COMP_COMP1_CSR_COMP1_INMESEL = ((1UL<<2)-1) << 25, // comparator 1 input minus extended selection bits
	COMP_COMP1_CSR_COMP1_SCALEN = 1UL<<23, // Voltage scaler enable bit
	COMP_COMP1_CSR_COMP1_BRGEN = 1UL<<22, // Scaler bridge enable
	COMP_COMP1_CSR_COMP1_BLANKING = ((1UL<<3)-1) << 18, // Comparator 1 blanking source selection bits
	COMP_COMP1_CSR_COMP1_HYST = ((1UL<<2)-1) << 16, // Comparator 1 hysteresis selection bits
	COMP_COMP1_CSR_COMP1_POLARITY = 1UL<<15, // Comparator 1 polarity selection bit
	COMP_COMP1_CSR_COMP1_INPSEL = ((1UL<<2)-1) << 7, // Comparator1 input plus selection bit
	COMP_COMP1_CSR_COMP1_INMSEL = ((1UL<<3)-1) << 4, // Comparator 1 Input Minus connection configuration bit
	COMP_COMP1_CSR_COMP1_PWRMODE = ((1UL<<2)-1) << 2, // Power Mode of the comparator 1
	COMP_COMP1_CSR_COMP1_EN = 1UL<<0, // Comparator 1 enable bit		
};
inline void comp_comp1_csr_set_comp1_inmesel(struct COMP_Type* p, uint32_t val) { p->COMP1_CSR = (p->COMP1_CSR & ~COMP_COMP1_CSR_COMP1_INMESEL) | ((val<<25) & COMP_COMP1_CSR_COMP1_INMESEL); }
inline void comp_comp1_csr_set_comp1_blanking(struct COMP_Type* p, uint32_t val) { p->COMP1_CSR = (p->COMP1_CSR & ~COMP_COMP1_CSR_COMP1_BLANKING) | ((val<<18) & COMP_COMP1_CSR_COMP1_BLANKING); }
inline void comp_comp1_csr_set_comp1_hyst(struct COMP_Type* p, uint32_t val) { p->COMP1_CSR = (p->COMP1_CSR & ~COMP_COMP1_CSR_COMP1_HYST) | ((val<<16) & COMP_COMP1_CSR_COMP1_HYST); }
inline void comp_comp1_csr_set_comp1_inpsel(struct COMP_Type* p, uint32_t val) { p->COMP1_CSR = (p->COMP1_CSR & ~COMP_COMP1_CSR_COMP1_INPSEL) | ((val<<7) & COMP_COMP1_CSR_COMP1_INPSEL); }
inline void comp_comp1_csr_set_comp1_inmsel(struct COMP_Type* p, uint32_t val) { p->COMP1_CSR = (p->COMP1_CSR & ~COMP_COMP1_CSR_COMP1_INMSEL) | ((val<<4) & COMP_COMP1_CSR_COMP1_INMSEL); }
inline void comp_comp1_csr_set_comp1_pwrmode(struct COMP_Type* p, uint32_t val) { p->COMP1_CSR = (p->COMP1_CSR & ~COMP_COMP1_CSR_COMP1_PWRMODE) | ((val<<2) & COMP_COMP1_CSR_COMP1_PWRMODE); }
inline uint32_t comp_comp1_csr_get_comp1_inmesel(struct COMP_Type* p) { return (p->COMP1_CSR & COMP_COMP1_CSR_COMP1_INMESEL) >> 25 ; }
inline uint32_t comp_comp1_csr_get_comp1_blanking(struct COMP_Type* p) { return (p->COMP1_CSR & COMP_COMP1_CSR_COMP1_BLANKING) >> 18 ; }
inline uint32_t comp_comp1_csr_get_comp1_hyst(struct COMP_Type* p) { return (p->COMP1_CSR & COMP_COMP1_CSR_COMP1_HYST) >> 16 ; }
inline uint32_t comp_comp1_csr_get_comp1_inpsel(struct COMP_Type* p) { return (p->COMP1_CSR & COMP_COMP1_CSR_COMP1_INPSEL) >> 7 ; }
inline uint32_t comp_comp1_csr_get_comp1_inmsel(struct COMP_Type* p) { return (p->COMP1_CSR & COMP_COMP1_CSR_COMP1_INMSEL) >> 4 ; }
inline uint32_t comp_comp1_csr_get_comp1_pwrmode(struct COMP_Type* p) { return (p->COMP1_CSR & COMP_COMP1_CSR_COMP1_PWRMODE) >> 2 ; }

// COMP->COMP2_CSR Comparator 2 control and status register
enum {
	COMP_COMP2_CSR_COMP2_LOCK = 1UL<<31, // COMP2_CSR register lock bit
	COMP_COMP2_CSR_COMP2_VALUE = 1UL<<30, // Comparator 2 output status bit
	COMP_COMP2_CSR_COMP2_INMESEL = ((1UL<<2)-1) << 25, // comparator 2 input minus extended selection bits
	COMP_COMP2_CSR_COMP2_SCALEN = 1UL<<23, // Voltage scaler enable bit
	COMP_COMP2_CSR_COMP2_BRGEN = 1UL<<22, // Scaler bridge enable
	COMP_COMP2_CSR_COMP2_BLANKING = ((1UL<<3)-1) << 18, // Comparator 2 blanking source selection bits
	COMP_COMP2_CSR_COMP2_HYST = ((1UL<<2)-1) << 16, // Comparator 2 hysteresis selection bits
	COMP_COMP2_CSR_COMP2_POLARITY = 1UL<<15, // Comparator 2 polarity selection bit
	COMP_COMP2_CSR_COMP2_WINMODE = 1UL<<9, // Windows mode selection bit
	COMP_COMP2_CSR_COMP2_INPSEL = ((1UL<<2)-1) << 7, // Comparator 2 Input Plus connection configuration bit
	COMP_COMP2_CSR_COMP2_INMSEL = ((1UL<<3)-1) << 4, // Comparator 2 Input Minus connection configuration bit
	COMP_COMP2_CSR_COMP2_PWRMODE = ((1UL<<2)-1) << 2, // Power Mode of the comparator 2
	COMP_COMP2_CSR_COMP2_EN = 1UL<<0, // Comparator 2 enable bit		
};
inline void comp_comp2_csr_set_comp2_inmesel(struct COMP_Type* p, uint32_t val) { p->COMP2_CSR = (p->COMP2_CSR & ~COMP_COMP2_CSR_COMP2_INMESEL) | ((val<<25) & COMP_COMP2_CSR_COMP2_INMESEL); }
inline void comp_comp2_csr_set_comp2_blanking(struct COMP_Type* p, uint32_t val) { p->COMP2_CSR = (p->COMP2_CSR & ~COMP_COMP2_CSR_COMP2_BLANKING) | ((val<<18) & COMP_COMP2_CSR_COMP2_BLANKING); }
inline void comp_comp2_csr_set_comp2_hyst(struct COMP_Type* p, uint32_t val) { p->COMP2_CSR = (p->COMP2_CSR & ~COMP_COMP2_CSR_COMP2_HYST) | ((val<<16) & COMP_COMP2_CSR_COMP2_HYST); }
inline void comp_comp2_csr_set_comp2_inpsel(struct COMP_Type* p, uint32_t val) { p->COMP2_CSR = (p->COMP2_CSR & ~COMP_COMP2_CSR_COMP2_INPSEL) | ((val<<7) & COMP_COMP2_CSR_COMP2_INPSEL); }
inline void comp_comp2_csr_set_comp2_inmsel(struct COMP_Type* p, uint32_t val) { p->COMP2_CSR = (p->COMP2_CSR & ~COMP_COMP2_CSR_COMP2_INMSEL) | ((val<<4) & COMP_COMP2_CSR_COMP2_INMSEL); }
inline void comp_comp2_csr_set_comp2_pwrmode(struct COMP_Type* p, uint32_t val) { p->COMP2_CSR = (p->COMP2_CSR & ~COMP_COMP2_CSR_COMP2_PWRMODE) | ((val<<2) & COMP_COMP2_CSR_COMP2_PWRMODE); }
inline uint32_t comp_comp2_csr_get_comp2_inmesel(struct COMP_Type* p) { return (p->COMP2_CSR & COMP_COMP2_CSR_COMP2_INMESEL) >> 25 ; }
inline uint32_t comp_comp2_csr_get_comp2_blanking(struct COMP_Type* p) { return (p->COMP2_CSR & COMP_COMP2_CSR_COMP2_BLANKING) >> 18 ; }
inline uint32_t comp_comp2_csr_get_comp2_hyst(struct COMP_Type* p) { return (p->COMP2_CSR & COMP_COMP2_CSR_COMP2_HYST) >> 16 ; }
inline uint32_t comp_comp2_csr_get_comp2_inpsel(struct COMP_Type* p) { return (p->COMP2_CSR & COMP_COMP2_CSR_COMP2_INPSEL) >> 7 ; }
inline uint32_t comp_comp2_csr_get_comp2_inmsel(struct COMP_Type* p) { return (p->COMP2_CSR & COMP_COMP2_CSR_COMP2_INMSEL) >> 4 ; }
inline uint32_t comp_comp2_csr_get_comp2_pwrmode(struct COMP_Type* p) { return (p->COMP2_CSR & COMP_COMP2_CSR_COMP2_PWRMODE) >> 2 ; }

/* Cyclic redundancy check calculation unit */
struct CRC_Type {
	union { // WARNING HAND EDITED
		__IO uint32_t DR32; // @0 Data register
		__IO uint16_t DR16; // @0 Data register
		__IO uint8_t DR8; // @0 Data register
	};
	__IO uint8_t IDR; // @4 Independent data register
	 uint8_t RESERVED0[3]; // @5 
	__IO uint8_t CR; // @8 Control register
	 uint8_t RESERVED1[7]; // @9 
	__IO uint32_t INIT; // @16 Initial CRC value
	__IO uint32_t POL; // @20 polynomial
};

// CRC->CR Control register
enum {
	CRC_CR_REV_OUT = 1UL<<7, // Reverse output data
	CRC_CR_REV_IN = ((1UL<<2)-1) << 5, // Reverse input data
	CRC_CR_POLYSIZE = ((1UL<<2)-1) << 3, // Polynomial size
	CRC_CR_RESET = 1UL<<0, // RESET bit		
};
inline void crc_cr_set_rev_in(struct CRC_Type* p, uint32_t val) { p->CR = (p->CR & ~CRC_CR_REV_IN) | ((val<<5) & CRC_CR_REV_IN); }
inline void crc_cr_set_polysize(struct CRC_Type* p, uint32_t val) { p->CR = (p->CR & ~CRC_CR_POLYSIZE) | ((val<<3) & CRC_CR_POLYSIZE); }
inline uint32_t crc_cr_get_rev_in(struct CRC_Type* p) { return (p->CR & CRC_CR_REV_IN) >> 5 ; }
inline uint32_t crc_cr_get_polysize(struct CRC_Type* p) { return (p->CR & CRC_CR_POLYSIZE) >> 3 ; }

/* Clock recovery system */
struct CRS_Type {
	__IO uint16_t CR; // @0 control register
	 uint8_t RESERVED0[2]; // @2 
	__IO uint32_t CFGR; // @4 configuration register
	__I uint32_t ISR; // @8 interrupt and status register
	__IO uint8_t ICR; // @12 interrupt flag clear register
};

// CRS->CR control register
enum {
	CRS_CR_TRIM = ((1UL<<6)-1) << 8, // HSI48 oscillator smooth trimming
	CRS_CR_SWSYNC = 1UL<<7, // Generate software SYNC event
	CRS_CR_AUTOTRIMEN = 1UL<<6, // Automatic trimming enable
	CRS_CR_CEN = 1UL<<5, // Frequency error counter enable
	CRS_CR_ESYNCIE = 1UL<<3, // Expected SYNC interrupt enable
	CRS_CR_ERRIE = 1UL<<2, // Synchronization or trimming error interrupt enable
	CRS_CR_SYNCWARNIE = 1UL<<1, // SYNC warning interrupt enable
	CRS_CR_SYNCOKIE = 1UL<<0, // SYNC event OK interrupt enable		
};
inline void crs_cr_set_trim(struct CRS_Type* p, uint32_t val) { p->CR = (p->CR & ~CRS_CR_TRIM) | ((val<<8) & CRS_CR_TRIM); }
inline uint32_t crs_cr_get_trim(struct CRS_Type* p) { return (p->CR & CRS_CR_TRIM) >> 8 ; }

// CRS->CFGR configuration register
enum {
	CRS_CFGR_SYNCPOL = 1UL<<31, // SYNC polarity selection
	CRS_CFGR_SYNCSRC = ((1UL<<2)-1) << 28, // SYNC signal source selection
	CRS_CFGR_SYNCDIV = ((1UL<<3)-1) << 24, // SYNC divider
	CRS_CFGR_FELIM = ((1UL<<8)-1) << 16, // Frequency error limit
	CRS_CFGR_RELOAD = ((1UL<<16)-1) << 0, // Counter reload value		
};
inline void crs_cfgr_set_syncsrc(struct CRS_Type* p, uint32_t val) { p->CFGR = (p->CFGR & ~CRS_CFGR_SYNCSRC) | ((val<<28) & CRS_CFGR_SYNCSRC); }
inline void crs_cfgr_set_syncdiv(struct CRS_Type* p, uint32_t val) { p->CFGR = (p->CFGR & ~CRS_CFGR_SYNCDIV) | ((val<<24) & CRS_CFGR_SYNCDIV); }
inline void crs_cfgr_set_felim(struct CRS_Type* p, uint32_t val) { p->CFGR = (p->CFGR & ~CRS_CFGR_FELIM) | ((val<<16) & CRS_CFGR_FELIM); }
inline void crs_cfgr_set_reload(struct CRS_Type* p, uint32_t val) { p->CFGR = (p->CFGR & ~CRS_CFGR_RELOAD) | ((val<<0) & CRS_CFGR_RELOAD); }
inline uint32_t crs_cfgr_get_syncsrc(struct CRS_Type* p) { return (p->CFGR & CRS_CFGR_SYNCSRC) >> 28 ; }
inline uint32_t crs_cfgr_get_syncdiv(struct CRS_Type* p) { return (p->CFGR & CRS_CFGR_SYNCDIV) >> 24 ; }
inline uint32_t crs_cfgr_get_felim(struct CRS_Type* p) { return (p->CFGR & CRS_CFGR_FELIM) >> 16 ; }
inline uint32_t crs_cfgr_get_reload(struct CRS_Type* p) { return (p->CFGR & CRS_CFGR_RELOAD) >> 0 ; }

// CRS->ISR interrupt and status register
enum {
	CRS_ISR_FECAP = ((1UL<<16)-1) << 16, // Frequency error capture
	CRS_ISR_FEDIR = 1UL<<15, // Frequency error direction
	CRS_ISR_TRIMOVF = 1UL<<10, // Trimming overflow or underflow
	CRS_ISR_SYNCMISS = 1UL<<9, // SYNC missed
	CRS_ISR_SYNCERR = 1UL<<8, // SYNC error
	CRS_ISR_ESYNCF = 1UL<<3, // Expected SYNC flag
	CRS_ISR_ERRF = 1UL<<2, // Error flag
	CRS_ISR_SYNCWARNF = 1UL<<1, // SYNC warning flag
	CRS_ISR_SYNCOKF = 1UL<<0, // SYNC event OK flag		
};
inline uint32_t crs_isr_get_fecap(struct CRS_Type* p) { return (p->ISR & CRS_ISR_FECAP) >> 16 ; }

// CRS->ICR interrupt flag clear register
enum {
	CRS_ICR_ESYNCC = 1UL<<3, // Expected SYNC clear flag
	CRS_ICR_ERRC = 1UL<<2, // Error clear flag
	CRS_ICR_SYNCWARNC = 1UL<<1, // SYNC warning clear flag
	CRS_ICR_SYNCOKC = 1UL<<0, // SYNC event OK clear flag		
};

/* Digital-to-analog converter */
struct DAC1_Type {
	__IO uint32_t CR; // @0 control register
	__O uint8_t SWTRIGR; // @4 software trigger register
	 uint8_t RESERVED0[3]; // @5 
	__IO uint16_t DHR12R1; // @8 channel1 12-bit right-aligned data holding register
	 uint8_t RESERVED1[2]; // @10 
	__IO uint16_t DHR12L1; // @12 channel1 12-bit left-aligned data holding register
	 uint8_t RESERVED2[2]; // @14 
	__IO uint8_t DHR8R1; // @16 channel1 8-bit right-aligned data holding register
	 uint8_t RESERVED3[3]; // @17 
	__IO uint16_t DHR12R2; // @20 channel2 12-bit right aligned data holding register
	 uint8_t RESERVED4[2]; // @22 
	__IO uint16_t DHR12L2; // @24 channel2 12-bit left aligned data holding register
	 uint8_t RESERVED5[2]; // @26 
	__IO uint8_t DHR8R2; // @28 channel2 8-bit right-aligned data holding register
	 uint8_t RESERVED6[3]; // @29 
	__IO uint32_t DHR12RD; // @32 Dual DAC 12-bit right-aligned data holding register
	__IO uint32_t DHR12LD; // @36 DUAL DAC 12-bit left aligned data holding register
	__IO uint16_t DHR8RD; // @40 DUAL DAC 8-bit right aligned data holding register
	 uint8_t RESERVED7[2]; // @42 
	__I uint16_t DOR1; // @44 channel1 data output register
	 uint8_t RESERVED8[2]; // @46 
	__I uint16_t DOR2; // @48 channel2 data output register
	 uint8_t RESERVED9[2]; // @50 
	__IO uint32_t SR; // @52 status register
	__IO uint32_t CCR; // @56 calibration control register
	__IO uint32_t MCR; // @60 mode control register
	__IO uint16_t SHSR1; // @64 Sample and Hold sample time register 1
	 uint8_t RESERVED10[2]; // @66 
	__IO uint16_t SHSR2; // @68 Sample and Hold sample time register 2
	 uint8_t RESERVED11[2]; // @70 
	__IO uint32_t SHHR; // @72 Sample and Hold hold time register
	__IO uint32_t SHRR; // @76 Sample and Hold refresh time register
};

// DAC1->CR control register
enum {
	DAC1_CR_CEN2 = 1UL<<30, // DAC Channel 2 calibration enable
	DAC1_CR_DMAUDRIE2 = 1UL<<29, // DAC channel2 DMA underrun interrupt enable
	DAC1_CR_DMAEN2 = 1UL<<28, // DAC channel2 DMA enable
	DAC1_CR_MAMP2 = ((1UL<<4)-1) << 24, // DAC channel2 mask/amplitude selector
	DAC1_CR_WAVE2 = ((1UL<<2)-1) << 22, // DAC channel2 noise/triangle wave generation enable
	DAC1_CR_TSEL2 = ((1UL<<3)-1) << 19, // DAC channel2 trigger selection
	DAC1_CR_TEN2 = 1UL<<18, // DAC channel2 trigger enable
	DAC1_CR_EN2 = 1UL<<16, // DAC channel2 enable
	DAC1_CR_CEN1 = 1UL<<14, // DAC Channel 1 calibration enable
	DAC1_CR_DMAUDRIE1 = 1UL<<13, // DAC channel1 DMA Underrun Interrupt enable
	DAC1_CR_DMAEN1 = 1UL<<12, // DAC channel1 DMA enable
	DAC1_CR_MAMP1 = ((1UL<<4)-1) << 8, // DAC channel1 mask/amplitude selector
	DAC1_CR_WAVE1 = ((1UL<<2)-1) << 6, // DAC channel1 noise/triangle wave generation enable
	DAC1_CR_TSEL1 = ((1UL<<3)-1) << 3, // DAC channel1 trigger selection
	DAC1_CR_TEN1 = 1UL<<2, // DAC channel1 trigger enable
	DAC1_CR_EN1 = 1UL<<0, // DAC channel1 enable		
};
inline void dac1_cr_set_mamp2(struct DAC1_Type* p, uint32_t val) { p->CR = (p->CR & ~DAC1_CR_MAMP2) | ((val<<24) & DAC1_CR_MAMP2); }
inline void dac1_cr_set_wave2(struct DAC1_Type* p, uint32_t val) { p->CR = (p->CR & ~DAC1_CR_WAVE2) | ((val<<22) & DAC1_CR_WAVE2); }
inline void dac1_cr_set_tsel2(struct DAC1_Type* p, uint32_t val) { p->CR = (p->CR & ~DAC1_CR_TSEL2) | ((val<<19) & DAC1_CR_TSEL2); }
inline void dac1_cr_set_mamp1(struct DAC1_Type* p, uint32_t val) { p->CR = (p->CR & ~DAC1_CR_MAMP1) | ((val<<8) & DAC1_CR_MAMP1); }
inline void dac1_cr_set_wave1(struct DAC1_Type* p, uint32_t val) { p->CR = (p->CR & ~DAC1_CR_WAVE1) | ((val<<6) & DAC1_CR_WAVE1); }
inline void dac1_cr_set_tsel1(struct DAC1_Type* p, uint32_t val) { p->CR = (p->CR & ~DAC1_CR_TSEL1) | ((val<<3) & DAC1_CR_TSEL1); }
inline uint32_t dac1_cr_get_mamp2(struct DAC1_Type* p) { return (p->CR & DAC1_CR_MAMP2) >> 24 ; }
inline uint32_t dac1_cr_get_wave2(struct DAC1_Type* p) { return (p->CR & DAC1_CR_WAVE2) >> 22 ; }
inline uint32_t dac1_cr_get_tsel2(struct DAC1_Type* p) { return (p->CR & DAC1_CR_TSEL2) >> 19 ; }
inline uint32_t dac1_cr_get_mamp1(struct DAC1_Type* p) { return (p->CR & DAC1_CR_MAMP1) >> 8 ; }
inline uint32_t dac1_cr_get_wave1(struct DAC1_Type* p) { return (p->CR & DAC1_CR_WAVE1) >> 6 ; }
inline uint32_t dac1_cr_get_tsel1(struct DAC1_Type* p) { return (p->CR & DAC1_CR_TSEL1) >> 3 ; }

// DAC1->SWTRIGR software trigger register
enum {
	DAC1_SWTRIGR_SWTRIGX  = ((1UL<<2)-1) << 0, // Merged DAC channel2 software trigger		
};
inline void dac1_swtrigr_set_swtrigx (struct DAC1_Type* p, uint32_t val) { p->SWTRIGR = (p->SWTRIGR & ~DAC1_SWTRIGR_SWTRIGX ) | ((val<<0) & DAC1_SWTRIGR_SWTRIGX ); }
inline uint32_t dac1_swtrigr_get_swtrigx (struct DAC1_Type* p) { return (p->SWTRIGR & DAC1_SWTRIGR_SWTRIGX ) >> 0 ; }

// DAC1->DHR12R1 channel1 12-bit right-aligned data holding register
enum {
	DAC1_DHR12R1_DACC1DHR = ((1UL<<12)-1) << 0, // DAC channel1 12-bit right-aligned data		
};
inline void dac1_dhr12r1_set_dacc1dhr(struct DAC1_Type* p, uint32_t val) { p->DHR12R1 = (p->DHR12R1 & ~DAC1_DHR12R1_DACC1DHR) | ((val<<0) & DAC1_DHR12R1_DACC1DHR); }
inline uint32_t dac1_dhr12r1_get_dacc1dhr(struct DAC1_Type* p) { return (p->DHR12R1 & DAC1_DHR12R1_DACC1DHR) >> 0 ; }

// DAC1->DHR12L1 channel1 12-bit left-aligned data holding register
enum {
	DAC1_DHR12L1_DACC1DHR = ((1UL<<12)-1) << 4, // DAC channel1 12-bit left-aligned data		
};
inline void dac1_dhr12l1_set_dacc1dhr(struct DAC1_Type* p, uint32_t val) { p->DHR12L1 = (p->DHR12L1 & ~DAC1_DHR12L1_DACC1DHR) | ((val<<4) & DAC1_DHR12L1_DACC1DHR); }
inline uint32_t dac1_dhr12l1_get_dacc1dhr(struct DAC1_Type* p) { return (p->DHR12L1 & DAC1_DHR12L1_DACC1DHR) >> 4 ; }

// DAC1->DHR12R2 channel2 12-bit right aligned data holding register
enum {
	DAC1_DHR12R2_DACC2DHR = ((1UL<<12)-1) << 0, // DAC channel2 12-bit right-aligned data		
};
inline void dac1_dhr12r2_set_dacc2dhr(struct DAC1_Type* p, uint32_t val) { p->DHR12R2 = (p->DHR12R2 & ~DAC1_DHR12R2_DACC2DHR) | ((val<<0) & DAC1_DHR12R2_DACC2DHR); }
inline uint32_t dac1_dhr12r2_get_dacc2dhr(struct DAC1_Type* p) { return (p->DHR12R2 & DAC1_DHR12R2_DACC2DHR) >> 0 ; }

// DAC1->DHR12L2 channel2 12-bit left aligned data holding register
enum {
	DAC1_DHR12L2_DACC2DHR = ((1UL<<12)-1) << 4, // DAC channel2 12-bit left-aligned data		
};
inline void dac1_dhr12l2_set_dacc2dhr(struct DAC1_Type* p, uint32_t val) { p->DHR12L2 = (p->DHR12L2 & ~DAC1_DHR12L2_DACC2DHR) | ((val<<4) & DAC1_DHR12L2_DACC2DHR); }
inline uint32_t dac1_dhr12l2_get_dacc2dhr(struct DAC1_Type* p) { return (p->DHR12L2 & DAC1_DHR12L2_DACC2DHR) >> 4 ; }

// DAC1->DHR12RD Dual DAC 12-bit right-aligned data holding register
enum {
	DAC1_DHR12RD_DACC2DHR = ((1UL<<12)-1) << 16, // DAC channel2 12-bit right-aligned data
	DAC1_DHR12RD_DACC1DHR = ((1UL<<12)-1) << 0, // DAC channel1 12-bit right-aligned data		
};
inline void dac1_dhr12rd_set_dacc2dhr(struct DAC1_Type* p, uint32_t val) { p->DHR12RD = (p->DHR12RD & ~DAC1_DHR12RD_DACC2DHR) | ((val<<16) & DAC1_DHR12RD_DACC2DHR); }
inline void dac1_dhr12rd_set_dacc1dhr(struct DAC1_Type* p, uint32_t val) { p->DHR12RD = (p->DHR12RD & ~DAC1_DHR12RD_DACC1DHR) | ((val<<0) & DAC1_DHR12RD_DACC1DHR); }
inline uint32_t dac1_dhr12rd_get_dacc2dhr(struct DAC1_Type* p) { return (p->DHR12RD & DAC1_DHR12RD_DACC2DHR) >> 16 ; }
inline uint32_t dac1_dhr12rd_get_dacc1dhr(struct DAC1_Type* p) { return (p->DHR12RD & DAC1_DHR12RD_DACC1DHR) >> 0 ; }

// DAC1->DHR12LD DUAL DAC 12-bit left aligned data holding register
enum {
	DAC1_DHR12LD_DACC2DHR = ((1UL<<12)-1) << 20, // DAC channel2 12-bit left-aligned data
	DAC1_DHR12LD_DACC1DHR = ((1UL<<12)-1) << 4, // DAC channel1 12-bit left-aligned data		
};
inline void dac1_dhr12ld_set_dacc2dhr(struct DAC1_Type* p, uint32_t val) { p->DHR12LD = (p->DHR12LD & ~DAC1_DHR12LD_DACC2DHR) | ((val<<20) & DAC1_DHR12LD_DACC2DHR); }
inline void dac1_dhr12ld_set_dacc1dhr(struct DAC1_Type* p, uint32_t val) { p->DHR12LD = (p->DHR12LD & ~DAC1_DHR12LD_DACC1DHR) | ((val<<4) & DAC1_DHR12LD_DACC1DHR); }
inline uint32_t dac1_dhr12ld_get_dacc2dhr(struct DAC1_Type* p) { return (p->DHR12LD & DAC1_DHR12LD_DACC2DHR) >> 20 ; }
inline uint32_t dac1_dhr12ld_get_dacc1dhr(struct DAC1_Type* p) { return (p->DHR12LD & DAC1_DHR12LD_DACC1DHR) >> 4 ; }

// DAC1->DHR8RD DUAL DAC 8-bit right aligned data holding register
enum {
	DAC1_DHR8RD_DACC2DHR = ((1UL<<8)-1) << 8, // DAC channel2 8-bit right-aligned data
	DAC1_DHR8RD_DACC1DHR = ((1UL<<8)-1) << 0, // DAC channel1 8-bit right-aligned data		
};
inline void dac1_dhr8rd_set_dacc2dhr(struct DAC1_Type* p, uint32_t val) { p->DHR8RD = (p->DHR8RD & ~DAC1_DHR8RD_DACC2DHR) | ((val<<8) & DAC1_DHR8RD_DACC2DHR); }
inline void dac1_dhr8rd_set_dacc1dhr(struct DAC1_Type* p, uint32_t val) { p->DHR8RD = (p->DHR8RD & ~DAC1_DHR8RD_DACC1DHR) | ((val<<0) & DAC1_DHR8RD_DACC1DHR); }
inline uint32_t dac1_dhr8rd_get_dacc2dhr(struct DAC1_Type* p) { return (p->DHR8RD & DAC1_DHR8RD_DACC2DHR) >> 8 ; }
inline uint32_t dac1_dhr8rd_get_dacc1dhr(struct DAC1_Type* p) { return (p->DHR8RD & DAC1_DHR8RD_DACC1DHR) >> 0 ; }

// DAC1->DOR1 channel1 data output register
enum {
	DAC1_DOR1_DACC1DOR = ((1UL<<12)-1) << 0, // DAC channel1 data output		
};
inline uint32_t dac1_dor1_get_dacc1dor(struct DAC1_Type* p) { return (p->DOR1 & DAC1_DOR1_DACC1DOR) >> 0 ; }

// DAC1->DOR2 channel2 data output register
enum {
	DAC1_DOR2_DACC2DOR = ((1UL<<12)-1) << 0, // DAC channel2 data output		
};
inline uint32_t dac1_dor2_get_dacc2dor(struct DAC1_Type* p) { return (p->DOR2 & DAC1_DOR2_DACC2DOR) >> 0 ; }

// DAC1->SR status register
enum {
	DAC1_SR_BWST2 = 1UL<<31, // DAC Channel 2 busy writing sample time flag
	DAC1_SR_CAL_FLAG2 = 1UL<<30, // DAC Channel 2 calibration offset status
	DAC1_SR_DMAUDR2 = 1UL<<29, // DAC channel2 DMA underrun flag
	DAC1_SR_BWST1 = 1UL<<15, // DAC Channel 1 busy writing sample time flag
	DAC1_SR_CAL_FLAG1 = 1UL<<14, // DAC Channel 1 calibration offset status
	DAC1_SR_DMAUDR1 = 1UL<<13, // DAC channel1 DMA underrun flag		
};

// DAC1->CCR calibration control register
enum {
	DAC1_CCR_OTRIM2 = ((1UL<<5)-1) << 16, // DAC Channel 2 offset trimming value
	DAC1_CCR_OTRIM1 = ((1UL<<5)-1) << 0, // DAC Channel 1 offset trimming value		
};
inline void dac1_ccr_set_otrim2(struct DAC1_Type* p, uint32_t val) { p->CCR = (p->CCR & ~DAC1_CCR_OTRIM2) | ((val<<16) & DAC1_CCR_OTRIM2); }
inline void dac1_ccr_set_otrim1(struct DAC1_Type* p, uint32_t val) { p->CCR = (p->CCR & ~DAC1_CCR_OTRIM1) | ((val<<0) & DAC1_CCR_OTRIM1); }
inline uint32_t dac1_ccr_get_otrim2(struct DAC1_Type* p) { return (p->CCR & DAC1_CCR_OTRIM2) >> 16 ; }
inline uint32_t dac1_ccr_get_otrim1(struct DAC1_Type* p) { return (p->CCR & DAC1_CCR_OTRIM1) >> 0 ; }

// DAC1->MCR mode control register
enum {
	DAC1_MCR_MODE2 = ((1UL<<3)-1) << 16, // DAC Channel 2 mode
	DAC1_MCR_MODE1 = ((1UL<<3)-1) << 0, // DAC Channel 1 mode		
};
inline void dac1_mcr_set_mode2(struct DAC1_Type* p, uint32_t val) { p->MCR = (p->MCR & ~DAC1_MCR_MODE2) | ((val<<16) & DAC1_MCR_MODE2); }
inline void dac1_mcr_set_mode1(struct DAC1_Type* p, uint32_t val) { p->MCR = (p->MCR & ~DAC1_MCR_MODE1) | ((val<<0) & DAC1_MCR_MODE1); }
inline uint32_t dac1_mcr_get_mode2(struct DAC1_Type* p) { return (p->MCR & DAC1_MCR_MODE2) >> 16 ; }
inline uint32_t dac1_mcr_get_mode1(struct DAC1_Type* p) { return (p->MCR & DAC1_MCR_MODE1) >> 0 ; }

// DAC1->SHSR1 Sample and Hold sample time register 1
enum {
	DAC1_SHSR1_TSAMPLE1 = ((1UL<<10)-1) << 0, // DAC Channel 1 sample Time		
};
inline void dac1_shsr1_set_tsample1(struct DAC1_Type* p, uint32_t val) { p->SHSR1 = (p->SHSR1 & ~DAC1_SHSR1_TSAMPLE1) | ((val<<0) & DAC1_SHSR1_TSAMPLE1); }
inline uint32_t dac1_shsr1_get_tsample1(struct DAC1_Type* p) { return (p->SHSR1 & DAC1_SHSR1_TSAMPLE1) >> 0 ; }

// DAC1->SHSR2 Sample and Hold sample time register 2
enum {
	DAC1_SHSR2_TSAMPLE2 = ((1UL<<10)-1) << 0, // DAC Channel 2 sample Time		
};
inline void dac1_shsr2_set_tsample2(struct DAC1_Type* p, uint32_t val) { p->SHSR2 = (p->SHSR2 & ~DAC1_SHSR2_TSAMPLE2) | ((val<<0) & DAC1_SHSR2_TSAMPLE2); }
inline uint32_t dac1_shsr2_get_tsample2(struct DAC1_Type* p) { return (p->SHSR2 & DAC1_SHSR2_TSAMPLE2) >> 0 ; }

// DAC1->SHHR Sample and Hold hold time register
enum {
	DAC1_SHHR_THOLD2 = ((1UL<<10)-1) << 16, // DAC Channel 2 hold time
	DAC1_SHHR_THOLD1 = ((1UL<<10)-1) << 0, // DAC Channel 1 hold Time		
};
inline void dac1_shhr_set_thold2(struct DAC1_Type* p, uint32_t val) { p->SHHR = (p->SHHR & ~DAC1_SHHR_THOLD2) | ((val<<16) & DAC1_SHHR_THOLD2); }
inline void dac1_shhr_set_thold1(struct DAC1_Type* p, uint32_t val) { p->SHHR = (p->SHHR & ~DAC1_SHHR_THOLD1) | ((val<<0) & DAC1_SHHR_THOLD1); }
inline uint32_t dac1_shhr_get_thold2(struct DAC1_Type* p) { return (p->SHHR & DAC1_SHHR_THOLD2) >> 16 ; }
inline uint32_t dac1_shhr_get_thold1(struct DAC1_Type* p) { return (p->SHHR & DAC1_SHHR_THOLD1) >> 0 ; }

// DAC1->SHRR Sample and Hold refresh time register
enum {
	DAC1_SHRR_TREFRESH2 = ((1UL<<8)-1) << 16, // DAC Channel 2 refresh Time
	DAC1_SHRR_TREFRESH1 = ((1UL<<8)-1) << 0, // DAC Channel 1 refresh Time		
};
inline void dac1_shrr_set_trefresh2(struct DAC1_Type* p, uint32_t val) { p->SHRR = (p->SHRR & ~DAC1_SHRR_TREFRESH2) | ((val<<16) & DAC1_SHRR_TREFRESH2); }
inline void dac1_shrr_set_trefresh1(struct DAC1_Type* p, uint32_t val) { p->SHRR = (p->SHRR & ~DAC1_SHRR_TREFRESH1) | ((val<<0) & DAC1_SHRR_TREFRESH1); }
inline uint32_t dac1_shrr_get_trefresh2(struct DAC1_Type* p) { return (p->SHRR & DAC1_SHRR_TREFRESH2) >> 16 ; }
inline uint32_t dac1_shrr_get_trefresh1(struct DAC1_Type* p) { return (p->SHRR & DAC1_SHRR_TREFRESH1) >> 0 ; }

/* MCU debug component */
struct DBGMCU_Type {
	__I uint32_t IDCODE; // @0 DBGMCU_IDCODE
	__IO uint8_t CR; // @4 Debug MCU configuration register
	 uint8_t RESERVED0[3]; // @5 
	__IO uint32_t APB1FZR1; // @8 Debug MCU APB1 freeze register1
	__IO uint8_t APB1FZR2; // @12 Debug MCU APB1 freeze register 2
	 uint8_t RESERVED1[3]; // @13 
	__IO uint32_t APB2FZR; // @16 Debug MCU APB2 freeze register
};

// DBGMCU->IDCODE DBGMCU_IDCODE
enum {
	DBGMCU_IDCODE_REV_ID = ((1UL<<16)-1) << 16, // Revision identifie
	DBGMCU_IDCODE_DEV_ID = ((1UL<<12)-1) << 0, // Device identifier		
};
inline uint32_t dbgmcu_idcode_get_rev_id(struct DBGMCU_Type* p) { return (p->IDCODE & DBGMCU_IDCODE_REV_ID) >> 16 ; }
inline uint32_t dbgmcu_idcode_get_dev_id(struct DBGMCU_Type* p) { return (p->IDCODE & DBGMCU_IDCODE_DEV_ID) >> 0 ; }

// DBGMCU->CR Debug MCU configuration register
enum {
	DBGMCU_CR_TRACE_MODE = ((1UL<<2)-1) << 6, // Trace pin assignment control
	DBGMCU_CR_TRACE_IOEN = 1UL<<5, // Trace pin assignment control
	DBGMCU_CR_DBG_STANDBY = 1UL<<2, // Debug Standby mode
	DBGMCU_CR_DBG_STOP = 1UL<<1, // Debug Stop mode
	DBGMCU_CR_DBG_SLEEP = 1UL<<0, // Debug Sleep mode		
};
inline void dbgmcu_cr_set_trace_mode(struct DBGMCU_Type* p, uint32_t val) { p->CR = (p->CR & ~DBGMCU_CR_TRACE_MODE) | ((val<<6) & DBGMCU_CR_TRACE_MODE); }
inline uint32_t dbgmcu_cr_get_trace_mode(struct DBGMCU_Type* p) { return (p->CR & DBGMCU_CR_TRACE_MODE) >> 6 ; }

// DBGMCU->APB1FZR1 Debug MCU APB1 freeze register1
enum {
	DBGMCU_APB1FZR1_DBG_LPTIM1_STOP = 1UL<<31, // LPTIM1 counter stopped when core is halted
	DBGMCU_APB1FZR1_DBG_CAN_STOP = 1UL<<25, // bxCAN stopped when core is halted
	DBGMCU_APB1FZR1_DBG_I2C3_STOP = 1UL<<23, // I2C3 SMBUS timeout counter stopped when core is halted
	DBGMCU_APB1FZR1_DBG_I2C2_STOP = 1UL<<22, // I2C2 SMBUS timeout counter stopped when core is halted
	DBGMCU_APB1FZR1_DBG_I2C1_STOP = 1UL<<21, // I2C1 SMBUS timeout counter stopped when core is halted
	DBGMCU_APB1FZR1_DBG_IWDG_STOP = 1UL<<12, // Independent watchdog counter stopped when core is halted
	DBGMCU_APB1FZR1_DBG_WWDG_STOP = 1UL<<11, // Window watchdog counter stopped when core is halted
	DBGMCU_APB1FZR1_DBG_RTC_STOP = 1UL<<10, // RTC counter stopped when core is halted
	DBGMCU_APB1FZR1_DBG_TIM7_STOP = 1UL<<5, // TIM7 counter stopped when core is halted
	DBGMCU_APB1FZR1_DBG_TIM6_STOP = 1UL<<4, // TIM6 counter stopped when core is halted
	DBGMCU_APB1FZR1_DBG_TIM2_STOP = 1UL<<0, // TIM2 counter stopped when core is halted		
};

// DBGMCU->APB1FZR2 Debug MCU APB1 freeze register 2
enum {
	DBGMCU_APB1FZR2_DBG_LPTIM2_STOP = 1UL<<5, // LPTIM2 counter stopped when core is halted		
};

// DBGMCU->APB2FZR Debug MCU APB2 freeze register
enum {
	DBGMCU_APB2FZR_DBG_TIM16_STOP = 1UL<<17, // TIM16 counter stopped when core is halted
	DBGMCU_APB2FZR_DBG_TIM15_STOP = 1UL<<16, // TIM15 counter stopped when core is halted
	DBGMCU_APB2FZR_DBG_TIM1_STOP = 1UL<<11, // TIM1 counter stopped when core is halted		
};

/* Digital filter for sigma delta modulators */
struct DFSDM_Type {
	__IO uint32_t CHCFG0R1; // @0 channel configuration y register
	__IO uint32_t CHCFG0R2; // @4 channel configuration y register
	__IO uint32_t AWSCD0R; // @8 analog watchdog and short-circuit detector register
	__IO uint16_t CHWDAT0R; // @12 channel watchdog filter data register
	 uint8_t RESERVED0[2]; // @14 
	__IO uint32_t CHDATIN0R; // @16 channel data input register
	 uint8_t RESERVED1[12]; // @20 
	__IO uint16_t CHCFG1R1; // @32 CHCFG1R1
	 uint8_t RESERVED2[2]; // @34 
	__IO uint32_t CHCFG1R2; // @36 CHCFG1R2
	__IO uint32_t AWSCD1R; // @40 AWSCD1R
	__IO uint16_t CHWDAT1R; // @44 CHWDAT1R
	 uint8_t RESERVED3[2]; // @46 
	__IO uint32_t CHDATIN1R; // @48 CHDATIN1R
	 uint8_t RESERVED4[12]; // @52 
	__IO uint16_t CHCFG2R1; // @64 CHCFG2R1
	 uint8_t RESERVED5[2]; // @66 
	__IO uint32_t CHCFG2R2; // @68 CHCFG2R2
	__IO uint32_t AWSCD2R; // @72 AWSCD2R
	__IO uint16_t CHWDAT2R; // @76 CHWDAT2R
	 uint8_t RESERVED6[2]; // @78 
	__IO uint32_t CHDATIN2R; // @80 CHDATIN2R
	 uint8_t RESERVED7[12]; // @84 
	__IO uint16_t CHCFG3R1; // @96 CHCFG3R1
	 uint8_t RESERVED8[2]; // @98 
	__IO uint32_t CHCFG3R2; // @100 CHCFG3R2
	__IO uint32_t AWSCD3R; // @104 AWSCD3R
	__IO uint16_t CHWDAT3R; // @108 CHWDAT3R
	 uint8_t RESERVED9[2]; // @110 
	__IO uint32_t CHDATIN3R; // @112 CHDATIN3R
	 uint8_t RESERVED10[12]; // @116 
	__IO uint16_t CHCFG4R1; // @128 CHCFG4R1
	 uint8_t RESERVED11[2]; // @130 
	__IO uint32_t CHCFG4R2; // @132 CHCFG4R2
	__IO uint32_t AWSCD4R; // @136 AWSCD4R
	__IO uint16_t CHWDAT4R; // @140 CHWDAT4R
	 uint8_t RESERVED12[2]; // @142 
	__IO uint32_t CHDATIN4R; // @144 CHDATIN4R
	 uint8_t RESERVED13[12]; // @148 
	__IO uint16_t CHCFG5R1; // @160 CHCFG5R1
	 uint8_t RESERVED14[2]; // @162 
	__IO uint32_t CHCFG5R2; // @164 CHCFG5R2
	__IO uint32_t AWSCD5R; // @168 AWSCD5R
	__IO uint16_t CHWDAT5R; // @172 CHWDAT5R
	 uint8_t RESERVED15[2]; // @174 
	__IO uint32_t CHDATIN5R; // @176 CHDATIN5R
	 uint8_t RESERVED16[12]; // @180 
	__IO uint16_t CHCFG6R1; // @192 CHCFG6R1
	 uint8_t RESERVED17[2]; // @194 
	__IO uint32_t CHCFG6R2; // @196 CHCFG6R2
	__IO uint32_t AWSCD6R; // @200 AWSCD6R
	__IO uint16_t CHWDAT6R; // @204 CHWDAT6R
	 uint8_t RESERVED18[2]; // @206 
	__IO uint32_t CHDATIN6R; // @208 CHDATIN6R
	 uint8_t RESERVED19[12]; // @212 
	__IO uint16_t CHCFG7R1; // @224 CHCFG7R1
	 uint8_t RESERVED20[2]; // @226 
	__IO uint32_t CHCFG7R2; // @228 CHCFG7R2
	__IO uint32_t AWSCD7R; // @232 AWSCD7R
	__IO uint16_t CHWDAT7R; // @236 CHWDAT7R
	 uint8_t RESERVED21[2]; // @238 
	__IO uint32_t CHDATIN7R; // @240 CHDATIN7R
	 uint8_t RESERVED22[12]; // @244 
	__IO uint32_t DFSDM0_CR1; // @256 control register 1
	__IO uint32_t DFSDM0_CR2; // @260 control register 2
	__I uint32_t DFSDM0_ISR; // @264 interrupt and status register
	__IO uint32_t DFSDM0_ICR; // @268 interrupt flag clear register
	__IO uint8_t DFSDM0_JCHGR; // @272 injected channel group selection register
	 uint8_t RESERVED23[3]; // @273 
	__IO uint32_t DFSDM0_FCR; // @276 filter control register
	__I uint32_t DFSDM0_JDATAR; // @280 data register for injected group
	__I uint32_t DFSDM0_RDATAR; // @284 data register for the regular channel
	__IO uint32_t DFSDM0_AWHTR; // @288 analog watchdog high threshold register
	__IO uint32_t DFSDM0_AWLTR; // @292 analog watchdog low threshold register
	__I uint16_t DFSDM0_AWSR; // @296 analog watchdog status register
	 uint8_t RESERVED24[2]; // @298 
	__IO uint16_t DFSDM0_AWCFR; // @300 analog watchdog clear flag register
	 uint8_t RESERVED25[2]; // @302 
	__I uint32_t DFSDM0_EXMAX; // @304 Extremes detector maximum register
	__I uint32_t DFSDM0_EXMIN; // @308 Extremes detector minimum register
	__I uint32_t DFSDM0_CNVTIMR; // @312 conversion timer register
	 uint8_t RESERVED26[196]; // @316 
	__IO uint32_t DFSDM1_CR1; // @512 control register 1
	__IO uint32_t DFSDM1_CR2; // @516 control register 2
	__I uint32_t DFSDM1_ISR; // @520 interrupt and status register
	__IO uint32_t DFSDM1_ICR; // @524 interrupt flag clear register
	__IO uint8_t DFSDM1_JCHGR; // @528 injected channel group selection register
	 uint8_t RESERVED27[3]; // @529 
	__IO uint32_t DFSDM1_FCR; // @532 filter control register
	__I uint32_t DFSDM1_JDATAR; // @536 data register for injected group
	__I uint32_t DFSDM1_RDATAR; // @540 data register for the regular channel
	__IO uint32_t DFSDM1_AWHTR; // @544 analog watchdog high threshold register
	__IO uint32_t DFSDM1_AWLTR; // @548 analog watchdog low threshold register
	__I uint16_t DFSDM1_AWSR; // @552 analog watchdog status register
	 uint8_t RESERVED28[2]; // @554 
	__IO uint16_t DFSDM1_AWCFR; // @556 analog watchdog clear flag register
	 uint8_t RESERVED29[2]; // @558 
	__I uint32_t DFSDM1_EXMAX; // @560 Extremes detector maximum register
	__I uint32_t DFSDM1_EXMIN; // @564 Extremes detector minimum register
	__I uint32_t DFSDM1_CNVTIMR; // @568 conversion timer register
	 uint8_t RESERVED30[196]; // @572 
	__IO uint32_t DFSDM2_CR1; // @768 control register 1
	__IO uint32_t DFSDM2_CR2; // @772 control register 2
	__I uint32_t DFSDM2_ISR; // @776 interrupt and status register
	__IO uint32_t DFSDM2_ICR; // @780 interrupt flag clear register
	__IO uint8_t DFSDM2_JCHGR; // @784 injected channel group selection register
	 uint8_t RESERVED31[3]; // @785 
	__IO uint32_t DFSDM2_FCR; // @788 filter control register
	__I uint32_t DFSDM2_JDATAR; // @792 data register for injected group
	__I uint32_t DFSDM2_RDATAR; // @796 data register for the regular channel
	__IO uint32_t DFSDM2_AWHTR; // @800 analog watchdog high threshold register
	__IO uint32_t DFSDM2_AWLTR; // @804 analog watchdog low threshold register
	__I uint16_t DFSDM2_AWSR; // @808 analog watchdog status register
	 uint8_t RESERVED32[2]; // @810 
	__IO uint16_t DFSDM2_AWCFR; // @812 analog watchdog clear flag register
	 uint8_t RESERVED33[2]; // @814 
	__I uint32_t DFSDM2_EXMAX; // @816 Extremes detector maximum register
	__I uint32_t DFSDM2_EXMIN; // @820 Extremes detector minimum register
	__I uint32_t DFSDM2_CNVTIMR; // @824 conversion timer register
	 uint8_t RESERVED34[196]; // @828 
	__IO uint32_t DFSDM3_CR1; // @1024 control register 1
	__IO uint32_t DFSDM3_CR2; // @1028 control register 2
	__I uint32_t DFSDM3_ISR; // @1032 interrupt and status register
	__IO uint32_t DFSDM3_ICR; // @1036 interrupt flag clear register
	__IO uint8_t DFSDM3_JCHGR; // @1040 injected channel group selection register
	 uint8_t RESERVED35[3]; // @1041 
	__IO uint32_t DFSDM3_FCR; // @1044 filter control register
	__I uint32_t DFSDM3_JDATAR; // @1048 data register for injected group
	__I uint32_t DFSDM3_RDATAR; // @1052 data register for the regular channel
	__IO uint32_t DFSDM3_AWHTR; // @1056 analog watchdog high threshold register
	__IO uint32_t DFSDM3_AWLTR; // @1060 analog watchdog low threshold register
	__I uint16_t DFSDM3_AWSR; // @1064 analog watchdog status register
	 uint8_t RESERVED36[2]; // @1066 
	__IO uint16_t DFSDM3_AWCFR; // @1068 analog watchdog clear flag register
	 uint8_t RESERVED37[2]; // @1070 
	__I uint32_t DFSDM3_EXMAX; // @1072 Extremes detector maximum register
	__I uint32_t DFSDM3_EXMIN; // @1076 Extremes detector minimum register
	__I uint32_t DFSDM3_CNVTIMR; // @1080 conversion timer register
};

// DFSDM->CHCFG0R1 channel configuration y register
enum {
	DFSDM_CHCFG0R1_DFSDMEN = 1UL<<31, // DFSDMEN
	DFSDM_CHCFG0R1_CKOUTSRC = 1UL<<30, // CKOUTSRC
	DFSDM_CHCFG0R1_CKOUTDIV = ((1UL<<8)-1) << 16, // CKOUTDIV
	DFSDM_CHCFG0R1_DATPACK = ((1UL<<2)-1) << 14, // DATPACK
	DFSDM_CHCFG0R1_DATMPX = ((1UL<<2)-1) << 12, // DATMPX
	DFSDM_CHCFG0R1_CHINSEL = 1UL<<8, // CHINSEL
	DFSDM_CHCFG0R1_CHEN = 1UL<<7, // CHEN
	DFSDM_CHCFG0R1_CKABEN = 1UL<<6, // CKABEN
	DFSDM_CHCFG0R1_SCDEN = 1UL<<5, // SCDEN
	DFSDM_CHCFG0R1_SPICKSEL = ((1UL<<2)-1) << 2, // SPICKSEL
	DFSDM_CHCFG0R1_SITP = ((1UL<<2)-1) << 0, // SITP		
};
inline void dfsdm_chcfg0r1_set_ckoutdiv(struct DFSDM_Type* p, uint32_t val) { p->CHCFG0R1 = (p->CHCFG0R1 & ~DFSDM_CHCFG0R1_CKOUTDIV) | ((val<<16) & DFSDM_CHCFG0R1_CKOUTDIV); }
inline void dfsdm_chcfg0r1_set_datpack(struct DFSDM_Type* p, uint32_t val) { p->CHCFG0R1 = (p->CHCFG0R1 & ~DFSDM_CHCFG0R1_DATPACK) | ((val<<14) & DFSDM_CHCFG0R1_DATPACK); }
inline void dfsdm_chcfg0r1_set_datmpx(struct DFSDM_Type* p, uint32_t val) { p->CHCFG0R1 = (p->CHCFG0R1 & ~DFSDM_CHCFG0R1_DATMPX) | ((val<<12) & DFSDM_CHCFG0R1_DATMPX); }
inline void dfsdm_chcfg0r1_set_spicksel(struct DFSDM_Type* p, uint32_t val) { p->CHCFG0R1 = (p->CHCFG0R1 & ~DFSDM_CHCFG0R1_SPICKSEL) | ((val<<2) & DFSDM_CHCFG0R1_SPICKSEL); }
inline void dfsdm_chcfg0r1_set_sitp(struct DFSDM_Type* p, uint32_t val) { p->CHCFG0R1 = (p->CHCFG0R1 & ~DFSDM_CHCFG0R1_SITP) | ((val<<0) & DFSDM_CHCFG0R1_SITP); }
inline uint32_t dfsdm_chcfg0r1_get_ckoutdiv(struct DFSDM_Type* p) { return (p->CHCFG0R1 & DFSDM_CHCFG0R1_CKOUTDIV) >> 16 ; }
inline uint32_t dfsdm_chcfg0r1_get_datpack(struct DFSDM_Type* p) { return (p->CHCFG0R1 & DFSDM_CHCFG0R1_DATPACK) >> 14 ; }
inline uint32_t dfsdm_chcfg0r1_get_datmpx(struct DFSDM_Type* p) { return (p->CHCFG0R1 & DFSDM_CHCFG0R1_DATMPX) >> 12 ; }
inline uint32_t dfsdm_chcfg0r1_get_spicksel(struct DFSDM_Type* p) { return (p->CHCFG0R1 & DFSDM_CHCFG0R1_SPICKSEL) >> 2 ; }
inline uint32_t dfsdm_chcfg0r1_get_sitp(struct DFSDM_Type* p) { return (p->CHCFG0R1 & DFSDM_CHCFG0R1_SITP) >> 0 ; }

// DFSDM->CHCFG0R2 channel configuration y register
enum {
	DFSDM_CHCFG0R2_OFFSET = ((1UL<<24)-1) << 8, // OFFSET
	DFSDM_CHCFG0R2_DTRBS = ((1UL<<5)-1) << 3, // DTRBS		
};
inline void dfsdm_chcfg0r2_set_offset(struct DFSDM_Type* p, uint32_t val) { p->CHCFG0R2 = (p->CHCFG0R2 & ~DFSDM_CHCFG0R2_OFFSET) | ((val<<8) & DFSDM_CHCFG0R2_OFFSET); }
inline void dfsdm_chcfg0r2_set_dtrbs(struct DFSDM_Type* p, uint32_t val) { p->CHCFG0R2 = (p->CHCFG0R2 & ~DFSDM_CHCFG0R2_DTRBS) | ((val<<3) & DFSDM_CHCFG0R2_DTRBS); }
inline uint32_t dfsdm_chcfg0r2_get_offset(struct DFSDM_Type* p) { return (p->CHCFG0R2 & DFSDM_CHCFG0R2_OFFSET) >> 8 ; }
inline uint32_t dfsdm_chcfg0r2_get_dtrbs(struct DFSDM_Type* p) { return (p->CHCFG0R2 & DFSDM_CHCFG0R2_DTRBS) >> 3 ; }

// DFSDM->AWSCD0R analog watchdog and short-circuit detector register
enum {
	DFSDM_AWSCD0R_AWFORD = ((1UL<<2)-1) << 22, // AWFORD
	DFSDM_AWSCD0R_AWFOSR = ((1UL<<5)-1) << 16, // AWFOSR
	DFSDM_AWSCD0R_BKSCD = ((1UL<<4)-1) << 12, // BKSCD
	DFSDM_AWSCD0R_SCDT = ((1UL<<8)-1) << 0, // SCDT		
};
inline void dfsdm_awscd0r_set_awford(struct DFSDM_Type* p, uint32_t val) { p->AWSCD0R = (p->AWSCD0R & ~DFSDM_AWSCD0R_AWFORD) | ((val<<22) & DFSDM_AWSCD0R_AWFORD); }
inline void dfsdm_awscd0r_set_awfosr(struct DFSDM_Type* p, uint32_t val) { p->AWSCD0R = (p->AWSCD0R & ~DFSDM_AWSCD0R_AWFOSR) | ((val<<16) & DFSDM_AWSCD0R_AWFOSR); }
inline void dfsdm_awscd0r_set_bkscd(struct DFSDM_Type* p, uint32_t val) { p->AWSCD0R = (p->AWSCD0R & ~DFSDM_AWSCD0R_BKSCD) | ((val<<12) & DFSDM_AWSCD0R_BKSCD); }
inline void dfsdm_awscd0r_set_scdt(struct DFSDM_Type* p, uint32_t val) { p->AWSCD0R = (p->AWSCD0R & ~DFSDM_AWSCD0R_SCDT) | ((val<<0) & DFSDM_AWSCD0R_SCDT); }
inline uint32_t dfsdm_awscd0r_get_awford(struct DFSDM_Type* p) { return (p->AWSCD0R & DFSDM_AWSCD0R_AWFORD) >> 22 ; }
inline uint32_t dfsdm_awscd0r_get_awfosr(struct DFSDM_Type* p) { return (p->AWSCD0R & DFSDM_AWSCD0R_AWFOSR) >> 16 ; }
inline uint32_t dfsdm_awscd0r_get_bkscd(struct DFSDM_Type* p) { return (p->AWSCD0R & DFSDM_AWSCD0R_BKSCD) >> 12 ; }
inline uint32_t dfsdm_awscd0r_get_scdt(struct DFSDM_Type* p) { return (p->AWSCD0R & DFSDM_AWSCD0R_SCDT) >> 0 ; }

// DFSDM->CHDATIN0R channel data input register
enum {
	DFSDM_CHDATIN0R_INDAT1 = ((1UL<<16)-1) << 16, // INDAT1
	DFSDM_CHDATIN0R_INDAT0 = ((1UL<<16)-1) << 0, // INDAT0		
};
inline void dfsdm_chdatin0r_set_indat1(struct DFSDM_Type* p, uint32_t val) { p->CHDATIN0R = (p->CHDATIN0R & ~DFSDM_CHDATIN0R_INDAT1) | ((val<<16) & DFSDM_CHDATIN0R_INDAT1); }
inline void dfsdm_chdatin0r_set_indat0(struct DFSDM_Type* p, uint32_t val) { p->CHDATIN0R = (p->CHDATIN0R & ~DFSDM_CHDATIN0R_INDAT0) | ((val<<0) & DFSDM_CHDATIN0R_INDAT0); }
inline uint32_t dfsdm_chdatin0r_get_indat1(struct DFSDM_Type* p) { return (p->CHDATIN0R & DFSDM_CHDATIN0R_INDAT1) >> 16 ; }
inline uint32_t dfsdm_chdatin0r_get_indat0(struct DFSDM_Type* p) { return (p->CHDATIN0R & DFSDM_CHDATIN0R_INDAT0) >> 0 ; }

// DFSDM->CHCFG1R1 CHCFG1R1
enum {
	DFSDM_CHCFG1R1_DATPACK = ((1UL<<2)-1) << 14, // DATPACK
	DFSDM_CHCFG1R1_DATMPX = ((1UL<<2)-1) << 12, // DATMPX
	DFSDM_CHCFG1R1_CHINSEL = 1UL<<8, // CHINSEL
	DFSDM_CHCFG1R1_CHEN = 1UL<<7, // CHEN
	DFSDM_CHCFG1R1_CKABEN = 1UL<<6, // CKABEN
	DFSDM_CHCFG1R1_SCDEN = 1UL<<5, // SCDEN
	DFSDM_CHCFG1R1_SPICKSEL = ((1UL<<2)-1) << 2, // SPICKSEL
	DFSDM_CHCFG1R1_SITP = ((1UL<<2)-1) << 0, // SITP		
};
inline void dfsdm_chcfg1r1_set_datpack(struct DFSDM_Type* p, uint32_t val) { p->CHCFG1R1 = (p->CHCFG1R1 & ~DFSDM_CHCFG1R1_DATPACK) | ((val<<14) & DFSDM_CHCFG1R1_DATPACK); }
inline void dfsdm_chcfg1r1_set_datmpx(struct DFSDM_Type* p, uint32_t val) { p->CHCFG1R1 = (p->CHCFG1R1 & ~DFSDM_CHCFG1R1_DATMPX) | ((val<<12) & DFSDM_CHCFG1R1_DATMPX); }
inline void dfsdm_chcfg1r1_set_spicksel(struct DFSDM_Type* p, uint32_t val) { p->CHCFG1R1 = (p->CHCFG1R1 & ~DFSDM_CHCFG1R1_SPICKSEL) | ((val<<2) & DFSDM_CHCFG1R1_SPICKSEL); }
inline void dfsdm_chcfg1r1_set_sitp(struct DFSDM_Type* p, uint32_t val) { p->CHCFG1R1 = (p->CHCFG1R1 & ~DFSDM_CHCFG1R1_SITP) | ((val<<0) & DFSDM_CHCFG1R1_SITP); }
inline uint32_t dfsdm_chcfg1r1_get_datpack(struct DFSDM_Type* p) { return (p->CHCFG1R1 & DFSDM_CHCFG1R1_DATPACK) >> 14 ; }
inline uint32_t dfsdm_chcfg1r1_get_datmpx(struct DFSDM_Type* p) { return (p->CHCFG1R1 & DFSDM_CHCFG1R1_DATMPX) >> 12 ; }
inline uint32_t dfsdm_chcfg1r1_get_spicksel(struct DFSDM_Type* p) { return (p->CHCFG1R1 & DFSDM_CHCFG1R1_SPICKSEL) >> 2 ; }
inline uint32_t dfsdm_chcfg1r1_get_sitp(struct DFSDM_Type* p) { return (p->CHCFG1R1 & DFSDM_CHCFG1R1_SITP) >> 0 ; }

// DFSDM->CHCFG1R2 CHCFG1R2
enum {
	DFSDM_CHCFG1R2_OFFSET = ((1UL<<24)-1) << 8, // OFFSET
	DFSDM_CHCFG1R2_DTRBS = ((1UL<<5)-1) << 3, // DTRBS		
};
inline void dfsdm_chcfg1r2_set_offset(struct DFSDM_Type* p, uint32_t val) { p->CHCFG1R2 = (p->CHCFG1R2 & ~DFSDM_CHCFG1R2_OFFSET) | ((val<<8) & DFSDM_CHCFG1R2_OFFSET); }
inline void dfsdm_chcfg1r2_set_dtrbs(struct DFSDM_Type* p, uint32_t val) { p->CHCFG1R2 = (p->CHCFG1R2 & ~DFSDM_CHCFG1R2_DTRBS) | ((val<<3) & DFSDM_CHCFG1R2_DTRBS); }
inline uint32_t dfsdm_chcfg1r2_get_offset(struct DFSDM_Type* p) { return (p->CHCFG1R2 & DFSDM_CHCFG1R2_OFFSET) >> 8 ; }
inline uint32_t dfsdm_chcfg1r2_get_dtrbs(struct DFSDM_Type* p) { return (p->CHCFG1R2 & DFSDM_CHCFG1R2_DTRBS) >> 3 ; }

// DFSDM->AWSCD1R AWSCD1R
enum {
	DFSDM_AWSCD1R_AWFORD = ((1UL<<2)-1) << 22, // AWFORD
	DFSDM_AWSCD1R_AWFOSR = ((1UL<<5)-1) << 16, // AWFOSR
	DFSDM_AWSCD1R_BKSCD = ((1UL<<4)-1) << 12, // BKSCD
	DFSDM_AWSCD1R_SCDT = ((1UL<<8)-1) << 0, // SCDT		
};
inline void dfsdm_awscd1r_set_awford(struct DFSDM_Type* p, uint32_t val) { p->AWSCD1R = (p->AWSCD1R & ~DFSDM_AWSCD1R_AWFORD) | ((val<<22) & DFSDM_AWSCD1R_AWFORD); }
inline void dfsdm_awscd1r_set_awfosr(struct DFSDM_Type* p, uint32_t val) { p->AWSCD1R = (p->AWSCD1R & ~DFSDM_AWSCD1R_AWFOSR) | ((val<<16) & DFSDM_AWSCD1R_AWFOSR); }
inline void dfsdm_awscd1r_set_bkscd(struct DFSDM_Type* p, uint32_t val) { p->AWSCD1R = (p->AWSCD1R & ~DFSDM_AWSCD1R_BKSCD) | ((val<<12) & DFSDM_AWSCD1R_BKSCD); }
inline void dfsdm_awscd1r_set_scdt(struct DFSDM_Type* p, uint32_t val) { p->AWSCD1R = (p->AWSCD1R & ~DFSDM_AWSCD1R_SCDT) | ((val<<0) & DFSDM_AWSCD1R_SCDT); }
inline uint32_t dfsdm_awscd1r_get_awford(struct DFSDM_Type* p) { return (p->AWSCD1R & DFSDM_AWSCD1R_AWFORD) >> 22 ; }
inline uint32_t dfsdm_awscd1r_get_awfosr(struct DFSDM_Type* p) { return (p->AWSCD1R & DFSDM_AWSCD1R_AWFOSR) >> 16 ; }
inline uint32_t dfsdm_awscd1r_get_bkscd(struct DFSDM_Type* p) { return (p->AWSCD1R & DFSDM_AWSCD1R_BKSCD) >> 12 ; }
inline uint32_t dfsdm_awscd1r_get_scdt(struct DFSDM_Type* p) { return (p->AWSCD1R & DFSDM_AWSCD1R_SCDT) >> 0 ; }

// DFSDM->CHDATIN1R CHDATIN1R
enum {
	DFSDM_CHDATIN1R_INDAT1 = ((1UL<<16)-1) << 16, // INDAT1
	DFSDM_CHDATIN1R_INDAT0 = ((1UL<<16)-1) << 0, // INDAT0		
};
inline void dfsdm_chdatin1r_set_indat1(struct DFSDM_Type* p, uint32_t val) { p->CHDATIN1R = (p->CHDATIN1R & ~DFSDM_CHDATIN1R_INDAT1) | ((val<<16) & DFSDM_CHDATIN1R_INDAT1); }
inline void dfsdm_chdatin1r_set_indat0(struct DFSDM_Type* p, uint32_t val) { p->CHDATIN1R = (p->CHDATIN1R & ~DFSDM_CHDATIN1R_INDAT0) | ((val<<0) & DFSDM_CHDATIN1R_INDAT0); }
inline uint32_t dfsdm_chdatin1r_get_indat1(struct DFSDM_Type* p) { return (p->CHDATIN1R & DFSDM_CHDATIN1R_INDAT1) >> 16 ; }
inline uint32_t dfsdm_chdatin1r_get_indat0(struct DFSDM_Type* p) { return (p->CHDATIN1R & DFSDM_CHDATIN1R_INDAT0) >> 0 ; }

// DFSDM->CHCFG2R1 CHCFG2R1
enum {
	DFSDM_CHCFG2R1_DATPACK = ((1UL<<2)-1) << 14, // DATPACK
	DFSDM_CHCFG2R1_DATMPX = ((1UL<<2)-1) << 12, // DATMPX
	DFSDM_CHCFG2R1_CHINSEL = 1UL<<8, // CHINSEL
	DFSDM_CHCFG2R1_CHEN = 1UL<<7, // CHEN
	DFSDM_CHCFG2R1_CKABEN = 1UL<<6, // CKABEN
	DFSDM_CHCFG2R1_SCDEN = 1UL<<5, // SCDEN
	DFSDM_CHCFG2R1_SPICKSEL = ((1UL<<2)-1) << 2, // SPICKSEL
	DFSDM_CHCFG2R1_SITP = ((1UL<<2)-1) << 0, // SITP		
};
inline void dfsdm_chcfg2r1_set_datpack(struct DFSDM_Type* p, uint32_t val) { p->CHCFG2R1 = (p->CHCFG2R1 & ~DFSDM_CHCFG2R1_DATPACK) | ((val<<14) & DFSDM_CHCFG2R1_DATPACK); }
inline void dfsdm_chcfg2r1_set_datmpx(struct DFSDM_Type* p, uint32_t val) { p->CHCFG2R1 = (p->CHCFG2R1 & ~DFSDM_CHCFG2R1_DATMPX) | ((val<<12) & DFSDM_CHCFG2R1_DATMPX); }
inline void dfsdm_chcfg2r1_set_spicksel(struct DFSDM_Type* p, uint32_t val) { p->CHCFG2R1 = (p->CHCFG2R1 & ~DFSDM_CHCFG2R1_SPICKSEL) | ((val<<2) & DFSDM_CHCFG2R1_SPICKSEL); }
inline void dfsdm_chcfg2r1_set_sitp(struct DFSDM_Type* p, uint32_t val) { p->CHCFG2R1 = (p->CHCFG2R1 & ~DFSDM_CHCFG2R1_SITP) | ((val<<0) & DFSDM_CHCFG2R1_SITP); }
inline uint32_t dfsdm_chcfg2r1_get_datpack(struct DFSDM_Type* p) { return (p->CHCFG2R1 & DFSDM_CHCFG2R1_DATPACK) >> 14 ; }
inline uint32_t dfsdm_chcfg2r1_get_datmpx(struct DFSDM_Type* p) { return (p->CHCFG2R1 & DFSDM_CHCFG2R1_DATMPX) >> 12 ; }
inline uint32_t dfsdm_chcfg2r1_get_spicksel(struct DFSDM_Type* p) { return (p->CHCFG2R1 & DFSDM_CHCFG2R1_SPICKSEL) >> 2 ; }
inline uint32_t dfsdm_chcfg2r1_get_sitp(struct DFSDM_Type* p) { return (p->CHCFG2R1 & DFSDM_CHCFG2R1_SITP) >> 0 ; }

// DFSDM->CHCFG2R2 CHCFG2R2
enum {
	DFSDM_CHCFG2R2_OFFSET = ((1UL<<24)-1) << 8, // OFFSET
	DFSDM_CHCFG2R2_DTRBS = ((1UL<<5)-1) << 3, // DTRBS		
};
inline void dfsdm_chcfg2r2_set_offset(struct DFSDM_Type* p, uint32_t val) { p->CHCFG2R2 = (p->CHCFG2R2 & ~DFSDM_CHCFG2R2_OFFSET) | ((val<<8) & DFSDM_CHCFG2R2_OFFSET); }
inline void dfsdm_chcfg2r2_set_dtrbs(struct DFSDM_Type* p, uint32_t val) { p->CHCFG2R2 = (p->CHCFG2R2 & ~DFSDM_CHCFG2R2_DTRBS) | ((val<<3) & DFSDM_CHCFG2R2_DTRBS); }
inline uint32_t dfsdm_chcfg2r2_get_offset(struct DFSDM_Type* p) { return (p->CHCFG2R2 & DFSDM_CHCFG2R2_OFFSET) >> 8 ; }
inline uint32_t dfsdm_chcfg2r2_get_dtrbs(struct DFSDM_Type* p) { return (p->CHCFG2R2 & DFSDM_CHCFG2R2_DTRBS) >> 3 ; }

// DFSDM->AWSCD2R AWSCD2R
enum {
	DFSDM_AWSCD2R_AWFORD = ((1UL<<2)-1) << 22, // AWFORD
	DFSDM_AWSCD2R_AWFOSR = ((1UL<<5)-1) << 16, // AWFOSR
	DFSDM_AWSCD2R_BKSCD = ((1UL<<4)-1) << 12, // BKSCD
	DFSDM_AWSCD2R_SCDT = ((1UL<<8)-1) << 0, // SCDT		
};
inline void dfsdm_awscd2r_set_awford(struct DFSDM_Type* p, uint32_t val) { p->AWSCD2R = (p->AWSCD2R & ~DFSDM_AWSCD2R_AWFORD) | ((val<<22) & DFSDM_AWSCD2R_AWFORD); }
inline void dfsdm_awscd2r_set_awfosr(struct DFSDM_Type* p, uint32_t val) { p->AWSCD2R = (p->AWSCD2R & ~DFSDM_AWSCD2R_AWFOSR) | ((val<<16) & DFSDM_AWSCD2R_AWFOSR); }
inline void dfsdm_awscd2r_set_bkscd(struct DFSDM_Type* p, uint32_t val) { p->AWSCD2R = (p->AWSCD2R & ~DFSDM_AWSCD2R_BKSCD) | ((val<<12) & DFSDM_AWSCD2R_BKSCD); }
inline void dfsdm_awscd2r_set_scdt(struct DFSDM_Type* p, uint32_t val) { p->AWSCD2R = (p->AWSCD2R & ~DFSDM_AWSCD2R_SCDT) | ((val<<0) & DFSDM_AWSCD2R_SCDT); }
inline uint32_t dfsdm_awscd2r_get_awford(struct DFSDM_Type* p) { return (p->AWSCD2R & DFSDM_AWSCD2R_AWFORD) >> 22 ; }
inline uint32_t dfsdm_awscd2r_get_awfosr(struct DFSDM_Type* p) { return (p->AWSCD2R & DFSDM_AWSCD2R_AWFOSR) >> 16 ; }
inline uint32_t dfsdm_awscd2r_get_bkscd(struct DFSDM_Type* p) { return (p->AWSCD2R & DFSDM_AWSCD2R_BKSCD) >> 12 ; }
inline uint32_t dfsdm_awscd2r_get_scdt(struct DFSDM_Type* p) { return (p->AWSCD2R & DFSDM_AWSCD2R_SCDT) >> 0 ; }

// DFSDM->CHDATIN2R CHDATIN2R
enum {
	DFSDM_CHDATIN2R_INDAT1 = ((1UL<<16)-1) << 16, // INDAT1
	DFSDM_CHDATIN2R_INDAT0 = ((1UL<<16)-1) << 0, // INDAT0		
};
inline void dfsdm_chdatin2r_set_indat1(struct DFSDM_Type* p, uint32_t val) { p->CHDATIN2R = (p->CHDATIN2R & ~DFSDM_CHDATIN2R_INDAT1) | ((val<<16) & DFSDM_CHDATIN2R_INDAT1); }
inline void dfsdm_chdatin2r_set_indat0(struct DFSDM_Type* p, uint32_t val) { p->CHDATIN2R = (p->CHDATIN2R & ~DFSDM_CHDATIN2R_INDAT0) | ((val<<0) & DFSDM_CHDATIN2R_INDAT0); }
inline uint32_t dfsdm_chdatin2r_get_indat1(struct DFSDM_Type* p) { return (p->CHDATIN2R & DFSDM_CHDATIN2R_INDAT1) >> 16 ; }
inline uint32_t dfsdm_chdatin2r_get_indat0(struct DFSDM_Type* p) { return (p->CHDATIN2R & DFSDM_CHDATIN2R_INDAT0) >> 0 ; }

// DFSDM->CHCFG3R1 CHCFG3R1
enum {
	DFSDM_CHCFG3R1_DATPACK = ((1UL<<2)-1) << 14, // DATPACK
	DFSDM_CHCFG3R1_DATMPX = ((1UL<<2)-1) << 12, // DATMPX
	DFSDM_CHCFG3R1_CHINSEL = 1UL<<8, // CHINSEL
	DFSDM_CHCFG3R1_CHEN = 1UL<<7, // CHEN
	DFSDM_CHCFG3R1_CKABEN = 1UL<<6, // CKABEN
	DFSDM_CHCFG3R1_SCDEN = 1UL<<5, // SCDEN
	DFSDM_CHCFG3R1_SPICKSEL = ((1UL<<2)-1) << 2, // SPICKSEL
	DFSDM_CHCFG3R1_SITP = ((1UL<<2)-1) << 0, // SITP		
};
inline void dfsdm_chcfg3r1_set_datpack(struct DFSDM_Type* p, uint32_t val) { p->CHCFG3R1 = (p->CHCFG3R1 & ~DFSDM_CHCFG3R1_DATPACK) | ((val<<14) & DFSDM_CHCFG3R1_DATPACK); }
inline void dfsdm_chcfg3r1_set_datmpx(struct DFSDM_Type* p, uint32_t val) { p->CHCFG3R1 = (p->CHCFG3R1 & ~DFSDM_CHCFG3R1_DATMPX) | ((val<<12) & DFSDM_CHCFG3R1_DATMPX); }
inline void dfsdm_chcfg3r1_set_spicksel(struct DFSDM_Type* p, uint32_t val) { p->CHCFG3R1 = (p->CHCFG3R1 & ~DFSDM_CHCFG3R1_SPICKSEL) | ((val<<2) & DFSDM_CHCFG3R1_SPICKSEL); }
inline void dfsdm_chcfg3r1_set_sitp(struct DFSDM_Type* p, uint32_t val) { p->CHCFG3R1 = (p->CHCFG3R1 & ~DFSDM_CHCFG3R1_SITP) | ((val<<0) & DFSDM_CHCFG3R1_SITP); }
inline uint32_t dfsdm_chcfg3r1_get_datpack(struct DFSDM_Type* p) { return (p->CHCFG3R1 & DFSDM_CHCFG3R1_DATPACK) >> 14 ; }
inline uint32_t dfsdm_chcfg3r1_get_datmpx(struct DFSDM_Type* p) { return (p->CHCFG3R1 & DFSDM_CHCFG3R1_DATMPX) >> 12 ; }
inline uint32_t dfsdm_chcfg3r1_get_spicksel(struct DFSDM_Type* p) { return (p->CHCFG3R1 & DFSDM_CHCFG3R1_SPICKSEL) >> 2 ; }
inline uint32_t dfsdm_chcfg3r1_get_sitp(struct DFSDM_Type* p) { return (p->CHCFG3R1 & DFSDM_CHCFG3R1_SITP) >> 0 ; }

// DFSDM->CHCFG3R2 CHCFG3R2
enum {
	DFSDM_CHCFG3R2_OFFSET = ((1UL<<24)-1) << 8, // OFFSET
	DFSDM_CHCFG3R2_DTRBS = ((1UL<<5)-1) << 3, // DTRBS		
};
inline void dfsdm_chcfg3r2_set_offset(struct DFSDM_Type* p, uint32_t val) { p->CHCFG3R2 = (p->CHCFG3R2 & ~DFSDM_CHCFG3R2_OFFSET) | ((val<<8) & DFSDM_CHCFG3R2_OFFSET); }
inline void dfsdm_chcfg3r2_set_dtrbs(struct DFSDM_Type* p, uint32_t val) { p->CHCFG3R2 = (p->CHCFG3R2 & ~DFSDM_CHCFG3R2_DTRBS) | ((val<<3) & DFSDM_CHCFG3R2_DTRBS); }
inline uint32_t dfsdm_chcfg3r2_get_offset(struct DFSDM_Type* p) { return (p->CHCFG3R2 & DFSDM_CHCFG3R2_OFFSET) >> 8 ; }
inline uint32_t dfsdm_chcfg3r2_get_dtrbs(struct DFSDM_Type* p) { return (p->CHCFG3R2 & DFSDM_CHCFG3R2_DTRBS) >> 3 ; }

// DFSDM->AWSCD3R AWSCD3R
enum {
	DFSDM_AWSCD3R_AWFORD = ((1UL<<2)-1) << 22, // AWFORD
	DFSDM_AWSCD3R_AWFOSR = ((1UL<<5)-1) << 16, // AWFOSR
	DFSDM_AWSCD3R_BKSCD = ((1UL<<4)-1) << 12, // BKSCD
	DFSDM_AWSCD3R_SCDT = ((1UL<<8)-1) << 0, // SCDT		
};
inline void dfsdm_awscd3r_set_awford(struct DFSDM_Type* p, uint32_t val) { p->AWSCD3R = (p->AWSCD3R & ~DFSDM_AWSCD3R_AWFORD) | ((val<<22) & DFSDM_AWSCD3R_AWFORD); }
inline void dfsdm_awscd3r_set_awfosr(struct DFSDM_Type* p, uint32_t val) { p->AWSCD3R = (p->AWSCD3R & ~DFSDM_AWSCD3R_AWFOSR) | ((val<<16) & DFSDM_AWSCD3R_AWFOSR); }
inline void dfsdm_awscd3r_set_bkscd(struct DFSDM_Type* p, uint32_t val) { p->AWSCD3R = (p->AWSCD3R & ~DFSDM_AWSCD3R_BKSCD) | ((val<<12) & DFSDM_AWSCD3R_BKSCD); }
inline void dfsdm_awscd3r_set_scdt(struct DFSDM_Type* p, uint32_t val) { p->AWSCD3R = (p->AWSCD3R & ~DFSDM_AWSCD3R_SCDT) | ((val<<0) & DFSDM_AWSCD3R_SCDT); }
inline uint32_t dfsdm_awscd3r_get_awford(struct DFSDM_Type* p) { return (p->AWSCD3R & DFSDM_AWSCD3R_AWFORD) >> 22 ; }
inline uint32_t dfsdm_awscd3r_get_awfosr(struct DFSDM_Type* p) { return (p->AWSCD3R & DFSDM_AWSCD3R_AWFOSR) >> 16 ; }
inline uint32_t dfsdm_awscd3r_get_bkscd(struct DFSDM_Type* p) { return (p->AWSCD3R & DFSDM_AWSCD3R_BKSCD) >> 12 ; }
inline uint32_t dfsdm_awscd3r_get_scdt(struct DFSDM_Type* p) { return (p->AWSCD3R & DFSDM_AWSCD3R_SCDT) >> 0 ; }

// DFSDM->CHDATIN3R CHDATIN3R
enum {
	DFSDM_CHDATIN3R_INDAT1 = ((1UL<<16)-1) << 16, // INDAT1
	DFSDM_CHDATIN3R_INDAT0 = ((1UL<<16)-1) << 0, // INDAT0		
};
inline void dfsdm_chdatin3r_set_indat1(struct DFSDM_Type* p, uint32_t val) { p->CHDATIN3R = (p->CHDATIN3R & ~DFSDM_CHDATIN3R_INDAT1) | ((val<<16) & DFSDM_CHDATIN3R_INDAT1); }
inline void dfsdm_chdatin3r_set_indat0(struct DFSDM_Type* p, uint32_t val) { p->CHDATIN3R = (p->CHDATIN3R & ~DFSDM_CHDATIN3R_INDAT0) | ((val<<0) & DFSDM_CHDATIN3R_INDAT0); }
inline uint32_t dfsdm_chdatin3r_get_indat1(struct DFSDM_Type* p) { return (p->CHDATIN3R & DFSDM_CHDATIN3R_INDAT1) >> 16 ; }
inline uint32_t dfsdm_chdatin3r_get_indat0(struct DFSDM_Type* p) { return (p->CHDATIN3R & DFSDM_CHDATIN3R_INDAT0) >> 0 ; }

// DFSDM->CHCFG4R1 CHCFG4R1
enum {
	DFSDM_CHCFG4R1_DATPACK = ((1UL<<2)-1) << 14, // DATPACK
	DFSDM_CHCFG4R1_DATMPX = ((1UL<<2)-1) << 12, // DATMPX
	DFSDM_CHCFG4R1_CHINSEL = 1UL<<8, // CHINSEL
	DFSDM_CHCFG4R1_CHEN = 1UL<<7, // CHEN
	DFSDM_CHCFG4R1_CKABEN = 1UL<<6, // CKABEN
	DFSDM_CHCFG4R1_SCDEN = 1UL<<5, // SCDEN
	DFSDM_CHCFG4R1_SPICKSEL = ((1UL<<2)-1) << 2, // SPICKSEL
	DFSDM_CHCFG4R1_SITP = ((1UL<<2)-1) << 0, // SITP		
};
inline void dfsdm_chcfg4r1_set_datpack(struct DFSDM_Type* p, uint32_t val) { p->CHCFG4R1 = (p->CHCFG4R1 & ~DFSDM_CHCFG4R1_DATPACK) | ((val<<14) & DFSDM_CHCFG4R1_DATPACK); }
inline void dfsdm_chcfg4r1_set_datmpx(struct DFSDM_Type* p, uint32_t val) { p->CHCFG4R1 = (p->CHCFG4R1 & ~DFSDM_CHCFG4R1_DATMPX) | ((val<<12) & DFSDM_CHCFG4R1_DATMPX); }
inline void dfsdm_chcfg4r1_set_spicksel(struct DFSDM_Type* p, uint32_t val) { p->CHCFG4R1 = (p->CHCFG4R1 & ~DFSDM_CHCFG4R1_SPICKSEL) | ((val<<2) & DFSDM_CHCFG4R1_SPICKSEL); }
inline void dfsdm_chcfg4r1_set_sitp(struct DFSDM_Type* p, uint32_t val) { p->CHCFG4R1 = (p->CHCFG4R1 & ~DFSDM_CHCFG4R1_SITP) | ((val<<0) & DFSDM_CHCFG4R1_SITP); }
inline uint32_t dfsdm_chcfg4r1_get_datpack(struct DFSDM_Type* p) { return (p->CHCFG4R1 & DFSDM_CHCFG4R1_DATPACK) >> 14 ; }
inline uint32_t dfsdm_chcfg4r1_get_datmpx(struct DFSDM_Type* p) { return (p->CHCFG4R1 & DFSDM_CHCFG4R1_DATMPX) >> 12 ; }
inline uint32_t dfsdm_chcfg4r1_get_spicksel(struct DFSDM_Type* p) { return (p->CHCFG4R1 & DFSDM_CHCFG4R1_SPICKSEL) >> 2 ; }
inline uint32_t dfsdm_chcfg4r1_get_sitp(struct DFSDM_Type* p) { return (p->CHCFG4R1 & DFSDM_CHCFG4R1_SITP) >> 0 ; }

// DFSDM->CHCFG4R2 CHCFG4R2
enum {
	DFSDM_CHCFG4R2_OFFSET = ((1UL<<24)-1) << 8, // OFFSET
	DFSDM_CHCFG4R2_DTRBS = ((1UL<<5)-1) << 3, // DTRBS		
};
inline void dfsdm_chcfg4r2_set_offset(struct DFSDM_Type* p, uint32_t val) { p->CHCFG4R2 = (p->CHCFG4R2 & ~DFSDM_CHCFG4R2_OFFSET) | ((val<<8) & DFSDM_CHCFG4R2_OFFSET); }
inline void dfsdm_chcfg4r2_set_dtrbs(struct DFSDM_Type* p, uint32_t val) { p->CHCFG4R2 = (p->CHCFG4R2 & ~DFSDM_CHCFG4R2_DTRBS) | ((val<<3) & DFSDM_CHCFG4R2_DTRBS); }
inline uint32_t dfsdm_chcfg4r2_get_offset(struct DFSDM_Type* p) { return (p->CHCFG4R2 & DFSDM_CHCFG4R2_OFFSET) >> 8 ; }
inline uint32_t dfsdm_chcfg4r2_get_dtrbs(struct DFSDM_Type* p) { return (p->CHCFG4R2 & DFSDM_CHCFG4R2_DTRBS) >> 3 ; }

// DFSDM->AWSCD4R AWSCD4R
enum {
	DFSDM_AWSCD4R_AWFORD = ((1UL<<2)-1) << 22, // AWFORD
	DFSDM_AWSCD4R_AWFOSR = ((1UL<<5)-1) << 16, // AWFOSR
	DFSDM_AWSCD4R_BKSCD = ((1UL<<4)-1) << 12, // BKSCD
	DFSDM_AWSCD4R_SCDT = ((1UL<<8)-1) << 0, // SCDT		
};
inline void dfsdm_awscd4r_set_awford(struct DFSDM_Type* p, uint32_t val) { p->AWSCD4R = (p->AWSCD4R & ~DFSDM_AWSCD4R_AWFORD) | ((val<<22) & DFSDM_AWSCD4R_AWFORD); }
inline void dfsdm_awscd4r_set_awfosr(struct DFSDM_Type* p, uint32_t val) { p->AWSCD4R = (p->AWSCD4R & ~DFSDM_AWSCD4R_AWFOSR) | ((val<<16) & DFSDM_AWSCD4R_AWFOSR); }
inline void dfsdm_awscd4r_set_bkscd(struct DFSDM_Type* p, uint32_t val) { p->AWSCD4R = (p->AWSCD4R & ~DFSDM_AWSCD4R_BKSCD) | ((val<<12) & DFSDM_AWSCD4R_BKSCD); }
inline void dfsdm_awscd4r_set_scdt(struct DFSDM_Type* p, uint32_t val) { p->AWSCD4R = (p->AWSCD4R & ~DFSDM_AWSCD4R_SCDT) | ((val<<0) & DFSDM_AWSCD4R_SCDT); }
inline uint32_t dfsdm_awscd4r_get_awford(struct DFSDM_Type* p) { return (p->AWSCD4R & DFSDM_AWSCD4R_AWFORD) >> 22 ; }
inline uint32_t dfsdm_awscd4r_get_awfosr(struct DFSDM_Type* p) { return (p->AWSCD4R & DFSDM_AWSCD4R_AWFOSR) >> 16 ; }
inline uint32_t dfsdm_awscd4r_get_bkscd(struct DFSDM_Type* p) { return (p->AWSCD4R & DFSDM_AWSCD4R_BKSCD) >> 12 ; }
inline uint32_t dfsdm_awscd4r_get_scdt(struct DFSDM_Type* p) { return (p->AWSCD4R & DFSDM_AWSCD4R_SCDT) >> 0 ; }

// DFSDM->CHDATIN4R CHDATIN4R
enum {
	DFSDM_CHDATIN4R_INDAT1 = ((1UL<<16)-1) << 16, // INDAT1
	DFSDM_CHDATIN4R_INDAT0 = ((1UL<<16)-1) << 0, // INDAT0		
};
inline void dfsdm_chdatin4r_set_indat1(struct DFSDM_Type* p, uint32_t val) { p->CHDATIN4R = (p->CHDATIN4R & ~DFSDM_CHDATIN4R_INDAT1) | ((val<<16) & DFSDM_CHDATIN4R_INDAT1); }
inline void dfsdm_chdatin4r_set_indat0(struct DFSDM_Type* p, uint32_t val) { p->CHDATIN4R = (p->CHDATIN4R & ~DFSDM_CHDATIN4R_INDAT0) | ((val<<0) & DFSDM_CHDATIN4R_INDAT0); }
inline uint32_t dfsdm_chdatin4r_get_indat1(struct DFSDM_Type* p) { return (p->CHDATIN4R & DFSDM_CHDATIN4R_INDAT1) >> 16 ; }
inline uint32_t dfsdm_chdatin4r_get_indat0(struct DFSDM_Type* p) { return (p->CHDATIN4R & DFSDM_CHDATIN4R_INDAT0) >> 0 ; }

// DFSDM->CHCFG5R1 CHCFG5R1
enum {
	DFSDM_CHCFG5R1_DATPACK = ((1UL<<2)-1) << 14, // DATPACK
	DFSDM_CHCFG5R1_DATMPX = ((1UL<<2)-1) << 12, // DATMPX
	DFSDM_CHCFG5R1_CHINSEL = 1UL<<8, // CHINSEL
	DFSDM_CHCFG5R1_CHEN = 1UL<<7, // CHEN
	DFSDM_CHCFG5R1_CKABEN = 1UL<<6, // CKABEN
	DFSDM_CHCFG5R1_SCDEN = 1UL<<5, // SCDEN
	DFSDM_CHCFG5R1_SPICKSEL = ((1UL<<2)-1) << 2, // SPICKSEL
	DFSDM_CHCFG5R1_SITP = ((1UL<<2)-1) << 0, // SITP		
};
inline void dfsdm_chcfg5r1_set_datpack(struct DFSDM_Type* p, uint32_t val) { p->CHCFG5R1 = (p->CHCFG5R1 & ~DFSDM_CHCFG5R1_DATPACK) | ((val<<14) & DFSDM_CHCFG5R1_DATPACK); }
inline void dfsdm_chcfg5r1_set_datmpx(struct DFSDM_Type* p, uint32_t val) { p->CHCFG5R1 = (p->CHCFG5R1 & ~DFSDM_CHCFG5R1_DATMPX) | ((val<<12) & DFSDM_CHCFG5R1_DATMPX); }
inline void dfsdm_chcfg5r1_set_spicksel(struct DFSDM_Type* p, uint32_t val) { p->CHCFG5R1 = (p->CHCFG5R1 & ~DFSDM_CHCFG5R1_SPICKSEL) | ((val<<2) & DFSDM_CHCFG5R1_SPICKSEL); }
inline void dfsdm_chcfg5r1_set_sitp(struct DFSDM_Type* p, uint32_t val) { p->CHCFG5R1 = (p->CHCFG5R1 & ~DFSDM_CHCFG5R1_SITP) | ((val<<0) & DFSDM_CHCFG5R1_SITP); }
inline uint32_t dfsdm_chcfg5r1_get_datpack(struct DFSDM_Type* p) { return (p->CHCFG5R1 & DFSDM_CHCFG5R1_DATPACK) >> 14 ; }
inline uint32_t dfsdm_chcfg5r1_get_datmpx(struct DFSDM_Type* p) { return (p->CHCFG5R1 & DFSDM_CHCFG5R1_DATMPX) >> 12 ; }
inline uint32_t dfsdm_chcfg5r1_get_spicksel(struct DFSDM_Type* p) { return (p->CHCFG5R1 & DFSDM_CHCFG5R1_SPICKSEL) >> 2 ; }
inline uint32_t dfsdm_chcfg5r1_get_sitp(struct DFSDM_Type* p) { return (p->CHCFG5R1 & DFSDM_CHCFG5R1_SITP) >> 0 ; }

// DFSDM->CHCFG5R2 CHCFG5R2
enum {
	DFSDM_CHCFG5R2_OFFSET = ((1UL<<24)-1) << 8, // OFFSET
	DFSDM_CHCFG5R2_DTRBS = ((1UL<<5)-1) << 3, // DTRBS		
};
inline void dfsdm_chcfg5r2_set_offset(struct DFSDM_Type* p, uint32_t val) { p->CHCFG5R2 = (p->CHCFG5R2 & ~DFSDM_CHCFG5R2_OFFSET) | ((val<<8) & DFSDM_CHCFG5R2_OFFSET); }
inline void dfsdm_chcfg5r2_set_dtrbs(struct DFSDM_Type* p, uint32_t val) { p->CHCFG5R2 = (p->CHCFG5R2 & ~DFSDM_CHCFG5R2_DTRBS) | ((val<<3) & DFSDM_CHCFG5R2_DTRBS); }
inline uint32_t dfsdm_chcfg5r2_get_offset(struct DFSDM_Type* p) { return (p->CHCFG5R2 & DFSDM_CHCFG5R2_OFFSET) >> 8 ; }
inline uint32_t dfsdm_chcfg5r2_get_dtrbs(struct DFSDM_Type* p) { return (p->CHCFG5R2 & DFSDM_CHCFG5R2_DTRBS) >> 3 ; }

// DFSDM->AWSCD5R AWSCD5R
enum {
	DFSDM_AWSCD5R_AWFORD = ((1UL<<2)-1) << 22, // AWFORD
	DFSDM_AWSCD5R_AWFOSR = ((1UL<<5)-1) << 16, // AWFOSR
	DFSDM_AWSCD5R_BKSCD = ((1UL<<4)-1) << 12, // BKSCD
	DFSDM_AWSCD5R_SCDT = ((1UL<<8)-1) << 0, // SCDT		
};
inline void dfsdm_awscd5r_set_awford(struct DFSDM_Type* p, uint32_t val) { p->AWSCD5R = (p->AWSCD5R & ~DFSDM_AWSCD5R_AWFORD) | ((val<<22) & DFSDM_AWSCD5R_AWFORD); }
inline void dfsdm_awscd5r_set_awfosr(struct DFSDM_Type* p, uint32_t val) { p->AWSCD5R = (p->AWSCD5R & ~DFSDM_AWSCD5R_AWFOSR) | ((val<<16) & DFSDM_AWSCD5R_AWFOSR); }
inline void dfsdm_awscd5r_set_bkscd(struct DFSDM_Type* p, uint32_t val) { p->AWSCD5R = (p->AWSCD5R & ~DFSDM_AWSCD5R_BKSCD) | ((val<<12) & DFSDM_AWSCD5R_BKSCD); }
inline void dfsdm_awscd5r_set_scdt(struct DFSDM_Type* p, uint32_t val) { p->AWSCD5R = (p->AWSCD5R & ~DFSDM_AWSCD5R_SCDT) | ((val<<0) & DFSDM_AWSCD5R_SCDT); }
inline uint32_t dfsdm_awscd5r_get_awford(struct DFSDM_Type* p) { return (p->AWSCD5R & DFSDM_AWSCD5R_AWFORD) >> 22 ; }
inline uint32_t dfsdm_awscd5r_get_awfosr(struct DFSDM_Type* p) { return (p->AWSCD5R & DFSDM_AWSCD5R_AWFOSR) >> 16 ; }
inline uint32_t dfsdm_awscd5r_get_bkscd(struct DFSDM_Type* p) { return (p->AWSCD5R & DFSDM_AWSCD5R_BKSCD) >> 12 ; }
inline uint32_t dfsdm_awscd5r_get_scdt(struct DFSDM_Type* p) { return (p->AWSCD5R & DFSDM_AWSCD5R_SCDT) >> 0 ; }

// DFSDM->CHDATIN5R CHDATIN5R
enum {
	DFSDM_CHDATIN5R_INDAT1 = ((1UL<<16)-1) << 16, // INDAT1
	DFSDM_CHDATIN5R_INDAT0 = ((1UL<<16)-1) << 0, // INDAT0		
};
inline void dfsdm_chdatin5r_set_indat1(struct DFSDM_Type* p, uint32_t val) { p->CHDATIN5R = (p->CHDATIN5R & ~DFSDM_CHDATIN5R_INDAT1) | ((val<<16) & DFSDM_CHDATIN5R_INDAT1); }
inline void dfsdm_chdatin5r_set_indat0(struct DFSDM_Type* p, uint32_t val) { p->CHDATIN5R = (p->CHDATIN5R & ~DFSDM_CHDATIN5R_INDAT0) | ((val<<0) & DFSDM_CHDATIN5R_INDAT0); }
inline uint32_t dfsdm_chdatin5r_get_indat1(struct DFSDM_Type* p) { return (p->CHDATIN5R & DFSDM_CHDATIN5R_INDAT1) >> 16 ; }
inline uint32_t dfsdm_chdatin5r_get_indat0(struct DFSDM_Type* p) { return (p->CHDATIN5R & DFSDM_CHDATIN5R_INDAT0) >> 0 ; }

// DFSDM->CHCFG6R1 CHCFG6R1
enum {
	DFSDM_CHCFG6R1_DATPACK = ((1UL<<2)-1) << 14, // DATPACK
	DFSDM_CHCFG6R1_DATMPX = ((1UL<<2)-1) << 12, // DATMPX
	DFSDM_CHCFG6R1_CHINSEL = 1UL<<8, // CHINSEL
	DFSDM_CHCFG6R1_CHEN = 1UL<<7, // CHEN
	DFSDM_CHCFG6R1_CKABEN = 1UL<<6, // CKABEN
	DFSDM_CHCFG6R1_SCDEN = 1UL<<5, // SCDEN
	DFSDM_CHCFG6R1_SPICKSEL = ((1UL<<2)-1) << 2, // SPICKSEL
	DFSDM_CHCFG6R1_SITP = ((1UL<<2)-1) << 0, // SITP		
};
inline void dfsdm_chcfg6r1_set_datpack(struct DFSDM_Type* p, uint32_t val) { p->CHCFG6R1 = (p->CHCFG6R1 & ~DFSDM_CHCFG6R1_DATPACK) | ((val<<14) & DFSDM_CHCFG6R1_DATPACK); }
inline void dfsdm_chcfg6r1_set_datmpx(struct DFSDM_Type* p, uint32_t val) { p->CHCFG6R1 = (p->CHCFG6R1 & ~DFSDM_CHCFG6R1_DATMPX) | ((val<<12) & DFSDM_CHCFG6R1_DATMPX); }
inline void dfsdm_chcfg6r1_set_spicksel(struct DFSDM_Type* p, uint32_t val) { p->CHCFG6R1 = (p->CHCFG6R1 & ~DFSDM_CHCFG6R1_SPICKSEL) | ((val<<2) & DFSDM_CHCFG6R1_SPICKSEL); }
inline void dfsdm_chcfg6r1_set_sitp(struct DFSDM_Type* p, uint32_t val) { p->CHCFG6R1 = (p->CHCFG6R1 & ~DFSDM_CHCFG6R1_SITP) | ((val<<0) & DFSDM_CHCFG6R1_SITP); }
inline uint32_t dfsdm_chcfg6r1_get_datpack(struct DFSDM_Type* p) { return (p->CHCFG6R1 & DFSDM_CHCFG6R1_DATPACK) >> 14 ; }
inline uint32_t dfsdm_chcfg6r1_get_datmpx(struct DFSDM_Type* p) { return (p->CHCFG6R1 & DFSDM_CHCFG6R1_DATMPX) >> 12 ; }
inline uint32_t dfsdm_chcfg6r1_get_spicksel(struct DFSDM_Type* p) { return (p->CHCFG6R1 & DFSDM_CHCFG6R1_SPICKSEL) >> 2 ; }
inline uint32_t dfsdm_chcfg6r1_get_sitp(struct DFSDM_Type* p) { return (p->CHCFG6R1 & DFSDM_CHCFG6R1_SITP) >> 0 ; }

// DFSDM->CHCFG6R2 CHCFG6R2
enum {
	DFSDM_CHCFG6R2_OFFSET = ((1UL<<24)-1) << 8, // OFFSET
	DFSDM_CHCFG6R2_DTRBS = ((1UL<<5)-1) << 3, // DTRBS		
};
inline void dfsdm_chcfg6r2_set_offset(struct DFSDM_Type* p, uint32_t val) { p->CHCFG6R2 = (p->CHCFG6R2 & ~DFSDM_CHCFG6R2_OFFSET) | ((val<<8) & DFSDM_CHCFG6R2_OFFSET); }
inline void dfsdm_chcfg6r2_set_dtrbs(struct DFSDM_Type* p, uint32_t val) { p->CHCFG6R2 = (p->CHCFG6R2 & ~DFSDM_CHCFG6R2_DTRBS) | ((val<<3) & DFSDM_CHCFG6R2_DTRBS); }
inline uint32_t dfsdm_chcfg6r2_get_offset(struct DFSDM_Type* p) { return (p->CHCFG6R2 & DFSDM_CHCFG6R2_OFFSET) >> 8 ; }
inline uint32_t dfsdm_chcfg6r2_get_dtrbs(struct DFSDM_Type* p) { return (p->CHCFG6R2 & DFSDM_CHCFG6R2_DTRBS) >> 3 ; }

// DFSDM->AWSCD6R AWSCD6R
enum {
	DFSDM_AWSCD6R_AWFORD = ((1UL<<2)-1) << 22, // AWFORD
	DFSDM_AWSCD6R_AWFOSR = ((1UL<<5)-1) << 16, // AWFOSR
	DFSDM_AWSCD6R_BKSCD = ((1UL<<4)-1) << 12, // BKSCD
	DFSDM_AWSCD6R_SCDT = ((1UL<<8)-1) << 0, // SCDT		
};
inline void dfsdm_awscd6r_set_awford(struct DFSDM_Type* p, uint32_t val) { p->AWSCD6R = (p->AWSCD6R & ~DFSDM_AWSCD6R_AWFORD) | ((val<<22) & DFSDM_AWSCD6R_AWFORD); }
inline void dfsdm_awscd6r_set_awfosr(struct DFSDM_Type* p, uint32_t val) { p->AWSCD6R = (p->AWSCD6R & ~DFSDM_AWSCD6R_AWFOSR) | ((val<<16) & DFSDM_AWSCD6R_AWFOSR); }
inline void dfsdm_awscd6r_set_bkscd(struct DFSDM_Type* p, uint32_t val) { p->AWSCD6R = (p->AWSCD6R & ~DFSDM_AWSCD6R_BKSCD) | ((val<<12) & DFSDM_AWSCD6R_BKSCD); }
inline void dfsdm_awscd6r_set_scdt(struct DFSDM_Type* p, uint32_t val) { p->AWSCD6R = (p->AWSCD6R & ~DFSDM_AWSCD6R_SCDT) | ((val<<0) & DFSDM_AWSCD6R_SCDT); }
inline uint32_t dfsdm_awscd6r_get_awford(struct DFSDM_Type* p) { return (p->AWSCD6R & DFSDM_AWSCD6R_AWFORD) >> 22 ; }
inline uint32_t dfsdm_awscd6r_get_awfosr(struct DFSDM_Type* p) { return (p->AWSCD6R & DFSDM_AWSCD6R_AWFOSR) >> 16 ; }
inline uint32_t dfsdm_awscd6r_get_bkscd(struct DFSDM_Type* p) { return (p->AWSCD6R & DFSDM_AWSCD6R_BKSCD) >> 12 ; }
inline uint32_t dfsdm_awscd6r_get_scdt(struct DFSDM_Type* p) { return (p->AWSCD6R & DFSDM_AWSCD6R_SCDT) >> 0 ; }

// DFSDM->CHDATIN6R CHDATIN6R
enum {
	DFSDM_CHDATIN6R_INDAT1 = ((1UL<<16)-1) << 16, // INDAT1
	DFSDM_CHDATIN6R_INDAT0 = ((1UL<<16)-1) << 0, // INDAT0		
};
inline void dfsdm_chdatin6r_set_indat1(struct DFSDM_Type* p, uint32_t val) { p->CHDATIN6R = (p->CHDATIN6R & ~DFSDM_CHDATIN6R_INDAT1) | ((val<<16) & DFSDM_CHDATIN6R_INDAT1); }
inline void dfsdm_chdatin6r_set_indat0(struct DFSDM_Type* p, uint32_t val) { p->CHDATIN6R = (p->CHDATIN6R & ~DFSDM_CHDATIN6R_INDAT0) | ((val<<0) & DFSDM_CHDATIN6R_INDAT0); }
inline uint32_t dfsdm_chdatin6r_get_indat1(struct DFSDM_Type* p) { return (p->CHDATIN6R & DFSDM_CHDATIN6R_INDAT1) >> 16 ; }
inline uint32_t dfsdm_chdatin6r_get_indat0(struct DFSDM_Type* p) { return (p->CHDATIN6R & DFSDM_CHDATIN6R_INDAT0) >> 0 ; }

// DFSDM->CHCFG7R1 CHCFG7R1
enum {
	DFSDM_CHCFG7R1_DATPACK = ((1UL<<2)-1) << 14, // DATPACK
	DFSDM_CHCFG7R1_DATMPX = ((1UL<<2)-1) << 12, // DATMPX
	DFSDM_CHCFG7R1_CHINSEL = 1UL<<8, // CHINSEL
	DFSDM_CHCFG7R1_CHEN = 1UL<<7, // CHEN
	DFSDM_CHCFG7R1_CKABEN = 1UL<<6, // CKABEN
	DFSDM_CHCFG7R1_SCDEN = 1UL<<5, // SCDEN
	DFSDM_CHCFG7R1_SPICKSEL = ((1UL<<2)-1) << 2, // SPICKSEL
	DFSDM_CHCFG7R1_SITP = ((1UL<<2)-1) << 0, // SITP		
};
inline void dfsdm_chcfg7r1_set_datpack(struct DFSDM_Type* p, uint32_t val) { p->CHCFG7R1 = (p->CHCFG7R1 & ~DFSDM_CHCFG7R1_DATPACK) | ((val<<14) & DFSDM_CHCFG7R1_DATPACK); }
inline void dfsdm_chcfg7r1_set_datmpx(struct DFSDM_Type* p, uint32_t val) { p->CHCFG7R1 = (p->CHCFG7R1 & ~DFSDM_CHCFG7R1_DATMPX) | ((val<<12) & DFSDM_CHCFG7R1_DATMPX); }
inline void dfsdm_chcfg7r1_set_spicksel(struct DFSDM_Type* p, uint32_t val) { p->CHCFG7R1 = (p->CHCFG7R1 & ~DFSDM_CHCFG7R1_SPICKSEL) | ((val<<2) & DFSDM_CHCFG7R1_SPICKSEL); }
inline void dfsdm_chcfg7r1_set_sitp(struct DFSDM_Type* p, uint32_t val) { p->CHCFG7R1 = (p->CHCFG7R1 & ~DFSDM_CHCFG7R1_SITP) | ((val<<0) & DFSDM_CHCFG7R1_SITP); }
inline uint32_t dfsdm_chcfg7r1_get_datpack(struct DFSDM_Type* p) { return (p->CHCFG7R1 & DFSDM_CHCFG7R1_DATPACK) >> 14 ; }
inline uint32_t dfsdm_chcfg7r1_get_datmpx(struct DFSDM_Type* p) { return (p->CHCFG7R1 & DFSDM_CHCFG7R1_DATMPX) >> 12 ; }
inline uint32_t dfsdm_chcfg7r1_get_spicksel(struct DFSDM_Type* p) { return (p->CHCFG7R1 & DFSDM_CHCFG7R1_SPICKSEL) >> 2 ; }
inline uint32_t dfsdm_chcfg7r1_get_sitp(struct DFSDM_Type* p) { return (p->CHCFG7R1 & DFSDM_CHCFG7R1_SITP) >> 0 ; }

// DFSDM->CHCFG7R2 CHCFG7R2
enum {
	DFSDM_CHCFG7R2_OFFSET = ((1UL<<24)-1) << 8, // OFFSET
	DFSDM_CHCFG7R2_DTRBS = ((1UL<<5)-1) << 3, // DTRBS		
};
inline void dfsdm_chcfg7r2_set_offset(struct DFSDM_Type* p, uint32_t val) { p->CHCFG7R2 = (p->CHCFG7R2 & ~DFSDM_CHCFG7R2_OFFSET) | ((val<<8) & DFSDM_CHCFG7R2_OFFSET); }
inline void dfsdm_chcfg7r2_set_dtrbs(struct DFSDM_Type* p, uint32_t val) { p->CHCFG7R2 = (p->CHCFG7R2 & ~DFSDM_CHCFG7R2_DTRBS) | ((val<<3) & DFSDM_CHCFG7R2_DTRBS); }
inline uint32_t dfsdm_chcfg7r2_get_offset(struct DFSDM_Type* p) { return (p->CHCFG7R2 & DFSDM_CHCFG7R2_OFFSET) >> 8 ; }
inline uint32_t dfsdm_chcfg7r2_get_dtrbs(struct DFSDM_Type* p) { return (p->CHCFG7R2 & DFSDM_CHCFG7R2_DTRBS) >> 3 ; }

// DFSDM->AWSCD7R AWSCD7R
enum {
	DFSDM_AWSCD7R_AWFORD = ((1UL<<2)-1) << 22, // AWFORD
	DFSDM_AWSCD7R_AWFOSR = ((1UL<<5)-1) << 16, // AWFOSR
	DFSDM_AWSCD7R_BKSCD = ((1UL<<4)-1) << 12, // BKSCD
	DFSDM_AWSCD7R_SCDT = ((1UL<<8)-1) << 0, // SCDT		
};
inline void dfsdm_awscd7r_set_awford(struct DFSDM_Type* p, uint32_t val) { p->AWSCD7R = (p->AWSCD7R & ~DFSDM_AWSCD7R_AWFORD) | ((val<<22) & DFSDM_AWSCD7R_AWFORD); }
inline void dfsdm_awscd7r_set_awfosr(struct DFSDM_Type* p, uint32_t val) { p->AWSCD7R = (p->AWSCD7R & ~DFSDM_AWSCD7R_AWFOSR) | ((val<<16) & DFSDM_AWSCD7R_AWFOSR); }
inline void dfsdm_awscd7r_set_bkscd(struct DFSDM_Type* p, uint32_t val) { p->AWSCD7R = (p->AWSCD7R & ~DFSDM_AWSCD7R_BKSCD) | ((val<<12) & DFSDM_AWSCD7R_BKSCD); }
inline void dfsdm_awscd7r_set_scdt(struct DFSDM_Type* p, uint32_t val) { p->AWSCD7R = (p->AWSCD7R & ~DFSDM_AWSCD7R_SCDT) | ((val<<0) & DFSDM_AWSCD7R_SCDT); }
inline uint32_t dfsdm_awscd7r_get_awford(struct DFSDM_Type* p) { return (p->AWSCD7R & DFSDM_AWSCD7R_AWFORD) >> 22 ; }
inline uint32_t dfsdm_awscd7r_get_awfosr(struct DFSDM_Type* p) { return (p->AWSCD7R & DFSDM_AWSCD7R_AWFOSR) >> 16 ; }
inline uint32_t dfsdm_awscd7r_get_bkscd(struct DFSDM_Type* p) { return (p->AWSCD7R & DFSDM_AWSCD7R_BKSCD) >> 12 ; }
inline uint32_t dfsdm_awscd7r_get_scdt(struct DFSDM_Type* p) { return (p->AWSCD7R & DFSDM_AWSCD7R_SCDT) >> 0 ; }

// DFSDM->CHDATIN7R CHDATIN7R
enum {
	DFSDM_CHDATIN7R_INDAT1 = ((1UL<<16)-1) << 16, // INDAT1
	DFSDM_CHDATIN7R_INDAT0 = ((1UL<<16)-1) << 0, // INDAT0		
};
inline void dfsdm_chdatin7r_set_indat1(struct DFSDM_Type* p, uint32_t val) { p->CHDATIN7R = (p->CHDATIN7R & ~DFSDM_CHDATIN7R_INDAT1) | ((val<<16) & DFSDM_CHDATIN7R_INDAT1); }
inline void dfsdm_chdatin7r_set_indat0(struct DFSDM_Type* p, uint32_t val) { p->CHDATIN7R = (p->CHDATIN7R & ~DFSDM_CHDATIN7R_INDAT0) | ((val<<0) & DFSDM_CHDATIN7R_INDAT0); }
inline uint32_t dfsdm_chdatin7r_get_indat1(struct DFSDM_Type* p) { return (p->CHDATIN7R & DFSDM_CHDATIN7R_INDAT1) >> 16 ; }
inline uint32_t dfsdm_chdatin7r_get_indat0(struct DFSDM_Type* p) { return (p->CHDATIN7R & DFSDM_CHDATIN7R_INDAT0) >> 0 ; }

// DFSDM->DFSDM0_CR1 control register 1
enum {
	DFSDM_DFSDM0_CR1_AWFSEL = 1UL<<30, // Analog watchdog fast mode select
	DFSDM_DFSDM0_CR1_FAST = 1UL<<29, // Fast conversion mode selection for regular conversions
	DFSDM_DFSDM0_CR1_RCH = ((1UL<<3)-1) << 24, // Regular channel selection
	DFSDM_DFSDM0_CR1_RDMAEN = 1UL<<21, // DMA channel enabled to read data for the regular conversion
	DFSDM_DFSDM0_CR1_RSYNC = 1UL<<19, // Launch regular conversion synchronously with DFSDM0
	DFSDM_DFSDM0_CR1_RCONT = 1UL<<18, // Continuous mode selection for regular conversions
	DFSDM_DFSDM0_CR1_RSWSTART = 1UL<<17, // Software start of a conversion on the regular channel
	DFSDM_DFSDM0_CR1_JEXTEN = ((1UL<<2)-1) << 13, // Trigger enable and trigger edge selection for injected conversions
	DFSDM_DFSDM0_CR1_JEXTSEL = ((1UL<<3)-1) << 8, // Trigger signal selection for launching injected conversions
	DFSDM_DFSDM0_CR1_JDMAEN = 1UL<<5, // DMA channel enabled to read data for the injected channel group
	DFSDM_DFSDM0_CR1_JSCAN = 1UL<<4, // Scanning conversion mode for injected conversions
	DFSDM_DFSDM0_CR1_JSYNC = 1UL<<3, // Launch an injected conversion synchronously with the DFSDM0 JSWSTART trigger
	DFSDM_DFSDM0_CR1_JSWSTART = 1UL<<1, // Start a conversion of the injected group of channels
	DFSDM_DFSDM0_CR1_DFEN = 1UL<<0, // DFSDM enable		
};
inline void dfsdm_dfsdm0_cr1_set_rch(struct DFSDM_Type* p, uint32_t val) { p->DFSDM0_CR1 = (p->DFSDM0_CR1 & ~DFSDM_DFSDM0_CR1_RCH) | ((val<<24) & DFSDM_DFSDM0_CR1_RCH); }
inline void dfsdm_dfsdm0_cr1_set_jexten(struct DFSDM_Type* p, uint32_t val) { p->DFSDM0_CR1 = (p->DFSDM0_CR1 & ~DFSDM_DFSDM0_CR1_JEXTEN) | ((val<<13) & DFSDM_DFSDM0_CR1_JEXTEN); }
inline void dfsdm_dfsdm0_cr1_set_jextsel(struct DFSDM_Type* p, uint32_t val) { p->DFSDM0_CR1 = (p->DFSDM0_CR1 & ~DFSDM_DFSDM0_CR1_JEXTSEL) | ((val<<8) & DFSDM_DFSDM0_CR1_JEXTSEL); }
inline uint32_t dfsdm_dfsdm0_cr1_get_rch(struct DFSDM_Type* p) { return (p->DFSDM0_CR1 & DFSDM_DFSDM0_CR1_RCH) >> 24 ; }
inline uint32_t dfsdm_dfsdm0_cr1_get_jexten(struct DFSDM_Type* p) { return (p->DFSDM0_CR1 & DFSDM_DFSDM0_CR1_JEXTEN) >> 13 ; }
inline uint32_t dfsdm_dfsdm0_cr1_get_jextsel(struct DFSDM_Type* p) { return (p->DFSDM0_CR1 & DFSDM_DFSDM0_CR1_JEXTSEL) >> 8 ; }

// DFSDM->DFSDM0_CR2 control register 2
enum {
	DFSDM_DFSDM0_CR2_AWDCH = ((1UL<<8)-1) << 16, // Analog watchdog channel selection
	DFSDM_DFSDM0_CR2_EXCH = ((1UL<<8)-1) << 8, // Extremes detector channel selection
	DFSDM_DFSDM0_CR2_CKABIE = 1UL<<6, // Clock absence interrupt enable
	DFSDM_DFSDM0_CR2_SCDIE = 1UL<<5, // Short-circuit detector interrupt enable
	DFSDM_DFSDM0_CR2_AWDIE = 1UL<<4, // Analog watchdog interrupt enable
	DFSDM_DFSDM0_CR2_ROVRIE = 1UL<<3, // Regular data overrun interrupt enable
	DFSDM_DFSDM0_CR2_JOVRIE = 1UL<<2, // Injected data overrun interrupt enable
	DFSDM_DFSDM0_CR2_REOCIE = 1UL<<1, // Regular end of conversion interrupt enable
	DFSDM_DFSDM0_CR2_JEOCIE = 1UL<<0, // Injected end of conversion interrupt enable		
};
inline void dfsdm_dfsdm0_cr2_set_awdch(struct DFSDM_Type* p, uint32_t val) { p->DFSDM0_CR2 = (p->DFSDM0_CR2 & ~DFSDM_DFSDM0_CR2_AWDCH) | ((val<<16) & DFSDM_DFSDM0_CR2_AWDCH); }
inline void dfsdm_dfsdm0_cr2_set_exch(struct DFSDM_Type* p, uint32_t val) { p->DFSDM0_CR2 = (p->DFSDM0_CR2 & ~DFSDM_DFSDM0_CR2_EXCH) | ((val<<8) & DFSDM_DFSDM0_CR2_EXCH); }
inline uint32_t dfsdm_dfsdm0_cr2_get_awdch(struct DFSDM_Type* p) { return (p->DFSDM0_CR2 & DFSDM_DFSDM0_CR2_AWDCH) >> 16 ; }
inline uint32_t dfsdm_dfsdm0_cr2_get_exch(struct DFSDM_Type* p) { return (p->DFSDM0_CR2 & DFSDM_DFSDM0_CR2_EXCH) >> 8 ; }

// DFSDM->DFSDM0_ISR interrupt and status register
enum {
	DFSDM_DFSDM0_ISR_SCDF = ((1UL<<8)-1) << 24, // short-circuit detector flag
	DFSDM_DFSDM0_ISR_CKABF = ((1UL<<8)-1) << 16, // Clock absence flag
	DFSDM_DFSDM0_ISR_RCIP = 1UL<<14, // Regular conversion in progress status
	DFSDM_DFSDM0_ISR_JCIP = 1UL<<13, // Injected conversion in progress status
	DFSDM_DFSDM0_ISR_AWDF = 1UL<<4, // Analog watchdog
	DFSDM_DFSDM0_ISR_ROVRF = 1UL<<3, // Regular conversion overrun flag
	DFSDM_DFSDM0_ISR_JOVRF = 1UL<<2, // Injected conversion overrun flag
	DFSDM_DFSDM0_ISR_REOCF = 1UL<<1, // End of regular conversion flag
	DFSDM_DFSDM0_ISR_JEOCF = 1UL<<0, // End of injected conversion flag		
};
inline uint32_t dfsdm_dfsdm0_isr_get_scdf(struct DFSDM_Type* p) { return (p->DFSDM0_ISR & DFSDM_DFSDM0_ISR_SCDF) >> 24 ; }
inline uint32_t dfsdm_dfsdm0_isr_get_ckabf(struct DFSDM_Type* p) { return (p->DFSDM0_ISR & DFSDM_DFSDM0_ISR_CKABF) >> 16 ; }

// DFSDM->DFSDM0_ICR interrupt flag clear register
enum {
	DFSDM_DFSDM0_ICR_CLRSCDF = ((1UL<<8)-1) << 24, // Clear the short-circuit detector flag
	DFSDM_DFSDM0_ICR_CLRCKABF = ((1UL<<8)-1) << 16, // Clear the clock absence flag
	DFSDM_DFSDM0_ICR_CLRROVRF = 1UL<<3, // Clear the regular conversion overrun flag
	DFSDM_DFSDM0_ICR_CLRJOVRF = 1UL<<2, // Clear the injected conversion overrun flag		
};
inline void dfsdm_dfsdm0_icr_set_clrscdf(struct DFSDM_Type* p, uint32_t val) { p->DFSDM0_ICR = (p->DFSDM0_ICR & ~DFSDM_DFSDM0_ICR_CLRSCDF) | ((val<<24) & DFSDM_DFSDM0_ICR_CLRSCDF); }
inline void dfsdm_dfsdm0_icr_set_clrckabf(struct DFSDM_Type* p, uint32_t val) { p->DFSDM0_ICR = (p->DFSDM0_ICR & ~DFSDM_DFSDM0_ICR_CLRCKABF) | ((val<<16) & DFSDM_DFSDM0_ICR_CLRCKABF); }
inline uint32_t dfsdm_dfsdm0_icr_get_clrscdf(struct DFSDM_Type* p) { return (p->DFSDM0_ICR & DFSDM_DFSDM0_ICR_CLRSCDF) >> 24 ; }
inline uint32_t dfsdm_dfsdm0_icr_get_clrckabf(struct DFSDM_Type* p) { return (p->DFSDM0_ICR & DFSDM_DFSDM0_ICR_CLRCKABF) >> 16 ; }

// DFSDM->DFSDM0_FCR filter control register
enum {
	DFSDM_DFSDM0_FCR_FORD = ((1UL<<3)-1) << 29, // Sinc filter order
	DFSDM_DFSDM0_FCR_FOSR = ((1UL<<10)-1) << 16, // Sinc filter oversampling ratio (decimation rate)
	DFSDM_DFSDM0_FCR_IOSR = ((1UL<<8)-1) << 0, // Integrator oversampling ratio (averaging length)		
};
inline void dfsdm_dfsdm0_fcr_set_ford(struct DFSDM_Type* p, uint32_t val) { p->DFSDM0_FCR = (p->DFSDM0_FCR & ~DFSDM_DFSDM0_FCR_FORD) | ((val<<29) & DFSDM_DFSDM0_FCR_FORD); }
inline void dfsdm_dfsdm0_fcr_set_fosr(struct DFSDM_Type* p, uint32_t val) { p->DFSDM0_FCR = (p->DFSDM0_FCR & ~DFSDM_DFSDM0_FCR_FOSR) | ((val<<16) & DFSDM_DFSDM0_FCR_FOSR); }
inline void dfsdm_dfsdm0_fcr_set_iosr(struct DFSDM_Type* p, uint32_t val) { p->DFSDM0_FCR = (p->DFSDM0_FCR & ~DFSDM_DFSDM0_FCR_IOSR) | ((val<<0) & DFSDM_DFSDM0_FCR_IOSR); }
inline uint32_t dfsdm_dfsdm0_fcr_get_ford(struct DFSDM_Type* p) { return (p->DFSDM0_FCR & DFSDM_DFSDM0_FCR_FORD) >> 29 ; }
inline uint32_t dfsdm_dfsdm0_fcr_get_fosr(struct DFSDM_Type* p) { return (p->DFSDM0_FCR & DFSDM_DFSDM0_FCR_FOSR) >> 16 ; }
inline uint32_t dfsdm_dfsdm0_fcr_get_iosr(struct DFSDM_Type* p) { return (p->DFSDM0_FCR & DFSDM_DFSDM0_FCR_IOSR) >> 0 ; }

// DFSDM->DFSDM0_JDATAR data register for injected group
enum {
	DFSDM_DFSDM0_JDATAR_JDATA = ((1UL<<24)-1) << 8, // Injected group conversion data
	DFSDM_DFSDM0_JDATAR_JDATACH = ((1UL<<3)-1) << 0, // Injected channel most recently converted		
};
inline uint32_t dfsdm_dfsdm0_jdatar_get_jdata(struct DFSDM_Type* p) { return (p->DFSDM0_JDATAR & DFSDM_DFSDM0_JDATAR_JDATA) >> 8 ; }
inline uint32_t dfsdm_dfsdm0_jdatar_get_jdatach(struct DFSDM_Type* p) { return (p->DFSDM0_JDATAR & DFSDM_DFSDM0_JDATAR_JDATACH) >> 0 ; }

// DFSDM->DFSDM0_RDATAR data register for the regular channel
enum {
	DFSDM_DFSDM0_RDATAR_RDATA = ((1UL<<24)-1) << 8, // Regular channel conversion data
	DFSDM_DFSDM0_RDATAR_RPEND = 1UL<<4, // Regular channel pending data
	DFSDM_DFSDM0_RDATAR_RDATACH = ((1UL<<3)-1) << 0, // Regular channel most recently converted		
};
inline uint32_t dfsdm_dfsdm0_rdatar_get_rdata(struct DFSDM_Type* p) { return (p->DFSDM0_RDATAR & DFSDM_DFSDM0_RDATAR_RDATA) >> 8 ; }
inline uint32_t dfsdm_dfsdm0_rdatar_get_rdatach(struct DFSDM_Type* p) { return (p->DFSDM0_RDATAR & DFSDM_DFSDM0_RDATAR_RDATACH) >> 0 ; }

// DFSDM->DFSDM0_AWHTR analog watchdog high threshold register
enum {
	DFSDM_DFSDM0_AWHTR_AWHT = ((1UL<<24)-1) << 8, // Analog watchdog high threshold
	DFSDM_DFSDM0_AWHTR_BKAWH = ((1UL<<4)-1) << 0, // Break signal assignment to analog watchdog high threshold event		
};
inline void dfsdm_dfsdm0_awhtr_set_awht(struct DFSDM_Type* p, uint32_t val) { p->DFSDM0_AWHTR = (p->DFSDM0_AWHTR & ~DFSDM_DFSDM0_AWHTR_AWHT) | ((val<<8) & DFSDM_DFSDM0_AWHTR_AWHT); }
inline void dfsdm_dfsdm0_awhtr_set_bkawh(struct DFSDM_Type* p, uint32_t val) { p->DFSDM0_AWHTR = (p->DFSDM0_AWHTR & ~DFSDM_DFSDM0_AWHTR_BKAWH) | ((val<<0) & DFSDM_DFSDM0_AWHTR_BKAWH); }
inline uint32_t dfsdm_dfsdm0_awhtr_get_awht(struct DFSDM_Type* p) { return (p->DFSDM0_AWHTR & DFSDM_DFSDM0_AWHTR_AWHT) >> 8 ; }
inline uint32_t dfsdm_dfsdm0_awhtr_get_bkawh(struct DFSDM_Type* p) { return (p->DFSDM0_AWHTR & DFSDM_DFSDM0_AWHTR_BKAWH) >> 0 ; }

// DFSDM->DFSDM0_AWLTR analog watchdog low threshold register
enum {
	DFSDM_DFSDM0_AWLTR_AWLT = ((1UL<<24)-1) << 8, // Analog watchdog low threshold
	DFSDM_DFSDM0_AWLTR_BKAWL = ((1UL<<4)-1) << 0, // Break signal assignment to analog watchdog low threshold event		
};
inline void dfsdm_dfsdm0_awltr_set_awlt(struct DFSDM_Type* p, uint32_t val) { p->DFSDM0_AWLTR = (p->DFSDM0_AWLTR & ~DFSDM_DFSDM0_AWLTR_AWLT) | ((val<<8) & DFSDM_DFSDM0_AWLTR_AWLT); }
inline void dfsdm_dfsdm0_awltr_set_bkawl(struct DFSDM_Type* p, uint32_t val) { p->DFSDM0_AWLTR = (p->DFSDM0_AWLTR & ~DFSDM_DFSDM0_AWLTR_BKAWL) | ((val<<0) & DFSDM_DFSDM0_AWLTR_BKAWL); }
inline uint32_t dfsdm_dfsdm0_awltr_get_awlt(struct DFSDM_Type* p) { return (p->DFSDM0_AWLTR & DFSDM_DFSDM0_AWLTR_AWLT) >> 8 ; }
inline uint32_t dfsdm_dfsdm0_awltr_get_bkawl(struct DFSDM_Type* p) { return (p->DFSDM0_AWLTR & DFSDM_DFSDM0_AWLTR_BKAWL) >> 0 ; }

// DFSDM->DFSDM0_AWSR analog watchdog status register
enum {
	DFSDM_DFSDM0_AWSR_AWHTF = ((1UL<<8)-1) << 8, // Analog watchdog high threshold flag
	DFSDM_DFSDM0_AWSR_AWLTF = ((1UL<<8)-1) << 0, // Analog watchdog low threshold flag		
};
inline uint32_t dfsdm_dfsdm0_awsr_get_awhtf(struct DFSDM_Type* p) { return (p->DFSDM0_AWSR & DFSDM_DFSDM0_AWSR_AWHTF) >> 8 ; }
inline uint32_t dfsdm_dfsdm0_awsr_get_awltf(struct DFSDM_Type* p) { return (p->DFSDM0_AWSR & DFSDM_DFSDM0_AWSR_AWLTF) >> 0 ; }

// DFSDM->DFSDM0_AWCFR analog watchdog clear flag register
enum {
	DFSDM_DFSDM0_AWCFR_CLRAWHTF = ((1UL<<8)-1) << 8, // Clear the analog watchdog high threshold flag
	DFSDM_DFSDM0_AWCFR_CLRAWLTF = ((1UL<<8)-1) << 0, // Clear the analog watchdog low threshold flag		
};
inline void dfsdm_dfsdm0_awcfr_set_clrawhtf(struct DFSDM_Type* p, uint32_t val) { p->DFSDM0_AWCFR = (p->DFSDM0_AWCFR & ~DFSDM_DFSDM0_AWCFR_CLRAWHTF) | ((val<<8) & DFSDM_DFSDM0_AWCFR_CLRAWHTF); }
inline void dfsdm_dfsdm0_awcfr_set_clrawltf(struct DFSDM_Type* p, uint32_t val) { p->DFSDM0_AWCFR = (p->DFSDM0_AWCFR & ~DFSDM_DFSDM0_AWCFR_CLRAWLTF) | ((val<<0) & DFSDM_DFSDM0_AWCFR_CLRAWLTF); }
inline uint32_t dfsdm_dfsdm0_awcfr_get_clrawhtf(struct DFSDM_Type* p) { return (p->DFSDM0_AWCFR & DFSDM_DFSDM0_AWCFR_CLRAWHTF) >> 8 ; }
inline uint32_t dfsdm_dfsdm0_awcfr_get_clrawltf(struct DFSDM_Type* p) { return (p->DFSDM0_AWCFR & DFSDM_DFSDM0_AWCFR_CLRAWLTF) >> 0 ; }

// DFSDM->DFSDM0_EXMAX Extremes detector maximum register
enum {
	DFSDM_DFSDM0_EXMAX_EXMAX = ((1UL<<24)-1) << 8, // Extremes detector maximum value
	DFSDM_DFSDM0_EXMAX_EXMAXCH = ((1UL<<3)-1) << 0, // Extremes detector maximum data channel		
};
inline uint32_t dfsdm_dfsdm0_exmax_get_exmax(struct DFSDM_Type* p) { return (p->DFSDM0_EXMAX & DFSDM_DFSDM0_EXMAX_EXMAX) >> 8 ; }
inline uint32_t dfsdm_dfsdm0_exmax_get_exmaxch(struct DFSDM_Type* p) { return (p->DFSDM0_EXMAX & DFSDM_DFSDM0_EXMAX_EXMAXCH) >> 0 ; }

// DFSDM->DFSDM0_EXMIN Extremes detector minimum register
enum {
	DFSDM_DFSDM0_EXMIN_EXMIN = ((1UL<<24)-1) << 8, // EXMIN
	DFSDM_DFSDM0_EXMIN_EXMINCH = ((1UL<<3)-1) << 0, // Extremes detector minimum data channel		
};
inline uint32_t dfsdm_dfsdm0_exmin_get_exmin(struct DFSDM_Type* p) { return (p->DFSDM0_EXMIN & DFSDM_DFSDM0_EXMIN_EXMIN) >> 8 ; }
inline uint32_t dfsdm_dfsdm0_exmin_get_exminch(struct DFSDM_Type* p) { return (p->DFSDM0_EXMIN & DFSDM_DFSDM0_EXMIN_EXMINCH) >> 0 ; }

// DFSDM->DFSDM0_CNVTIMR conversion timer register
enum {
	DFSDM_DFSDM0_CNVTIMR_CNVCNT = ((1UL<<28)-1) << 4, // 28-bit timer counting conversion time t = CNVCNT[27:0] / fDFSDM_CKIN		
};
inline uint32_t dfsdm_dfsdm0_cnvtimr_get_cnvcnt(struct DFSDM_Type* p) { return (p->DFSDM0_CNVTIMR & DFSDM_DFSDM0_CNVTIMR_CNVCNT) >> 4 ; }

// DFSDM->DFSDM1_CR1 control register 1
enum {
	DFSDM_DFSDM1_CR1_AWFSEL = 1UL<<30, // Analog watchdog fast mode select
	DFSDM_DFSDM1_CR1_FAST = 1UL<<29, // Fast conversion mode selection for regular conversions
	DFSDM_DFSDM1_CR1_RCH = ((1UL<<3)-1) << 24, // Regular channel selection
	DFSDM_DFSDM1_CR1_RDMAEN = 1UL<<21, // DMA channel enabled to read data for the regular conversion
	DFSDM_DFSDM1_CR1_RSYNC = 1UL<<19, // Launch regular conversion synchronously with DFSDM0
	DFSDM_DFSDM1_CR1_RCONT = 1UL<<18, // Continuous mode selection for regular conversions
	DFSDM_DFSDM1_CR1_RSWSTART = 1UL<<17, // Software start of a conversion on the regular channel
	DFSDM_DFSDM1_CR1_JEXTEN = ((1UL<<2)-1) << 13, // Trigger enable and trigger edge selection for injected conversions
	DFSDM_DFSDM1_CR1_JEXTSEL = ((1UL<<3)-1) << 8, // Trigger signal selection for launching injected conversions
	DFSDM_DFSDM1_CR1_JDMAEN = 1UL<<5, // DMA channel enabled to read data for the injected channel group
	DFSDM_DFSDM1_CR1_JSCAN = 1UL<<4, // Scanning conversion mode for injected conversions
	DFSDM_DFSDM1_CR1_JSYNC = 1UL<<3, // Launch an injected conversion synchronously with the DFSDM0 JSWSTART trigger
	DFSDM_DFSDM1_CR1_JSWSTART = 1UL<<1, // Start a conversion of the injected group of channels
	DFSDM_DFSDM1_CR1_DFEN = 1UL<<0, // DFSDM enable		
};
inline void dfsdm_dfsdm1_cr1_set_rch(struct DFSDM_Type* p, uint32_t val) { p->DFSDM1_CR1 = (p->DFSDM1_CR1 & ~DFSDM_DFSDM1_CR1_RCH) | ((val<<24) & DFSDM_DFSDM1_CR1_RCH); }
inline void dfsdm_dfsdm1_cr1_set_jexten(struct DFSDM_Type* p, uint32_t val) { p->DFSDM1_CR1 = (p->DFSDM1_CR1 & ~DFSDM_DFSDM1_CR1_JEXTEN) | ((val<<13) & DFSDM_DFSDM1_CR1_JEXTEN); }
inline void dfsdm_dfsdm1_cr1_set_jextsel(struct DFSDM_Type* p, uint32_t val) { p->DFSDM1_CR1 = (p->DFSDM1_CR1 & ~DFSDM_DFSDM1_CR1_JEXTSEL) | ((val<<8) & DFSDM_DFSDM1_CR1_JEXTSEL); }
inline uint32_t dfsdm_dfsdm1_cr1_get_rch(struct DFSDM_Type* p) { return (p->DFSDM1_CR1 & DFSDM_DFSDM1_CR1_RCH) >> 24 ; }
inline uint32_t dfsdm_dfsdm1_cr1_get_jexten(struct DFSDM_Type* p) { return (p->DFSDM1_CR1 & DFSDM_DFSDM1_CR1_JEXTEN) >> 13 ; }
inline uint32_t dfsdm_dfsdm1_cr1_get_jextsel(struct DFSDM_Type* p) { return (p->DFSDM1_CR1 & DFSDM_DFSDM1_CR1_JEXTSEL) >> 8 ; }

// DFSDM->DFSDM1_CR2 control register 2
enum {
	DFSDM_DFSDM1_CR2_AWDCH = ((1UL<<8)-1) << 16, // Analog watchdog channel selection
	DFSDM_DFSDM1_CR2_EXCH = ((1UL<<8)-1) << 8, // Extremes detector channel selection
	DFSDM_DFSDM1_CR2_CKABIE = 1UL<<6, // Clock absence interrupt enable
	DFSDM_DFSDM1_CR2_SCDIE = 1UL<<5, // Short-circuit detector interrupt enable
	DFSDM_DFSDM1_CR2_AWDIE = 1UL<<4, // Analog watchdog interrupt enable
	DFSDM_DFSDM1_CR2_ROVRIE = 1UL<<3, // Regular data overrun interrupt enable
	DFSDM_DFSDM1_CR2_JOVRIE = 1UL<<2, // Injected data overrun interrupt enable
	DFSDM_DFSDM1_CR2_REOCIE = 1UL<<1, // Regular end of conversion interrupt enable
	DFSDM_DFSDM1_CR2_JEOCIE = 1UL<<0, // Injected end of conversion interrupt enable		
};
inline void dfsdm_dfsdm1_cr2_set_awdch(struct DFSDM_Type* p, uint32_t val) { p->DFSDM1_CR2 = (p->DFSDM1_CR2 & ~DFSDM_DFSDM1_CR2_AWDCH) | ((val<<16) & DFSDM_DFSDM1_CR2_AWDCH); }
inline void dfsdm_dfsdm1_cr2_set_exch(struct DFSDM_Type* p, uint32_t val) { p->DFSDM1_CR2 = (p->DFSDM1_CR2 & ~DFSDM_DFSDM1_CR2_EXCH) | ((val<<8) & DFSDM_DFSDM1_CR2_EXCH); }
inline uint32_t dfsdm_dfsdm1_cr2_get_awdch(struct DFSDM_Type* p) { return (p->DFSDM1_CR2 & DFSDM_DFSDM1_CR2_AWDCH) >> 16 ; }
inline uint32_t dfsdm_dfsdm1_cr2_get_exch(struct DFSDM_Type* p) { return (p->DFSDM1_CR2 & DFSDM_DFSDM1_CR2_EXCH) >> 8 ; }

// DFSDM->DFSDM1_ISR interrupt and status register
enum {
	DFSDM_DFSDM1_ISR_SCDF = ((1UL<<8)-1) << 24, // short-circuit detector flag
	DFSDM_DFSDM1_ISR_CKABF = ((1UL<<8)-1) << 16, // Clock absence flag
	DFSDM_DFSDM1_ISR_RCIP = 1UL<<14, // Regular conversion in progress status
	DFSDM_DFSDM1_ISR_JCIP = 1UL<<13, // Injected conversion in progress status
	DFSDM_DFSDM1_ISR_AWDF = 1UL<<4, // Analog watchdog
	DFSDM_DFSDM1_ISR_ROVRF = 1UL<<3, // Regular conversion overrun flag
	DFSDM_DFSDM1_ISR_JOVRF = 1UL<<2, // Injected conversion overrun flag
	DFSDM_DFSDM1_ISR_REOCF = 1UL<<1, // End of regular conversion flag
	DFSDM_DFSDM1_ISR_JEOCF = 1UL<<0, // End of injected conversion flag		
};
inline uint32_t dfsdm_dfsdm1_isr_get_scdf(struct DFSDM_Type* p) { return (p->DFSDM1_ISR & DFSDM_DFSDM1_ISR_SCDF) >> 24 ; }
inline uint32_t dfsdm_dfsdm1_isr_get_ckabf(struct DFSDM_Type* p) { return (p->DFSDM1_ISR & DFSDM_DFSDM1_ISR_CKABF) >> 16 ; }

// DFSDM->DFSDM1_ICR interrupt flag clear register
enum {
	DFSDM_DFSDM1_ICR_CLRSCDF = ((1UL<<8)-1) << 24, // Clear the short-circuit detector flag
	DFSDM_DFSDM1_ICR_CLRCKABF = ((1UL<<8)-1) << 16, // Clear the clock absence flag
	DFSDM_DFSDM1_ICR_CLRROVRF = 1UL<<3, // Clear the regular conversion overrun flag
	DFSDM_DFSDM1_ICR_CLRJOVRF = 1UL<<2, // Clear the injected conversion overrun flag		
};
inline void dfsdm_dfsdm1_icr_set_clrscdf(struct DFSDM_Type* p, uint32_t val) { p->DFSDM1_ICR = (p->DFSDM1_ICR & ~DFSDM_DFSDM1_ICR_CLRSCDF) | ((val<<24) & DFSDM_DFSDM1_ICR_CLRSCDF); }
inline void dfsdm_dfsdm1_icr_set_clrckabf(struct DFSDM_Type* p, uint32_t val) { p->DFSDM1_ICR = (p->DFSDM1_ICR & ~DFSDM_DFSDM1_ICR_CLRCKABF) | ((val<<16) & DFSDM_DFSDM1_ICR_CLRCKABF); }
inline uint32_t dfsdm_dfsdm1_icr_get_clrscdf(struct DFSDM_Type* p) { return (p->DFSDM1_ICR & DFSDM_DFSDM1_ICR_CLRSCDF) >> 24 ; }
inline uint32_t dfsdm_dfsdm1_icr_get_clrckabf(struct DFSDM_Type* p) { return (p->DFSDM1_ICR & DFSDM_DFSDM1_ICR_CLRCKABF) >> 16 ; }

// DFSDM->DFSDM1_FCR filter control register
enum {
	DFSDM_DFSDM1_FCR_FORD = ((1UL<<3)-1) << 29, // Sinc filter order
	DFSDM_DFSDM1_FCR_FOSR = ((1UL<<10)-1) << 16, // Sinc filter oversampling ratio (decimation rate)
	DFSDM_DFSDM1_FCR_IOSR = ((1UL<<8)-1) << 0, // Integrator oversampling ratio (averaging length)		
};
inline void dfsdm_dfsdm1_fcr_set_ford(struct DFSDM_Type* p, uint32_t val) { p->DFSDM1_FCR = (p->DFSDM1_FCR & ~DFSDM_DFSDM1_FCR_FORD) | ((val<<29) & DFSDM_DFSDM1_FCR_FORD); }
inline void dfsdm_dfsdm1_fcr_set_fosr(struct DFSDM_Type* p, uint32_t val) { p->DFSDM1_FCR = (p->DFSDM1_FCR & ~DFSDM_DFSDM1_FCR_FOSR) | ((val<<16) & DFSDM_DFSDM1_FCR_FOSR); }
inline void dfsdm_dfsdm1_fcr_set_iosr(struct DFSDM_Type* p, uint32_t val) { p->DFSDM1_FCR = (p->DFSDM1_FCR & ~DFSDM_DFSDM1_FCR_IOSR) | ((val<<0) & DFSDM_DFSDM1_FCR_IOSR); }
inline uint32_t dfsdm_dfsdm1_fcr_get_ford(struct DFSDM_Type* p) { return (p->DFSDM1_FCR & DFSDM_DFSDM1_FCR_FORD) >> 29 ; }
inline uint32_t dfsdm_dfsdm1_fcr_get_fosr(struct DFSDM_Type* p) { return (p->DFSDM1_FCR & DFSDM_DFSDM1_FCR_FOSR) >> 16 ; }
inline uint32_t dfsdm_dfsdm1_fcr_get_iosr(struct DFSDM_Type* p) { return (p->DFSDM1_FCR & DFSDM_DFSDM1_FCR_IOSR) >> 0 ; }

// DFSDM->DFSDM1_JDATAR data register for injected group
enum {
	DFSDM_DFSDM1_JDATAR_JDATA = ((1UL<<24)-1) << 8, // Injected group conversion data
	DFSDM_DFSDM1_JDATAR_JDATACH = ((1UL<<3)-1) << 0, // Injected channel most recently converted		
};
inline uint32_t dfsdm_dfsdm1_jdatar_get_jdata(struct DFSDM_Type* p) { return (p->DFSDM1_JDATAR & DFSDM_DFSDM1_JDATAR_JDATA) >> 8 ; }
inline uint32_t dfsdm_dfsdm1_jdatar_get_jdatach(struct DFSDM_Type* p) { return (p->DFSDM1_JDATAR & DFSDM_DFSDM1_JDATAR_JDATACH) >> 0 ; }

// DFSDM->DFSDM1_RDATAR data register for the regular channel
enum {
	DFSDM_DFSDM1_RDATAR_RDATA = ((1UL<<24)-1) << 8, // Regular channel conversion data
	DFSDM_DFSDM1_RDATAR_RPEND = 1UL<<4, // Regular channel pending data
	DFSDM_DFSDM1_RDATAR_RDATACH = ((1UL<<3)-1) << 0, // Regular channel most recently converted		
};
inline uint32_t dfsdm_dfsdm1_rdatar_get_rdata(struct DFSDM_Type* p) { return (p->DFSDM1_RDATAR & DFSDM_DFSDM1_RDATAR_RDATA) >> 8 ; }
inline uint32_t dfsdm_dfsdm1_rdatar_get_rdatach(struct DFSDM_Type* p) { return (p->DFSDM1_RDATAR & DFSDM_DFSDM1_RDATAR_RDATACH) >> 0 ; }

// DFSDM->DFSDM1_AWHTR analog watchdog high threshold register
enum {
	DFSDM_DFSDM1_AWHTR_AWHT = ((1UL<<24)-1) << 8, // Analog watchdog high threshold
	DFSDM_DFSDM1_AWHTR_BKAWH = ((1UL<<4)-1) << 0, // Break signal assignment to analog watchdog high threshold event		
};
inline void dfsdm_dfsdm1_awhtr_set_awht(struct DFSDM_Type* p, uint32_t val) { p->DFSDM1_AWHTR = (p->DFSDM1_AWHTR & ~DFSDM_DFSDM1_AWHTR_AWHT) | ((val<<8) & DFSDM_DFSDM1_AWHTR_AWHT); }
inline void dfsdm_dfsdm1_awhtr_set_bkawh(struct DFSDM_Type* p, uint32_t val) { p->DFSDM1_AWHTR = (p->DFSDM1_AWHTR & ~DFSDM_DFSDM1_AWHTR_BKAWH) | ((val<<0) & DFSDM_DFSDM1_AWHTR_BKAWH); }
inline uint32_t dfsdm_dfsdm1_awhtr_get_awht(struct DFSDM_Type* p) { return (p->DFSDM1_AWHTR & DFSDM_DFSDM1_AWHTR_AWHT) >> 8 ; }
inline uint32_t dfsdm_dfsdm1_awhtr_get_bkawh(struct DFSDM_Type* p) { return (p->DFSDM1_AWHTR & DFSDM_DFSDM1_AWHTR_BKAWH) >> 0 ; }

// DFSDM->DFSDM1_AWLTR analog watchdog low threshold register
enum {
	DFSDM_DFSDM1_AWLTR_AWLT = ((1UL<<24)-1) << 8, // Analog watchdog low threshold
	DFSDM_DFSDM1_AWLTR_BKAWL = ((1UL<<4)-1) << 0, // Break signal assignment to analog watchdog low threshold event		
};
inline void dfsdm_dfsdm1_awltr_set_awlt(struct DFSDM_Type* p, uint32_t val) { p->DFSDM1_AWLTR = (p->DFSDM1_AWLTR & ~DFSDM_DFSDM1_AWLTR_AWLT) | ((val<<8) & DFSDM_DFSDM1_AWLTR_AWLT); }
inline void dfsdm_dfsdm1_awltr_set_bkawl(struct DFSDM_Type* p, uint32_t val) { p->DFSDM1_AWLTR = (p->DFSDM1_AWLTR & ~DFSDM_DFSDM1_AWLTR_BKAWL) | ((val<<0) & DFSDM_DFSDM1_AWLTR_BKAWL); }
inline uint32_t dfsdm_dfsdm1_awltr_get_awlt(struct DFSDM_Type* p) { return (p->DFSDM1_AWLTR & DFSDM_DFSDM1_AWLTR_AWLT) >> 8 ; }
inline uint32_t dfsdm_dfsdm1_awltr_get_bkawl(struct DFSDM_Type* p) { return (p->DFSDM1_AWLTR & DFSDM_DFSDM1_AWLTR_BKAWL) >> 0 ; }

// DFSDM->DFSDM1_AWSR analog watchdog status register
enum {
	DFSDM_DFSDM1_AWSR_AWHTF = ((1UL<<8)-1) << 8, // Analog watchdog high threshold flag
	DFSDM_DFSDM1_AWSR_AWLTF = ((1UL<<8)-1) << 0, // Analog watchdog low threshold flag		
};
inline uint32_t dfsdm_dfsdm1_awsr_get_awhtf(struct DFSDM_Type* p) { return (p->DFSDM1_AWSR & DFSDM_DFSDM1_AWSR_AWHTF) >> 8 ; }
inline uint32_t dfsdm_dfsdm1_awsr_get_awltf(struct DFSDM_Type* p) { return (p->DFSDM1_AWSR & DFSDM_DFSDM1_AWSR_AWLTF) >> 0 ; }

// DFSDM->DFSDM1_AWCFR analog watchdog clear flag register
enum {
	DFSDM_DFSDM1_AWCFR_CLRAWHTF = ((1UL<<8)-1) << 8, // Clear the analog watchdog high threshold flag
	DFSDM_DFSDM1_AWCFR_CLRAWLTF = ((1UL<<8)-1) << 0, // Clear the analog watchdog low threshold flag		
};
inline void dfsdm_dfsdm1_awcfr_set_clrawhtf(struct DFSDM_Type* p, uint32_t val) { p->DFSDM1_AWCFR = (p->DFSDM1_AWCFR & ~DFSDM_DFSDM1_AWCFR_CLRAWHTF) | ((val<<8) & DFSDM_DFSDM1_AWCFR_CLRAWHTF); }
inline void dfsdm_dfsdm1_awcfr_set_clrawltf(struct DFSDM_Type* p, uint32_t val) { p->DFSDM1_AWCFR = (p->DFSDM1_AWCFR & ~DFSDM_DFSDM1_AWCFR_CLRAWLTF) | ((val<<0) & DFSDM_DFSDM1_AWCFR_CLRAWLTF); }
inline uint32_t dfsdm_dfsdm1_awcfr_get_clrawhtf(struct DFSDM_Type* p) { return (p->DFSDM1_AWCFR & DFSDM_DFSDM1_AWCFR_CLRAWHTF) >> 8 ; }
inline uint32_t dfsdm_dfsdm1_awcfr_get_clrawltf(struct DFSDM_Type* p) { return (p->DFSDM1_AWCFR & DFSDM_DFSDM1_AWCFR_CLRAWLTF) >> 0 ; }

// DFSDM->DFSDM1_EXMAX Extremes detector maximum register
enum {
	DFSDM_DFSDM1_EXMAX_EXMAX = ((1UL<<24)-1) << 8, // Extremes detector maximum value
	DFSDM_DFSDM1_EXMAX_EXMAXCH = ((1UL<<3)-1) << 0, // Extremes detector maximum data channel		
};
inline uint32_t dfsdm_dfsdm1_exmax_get_exmax(struct DFSDM_Type* p) { return (p->DFSDM1_EXMAX & DFSDM_DFSDM1_EXMAX_EXMAX) >> 8 ; }
inline uint32_t dfsdm_dfsdm1_exmax_get_exmaxch(struct DFSDM_Type* p) { return (p->DFSDM1_EXMAX & DFSDM_DFSDM1_EXMAX_EXMAXCH) >> 0 ; }

// DFSDM->DFSDM1_EXMIN Extremes detector minimum register
enum {
	DFSDM_DFSDM1_EXMIN_EXMIN = ((1UL<<24)-1) << 8, // EXMIN
	DFSDM_DFSDM1_EXMIN_EXMINCH = ((1UL<<3)-1) << 0, // Extremes detector minimum data channel		
};
inline uint32_t dfsdm_dfsdm1_exmin_get_exmin(struct DFSDM_Type* p) { return (p->DFSDM1_EXMIN & DFSDM_DFSDM1_EXMIN_EXMIN) >> 8 ; }
inline uint32_t dfsdm_dfsdm1_exmin_get_exminch(struct DFSDM_Type* p) { return (p->DFSDM1_EXMIN & DFSDM_DFSDM1_EXMIN_EXMINCH) >> 0 ; }

// DFSDM->DFSDM1_CNVTIMR conversion timer register
enum {
	DFSDM_DFSDM1_CNVTIMR_CNVCNT = ((1UL<<28)-1) << 4, // 28-bit timer counting conversion time t = CNVCNT[27:0] / fDFSDM_CKIN		
};
inline uint32_t dfsdm_dfsdm1_cnvtimr_get_cnvcnt(struct DFSDM_Type* p) { return (p->DFSDM1_CNVTIMR & DFSDM_DFSDM1_CNVTIMR_CNVCNT) >> 4 ; }

// DFSDM->DFSDM2_CR1 control register 1
enum {
	DFSDM_DFSDM2_CR1_AWFSEL = 1UL<<30, // Analog watchdog fast mode select
	DFSDM_DFSDM2_CR1_FAST = 1UL<<29, // Fast conversion mode selection for regular conversions
	DFSDM_DFSDM2_CR1_RCH = ((1UL<<3)-1) << 24, // Regular channel selection
	DFSDM_DFSDM2_CR1_RDMAEN = 1UL<<21, // DMA channel enabled to read data for the regular conversion
	DFSDM_DFSDM2_CR1_RSYNC = 1UL<<19, // Launch regular conversion synchronously with DFSDM0
	DFSDM_DFSDM2_CR1_RCONT = 1UL<<18, // Continuous mode selection for regular conversions
	DFSDM_DFSDM2_CR1_RSWSTART = 1UL<<17, // Software start of a conversion on the regular channel
	DFSDM_DFSDM2_CR1_JEXTEN = ((1UL<<2)-1) << 13, // Trigger enable and trigger edge selection for injected conversions
	DFSDM_DFSDM2_CR1_JEXTSEL = ((1UL<<3)-1) << 8, // Trigger signal selection for launching injected conversions
	DFSDM_DFSDM2_CR1_JDMAEN = 1UL<<5, // DMA channel enabled to read data for the injected channel group
	DFSDM_DFSDM2_CR1_JSCAN = 1UL<<4, // Scanning conversion mode for injected conversions
	DFSDM_DFSDM2_CR1_JSYNC = 1UL<<3, // Launch an injected conversion synchronously with the DFSDM0 JSWSTART trigger
	DFSDM_DFSDM2_CR1_JSWSTART = 1UL<<1, // Start a conversion of the injected group of channels
	DFSDM_DFSDM2_CR1_DFEN = 1UL<<0, // DFSDM enable		
};
inline void dfsdm_dfsdm2_cr1_set_rch(struct DFSDM_Type* p, uint32_t val) { p->DFSDM2_CR1 = (p->DFSDM2_CR1 & ~DFSDM_DFSDM2_CR1_RCH) | ((val<<24) & DFSDM_DFSDM2_CR1_RCH); }
inline void dfsdm_dfsdm2_cr1_set_jexten(struct DFSDM_Type* p, uint32_t val) { p->DFSDM2_CR1 = (p->DFSDM2_CR1 & ~DFSDM_DFSDM2_CR1_JEXTEN) | ((val<<13) & DFSDM_DFSDM2_CR1_JEXTEN); }
inline void dfsdm_dfsdm2_cr1_set_jextsel(struct DFSDM_Type* p, uint32_t val) { p->DFSDM2_CR1 = (p->DFSDM2_CR1 & ~DFSDM_DFSDM2_CR1_JEXTSEL) | ((val<<8) & DFSDM_DFSDM2_CR1_JEXTSEL); }
inline uint32_t dfsdm_dfsdm2_cr1_get_rch(struct DFSDM_Type* p) { return (p->DFSDM2_CR1 & DFSDM_DFSDM2_CR1_RCH) >> 24 ; }
inline uint32_t dfsdm_dfsdm2_cr1_get_jexten(struct DFSDM_Type* p) { return (p->DFSDM2_CR1 & DFSDM_DFSDM2_CR1_JEXTEN) >> 13 ; }
inline uint32_t dfsdm_dfsdm2_cr1_get_jextsel(struct DFSDM_Type* p) { return (p->DFSDM2_CR1 & DFSDM_DFSDM2_CR1_JEXTSEL) >> 8 ; }

// DFSDM->DFSDM2_CR2 control register 2
enum {
	DFSDM_DFSDM2_CR2_AWDCH = ((1UL<<8)-1) << 16, // Analog watchdog channel selection
	DFSDM_DFSDM2_CR2_EXCH = ((1UL<<8)-1) << 8, // Extremes detector channel selection
	DFSDM_DFSDM2_CR2_CKABIE = 1UL<<6, // Clock absence interrupt enable
	DFSDM_DFSDM2_CR2_SCDIE = 1UL<<5, // Short-circuit detector interrupt enable
	DFSDM_DFSDM2_CR2_AWDIE = 1UL<<4, // Analog watchdog interrupt enable
	DFSDM_DFSDM2_CR2_ROVRIE = 1UL<<3, // Regular data overrun interrupt enable
	DFSDM_DFSDM2_CR2_JOVRIE = 1UL<<2, // Injected data overrun interrupt enable
	DFSDM_DFSDM2_CR2_REOCIE = 1UL<<1, // Regular end of conversion interrupt enable
	DFSDM_DFSDM2_CR2_JEOCIE = 1UL<<0, // Injected end of conversion interrupt enable		
};
inline void dfsdm_dfsdm2_cr2_set_awdch(struct DFSDM_Type* p, uint32_t val) { p->DFSDM2_CR2 = (p->DFSDM2_CR2 & ~DFSDM_DFSDM2_CR2_AWDCH) | ((val<<16) & DFSDM_DFSDM2_CR2_AWDCH); }
inline void dfsdm_dfsdm2_cr2_set_exch(struct DFSDM_Type* p, uint32_t val) { p->DFSDM2_CR2 = (p->DFSDM2_CR2 & ~DFSDM_DFSDM2_CR2_EXCH) | ((val<<8) & DFSDM_DFSDM2_CR2_EXCH); }
inline uint32_t dfsdm_dfsdm2_cr2_get_awdch(struct DFSDM_Type* p) { return (p->DFSDM2_CR2 & DFSDM_DFSDM2_CR2_AWDCH) >> 16 ; }
inline uint32_t dfsdm_dfsdm2_cr2_get_exch(struct DFSDM_Type* p) { return (p->DFSDM2_CR2 & DFSDM_DFSDM2_CR2_EXCH) >> 8 ; }

// DFSDM->DFSDM2_ISR interrupt and status register
enum {
	DFSDM_DFSDM2_ISR_SCDF = ((1UL<<8)-1) << 24, // short-circuit detector flag
	DFSDM_DFSDM2_ISR_CKABF = ((1UL<<8)-1) << 16, // Clock absence flag
	DFSDM_DFSDM2_ISR_RCIP = 1UL<<14, // Regular conversion in progress status
	DFSDM_DFSDM2_ISR_JCIP = 1UL<<13, // Injected conversion in progress status
	DFSDM_DFSDM2_ISR_AWDF = 1UL<<4, // Analog watchdog
	DFSDM_DFSDM2_ISR_ROVRF = 1UL<<3, // Regular conversion overrun flag
	DFSDM_DFSDM2_ISR_JOVRF = 1UL<<2, // Injected conversion overrun flag
	DFSDM_DFSDM2_ISR_REOCF = 1UL<<1, // End of regular conversion flag
	DFSDM_DFSDM2_ISR_JEOCF = 1UL<<0, // End of injected conversion flag		
};
inline uint32_t dfsdm_dfsdm2_isr_get_scdf(struct DFSDM_Type* p) { return (p->DFSDM2_ISR & DFSDM_DFSDM2_ISR_SCDF) >> 24 ; }
inline uint32_t dfsdm_dfsdm2_isr_get_ckabf(struct DFSDM_Type* p) { return (p->DFSDM2_ISR & DFSDM_DFSDM2_ISR_CKABF) >> 16 ; }

// DFSDM->DFSDM2_ICR interrupt flag clear register
enum {
	DFSDM_DFSDM2_ICR_CLRSCDF = ((1UL<<8)-1) << 24, // Clear the short-circuit detector flag
	DFSDM_DFSDM2_ICR_CLRCKABF = ((1UL<<8)-1) << 16, // Clear the clock absence flag
	DFSDM_DFSDM2_ICR_CLRROVRF = 1UL<<3, // Clear the regular conversion overrun flag
	DFSDM_DFSDM2_ICR_CLRJOVRF = 1UL<<2, // Clear the injected conversion overrun flag		
};
inline void dfsdm_dfsdm2_icr_set_clrscdf(struct DFSDM_Type* p, uint32_t val) { p->DFSDM2_ICR = (p->DFSDM2_ICR & ~DFSDM_DFSDM2_ICR_CLRSCDF) | ((val<<24) & DFSDM_DFSDM2_ICR_CLRSCDF); }
inline void dfsdm_dfsdm2_icr_set_clrckabf(struct DFSDM_Type* p, uint32_t val) { p->DFSDM2_ICR = (p->DFSDM2_ICR & ~DFSDM_DFSDM2_ICR_CLRCKABF) | ((val<<16) & DFSDM_DFSDM2_ICR_CLRCKABF); }
inline uint32_t dfsdm_dfsdm2_icr_get_clrscdf(struct DFSDM_Type* p) { return (p->DFSDM2_ICR & DFSDM_DFSDM2_ICR_CLRSCDF) >> 24 ; }
inline uint32_t dfsdm_dfsdm2_icr_get_clrckabf(struct DFSDM_Type* p) { return (p->DFSDM2_ICR & DFSDM_DFSDM2_ICR_CLRCKABF) >> 16 ; }

// DFSDM->DFSDM2_FCR filter control register
enum {
	DFSDM_DFSDM2_FCR_FORD = ((1UL<<3)-1) << 29, // Sinc filter order
	DFSDM_DFSDM2_FCR_FOSR = ((1UL<<10)-1) << 16, // Sinc filter oversampling ratio (decimation rate)
	DFSDM_DFSDM2_FCR_IOSR = ((1UL<<8)-1) << 0, // Integrator oversampling ratio (averaging length)		
};
inline void dfsdm_dfsdm2_fcr_set_ford(struct DFSDM_Type* p, uint32_t val) { p->DFSDM2_FCR = (p->DFSDM2_FCR & ~DFSDM_DFSDM2_FCR_FORD) | ((val<<29) & DFSDM_DFSDM2_FCR_FORD); }
inline void dfsdm_dfsdm2_fcr_set_fosr(struct DFSDM_Type* p, uint32_t val) { p->DFSDM2_FCR = (p->DFSDM2_FCR & ~DFSDM_DFSDM2_FCR_FOSR) | ((val<<16) & DFSDM_DFSDM2_FCR_FOSR); }
inline void dfsdm_dfsdm2_fcr_set_iosr(struct DFSDM_Type* p, uint32_t val) { p->DFSDM2_FCR = (p->DFSDM2_FCR & ~DFSDM_DFSDM2_FCR_IOSR) | ((val<<0) & DFSDM_DFSDM2_FCR_IOSR); }
inline uint32_t dfsdm_dfsdm2_fcr_get_ford(struct DFSDM_Type* p) { return (p->DFSDM2_FCR & DFSDM_DFSDM2_FCR_FORD) >> 29 ; }
inline uint32_t dfsdm_dfsdm2_fcr_get_fosr(struct DFSDM_Type* p) { return (p->DFSDM2_FCR & DFSDM_DFSDM2_FCR_FOSR) >> 16 ; }
inline uint32_t dfsdm_dfsdm2_fcr_get_iosr(struct DFSDM_Type* p) { return (p->DFSDM2_FCR & DFSDM_DFSDM2_FCR_IOSR) >> 0 ; }

// DFSDM->DFSDM2_JDATAR data register for injected group
enum {
	DFSDM_DFSDM2_JDATAR_JDATA = ((1UL<<24)-1) << 8, // Injected group conversion data
	DFSDM_DFSDM2_JDATAR_JDATACH = ((1UL<<3)-1) << 0, // Injected channel most recently converted		
};
inline uint32_t dfsdm_dfsdm2_jdatar_get_jdata(struct DFSDM_Type* p) { return (p->DFSDM2_JDATAR & DFSDM_DFSDM2_JDATAR_JDATA) >> 8 ; }
inline uint32_t dfsdm_dfsdm2_jdatar_get_jdatach(struct DFSDM_Type* p) { return (p->DFSDM2_JDATAR & DFSDM_DFSDM2_JDATAR_JDATACH) >> 0 ; }

// DFSDM->DFSDM2_RDATAR data register for the regular channel
enum {
	DFSDM_DFSDM2_RDATAR_RDATA = ((1UL<<24)-1) << 8, // Regular channel conversion data
	DFSDM_DFSDM2_RDATAR_RPEND = 1UL<<4, // Regular channel pending data
	DFSDM_DFSDM2_RDATAR_RDATACH = ((1UL<<3)-1) << 0, // Regular channel most recently converted		
};
inline uint32_t dfsdm_dfsdm2_rdatar_get_rdata(struct DFSDM_Type* p) { return (p->DFSDM2_RDATAR & DFSDM_DFSDM2_RDATAR_RDATA) >> 8 ; }
inline uint32_t dfsdm_dfsdm2_rdatar_get_rdatach(struct DFSDM_Type* p) { return (p->DFSDM2_RDATAR & DFSDM_DFSDM2_RDATAR_RDATACH) >> 0 ; }

// DFSDM->DFSDM2_AWHTR analog watchdog high threshold register
enum {
	DFSDM_DFSDM2_AWHTR_AWHT = ((1UL<<24)-1) << 8, // Analog watchdog high threshold
	DFSDM_DFSDM2_AWHTR_BKAWH = ((1UL<<4)-1) << 0, // Break signal assignment to analog watchdog high threshold event		
};
inline void dfsdm_dfsdm2_awhtr_set_awht(struct DFSDM_Type* p, uint32_t val) { p->DFSDM2_AWHTR = (p->DFSDM2_AWHTR & ~DFSDM_DFSDM2_AWHTR_AWHT) | ((val<<8) & DFSDM_DFSDM2_AWHTR_AWHT); }
inline void dfsdm_dfsdm2_awhtr_set_bkawh(struct DFSDM_Type* p, uint32_t val) { p->DFSDM2_AWHTR = (p->DFSDM2_AWHTR & ~DFSDM_DFSDM2_AWHTR_BKAWH) | ((val<<0) & DFSDM_DFSDM2_AWHTR_BKAWH); }
inline uint32_t dfsdm_dfsdm2_awhtr_get_awht(struct DFSDM_Type* p) { return (p->DFSDM2_AWHTR & DFSDM_DFSDM2_AWHTR_AWHT) >> 8 ; }
inline uint32_t dfsdm_dfsdm2_awhtr_get_bkawh(struct DFSDM_Type* p) { return (p->DFSDM2_AWHTR & DFSDM_DFSDM2_AWHTR_BKAWH) >> 0 ; }

// DFSDM->DFSDM2_AWLTR analog watchdog low threshold register
enum {
	DFSDM_DFSDM2_AWLTR_AWLT = ((1UL<<24)-1) << 8, // Analog watchdog low threshold
	DFSDM_DFSDM2_AWLTR_BKAWL = ((1UL<<4)-1) << 0, // Break signal assignment to analog watchdog low threshold event		
};
inline void dfsdm_dfsdm2_awltr_set_awlt(struct DFSDM_Type* p, uint32_t val) { p->DFSDM2_AWLTR = (p->DFSDM2_AWLTR & ~DFSDM_DFSDM2_AWLTR_AWLT) | ((val<<8) & DFSDM_DFSDM2_AWLTR_AWLT); }
inline void dfsdm_dfsdm2_awltr_set_bkawl(struct DFSDM_Type* p, uint32_t val) { p->DFSDM2_AWLTR = (p->DFSDM2_AWLTR & ~DFSDM_DFSDM2_AWLTR_BKAWL) | ((val<<0) & DFSDM_DFSDM2_AWLTR_BKAWL); }
inline uint32_t dfsdm_dfsdm2_awltr_get_awlt(struct DFSDM_Type* p) { return (p->DFSDM2_AWLTR & DFSDM_DFSDM2_AWLTR_AWLT) >> 8 ; }
inline uint32_t dfsdm_dfsdm2_awltr_get_bkawl(struct DFSDM_Type* p) { return (p->DFSDM2_AWLTR & DFSDM_DFSDM2_AWLTR_BKAWL) >> 0 ; }

// DFSDM->DFSDM2_AWSR analog watchdog status register
enum {
	DFSDM_DFSDM2_AWSR_AWHTF = ((1UL<<8)-1) << 8, // Analog watchdog high threshold flag
	DFSDM_DFSDM2_AWSR_AWLTF = ((1UL<<8)-1) << 0, // Analog watchdog low threshold flag		
};
inline uint32_t dfsdm_dfsdm2_awsr_get_awhtf(struct DFSDM_Type* p) { return (p->DFSDM2_AWSR & DFSDM_DFSDM2_AWSR_AWHTF) >> 8 ; }
inline uint32_t dfsdm_dfsdm2_awsr_get_awltf(struct DFSDM_Type* p) { return (p->DFSDM2_AWSR & DFSDM_DFSDM2_AWSR_AWLTF) >> 0 ; }

// DFSDM->DFSDM2_AWCFR analog watchdog clear flag register
enum {
	DFSDM_DFSDM2_AWCFR_CLRAWHTF = ((1UL<<8)-1) << 8, // Clear the analog watchdog high threshold flag
	DFSDM_DFSDM2_AWCFR_CLRAWLTF = ((1UL<<8)-1) << 0, // Clear the analog watchdog low threshold flag		
};
inline void dfsdm_dfsdm2_awcfr_set_clrawhtf(struct DFSDM_Type* p, uint32_t val) { p->DFSDM2_AWCFR = (p->DFSDM2_AWCFR & ~DFSDM_DFSDM2_AWCFR_CLRAWHTF) | ((val<<8) & DFSDM_DFSDM2_AWCFR_CLRAWHTF); }
inline void dfsdm_dfsdm2_awcfr_set_clrawltf(struct DFSDM_Type* p, uint32_t val) { p->DFSDM2_AWCFR = (p->DFSDM2_AWCFR & ~DFSDM_DFSDM2_AWCFR_CLRAWLTF) | ((val<<0) & DFSDM_DFSDM2_AWCFR_CLRAWLTF); }
inline uint32_t dfsdm_dfsdm2_awcfr_get_clrawhtf(struct DFSDM_Type* p) { return (p->DFSDM2_AWCFR & DFSDM_DFSDM2_AWCFR_CLRAWHTF) >> 8 ; }
inline uint32_t dfsdm_dfsdm2_awcfr_get_clrawltf(struct DFSDM_Type* p) { return (p->DFSDM2_AWCFR & DFSDM_DFSDM2_AWCFR_CLRAWLTF) >> 0 ; }

// DFSDM->DFSDM2_EXMAX Extremes detector maximum register
enum {
	DFSDM_DFSDM2_EXMAX_EXMAX = ((1UL<<24)-1) << 8, // Extremes detector maximum value
	DFSDM_DFSDM2_EXMAX_EXMAXCH = ((1UL<<3)-1) << 0, // Extremes detector maximum data channel		
};
inline uint32_t dfsdm_dfsdm2_exmax_get_exmax(struct DFSDM_Type* p) { return (p->DFSDM2_EXMAX & DFSDM_DFSDM2_EXMAX_EXMAX) >> 8 ; }
inline uint32_t dfsdm_dfsdm2_exmax_get_exmaxch(struct DFSDM_Type* p) { return (p->DFSDM2_EXMAX & DFSDM_DFSDM2_EXMAX_EXMAXCH) >> 0 ; }

// DFSDM->DFSDM2_EXMIN Extremes detector minimum register
enum {
	DFSDM_DFSDM2_EXMIN_EXMIN = ((1UL<<24)-1) << 8, // EXMIN
	DFSDM_DFSDM2_EXMIN_EXMINCH = ((1UL<<3)-1) << 0, // Extremes detector minimum data channel		
};
inline uint32_t dfsdm_dfsdm2_exmin_get_exmin(struct DFSDM_Type* p) { return (p->DFSDM2_EXMIN & DFSDM_DFSDM2_EXMIN_EXMIN) >> 8 ; }
inline uint32_t dfsdm_dfsdm2_exmin_get_exminch(struct DFSDM_Type* p) { return (p->DFSDM2_EXMIN & DFSDM_DFSDM2_EXMIN_EXMINCH) >> 0 ; }

// DFSDM->DFSDM2_CNVTIMR conversion timer register
enum {
	DFSDM_DFSDM2_CNVTIMR_CNVCNT = ((1UL<<28)-1) << 4, // 28-bit timer counting conversion time t = CNVCNT[27:0] / fDFSDM_CKIN		
};
inline uint32_t dfsdm_dfsdm2_cnvtimr_get_cnvcnt(struct DFSDM_Type* p) { return (p->DFSDM2_CNVTIMR & DFSDM_DFSDM2_CNVTIMR_CNVCNT) >> 4 ; }

// DFSDM->DFSDM3_CR1 control register 1
enum {
	DFSDM_DFSDM3_CR1_AWFSEL = 1UL<<30, // Analog watchdog fast mode select
	DFSDM_DFSDM3_CR1_FAST = 1UL<<29, // Fast conversion mode selection for regular conversions
	DFSDM_DFSDM3_CR1_RCH = ((1UL<<3)-1) << 24, // Regular channel selection
	DFSDM_DFSDM3_CR1_RDMAEN = 1UL<<21, // DMA channel enabled to read data for the regular conversion
	DFSDM_DFSDM3_CR1_RSYNC = 1UL<<19, // Launch regular conversion synchronously with DFSDM0
	DFSDM_DFSDM3_CR1_RCONT = 1UL<<18, // Continuous mode selection for regular conversions
	DFSDM_DFSDM3_CR1_RSWSTART = 1UL<<17, // Software start of a conversion on the regular channel
	DFSDM_DFSDM3_CR1_JEXTEN = ((1UL<<2)-1) << 13, // Trigger enable and trigger edge selection for injected conversions
	DFSDM_DFSDM3_CR1_JEXTSEL = ((1UL<<3)-1) << 8, // Trigger signal selection for launching injected conversions
	DFSDM_DFSDM3_CR1_JDMAEN = 1UL<<5, // DMA channel enabled to read data for the injected channel group
	DFSDM_DFSDM3_CR1_JSCAN = 1UL<<4, // Scanning conversion mode for injected conversions
	DFSDM_DFSDM3_CR1_JSYNC = 1UL<<3, // Launch an injected conversion synchronously with the DFSDM0 JSWSTART trigger
	DFSDM_DFSDM3_CR1_JSWSTART = 1UL<<1, // Start a conversion of the injected group of channels
	DFSDM_DFSDM3_CR1_DFEN = 1UL<<0, // DFSDM enable		
};
inline void dfsdm_dfsdm3_cr1_set_rch(struct DFSDM_Type* p, uint32_t val) { p->DFSDM3_CR1 = (p->DFSDM3_CR1 & ~DFSDM_DFSDM3_CR1_RCH) | ((val<<24) & DFSDM_DFSDM3_CR1_RCH); }
inline void dfsdm_dfsdm3_cr1_set_jexten(struct DFSDM_Type* p, uint32_t val) { p->DFSDM3_CR1 = (p->DFSDM3_CR1 & ~DFSDM_DFSDM3_CR1_JEXTEN) | ((val<<13) & DFSDM_DFSDM3_CR1_JEXTEN); }
inline void dfsdm_dfsdm3_cr1_set_jextsel(struct DFSDM_Type* p, uint32_t val) { p->DFSDM3_CR1 = (p->DFSDM3_CR1 & ~DFSDM_DFSDM3_CR1_JEXTSEL) | ((val<<8) & DFSDM_DFSDM3_CR1_JEXTSEL); }
inline uint32_t dfsdm_dfsdm3_cr1_get_rch(struct DFSDM_Type* p) { return (p->DFSDM3_CR1 & DFSDM_DFSDM3_CR1_RCH) >> 24 ; }
inline uint32_t dfsdm_dfsdm3_cr1_get_jexten(struct DFSDM_Type* p) { return (p->DFSDM3_CR1 & DFSDM_DFSDM3_CR1_JEXTEN) >> 13 ; }
inline uint32_t dfsdm_dfsdm3_cr1_get_jextsel(struct DFSDM_Type* p) { return (p->DFSDM3_CR1 & DFSDM_DFSDM3_CR1_JEXTSEL) >> 8 ; }

// DFSDM->DFSDM3_CR2 control register 2
enum {
	DFSDM_DFSDM3_CR2_AWDCH = ((1UL<<8)-1) << 16, // Analog watchdog channel selection
	DFSDM_DFSDM3_CR2_EXCH = ((1UL<<8)-1) << 8, // Extremes detector channel selection
	DFSDM_DFSDM3_CR2_CKABIE = 1UL<<6, // Clock absence interrupt enable
	DFSDM_DFSDM3_CR2_SCDIE = 1UL<<5, // Short-circuit detector interrupt enable
	DFSDM_DFSDM3_CR2_AWDIE = 1UL<<4, // Analog watchdog interrupt enable
	DFSDM_DFSDM3_CR2_ROVRIE = 1UL<<3, // Regular data overrun interrupt enable
	DFSDM_DFSDM3_CR2_JOVRIE = 1UL<<2, // Injected data overrun interrupt enable
	DFSDM_DFSDM3_CR2_REOCIE = 1UL<<1, // Regular end of conversion interrupt enable
	DFSDM_DFSDM3_CR2_JEOCIE = 1UL<<0, // Injected end of conversion interrupt enable		
};
inline void dfsdm_dfsdm3_cr2_set_awdch(struct DFSDM_Type* p, uint32_t val) { p->DFSDM3_CR2 = (p->DFSDM3_CR2 & ~DFSDM_DFSDM3_CR2_AWDCH) | ((val<<16) & DFSDM_DFSDM3_CR2_AWDCH); }
inline void dfsdm_dfsdm3_cr2_set_exch(struct DFSDM_Type* p, uint32_t val) { p->DFSDM3_CR2 = (p->DFSDM3_CR2 & ~DFSDM_DFSDM3_CR2_EXCH) | ((val<<8) & DFSDM_DFSDM3_CR2_EXCH); }
inline uint32_t dfsdm_dfsdm3_cr2_get_awdch(struct DFSDM_Type* p) { return (p->DFSDM3_CR2 & DFSDM_DFSDM3_CR2_AWDCH) >> 16 ; }
inline uint32_t dfsdm_dfsdm3_cr2_get_exch(struct DFSDM_Type* p) { return (p->DFSDM3_CR2 & DFSDM_DFSDM3_CR2_EXCH) >> 8 ; }

// DFSDM->DFSDM3_ISR interrupt and status register
enum {
	DFSDM_DFSDM3_ISR_SCDF = ((1UL<<8)-1) << 24, // short-circuit detector flag
	DFSDM_DFSDM3_ISR_CKABF = ((1UL<<8)-1) << 16, // Clock absence flag
	DFSDM_DFSDM3_ISR_RCIP = 1UL<<14, // Regular conversion in progress status
	DFSDM_DFSDM3_ISR_JCIP = 1UL<<13, // Injected conversion in progress status
	DFSDM_DFSDM3_ISR_AWDF = 1UL<<4, // Analog watchdog
	DFSDM_DFSDM3_ISR_ROVRF = 1UL<<3, // Regular conversion overrun flag
	DFSDM_DFSDM3_ISR_JOVRF = 1UL<<2, // Injected conversion overrun flag
	DFSDM_DFSDM3_ISR_REOCF = 1UL<<1, // End of regular conversion flag
	DFSDM_DFSDM3_ISR_JEOCF = 1UL<<0, // End of injected conversion flag		
};
inline uint32_t dfsdm_dfsdm3_isr_get_scdf(struct DFSDM_Type* p) { return (p->DFSDM3_ISR & DFSDM_DFSDM3_ISR_SCDF) >> 24 ; }
inline uint32_t dfsdm_dfsdm3_isr_get_ckabf(struct DFSDM_Type* p) { return (p->DFSDM3_ISR & DFSDM_DFSDM3_ISR_CKABF) >> 16 ; }

// DFSDM->DFSDM3_ICR interrupt flag clear register
enum {
	DFSDM_DFSDM3_ICR_CLRSCDF = ((1UL<<8)-1) << 24, // Clear the short-circuit detector flag
	DFSDM_DFSDM3_ICR_CLRCKABF = ((1UL<<8)-1) << 16, // Clear the clock absence flag
	DFSDM_DFSDM3_ICR_CLRROVRF = 1UL<<3, // Clear the regular conversion overrun flag
	DFSDM_DFSDM3_ICR_CLRJOVRF = 1UL<<2, // Clear the injected conversion overrun flag		
};
inline void dfsdm_dfsdm3_icr_set_clrscdf(struct DFSDM_Type* p, uint32_t val) { p->DFSDM3_ICR = (p->DFSDM3_ICR & ~DFSDM_DFSDM3_ICR_CLRSCDF) | ((val<<24) & DFSDM_DFSDM3_ICR_CLRSCDF); }
inline void dfsdm_dfsdm3_icr_set_clrckabf(struct DFSDM_Type* p, uint32_t val) { p->DFSDM3_ICR = (p->DFSDM3_ICR & ~DFSDM_DFSDM3_ICR_CLRCKABF) | ((val<<16) & DFSDM_DFSDM3_ICR_CLRCKABF); }
inline uint32_t dfsdm_dfsdm3_icr_get_clrscdf(struct DFSDM_Type* p) { return (p->DFSDM3_ICR & DFSDM_DFSDM3_ICR_CLRSCDF) >> 24 ; }
inline uint32_t dfsdm_dfsdm3_icr_get_clrckabf(struct DFSDM_Type* p) { return (p->DFSDM3_ICR & DFSDM_DFSDM3_ICR_CLRCKABF) >> 16 ; }

// DFSDM->DFSDM3_FCR filter control register
enum {
	DFSDM_DFSDM3_FCR_FORD = ((1UL<<3)-1) << 29, // Sinc filter order
	DFSDM_DFSDM3_FCR_FOSR = ((1UL<<10)-1) << 16, // Sinc filter oversampling ratio (decimation rate)
	DFSDM_DFSDM3_FCR_IOSR = ((1UL<<8)-1) << 0, // Integrator oversampling ratio (averaging length)		
};
inline void dfsdm_dfsdm3_fcr_set_ford(struct DFSDM_Type* p, uint32_t val) { p->DFSDM3_FCR = (p->DFSDM3_FCR & ~DFSDM_DFSDM3_FCR_FORD) | ((val<<29) & DFSDM_DFSDM3_FCR_FORD); }
inline void dfsdm_dfsdm3_fcr_set_fosr(struct DFSDM_Type* p, uint32_t val) { p->DFSDM3_FCR = (p->DFSDM3_FCR & ~DFSDM_DFSDM3_FCR_FOSR) | ((val<<16) & DFSDM_DFSDM3_FCR_FOSR); }
inline void dfsdm_dfsdm3_fcr_set_iosr(struct DFSDM_Type* p, uint32_t val) { p->DFSDM3_FCR = (p->DFSDM3_FCR & ~DFSDM_DFSDM3_FCR_IOSR) | ((val<<0) & DFSDM_DFSDM3_FCR_IOSR); }
inline uint32_t dfsdm_dfsdm3_fcr_get_ford(struct DFSDM_Type* p) { return (p->DFSDM3_FCR & DFSDM_DFSDM3_FCR_FORD) >> 29 ; }
inline uint32_t dfsdm_dfsdm3_fcr_get_fosr(struct DFSDM_Type* p) { return (p->DFSDM3_FCR & DFSDM_DFSDM3_FCR_FOSR) >> 16 ; }
inline uint32_t dfsdm_dfsdm3_fcr_get_iosr(struct DFSDM_Type* p) { return (p->DFSDM3_FCR & DFSDM_DFSDM3_FCR_IOSR) >> 0 ; }

// DFSDM->DFSDM3_JDATAR data register for injected group
enum {
	DFSDM_DFSDM3_JDATAR_JDATA = ((1UL<<24)-1) << 8, // Injected group conversion data
	DFSDM_DFSDM3_JDATAR_JDATACH = ((1UL<<3)-1) << 0, // Injected channel most recently converted		
};
inline uint32_t dfsdm_dfsdm3_jdatar_get_jdata(struct DFSDM_Type* p) { return (p->DFSDM3_JDATAR & DFSDM_DFSDM3_JDATAR_JDATA) >> 8 ; }
inline uint32_t dfsdm_dfsdm3_jdatar_get_jdatach(struct DFSDM_Type* p) { return (p->DFSDM3_JDATAR & DFSDM_DFSDM3_JDATAR_JDATACH) >> 0 ; }

// DFSDM->DFSDM3_RDATAR data register for the regular channel
enum {
	DFSDM_DFSDM3_RDATAR_RDATA = ((1UL<<24)-1) << 8, // Regular channel conversion data
	DFSDM_DFSDM3_RDATAR_RPEND = 1UL<<4, // Regular channel pending data
	DFSDM_DFSDM3_RDATAR_RDATACH = ((1UL<<3)-1) << 0, // Regular channel most recently converted		
};
inline uint32_t dfsdm_dfsdm3_rdatar_get_rdata(struct DFSDM_Type* p) { return (p->DFSDM3_RDATAR & DFSDM_DFSDM3_RDATAR_RDATA) >> 8 ; }
inline uint32_t dfsdm_dfsdm3_rdatar_get_rdatach(struct DFSDM_Type* p) { return (p->DFSDM3_RDATAR & DFSDM_DFSDM3_RDATAR_RDATACH) >> 0 ; }

// DFSDM->DFSDM3_AWHTR analog watchdog high threshold register
enum {
	DFSDM_DFSDM3_AWHTR_AWHT = ((1UL<<24)-1) << 8, // Analog watchdog high threshold
	DFSDM_DFSDM3_AWHTR_BKAWH = ((1UL<<4)-1) << 0, // Break signal assignment to analog watchdog high threshold event		
};
inline void dfsdm_dfsdm3_awhtr_set_awht(struct DFSDM_Type* p, uint32_t val) { p->DFSDM3_AWHTR = (p->DFSDM3_AWHTR & ~DFSDM_DFSDM3_AWHTR_AWHT) | ((val<<8) & DFSDM_DFSDM3_AWHTR_AWHT); }
inline void dfsdm_dfsdm3_awhtr_set_bkawh(struct DFSDM_Type* p, uint32_t val) { p->DFSDM3_AWHTR = (p->DFSDM3_AWHTR & ~DFSDM_DFSDM3_AWHTR_BKAWH) | ((val<<0) & DFSDM_DFSDM3_AWHTR_BKAWH); }
inline uint32_t dfsdm_dfsdm3_awhtr_get_awht(struct DFSDM_Type* p) { return (p->DFSDM3_AWHTR & DFSDM_DFSDM3_AWHTR_AWHT) >> 8 ; }
inline uint32_t dfsdm_dfsdm3_awhtr_get_bkawh(struct DFSDM_Type* p) { return (p->DFSDM3_AWHTR & DFSDM_DFSDM3_AWHTR_BKAWH) >> 0 ; }

// DFSDM->DFSDM3_AWLTR analog watchdog low threshold register
enum {
	DFSDM_DFSDM3_AWLTR_AWLT = ((1UL<<24)-1) << 8, // Analog watchdog low threshold
	DFSDM_DFSDM3_AWLTR_BKAWL = ((1UL<<4)-1) << 0, // Break signal assignment to analog watchdog low threshold event		
};
inline void dfsdm_dfsdm3_awltr_set_awlt(struct DFSDM_Type* p, uint32_t val) { p->DFSDM3_AWLTR = (p->DFSDM3_AWLTR & ~DFSDM_DFSDM3_AWLTR_AWLT) | ((val<<8) & DFSDM_DFSDM3_AWLTR_AWLT); }
inline void dfsdm_dfsdm3_awltr_set_bkawl(struct DFSDM_Type* p, uint32_t val) { p->DFSDM3_AWLTR = (p->DFSDM3_AWLTR & ~DFSDM_DFSDM3_AWLTR_BKAWL) | ((val<<0) & DFSDM_DFSDM3_AWLTR_BKAWL); }
inline uint32_t dfsdm_dfsdm3_awltr_get_awlt(struct DFSDM_Type* p) { return (p->DFSDM3_AWLTR & DFSDM_DFSDM3_AWLTR_AWLT) >> 8 ; }
inline uint32_t dfsdm_dfsdm3_awltr_get_bkawl(struct DFSDM_Type* p) { return (p->DFSDM3_AWLTR & DFSDM_DFSDM3_AWLTR_BKAWL) >> 0 ; }

// DFSDM->DFSDM3_AWSR analog watchdog status register
enum {
	DFSDM_DFSDM3_AWSR_AWHTF = ((1UL<<8)-1) << 8, // Analog watchdog high threshold flag
	DFSDM_DFSDM3_AWSR_AWLTF = ((1UL<<8)-1) << 0, // Analog watchdog low threshold flag		
};
inline uint32_t dfsdm_dfsdm3_awsr_get_awhtf(struct DFSDM_Type* p) { return (p->DFSDM3_AWSR & DFSDM_DFSDM3_AWSR_AWHTF) >> 8 ; }
inline uint32_t dfsdm_dfsdm3_awsr_get_awltf(struct DFSDM_Type* p) { return (p->DFSDM3_AWSR & DFSDM_DFSDM3_AWSR_AWLTF) >> 0 ; }

// DFSDM->DFSDM3_AWCFR analog watchdog clear flag register
enum {
	DFSDM_DFSDM3_AWCFR_CLRAWHTF = ((1UL<<8)-1) << 8, // Clear the analog watchdog high threshold flag
	DFSDM_DFSDM3_AWCFR_CLRAWLTF = ((1UL<<8)-1) << 0, // Clear the analog watchdog low threshold flag		
};
inline void dfsdm_dfsdm3_awcfr_set_clrawhtf(struct DFSDM_Type* p, uint32_t val) { p->DFSDM3_AWCFR = (p->DFSDM3_AWCFR & ~DFSDM_DFSDM3_AWCFR_CLRAWHTF) | ((val<<8) & DFSDM_DFSDM3_AWCFR_CLRAWHTF); }
inline void dfsdm_dfsdm3_awcfr_set_clrawltf(struct DFSDM_Type* p, uint32_t val) { p->DFSDM3_AWCFR = (p->DFSDM3_AWCFR & ~DFSDM_DFSDM3_AWCFR_CLRAWLTF) | ((val<<0) & DFSDM_DFSDM3_AWCFR_CLRAWLTF); }
inline uint32_t dfsdm_dfsdm3_awcfr_get_clrawhtf(struct DFSDM_Type* p) { return (p->DFSDM3_AWCFR & DFSDM_DFSDM3_AWCFR_CLRAWHTF) >> 8 ; }
inline uint32_t dfsdm_dfsdm3_awcfr_get_clrawltf(struct DFSDM_Type* p) { return (p->DFSDM3_AWCFR & DFSDM_DFSDM3_AWCFR_CLRAWLTF) >> 0 ; }

// DFSDM->DFSDM3_EXMAX Extremes detector maximum register
enum {
	DFSDM_DFSDM3_EXMAX_EXMAX = ((1UL<<24)-1) << 8, // Extremes detector maximum value
	DFSDM_DFSDM3_EXMAX_EXMAXCH = ((1UL<<3)-1) << 0, // Extremes detector maximum data channel		
};
inline uint32_t dfsdm_dfsdm3_exmax_get_exmax(struct DFSDM_Type* p) { return (p->DFSDM3_EXMAX & DFSDM_DFSDM3_EXMAX_EXMAX) >> 8 ; }
inline uint32_t dfsdm_dfsdm3_exmax_get_exmaxch(struct DFSDM_Type* p) { return (p->DFSDM3_EXMAX & DFSDM_DFSDM3_EXMAX_EXMAXCH) >> 0 ; }

// DFSDM->DFSDM3_EXMIN Extremes detector minimum register
enum {
	DFSDM_DFSDM3_EXMIN_EXMIN = ((1UL<<24)-1) << 8, // EXMIN
	DFSDM_DFSDM3_EXMIN_EXMINCH = ((1UL<<3)-1) << 0, // Extremes detector minimum data channel		
};
inline uint32_t dfsdm_dfsdm3_exmin_get_exmin(struct DFSDM_Type* p) { return (p->DFSDM3_EXMIN & DFSDM_DFSDM3_EXMIN_EXMIN) >> 8 ; }
inline uint32_t dfsdm_dfsdm3_exmin_get_exminch(struct DFSDM_Type* p) { return (p->DFSDM3_EXMIN & DFSDM_DFSDM3_EXMIN_EXMINCH) >> 0 ; }

// DFSDM->DFSDM3_CNVTIMR conversion timer register
enum {
	DFSDM_DFSDM3_CNVTIMR_CNVCNT = ((1UL<<28)-1) << 4, // 28-bit timer counting conversion time t = CNVCNT[27:0] / fDFSDM_CKIN		
};
inline uint32_t dfsdm_dfsdm3_cnvtimr_get_cnvcnt(struct DFSDM_Type* p) { return (p->DFSDM3_CNVTIMR & DFSDM_DFSDM3_CNVTIMR_CNVCNT) >> 4 ; }

/* Direct memory access controller */
struct DMA1_Type {
	__I uint32_t ISR; // @0 interrupt status register
	__O uint32_t IFCR; // @4 interrupt flag clear register
	__IO uint32_t CCR1; // @8 channel x configuration register
	__IO uint32_t CNDTR1; // @12 channel x number of data register
	__IO uint32_t CPAR1; // @16 channel x peripheral address register
	__IO uint32_t CMAR1; // @20 channel x memory address register
	 uint8_t RESERVED0[4]; // @24 
	__IO uint32_t CCR2; // @28 channel x configuration register
	__IO uint32_t CNDTR2; // @32 channel x number of data register
	__IO uint32_t CPAR2; // @36 channel x peripheral address register
	__IO uint32_t CMAR2; // @40 channel x memory address register
	 uint8_t RESERVED1[4]; // @44 
	__IO uint32_t CCR3; // @48 channel x configuration register
	__IO uint32_t CNDTR3; // @52 channel x number of data register
	__IO uint32_t CPAR3; // @56 channel x peripheral address register
	__IO uint32_t CMAR3; // @60 channel x memory address register
	 uint8_t RESERVED2[4]; // @64 
	__IO uint32_t CCR4; // @68 channel x configuration register
	__IO uint32_t CNDTR4; // @72 channel x number of data register
	__IO uint32_t CPAR4; // @76 channel x peripheral address register
	__IO uint32_t CMAR4; // @80 channel x memory address register
	 uint8_t RESERVED3[4]; // @84 
	__IO uint32_t CCR5; // @88 channel x configuration register
	__IO uint32_t CNDTR5; // @92 channel x number of data register
	__IO uint32_t CPAR5; // @96 channel x peripheral address register
	__IO uint32_t CMAR5; // @100 channel x memory address register
	 uint8_t RESERVED4[4]; // @104 
	__IO uint32_t CCR6; // @108 channel x configuration register
	__IO uint32_t CNDTR6; // @112 channel x number of data register
	__IO uint32_t CPAR6; // @116 channel x peripheral address register
	__IO uint32_t CMAR6; // @120 channel x memory address register
	 uint8_t RESERVED5[4]; // @124 
	__IO uint32_t CCR7; // @128 channel x configuration register
	__IO uint32_t CNDTR7; // @132 channel x number of data register
	__IO uint32_t CPAR7; // @136 channel x peripheral address register
	__IO uint32_t CMAR7; // @140 channel x memory address register
	 uint8_t RESERVED6[24]; // @144 
	__IO uint32_t CSELR; // @168 channel selection register
};

// DMA1->ISR interrupt status register
enum {
	DMA1_ISR_TEIF7 = 1UL<<27, // Channel x transfer error flag (x = 1 ..7)
	DMA1_ISR_HTIF7 = 1UL<<26, // Channel x half transfer flag (x = 1 ..7)
	DMA1_ISR_TCIF7 = 1UL<<25, // Channel x transfer complete flag (x = 1 ..7)
	DMA1_ISR_GIF7 = 1UL<<24, // Channel x global interrupt flag (x = 1 ..7)
	DMA1_ISR_TEIF6 = 1UL<<23, // Channel x transfer error flag (x = 1 ..7)
	DMA1_ISR_HTIF6 = 1UL<<22, // Channel x half transfer flag (x = 1 ..7)
	DMA1_ISR_TCIF6 = 1UL<<21, // Channel x transfer complete flag (x = 1 ..7)
	DMA1_ISR_GIF6 = 1UL<<20, // Channel x global interrupt flag (x = 1 ..7)
	DMA1_ISR_TEIF5 = 1UL<<19, // Channel x transfer error flag (x = 1 ..7)
	DMA1_ISR_HTIF5 = 1UL<<18, // Channel x half transfer flag (x = 1 ..7)
	DMA1_ISR_TCIF5 = 1UL<<17, // Channel x transfer complete flag (x = 1 ..7)
	DMA1_ISR_GIF5 = 1UL<<16, // Channel x global interrupt flag (x = 1 ..7)
	DMA1_ISR_TEIF4 = 1UL<<15, // Channel x transfer error flag (x = 1 ..7)
	DMA1_ISR_HTIF4 = 1UL<<14, // Channel x half transfer flag (x = 1 ..7)
	DMA1_ISR_TCIF4 = 1UL<<13, // Channel x transfer complete flag (x = 1 ..7)
	DMA1_ISR_GIF4 = 1UL<<12, // Channel x global interrupt flag (x = 1 ..7)
	DMA1_ISR_TEIF3 = 1UL<<11, // Channel x transfer error flag (x = 1 ..7)
	DMA1_ISR_HTIF3 = 1UL<<10, // Channel x half transfer flag (x = 1 ..7)
	DMA1_ISR_TCIF3 = 1UL<<9, // Channel x transfer complete flag (x = 1 ..7)
	DMA1_ISR_GIF3 = 1UL<<8, // Channel x global interrupt flag (x = 1 ..7)
	DMA1_ISR_TEIF2 = 1UL<<7, // Channel x transfer error flag (x = 1 ..7)
	DMA1_ISR_HTIF2 = 1UL<<6, // Channel x half transfer flag (x = 1 ..7)
	DMA1_ISR_TCIF2 = 1UL<<5, // Channel x transfer complete flag (x = 1 ..7)
	DMA1_ISR_GIF2 = 1UL<<4, // Channel x global interrupt flag (x = 1 ..7)
	DMA1_ISR_TEIF1 = 1UL<<3, // Channel x transfer error flag (x = 1 ..7)
	DMA1_ISR_HTIF1 = 1UL<<2, // Channel x half transfer flag (x = 1 ..7)
	DMA1_ISR_TCIF1 = 1UL<<1, // Channel x transfer complete flag (x = 1 ..7)
	DMA1_ISR_GIF1 = 1UL<<0, // Channel x global interrupt flag (x = 1 ..7)		
};

// DMA1->IFCR interrupt flag clear register
enum {
	DMA1_IFCR_CTEIF7 = 1UL<<27, // Channel x transfer error clear (x = 1 ..7)
	DMA1_IFCR_CHTIF7 = 1UL<<26, // Channel x half transfer clear (x = 1 ..7)
	DMA1_IFCR_CTCIF7 = 1UL<<25, // Channel x transfer complete clear (x = 1 ..7)
	DMA1_IFCR_CGIF7 = 1UL<<24, // Channel x global interrupt clear (x = 1 ..7)
	DMA1_IFCR_CTEIF6 = 1UL<<23, // Channel x transfer error clear (x = 1 ..7)
	DMA1_IFCR_CHTIF6 = 1UL<<22, // Channel x half transfer clear (x = 1 ..7)
	DMA1_IFCR_CTCIF6 = 1UL<<21, // Channel x transfer complete clear (x = 1 ..7)
	DMA1_IFCR_CGIF6 = 1UL<<20, // Channel x global interrupt clear (x = 1 ..7)
	DMA1_IFCR_CTEIF5 = 1UL<<19, // Channel x transfer error clear (x = 1 ..7)
	DMA1_IFCR_CHTIF5 = 1UL<<18, // Channel x half transfer clear (x = 1 ..7)
	DMA1_IFCR_CTCIF5 = 1UL<<17, // Channel x transfer complete clear (x = 1 ..7)
	DMA1_IFCR_CGIF5 = 1UL<<16, // Channel x global interrupt clear (x = 1 ..7)
	DMA1_IFCR_CTEIF4 = 1UL<<15, // Channel x transfer error clear (x = 1 ..7)
	DMA1_IFCR_CHTIF4 = 1UL<<14, // Channel x half transfer clear (x = 1 ..7)
	DMA1_IFCR_CTCIF4 = 1UL<<13, // Channel x transfer complete clear (x = 1 ..7)
	DMA1_IFCR_CGIF4 = 1UL<<12, // Channel x global interrupt clear (x = 1 ..7)
	DMA1_IFCR_CTEIF3 = 1UL<<11, // Channel x transfer error clear (x = 1 ..7)
	DMA1_IFCR_CHTIF3 = 1UL<<10, // Channel x half transfer clear (x = 1 ..7)
	DMA1_IFCR_CTCIF3 = 1UL<<9, // Channel x transfer complete clear (x = 1 ..7)
	DMA1_IFCR_CGIF3 = 1UL<<8, // Channel x global interrupt clear (x = 1 ..7)
	DMA1_IFCR_CTEIF2 = 1UL<<7, // Channel x transfer error clear (x = 1 ..7)
	DMA1_IFCR_CHTIF2 = 1UL<<6, // Channel x half transfer clear (x = 1 ..7)
	DMA1_IFCR_CTCIF2 = 1UL<<5, // Channel x transfer complete clear (x = 1 ..7)
	DMA1_IFCR_CGIF2 = 1UL<<4, // Channel x global interrupt clear (x = 1 ..7)
	DMA1_IFCR_CTEIF1 = 1UL<<3, // Channel x transfer error clear (x = 1 ..7)
	DMA1_IFCR_CHTIF1 = 1UL<<2, // Channel x half transfer clear (x = 1 ..7)
	DMA1_IFCR_CTCIF1 = 1UL<<1, // Channel x transfer complete clear (x = 1 ..7)
	DMA1_IFCR_CGIF1 = 1UL<<0, // Channel x global interrupt clear (x = 1 ..7)		
};

// DMA1->CCR1 channel x configuration register
enum {
	DMA1_CCR1_DUMMY = 1UL<<31, // force this to be a 32 bit register
	DMA1_CCR1_MEM2MEM = 1UL<<14, // Memory to memory mode
	DMA1_CCR1_PL = ((1UL<<2)-1) << 12, // Channel priority level
	DMA1_CCR1_MSIZE = ((1UL<<2)-1) << 10, // Memory size
	DMA1_CCR1_PSIZE = ((1UL<<2)-1) << 8, // Peripheral size
	DMA1_CCR1_MINC = 1UL<<7, // Memory increment mode
	DMA1_CCR1_PINC = 1UL<<6, // Peripheral increment mode
	DMA1_CCR1_CIRC = 1UL<<5, // Circular mode
	DMA1_CCR1_DIR = 1UL<<4, // Data transfer direction
	DMA1_CCR1_TEIE = 1UL<<3, // Transfer error interrupt enable
	DMA1_CCR1_HTIE = 1UL<<2, // Half transfer interrupt enable
	DMA1_CCR1_TCIE = 1UL<<1, // Transfer complete interrupt enable
	DMA1_CCR1_EN = 1UL<<0, // Channel enable		
};
inline void dma1_ccr1_set_pl(struct DMA1_Type* p, uint32_t val) { p->CCR1 = (p->CCR1 & ~DMA1_CCR1_PL) | ((val<<12) & DMA1_CCR1_PL); }
inline void dma1_ccr1_set_msize(struct DMA1_Type* p, uint32_t val) { p->CCR1 = (p->CCR1 & ~DMA1_CCR1_MSIZE) | ((val<<10) & DMA1_CCR1_MSIZE); }
inline void dma1_ccr1_set_psize(struct DMA1_Type* p, uint32_t val) { p->CCR1 = (p->CCR1 & ~DMA1_CCR1_PSIZE) | ((val<<8) & DMA1_CCR1_PSIZE); }
inline uint32_t dma1_ccr1_get_pl(struct DMA1_Type* p) { return (p->CCR1 & DMA1_CCR1_PL) >> 12 ; }
inline uint32_t dma1_ccr1_get_msize(struct DMA1_Type* p) { return (p->CCR1 & DMA1_CCR1_MSIZE) >> 10 ; }
inline uint32_t dma1_ccr1_get_psize(struct DMA1_Type* p) { return (p->CCR1 & DMA1_CCR1_PSIZE) >> 8 ; }

// DMA1->CCR2 channel x configuration register
enum {
	DMA1_CCR2_DUMMY = 1UL<<31, // force this to be a 32 bit register
	DMA1_CCR2_MEM2MEM = 1UL<<14, // Memory to memory mode
	DMA1_CCR2_PL = ((1UL<<2)-1) << 12, // Channel priority level
	DMA1_CCR2_MSIZE = ((1UL<<2)-1) << 10, // Memory size
	DMA1_CCR2_PSIZE = ((1UL<<2)-1) << 8, // Peripheral size
	DMA1_CCR2_MINC = 1UL<<7, // Memory increment mode
	DMA1_CCR2_PINC = 1UL<<6, // Peripheral increment mode
	DMA1_CCR2_CIRC = 1UL<<5, // Circular mode
	DMA1_CCR2_DIR = 1UL<<4, // Data transfer direction
	DMA1_CCR2_TEIE = 1UL<<3, // Transfer error interrupt enable
	DMA1_CCR2_HTIE = 1UL<<2, // Half transfer interrupt enable
	DMA1_CCR2_TCIE = 1UL<<1, // Transfer complete interrupt enable
	DMA1_CCR2_EN = 1UL<<0, // Channel enable		
};
inline void dma1_ccr2_set_pl(struct DMA1_Type* p, uint32_t val) { p->CCR2 = (p->CCR2 & ~DMA1_CCR2_PL) | ((val<<12) & DMA1_CCR2_PL); }
inline void dma1_ccr2_set_msize(struct DMA1_Type* p, uint32_t val) { p->CCR2 = (p->CCR2 & ~DMA1_CCR2_MSIZE) | ((val<<10) & DMA1_CCR2_MSIZE); }
inline void dma1_ccr2_set_psize(struct DMA1_Type* p, uint32_t val) { p->CCR2 = (p->CCR2 & ~DMA1_CCR2_PSIZE) | ((val<<8) & DMA1_CCR2_PSIZE); }
inline uint32_t dma1_ccr2_get_pl(struct DMA1_Type* p) { return (p->CCR2 & DMA1_CCR2_PL) >> 12 ; }
inline uint32_t dma1_ccr2_get_msize(struct DMA1_Type* p) { return (p->CCR2 & DMA1_CCR2_MSIZE) >> 10 ; }
inline uint32_t dma1_ccr2_get_psize(struct DMA1_Type* p) { return (p->CCR2 & DMA1_CCR2_PSIZE) >> 8 ; }

// DMA1->CCR3 channel x configuration register
enum {
	DMA1_CCR3_DUMMY = 1UL<<31, // force this to be a 32 bit register
	DMA1_CCR3_MEM2MEM = 1UL<<14, // Memory to memory mode
	DMA1_CCR3_PL = ((1UL<<2)-1) << 12, // Channel priority level
	DMA1_CCR3_MSIZE = ((1UL<<2)-1) << 10, // Memory size
	DMA1_CCR3_PSIZE = ((1UL<<2)-1) << 8, // Peripheral size
	DMA1_CCR3_MINC = 1UL<<7, // Memory increment mode
	DMA1_CCR3_PINC = 1UL<<6, // Peripheral increment mode
	DMA1_CCR3_CIRC = 1UL<<5, // Circular mode
	DMA1_CCR3_DIR = 1UL<<4, // Data transfer direction
	DMA1_CCR3_TEIE = 1UL<<3, // Transfer error interrupt enable
	DMA1_CCR3_HTIE = 1UL<<2, // Half transfer interrupt enable
	DMA1_CCR3_TCIE = 1UL<<1, // Transfer complete interrupt enable
	DMA1_CCR3_EN = 1UL<<0, // Channel enable		
};
inline void dma1_ccr3_set_pl(struct DMA1_Type* p, uint32_t val) { p->CCR3 = (p->CCR3 & ~DMA1_CCR3_PL) | ((val<<12) & DMA1_CCR3_PL); }
inline void dma1_ccr3_set_msize(struct DMA1_Type* p, uint32_t val) { p->CCR3 = (p->CCR3 & ~DMA1_CCR3_MSIZE) | ((val<<10) & DMA1_CCR3_MSIZE); }
inline void dma1_ccr3_set_psize(struct DMA1_Type* p, uint32_t val) { p->CCR3 = (p->CCR3 & ~DMA1_CCR3_PSIZE) | ((val<<8) & DMA1_CCR3_PSIZE); }
inline uint32_t dma1_ccr3_get_pl(struct DMA1_Type* p) { return (p->CCR3 & DMA1_CCR3_PL) >> 12 ; }
inline uint32_t dma1_ccr3_get_msize(struct DMA1_Type* p) { return (p->CCR3 & DMA1_CCR3_MSIZE) >> 10 ; }
inline uint32_t dma1_ccr3_get_psize(struct DMA1_Type* p) { return (p->CCR3 & DMA1_CCR3_PSIZE) >> 8 ; }

// DMA1->CCR4 channel x configuration register
enum {
	DMA1_CCR4_DUMMY = 1UL<<31, // force this to be a 32 bit register
	DMA1_CCR4_MEM2MEM = 1UL<<14, // Memory to memory mode
	DMA1_CCR4_PL = ((1UL<<2)-1) << 12, // Channel priority level
	DMA1_CCR4_MSIZE = ((1UL<<2)-1) << 10, // Memory size
	DMA1_CCR4_PSIZE = ((1UL<<2)-1) << 8, // Peripheral size
	DMA1_CCR4_MINC = 1UL<<7, // Memory increment mode
	DMA1_CCR4_PINC = 1UL<<6, // Peripheral increment mode
	DMA1_CCR4_CIRC = 1UL<<5, // Circular mode
	DMA1_CCR4_DIR = 1UL<<4, // Data transfer direction
	DMA1_CCR4_TEIE = 1UL<<3, // Transfer error interrupt enable
	DMA1_CCR4_HTIE = 1UL<<2, // Half transfer interrupt enable
	DMA1_CCR4_TCIE = 1UL<<1, // Transfer complete interrupt enable
	DMA1_CCR4_EN = 1UL<<0, // Channel enable		
};
inline void dma1_ccr4_set_pl(struct DMA1_Type* p, uint32_t val) { p->CCR4 = (p->CCR4 & ~DMA1_CCR4_PL) | ((val<<12) & DMA1_CCR4_PL); }
inline void dma1_ccr4_set_msize(struct DMA1_Type* p, uint32_t val) { p->CCR4 = (p->CCR4 & ~DMA1_CCR4_MSIZE) | ((val<<10) & DMA1_CCR4_MSIZE); }
inline void dma1_ccr4_set_psize(struct DMA1_Type* p, uint32_t val) { p->CCR4 = (p->CCR4 & ~DMA1_CCR4_PSIZE) | ((val<<8) & DMA1_CCR4_PSIZE); }
inline uint32_t dma1_ccr4_get_pl(struct DMA1_Type* p) { return (p->CCR4 & DMA1_CCR4_PL) >> 12 ; }
inline uint32_t dma1_ccr4_get_msize(struct DMA1_Type* p) { return (p->CCR4 & DMA1_CCR4_MSIZE) >> 10 ; }
inline uint32_t dma1_ccr4_get_psize(struct DMA1_Type* p) { return (p->CCR4 & DMA1_CCR4_PSIZE) >> 8 ; }

// DMA1->CCR5 channel x configuration register
enum {
	DMA1_CCR5_DUMMY = 1UL<<31, // force this to be a 32 bit register
	DMA1_CCR5_MEM2MEM = 1UL<<14, // Memory to memory mode
	DMA1_CCR5_PL = ((1UL<<2)-1) << 12, // Channel priority level
	DMA1_CCR5_MSIZE = ((1UL<<2)-1) << 10, // Memory size
	DMA1_CCR5_PSIZE = ((1UL<<2)-1) << 8, // Peripheral size
	DMA1_CCR5_MINC = 1UL<<7, // Memory increment mode
	DMA1_CCR5_PINC = 1UL<<6, // Peripheral increment mode
	DMA1_CCR5_CIRC = 1UL<<5, // Circular mode
	DMA1_CCR5_DIR = 1UL<<4, // Data transfer direction
	DMA1_CCR5_TEIE = 1UL<<3, // Transfer error interrupt enable
	DMA1_CCR5_HTIE = 1UL<<2, // Half transfer interrupt enable
	DMA1_CCR5_TCIE = 1UL<<1, // Transfer complete interrupt enable
	DMA1_CCR5_EN = 1UL<<0, // Channel enable		
};
inline void dma1_ccr5_set_pl(struct DMA1_Type* p, uint32_t val) { p->CCR5 = (p->CCR5 & ~DMA1_CCR5_PL) | ((val<<12) & DMA1_CCR5_PL); }
inline void dma1_ccr5_set_msize(struct DMA1_Type* p, uint32_t val) { p->CCR5 = (p->CCR5 & ~DMA1_CCR5_MSIZE) | ((val<<10) & DMA1_CCR5_MSIZE); }
inline void dma1_ccr5_set_psize(struct DMA1_Type* p, uint32_t val) { p->CCR5 = (p->CCR5 & ~DMA1_CCR5_PSIZE) | ((val<<8) & DMA1_CCR5_PSIZE); }
inline uint32_t dma1_ccr5_get_pl(struct DMA1_Type* p) { return (p->CCR5 & DMA1_CCR5_PL) >> 12 ; }
inline uint32_t dma1_ccr5_get_msize(struct DMA1_Type* p) { return (p->CCR5 & DMA1_CCR5_MSIZE) >> 10 ; }
inline uint32_t dma1_ccr5_get_psize(struct DMA1_Type* p) { return (p->CCR5 & DMA1_CCR5_PSIZE) >> 8 ; }

// DMA1->CCR6 channel x configuration register
enum {
	DMA1_CCR6_DUMMY = 1UL<<31, // force this to be a 32 bit register
	DMA1_CCR6_MEM2MEM = 1UL<<14, // Memory to memory mode
	DMA1_CCR6_PL = ((1UL<<2)-1) << 12, // Channel priority level
	DMA1_CCR6_MSIZE = ((1UL<<2)-1) << 10, // Memory size
	DMA1_CCR6_PSIZE = ((1UL<<2)-1) << 8, // Peripheral size
	DMA1_CCR6_MINC = 1UL<<7, // Memory increment mode
	DMA1_CCR6_PINC = 1UL<<6, // Peripheral increment mode
	DMA1_CCR6_CIRC = 1UL<<5, // Circular mode
	DMA1_CCR6_DIR = 1UL<<4, // Data transfer direction
	DMA1_CCR6_TEIE = 1UL<<3, // Transfer error interrupt enable
	DMA1_CCR6_HTIE = 1UL<<2, // Half transfer interrupt enable
	DMA1_CCR6_TCIE = 1UL<<1, // Transfer complete interrupt enable
	DMA1_CCR6_EN = 1UL<<0, // Channel enable		
};
inline void dma1_ccr6_set_pl(struct DMA1_Type* p, uint32_t val) { p->CCR6 = (p->CCR6 & ~DMA1_CCR6_PL) | ((val<<12) & DMA1_CCR6_PL); }
inline void dma1_ccr6_set_msize(struct DMA1_Type* p, uint32_t val) { p->CCR6 = (p->CCR6 & ~DMA1_CCR6_MSIZE) | ((val<<10) & DMA1_CCR6_MSIZE); }
inline void dma1_ccr6_set_psize(struct DMA1_Type* p, uint32_t val) { p->CCR6 = (p->CCR6 & ~DMA1_CCR6_PSIZE) | ((val<<8) & DMA1_CCR6_PSIZE); }
inline uint32_t dma1_ccr6_get_pl(struct DMA1_Type* p) { return (p->CCR6 & DMA1_CCR6_PL) >> 12 ; }
inline uint32_t dma1_ccr6_get_msize(struct DMA1_Type* p) { return (p->CCR6 & DMA1_CCR6_MSIZE) >> 10 ; }
inline uint32_t dma1_ccr6_get_psize(struct DMA1_Type* p) { return (p->CCR6 & DMA1_CCR6_PSIZE) >> 8 ; }

// DMA1->CCR7 channel x configuration register
enum {
	DMA1_CCR7_DUMMY = 1UL<<31, // force this to be a 32 bit register
	DMA1_CCR7_MEM2MEM = 1UL<<14, // Memory to memory mode
	DMA1_CCR7_PL = ((1UL<<2)-1) << 12, // Channel priority level
	DMA1_CCR7_MSIZE = ((1UL<<2)-1) << 10, // Memory size
	DMA1_CCR7_PSIZE = ((1UL<<2)-1) << 8, // Peripheral size
	DMA1_CCR7_MINC = 1UL<<7, // Memory increment mode
	DMA1_CCR7_PINC = 1UL<<6, // Peripheral increment mode
	DMA1_CCR7_CIRC = 1UL<<5, // Circular mode
	DMA1_CCR7_DIR = 1UL<<4, // Data transfer direction
	DMA1_CCR7_TEIE = 1UL<<3, // Transfer error interrupt enable
	DMA1_CCR7_HTIE = 1UL<<2, // Half transfer interrupt enable
	DMA1_CCR7_TCIE = 1UL<<1, // Transfer complete interrupt enable
	DMA1_CCR7_EN = 1UL<<0, // Channel enable		
};
inline void dma1_ccr7_set_pl(struct DMA1_Type* p, uint32_t val) { p->CCR7 = (p->CCR7 & ~DMA1_CCR7_PL) | ((val<<12) & DMA1_CCR7_PL); }
inline void dma1_ccr7_set_msize(struct DMA1_Type* p, uint32_t val) { p->CCR7 = (p->CCR7 & ~DMA1_CCR7_MSIZE) | ((val<<10) & DMA1_CCR7_MSIZE); }
inline void dma1_ccr7_set_psize(struct DMA1_Type* p, uint32_t val) { p->CCR7 = (p->CCR7 & ~DMA1_CCR7_PSIZE) | ((val<<8) & DMA1_CCR7_PSIZE); }
inline uint32_t dma1_ccr7_get_pl(struct DMA1_Type* p) { return (p->CCR7 & DMA1_CCR7_PL) >> 12 ; }
inline uint32_t dma1_ccr7_get_msize(struct DMA1_Type* p) { return (p->CCR7 & DMA1_CCR7_MSIZE) >> 10 ; }
inline uint32_t dma1_ccr7_get_psize(struct DMA1_Type* p) { return (p->CCR7 & DMA1_CCR7_PSIZE) >> 8 ; }

// DMA1->CSELR channel selection register
enum {
	DMA1_CSELR_C7S = ((1UL<<4)-1) << 24, // DMA channel 7 selection
	DMA1_CSELR_C6S = ((1UL<<4)-1) << 20, // DMA channel 6 selection
	DMA1_CSELR_C5S = ((1UL<<4)-1) << 16, // DMA channel 5 selection
	DMA1_CSELR_C4S = ((1UL<<4)-1) << 12, // DMA channel 4 selection
	DMA1_CSELR_C3S = ((1UL<<4)-1) << 8, // DMA channel 3 selection
	DMA1_CSELR_C2S = ((1UL<<4)-1) << 4, // DMA channel 2 selection
	DMA1_CSELR_C1S = ((1UL<<4)-1) << 0, // DMA channel 1 selection		
};
inline void dma1_cselr_set_c7s(struct DMA1_Type* p, uint32_t val) { p->CSELR = (p->CSELR & ~DMA1_CSELR_C7S) | ((val<<24) & DMA1_CSELR_C7S); }
inline void dma1_cselr_set_c6s(struct DMA1_Type* p, uint32_t val) { p->CSELR = (p->CSELR & ~DMA1_CSELR_C6S) | ((val<<20) & DMA1_CSELR_C6S); }
inline void dma1_cselr_set_c5s(struct DMA1_Type* p, uint32_t val) { p->CSELR = (p->CSELR & ~DMA1_CSELR_C5S) | ((val<<16) & DMA1_CSELR_C5S); }
inline void dma1_cselr_set_c4s(struct DMA1_Type* p, uint32_t val) { p->CSELR = (p->CSELR & ~DMA1_CSELR_C4S) | ((val<<12) & DMA1_CSELR_C4S); }
inline void dma1_cselr_set_c3s(struct DMA1_Type* p, uint32_t val) { p->CSELR = (p->CSELR & ~DMA1_CSELR_C3S) | ((val<<8) & DMA1_CSELR_C3S); }
inline void dma1_cselr_set_c2s(struct DMA1_Type* p, uint32_t val) { p->CSELR = (p->CSELR & ~DMA1_CSELR_C2S) | ((val<<4) & DMA1_CSELR_C2S); }
inline void dma1_cselr_set_c1s(struct DMA1_Type* p, uint32_t val) { p->CSELR = (p->CSELR & ~DMA1_CSELR_C1S) | ((val<<0) & DMA1_CSELR_C1S); }
inline uint32_t dma1_cselr_get_c7s(struct DMA1_Type* p) { return (p->CSELR & DMA1_CSELR_C7S) >> 24 ; }
inline uint32_t dma1_cselr_get_c6s(struct DMA1_Type* p) { return (p->CSELR & DMA1_CSELR_C6S) >> 20 ; }
inline uint32_t dma1_cselr_get_c5s(struct DMA1_Type* p) { return (p->CSELR & DMA1_CSELR_C5S) >> 16 ; }
inline uint32_t dma1_cselr_get_c4s(struct DMA1_Type* p) { return (p->CSELR & DMA1_CSELR_C4S) >> 12 ; }
inline uint32_t dma1_cselr_get_c3s(struct DMA1_Type* p) { return (p->CSELR & DMA1_CSELR_C3S) >> 8 ; }
inline uint32_t dma1_cselr_get_c2s(struct DMA1_Type* p) { return (p->CSELR & DMA1_CSELR_C2S) >> 4 ; }
inline uint32_t dma1_cselr_get_c1s(struct DMA1_Type* p) { return (p->CSELR & DMA1_CSELR_C1S) >> 0 ; }


/* External interrupt/event controller */
struct EXTI_Type {
	__IO uint32_t IMR1; // @0 Interrupt mask register
	__IO uint32_t EMR1; // @4 Event mask register
	__IO uint32_t RTSR1; // @8 Rising Trigger selection register
	__IO uint32_t FTSR1; // @12 Falling Trigger selection register
	__IO uint32_t SWIER1; // @16 Software interrupt event register
	__IO uint32_t PR1; // @20 Pending register
	 uint8_t RESERVED0[8]; // @24 
	__IO uint8_t IMR2; // @32 Interrupt mask register
	 uint8_t RESERVED1[3]; // @33 
	__IO uint8_t EMR2; // @36 Event mask register
	 uint8_t RESERVED2[3]; // @37 
	__IO uint8_t RTSR2; // @40 Rising Trigger selection register
	 uint8_t RESERVED3[3]; // @41 
	__IO uint8_t FTSR2; // @44 Falling Trigger selection register
	 uint8_t RESERVED4[3]; // @45 
	__IO uint8_t SWIER2; // @48 Software interrupt event register
	 uint8_t RESERVED5[3]; // @49 
	__IO uint8_t PR2; // @52 Pending register
};

// EXTI->RTSR1 Rising Trigger selection register
enum {
	EXTI_RTSR1_TR22 = 1UL<<22, // Rising trigger event configuration of line 22
	EXTI_RTSR1_TR21 = 1UL<<21, // Rising trigger event configuration of line 21
	EXTI_RTSR1_TR20 = 1UL<<20, // Rising trigger event configuration of line 20
	EXTI_RTSR1_TR19 = 1UL<<19, // Rising trigger event configuration of line 19
	EXTI_RTSR1_TR18 = 1UL<<18, // Rising trigger event configuration of line 18
	EXTI_RTSR1_TR16 = 1UL<<16, // Rising trigger event configuration of line 16
	EXTI_RTSR1_TR15 = 1UL<<15, // Rising trigger event configuration of line 15
	EXTI_RTSR1_TR14 = 1UL<<14, // Rising trigger event configuration of line 14
	EXTI_RTSR1_TR13 = 1UL<<13, // Rising trigger event configuration of line 13
	EXTI_RTSR1_TR12 = 1UL<<12, // Rising trigger event configuration of line 12
	EXTI_RTSR1_TR11 = 1UL<<11, // Rising trigger event configuration of line 11
	EXTI_RTSR1_TR10 = 1UL<<10, // Rising trigger event configuration of line 10
	EXTI_RTSR1_TR9 = 1UL<<9, // Rising trigger event configuration of line 9
	EXTI_RTSR1_TR8 = 1UL<<8, // Rising trigger event configuration of line 8
	EXTI_RTSR1_TR7 = 1UL<<7, // Rising trigger event configuration of line 7
	EXTI_RTSR1_TR6 = 1UL<<6, // Rising trigger event configuration of line 6
	EXTI_RTSR1_TR5 = 1UL<<5, // Rising trigger event configuration of line 5
	EXTI_RTSR1_TR4 = 1UL<<4, // Rising trigger event configuration of line 4
	EXTI_RTSR1_TR3 = 1UL<<3, // Rising trigger event configuration of line 3
	EXTI_RTSR1_TR2 = 1UL<<2, // Rising trigger event configuration of line 2
	EXTI_RTSR1_TR1 = 1UL<<1, // Rising trigger event configuration of line 1
	EXTI_RTSR1_TR0 = 1UL<<0, // Rising trigger event configuration of line 0		
};

// EXTI->FTSR1 Falling Trigger selection register
enum {
	EXTI_FTSR1_TR22 = 1UL<<22, // Falling trigger event configuration of line 22
	EXTI_FTSR1_TR21 = 1UL<<21, // Falling trigger event configuration of line 21
	EXTI_FTSR1_TR20 = 1UL<<20, // Falling trigger event configuration of line 20
	EXTI_FTSR1_TR19 = 1UL<<19, // Falling trigger event configuration of line 19
	EXTI_FTSR1_TR18 = 1UL<<18, // Falling trigger event configuration of line 18
	EXTI_FTSR1_TR16 = 1UL<<16, // Falling trigger event configuration of line 16
	EXTI_FTSR1_TR15 = 1UL<<15, // Falling trigger event configuration of line 15
	EXTI_FTSR1_TR14 = 1UL<<14, // Falling trigger event configuration of line 14
	EXTI_FTSR1_TR13 = 1UL<<13, // Falling trigger event configuration of line 13
	EXTI_FTSR1_TR12 = 1UL<<12, // Falling trigger event configuration of line 12
	EXTI_FTSR1_TR11 = 1UL<<11, // Falling trigger event configuration of line 11
	EXTI_FTSR1_TR10 = 1UL<<10, // Falling trigger event configuration of line 10
	EXTI_FTSR1_TR9 = 1UL<<9, // Falling trigger event configuration of line 9
	EXTI_FTSR1_TR8 = 1UL<<8, // Falling trigger event configuration of line 8
	EXTI_FTSR1_TR7 = 1UL<<7, // Falling trigger event configuration of line 7
	EXTI_FTSR1_TR6 = 1UL<<6, // Falling trigger event configuration of line 6
	EXTI_FTSR1_TR5 = 1UL<<5, // Falling trigger event configuration of line 5
	EXTI_FTSR1_TR4 = 1UL<<4, // Falling trigger event configuration of line 4
	EXTI_FTSR1_TR3 = 1UL<<3, // Falling trigger event configuration of line 3
	EXTI_FTSR1_TR2 = 1UL<<2, // Falling trigger event configuration of line 2
	EXTI_FTSR1_TR1 = 1UL<<1, // Falling trigger event configuration of line 1
	EXTI_FTSR1_TR0 = 1UL<<0, // Falling trigger event configuration of line 0		
};

// EXTI->SWIER1 Software interrupt event register
enum {
	EXTI_SWIER1_SWIER22 = 1UL<<22, // Software Interrupt on line 22
	EXTI_SWIER1_SWIER21 = 1UL<<21, // Software Interrupt on line 21
	EXTI_SWIER1_SWIER20 = 1UL<<20, // Software Interrupt on line 20
	EXTI_SWIER1_SWIER19 = 1UL<<19, // Software Interrupt on line 19
	EXTI_SWIER1_SWIER18 = 1UL<<18, // Software Interrupt on line 18
	EXTI_SWIER1_SWIER16 = 1UL<<16, // Software Interrupt on line 16
	EXTI_SWIER1_SWIER15 = 1UL<<15, // Software Interrupt on line 15
	EXTI_SWIER1_SWIER14 = 1UL<<14, // Software Interrupt on line 14
	EXTI_SWIER1_SWIER13 = 1UL<<13, // Software Interrupt on line 13
	EXTI_SWIER1_SWIER12 = 1UL<<12, // Software Interrupt on line 12
	EXTI_SWIER1_SWIER11 = 1UL<<11, // Software Interrupt on line 11
	EXTI_SWIER1_SWIER10 = 1UL<<10, // Software Interrupt on line 10
	EXTI_SWIER1_SWIER9 = 1UL<<9, // Software Interrupt on line 9
	EXTI_SWIER1_SWIER8 = 1UL<<8, // Software Interrupt on line 8
	EXTI_SWIER1_SWIER7 = 1UL<<7, // Software Interrupt on line 7
	EXTI_SWIER1_SWIER6 = 1UL<<6, // Software Interrupt on line 6
	EXTI_SWIER1_SWIER5 = 1UL<<5, // Software Interrupt on line 5
	EXTI_SWIER1_SWIER4 = 1UL<<4, // Software Interrupt on line 4
	EXTI_SWIER1_SWIER3 = 1UL<<3, // Software Interrupt on line 3
	EXTI_SWIER1_SWIER2 = 1UL<<2, // Software Interrupt on line 2
	EXTI_SWIER1_SWIER1 = 1UL<<1, // Software Interrupt on line 1
	EXTI_SWIER1_SWIER0 = 1UL<<0, // Software Interrupt on line 0		
};

// EXTI->PR1 Pending register
enum {
	EXTI_PR1_PR22 = 1UL<<22, // Pending bit 22
	EXTI_PR1_PR21 = 1UL<<21, // Pending bit 21
	EXTI_PR1_PR20 = 1UL<<20, // Pending bit 20
	EXTI_PR1_PR19 = 1UL<<19, // Pending bit 19
	EXTI_PR1_PR18 = 1UL<<18, // Pending bit 18
	EXTI_PR1_PR16 = 1UL<<16, // Pending bit 16
	EXTI_PR1_PR15 = 1UL<<15, // Pending bit 15
	EXTI_PR1_PR14 = 1UL<<14, // Pending bit 14
	EXTI_PR1_PR13 = 1UL<<13, // Pending bit 13
	EXTI_PR1_PR12 = 1UL<<12, // Pending bit 12
	EXTI_PR1_PR11 = 1UL<<11, // Pending bit 11
	EXTI_PR1_PR10 = 1UL<<10, // Pending bit 10
	EXTI_PR1_PR9 = 1UL<<9, // Pending bit 9
	EXTI_PR1_PR8 = 1UL<<8, // Pending bit 8
	EXTI_PR1_PR7 = 1UL<<7, // Pending bit 7
	EXTI_PR1_PR6 = 1UL<<6, // Pending bit 6
	EXTI_PR1_PR5 = 1UL<<5, // Pending bit 5
	EXTI_PR1_PR4 = 1UL<<4, // Pending bit 4
	EXTI_PR1_PR3 = 1UL<<3, // Pending bit 3
	EXTI_PR1_PR2 = 1UL<<2, // Pending bit 2
	EXTI_PR1_PR1 = 1UL<<1, // Pending bit 1
	EXTI_PR1_PR0 = 1UL<<0, // Pending bit 0		
};

// EXTI->RTSR2 Rising Trigger selection register
enum {
	EXTI_RTSR2_RT38 = 1UL<<6, // Rising trigger event configuration bit of line 38
	EXTI_RTSR2_RT37 = 1UL<<5, // Rising trigger event configuration bit of line 37
	EXTI_RTSR2_RT36 = 1UL<<4, // Rising trigger event configuration bit of line 36
	EXTI_RTSR2_RT35 = 1UL<<3, // Rising trigger event configuration bit of line 35		
};

// EXTI->FTSR2 Falling Trigger selection register
enum {
	EXTI_FTSR2_FT38 = 1UL<<6, // Falling trigger event configuration bit of line 38
	EXTI_FTSR2_FT37 = 1UL<<5, // Falling trigger event configuration bit of line 37
	EXTI_FTSR2_FT36 = 1UL<<4, // Falling trigger event configuration bit of line 36
	EXTI_FTSR2_FT35 = 1UL<<3, // Falling trigger event configuration bit of line 35		
};

// EXTI->SWIER2 Software interrupt event register
enum {
	EXTI_SWIER2_SWI38 = 1UL<<6, // Software interrupt on line 38
	EXTI_SWIER2_SWI37 = 1UL<<5, // Software interrupt on line 37
	EXTI_SWIER2_SWI36 = 1UL<<4, // Software interrupt on line 36
	EXTI_SWIER2_SWI35 = 1UL<<3, // Software interrupt on line 35		
};

// EXTI->PR2 Pending register
enum {
	EXTI_PR2_PIF38 = 1UL<<6, // Pending interrupt flag on line 38
	EXTI_PR2_PIF37 = 1UL<<5, // Pending interrupt flag on line 37
	EXTI_PR2_PIF36 = 1UL<<4, // Pending interrupt flag on line 36
	EXTI_PR2_PIF35 = 1UL<<3, // Pending interrupt flag on line 35		
};

/* Firewall */
struct FIREWALL_Type {
	__IO uint32_t CSSA; // @0 Code segment start address
	__IO uint32_t CSL; // @4 Code segment length
	__IO uint32_t NVDSSA; // @8 Non-volatile data segment start address
	__IO uint32_t NVDSL; // @12 Non-volatile data segment length
	__IO uint16_t VDSSA; // @16 Volatile data segment start address
	 uint8_t RESERVED0[2]; // @18 
	__IO uint16_t VDSL; // @20 Volatile data segment length
	 uint8_t RESERVED1[10]; // @22 
	__IO uint8_t CR; // @32 Configuration register
};

// FIREWALL->CSSA Code segment start address
enum {
	FIREWALL_CSSA_ADD = ((1UL<<16)-1) << 8, // code segment start address		
};
inline void firewall_cssa_set_add(struct FIREWALL_Type* p, uint32_t val) { p->CSSA = (p->CSSA & ~FIREWALL_CSSA_ADD) | ((val<<8) & FIREWALL_CSSA_ADD); }
inline uint32_t firewall_cssa_get_add(struct FIREWALL_Type* p) { return (p->CSSA & FIREWALL_CSSA_ADD) >> 8 ; }

// FIREWALL->CSL Code segment length
enum {
	FIREWALL_CSL_LENG = ((1UL<<14)-1) << 8, // code segment length		
};
inline void firewall_csl_set_leng(struct FIREWALL_Type* p, uint32_t val) { p->CSL = (p->CSL & ~FIREWALL_CSL_LENG) | ((val<<8) & FIREWALL_CSL_LENG); }
inline uint32_t firewall_csl_get_leng(struct FIREWALL_Type* p) { return (p->CSL & FIREWALL_CSL_LENG) >> 8 ; }

// FIREWALL->NVDSSA Non-volatile data segment start address
enum {
	FIREWALL_NVDSSA_ADD = ((1UL<<16)-1) << 8, // Non-volatile data segment start address		
};
inline void firewall_nvdssa_set_add(struct FIREWALL_Type* p, uint32_t val) { p->NVDSSA = (p->NVDSSA & ~FIREWALL_NVDSSA_ADD) | ((val<<8) & FIREWALL_NVDSSA_ADD); }
inline uint32_t firewall_nvdssa_get_add(struct FIREWALL_Type* p) { return (p->NVDSSA & FIREWALL_NVDSSA_ADD) >> 8 ; }

// FIREWALL->NVDSL Non-volatile data segment length
enum {
	FIREWALL_NVDSL_LENG = ((1UL<<14)-1) << 8, // Non-volatile data segment length		
};
inline void firewall_nvdsl_set_leng(struct FIREWALL_Type* p, uint32_t val) { p->NVDSL = (p->NVDSL & ~FIREWALL_NVDSL_LENG) | ((val<<8) & FIREWALL_NVDSL_LENG); }
inline uint32_t firewall_nvdsl_get_leng(struct FIREWALL_Type* p) { return (p->NVDSL & FIREWALL_NVDSL_LENG) >> 8 ; }

// FIREWALL->VDSSA Volatile data segment start address
enum {
	FIREWALL_VDSSA_ADD = ((1UL<<10)-1) << 6, // Volatile data segment start address		
};
inline void firewall_vdssa_set_add(struct FIREWALL_Type* p, uint32_t val) { p->VDSSA = (p->VDSSA & ~FIREWALL_VDSSA_ADD) | ((val<<6) & FIREWALL_VDSSA_ADD); }
inline uint32_t firewall_vdssa_get_add(struct FIREWALL_Type* p) { return (p->VDSSA & FIREWALL_VDSSA_ADD) >> 6 ; }

// FIREWALL->VDSL Volatile data segment length
enum {
	FIREWALL_VDSL_LENG = ((1UL<<10)-1) << 6, // Non-volatile data segment length		
};
inline void firewall_vdsl_set_leng(struct FIREWALL_Type* p, uint32_t val) { p->VDSL = (p->VDSL & ~FIREWALL_VDSL_LENG) | ((val<<6) & FIREWALL_VDSL_LENG); }
inline uint32_t firewall_vdsl_get_leng(struct FIREWALL_Type* p) { return (p->VDSL & FIREWALL_VDSL_LENG) >> 6 ; }

// FIREWALL->CR Configuration register
enum {
	FIREWALL_CR_VDE = 1UL<<2, // Volatile data execution
	FIREWALL_CR_VDS = 1UL<<1, // Volatile data shared
	FIREWALL_CR_FPA = 1UL<<0, // Firewall pre alarm		
};

/* Flash */
struct FLASH_Type {
	__IO uint16_t ACR; // @0 Access control register
	 uint8_t RESERVED0[2]; // @2 
	__O uint32_t PDKEYR; // @4 Power down key register
	__O uint32_t KEYR; // @8 Flash key register
	__O uint32_t OPTKEYR; // @12 Option byte key register
	__IO uint32_t SR; // @16 Status register
	__IO uint32_t CR; // @20 Flash control register
	__IO uint32_t ECCR; // @24 Flash ECC register
	 uint8_t RESERVED1[4]; // @28 
	__IO uint32_t OPTR; // @32 Flash option register
	__IO uint16_t PCROP1SR; // @36 Flash Bank 1 PCROP Start address register
	 uint8_t RESERVED2[2]; // @38 
	__IO uint32_t PCROP1ER; // @40 Flash Bank 1 PCROP End address register
	__IO uint32_t WRP1AR; // @44 Flash Bank 1 WRP area A address register
	__IO uint32_t WRP1BR; // @48 Flash Bank 1 WRP area B address register
	 uint8_t RESERVED3[16]; // @52 
	__IO uint16_t PCROP2SR; // @68 Flash Bank 2 PCROP Start address register
	 uint8_t RESERVED4[2]; // @70 
	__IO uint16_t PCROP2ER; // @72 Flash Bank 2 PCROP End address register
	 uint8_t RESERVED5[2]; // @74 
	__IO uint32_t WRP2AR; // @76 Flash Bank 2 WRP area A address register
	__IO uint32_t WRP2BR; // @80 Flash Bank 2 WRP area B address register
};

// FLASH->ACR Access control register
enum {
	FLASH_ACR_SLEEP_PD = 1UL<<14, // Flash Power-down mode during Low-power sleep mode
	FLASH_ACR_RUN_PD = 1UL<<13, // Flash Power-down mode during Low-power run mode
	FLASH_ACR_DCRST = 1UL<<12, // Data cache reset
	FLASH_ACR_ICRST = 1UL<<11, // Instruction cache reset
	FLASH_ACR_DCEN = 1UL<<10, // Data cache enable
	FLASH_ACR_ICEN = 1UL<<9, // Instruction cache enable
	FLASH_ACR_PRFTEN = 1UL<<8, // Prefetch enable
	FLASH_ACR_LATENCY = ((1UL<<3)-1) << 0, // Latency		
};
inline void flash_acr_set_latency(struct FLASH_Type* p, uint32_t val) { p->ACR = (p->ACR & ~FLASH_ACR_LATENCY) | ((val<<0) & FLASH_ACR_LATENCY); }
inline uint32_t flash_acr_get_latency(struct FLASH_Type* p) { return (p->ACR & FLASH_ACR_LATENCY) >> 0 ; }

// FLASH->SR Status register
enum {
	FLASH_SR_BSY = 1UL<<16, // Busy
	FLASH_SR_OPTVERR = 1UL<<15, // Option validity error
	FLASH_SR_RDERR = 1UL<<14, // PCROP read error
	FLASH_SR_FASTERR = 1UL<<9, // Fast programming error
	FLASH_SR_MISERR = 1UL<<8, // Fast programming data miss error
	FLASH_SR_PGSERR = 1UL<<7, // Programming sequence error
	FLASH_SR_SIZERR = 1UL<<6, // Size error
	FLASH_SR_PGAERR = 1UL<<5, // Programming alignment error
	FLASH_SR_WRPERR = 1UL<<4, // Write protected error
	FLASH_SR_PROGERR = 1UL<<3, // Programming error
	FLASH_SR_OPERR = 1UL<<1, // Operation error
	FLASH_SR_EOP = 1UL<<0, // End of operation		
};

// FLASH->CR Flash control register
enum {
	FLASH_CR_LOCK = 1UL<<31, // FLASH_CR Lock
	FLASH_CR_OPTLOCK = 1UL<<30, // Options Lock
	FLASH_CR_OBL_LAUNCH = 1UL<<27, // Force the option byte loading
	FLASH_CR_RDERRIE = 1UL<<26, // PCROP read error interrupt enable
	FLASH_CR_ERRIE = 1UL<<25, // Error interrupt enable
	FLASH_CR_EOPIE = 1UL<<24, // End of operation interrupt enable
	FLASH_CR_FSTPG = 1UL<<18, // Fast programming
	FLASH_CR_OPTSTRT = 1UL<<17, // Options modification start
	FLASH_CR_START = 1UL<<16, // Start
	FLASH_CR_MER2 = 1UL<<15, // Bank 2 Mass erase
	FLASH_CR_BKER = 1UL<<11, // Bank erase
	FLASH_CR_PNB = ((1UL<<8)-1) << 3, // Page number
	FLASH_CR_MER1 = 1UL<<2, // Bank 1 Mass erase
	FLASH_CR_PER = 1UL<<1, // Page erase
	FLASH_CR_PG = 1UL<<0, // Programming		
};
inline void flash_cr_set_pnb(struct FLASH_Type* p, uint32_t val) { p->CR = (p->CR & ~FLASH_CR_PNB) | ((val<<3) & FLASH_CR_PNB); }
inline uint32_t flash_cr_get_pnb(struct FLASH_Type* p) { return (p->CR & FLASH_CR_PNB) >> 3 ; }

// FLASH->ECCR Flash ECC register
enum {
	FLASH_ECCR_ECCD = 1UL<<31, // ECC detection
	FLASH_ECCR_ECCC = 1UL<<30, // ECC correction
	FLASH_ECCR_ECCIE = 1UL<<24, // ECC correction interrupt enable
	FLASH_ECCR_SYSF_ECC = 1UL<<20, // System Flash ECC fail
	FLASH_ECCR_BK_ECC = 1UL<<19, // ECC fail bank
	FLASH_ECCR_ADDR_ECC = ((1UL<<19)-1) << 0, // ECC fail address		
};
inline void flash_eccr_set_addr_ecc(struct FLASH_Type* p, uint32_t val) { p->ECCR = (p->ECCR & ~FLASH_ECCR_ADDR_ECC) | ((val<<0) & FLASH_ECCR_ADDR_ECC); }
inline uint32_t flash_eccr_get_addr_ecc(struct FLASH_Type* p) { return (p->ECCR & FLASH_ECCR_ADDR_ECC) >> 0 ; }

// FLASH->OPTR Flash option register
enum {
	FLASH_OPTR_SRAM2_RST = 1UL<<25, // SRAM2 Erase when system reset
	FLASH_OPTR_SRAM2_PE = 1UL<<24, // SRAM2 parity check enable
	FLASH_OPTR_NBOOT1 = 1UL<<23, // Boot configuration
	FLASH_OPTR_DUALBANK = 1UL<<21, // Dual-Bank on 512 KB or 256 KB Flash memory devices
	FLASH_OPTR_BFB2 = 1UL<<20, // Dual-bank boot
	FLASH_OPTR_WWDG_SW = 1UL<<19, // Window watchdog selection
	FLASH_OPTR_IWDG_STDBY = 1UL<<18, // Independent watchdog counter freeze in Standby mode
	FLASH_OPTR_IWDG_STOP = 1UL<<17, // Independent watchdog counter freeze in Stop mode
	FLASH_OPTR_IDWG_SW = 1UL<<16, // Independent watchdog selection
	FLASH_OPTR_NRST_STDBY = 1UL<<13, // nRST_STDBY
	FLASH_OPTR_NRST_STOP = 1UL<<12, // nRST_STOP
	FLASH_OPTR_BOR_LEV = ((1UL<<3)-1) << 8, // BOR reset Level
	FLASH_OPTR_RDP = ((1UL<<8)-1) << 0, // Read protection level		
};
inline void flash_optr_set_bor_lev(struct FLASH_Type* p, uint32_t val) { p->OPTR = (p->OPTR & ~FLASH_OPTR_BOR_LEV) | ((val<<8) & FLASH_OPTR_BOR_LEV); }
inline void flash_optr_set_rdp(struct FLASH_Type* p, uint32_t val) { p->OPTR = (p->OPTR & ~FLASH_OPTR_RDP) | ((val<<0) & FLASH_OPTR_RDP); }
inline uint32_t flash_optr_get_bor_lev(struct FLASH_Type* p) { return (p->OPTR & FLASH_OPTR_BOR_LEV) >> 8 ; }
inline uint32_t flash_optr_get_rdp(struct FLASH_Type* p) { return (p->OPTR & FLASH_OPTR_RDP) >> 0 ; }

// FLASH->PCROP1ER Flash Bank 1 PCROP End address register
enum {
	FLASH_PCROP1ER_PCROP_RDP = 1UL<<31, // PCROP area preserved when RDP level decreased
	FLASH_PCROP1ER_PCROP1_END = ((1UL<<16)-1) << 0, // Bank 1 PCROP area end offset		
};
inline void flash_pcrop1er_set_pcrop1_end(struct FLASH_Type* p, uint32_t val) { p->PCROP1ER = (p->PCROP1ER & ~FLASH_PCROP1ER_PCROP1_END) | ((val<<0) & FLASH_PCROP1ER_PCROP1_END); }
inline uint32_t flash_pcrop1er_get_pcrop1_end(struct FLASH_Type* p) { return (p->PCROP1ER & FLASH_PCROP1ER_PCROP1_END) >> 0 ; }

// FLASH->WRP1AR Flash Bank 1 WRP area A address register
enum {
	FLASH_WRP1AR_WRP1A_END = ((1UL<<8)-1) << 16, // Bank 1 WRP first area A end offset
	FLASH_WRP1AR_WRP1A_STRT = ((1UL<<8)-1) << 0, // Bank 1 WRP first area tart offset		
};
inline void flash_wrp1ar_set_wrp1a_end(struct FLASH_Type* p, uint32_t val) { p->WRP1AR = (p->WRP1AR & ~FLASH_WRP1AR_WRP1A_END) | ((val<<16) & FLASH_WRP1AR_WRP1A_END); }
inline void flash_wrp1ar_set_wrp1a_strt(struct FLASH_Type* p, uint32_t val) { p->WRP1AR = (p->WRP1AR & ~FLASH_WRP1AR_WRP1A_STRT) | ((val<<0) & FLASH_WRP1AR_WRP1A_STRT); }
inline uint32_t flash_wrp1ar_get_wrp1a_end(struct FLASH_Type* p) { return (p->WRP1AR & FLASH_WRP1AR_WRP1A_END) >> 16 ; }
inline uint32_t flash_wrp1ar_get_wrp1a_strt(struct FLASH_Type* p) { return (p->WRP1AR & FLASH_WRP1AR_WRP1A_STRT) >> 0 ; }

// FLASH->WRP1BR Flash Bank 1 WRP area B address register
enum {
	FLASH_WRP1BR_WRP1B_STRT = ((1UL<<8)-1) << 16, // Bank 1 WRP second area B end offset
	FLASH_WRP1BR_WRP1B_END = ((1UL<<8)-1) << 0, // Bank 1 WRP second area B start offset		
};
inline void flash_wrp1br_set_wrp1b_strt(struct FLASH_Type* p, uint32_t val) { p->WRP1BR = (p->WRP1BR & ~FLASH_WRP1BR_WRP1B_STRT) | ((val<<16) & FLASH_WRP1BR_WRP1B_STRT); }
inline void flash_wrp1br_set_wrp1b_end(struct FLASH_Type* p, uint32_t val) { p->WRP1BR = (p->WRP1BR & ~FLASH_WRP1BR_WRP1B_END) | ((val<<0) & FLASH_WRP1BR_WRP1B_END); }
inline uint32_t flash_wrp1br_get_wrp1b_strt(struct FLASH_Type* p) { return (p->WRP1BR & FLASH_WRP1BR_WRP1B_STRT) >> 16 ; }
inline uint32_t flash_wrp1br_get_wrp1b_end(struct FLASH_Type* p) { return (p->WRP1BR & FLASH_WRP1BR_WRP1B_END) >> 0 ; }

// FLASH->WRP2AR Flash Bank 2 WRP area A address register
enum {
	FLASH_WRP2AR_WRP2A_END = ((1UL<<8)-1) << 16, // Bank 2 WRP first area A end offset
	FLASH_WRP2AR_WRP2A_STRT = ((1UL<<8)-1) << 0, // Bank 2 WRP first area A start offset		
};
inline void flash_wrp2ar_set_wrp2a_end(struct FLASH_Type* p, uint32_t val) { p->WRP2AR = (p->WRP2AR & ~FLASH_WRP2AR_WRP2A_END) | ((val<<16) & FLASH_WRP2AR_WRP2A_END); }
inline void flash_wrp2ar_set_wrp2a_strt(struct FLASH_Type* p, uint32_t val) { p->WRP2AR = (p->WRP2AR & ~FLASH_WRP2AR_WRP2A_STRT) | ((val<<0) & FLASH_WRP2AR_WRP2A_STRT); }
inline uint32_t flash_wrp2ar_get_wrp2a_end(struct FLASH_Type* p) { return (p->WRP2AR & FLASH_WRP2AR_WRP2A_END) >> 16 ; }
inline uint32_t flash_wrp2ar_get_wrp2a_strt(struct FLASH_Type* p) { return (p->WRP2AR & FLASH_WRP2AR_WRP2A_STRT) >> 0 ; }

// FLASH->WRP2BR Flash Bank 2 WRP area B address register
enum {
	FLASH_WRP2BR_WRP2B_END = ((1UL<<8)-1) << 16, // Bank 2 WRP second area B end offset
	FLASH_WRP2BR_WRP2B_STRT = ((1UL<<8)-1) << 0, // Bank 2 WRP second area B start offset		
};
inline void flash_wrp2br_set_wrp2b_end(struct FLASH_Type* p, uint32_t val) { p->WRP2BR = (p->WRP2BR & ~FLASH_WRP2BR_WRP2B_END) | ((val<<16) & FLASH_WRP2BR_WRP2B_END); }
inline void flash_wrp2br_set_wrp2b_strt(struct FLASH_Type* p, uint32_t val) { p->WRP2BR = (p->WRP2BR & ~FLASH_WRP2BR_WRP2B_STRT) | ((val<<0) & FLASH_WRP2BR_WRP2B_STRT); }
inline uint32_t flash_wrp2br_get_wrp2b_end(struct FLASH_Type* p) { return (p->WRP2BR & FLASH_WRP2BR_WRP2B_END) >> 16 ; }
inline uint32_t flash_wrp2br_get_wrp2b_strt(struct FLASH_Type* p) { return (p->WRP2BR & FLASH_WRP2BR_WRP2B_STRT) >> 0 ; }

/* Floting point unit */
struct FPU_Type {
	__IO uint32_t FPCCR; // @0 Floating-point context control register
	__IO uint32_t FPCAR; // @4 Floating-point context address register
	__IO uint32_t FPSCR; // @8 Floating-point status control register
};

// FPU->FPCCR Floating-point context control register
enum {
	FPU_FPCCR_ASPEN = 1UL<<31, // ASPEN
	FPU_FPCCR_LSPEN = 1UL<<30, // LSPEN
	FPU_FPCCR_MONRDY = 1UL<<8, // MONRDY
	FPU_FPCCR_BFRDY = 1UL<<6, // BFRDY
	FPU_FPCCR_MMRDY = 1UL<<5, // MMRDY
	FPU_FPCCR_HFRDY = 1UL<<4, // HFRDY
	FPU_FPCCR_THREAD = 1UL<<3, // THREAD
	FPU_FPCCR_USER = 1UL<<1, // USER
	FPU_FPCCR_LSPACT = 1UL<<0, // LSPACT		
};

// FPU->FPCAR Floating-point context address register
enum {
	FPU_FPCAR_ADDRESS = ((1UL<<29)-1) << 3, // Location of unpopulated floating-point		
};
inline void fpu_fpcar_set_address(struct FPU_Type* p, uint32_t val) { p->FPCAR = (p->FPCAR & ~FPU_FPCAR_ADDRESS) | ((val<<3) & FPU_FPCAR_ADDRESS); }
inline uint32_t fpu_fpcar_get_address(struct FPU_Type* p) { return (p->FPCAR & FPU_FPCAR_ADDRESS) >> 3 ; }

// FPU->FPSCR Floating-point status control register
enum {
	FPU_FPSCR_N = 1UL<<31, // Negative condition code flag
	FPU_FPSCR_Z = 1UL<<30, // Zero condition code flag
	FPU_FPSCR_C = 1UL<<29, // Carry condition code flag
	FPU_FPSCR_V = 1UL<<28, // Overflow condition code flag
	FPU_FPSCR_AHP = 1UL<<26, // Alternative half-precision control bit
	FPU_FPSCR_DN = 1UL<<25, // Default NaN mode control bit
	FPU_FPSCR_FZ = 1UL<<24, // Flush-to-zero mode control bit:
	FPU_FPSCR_RMODE = ((1UL<<2)-1) << 22, // Rounding Mode control field
	FPU_FPSCR_IDC = 1UL<<7, // Input denormal cumulative exception bit.
	FPU_FPSCR_IXC = 1UL<<4, // Inexact cumulative exception bit
	FPU_FPSCR_UFC = 1UL<<3, // Underflow cumulative exception bit
	FPU_FPSCR_OFC = 1UL<<2, // Overflow cumulative exception bit
	FPU_FPSCR_DZC = 1UL<<1, // Division by zero cumulative exception bit.
	FPU_FPSCR_IOC = 1UL<<0, // Invalid operation cumulative exception bit		
};
inline void fpu_fpscr_set_rmode(struct FPU_Type* p, uint32_t val) { p->FPSCR = (p->FPSCR & ~FPU_FPSCR_RMODE) | ((val<<22) & FPU_FPSCR_RMODE); }
inline uint32_t fpu_fpscr_get_rmode(struct FPU_Type* p) { return (p->FPSCR & FPU_FPSCR_RMODE) >> 22 ; }

/* Floating point unit CPACR */
struct FPU_CPACR_Type {
	__IO uint32_t CPACR; // @0 Coprocessor access control register
};

// FPU_CPACR->CPACR Coprocessor access control register
enum {
	FPU_CPACR_CPACR_CP = ((1UL<<4)-1) << 20, // CP		
};
inline void fpu_cpacr_cpacr_set_cp(struct FPU_CPACR_Type* p, uint32_t val) { p->CPACR = (p->CPACR & ~FPU_CPACR_CPACR_CP) | ((val<<20) & FPU_CPACR_CPACR_CP); }
inline uint32_t fpu_cpacr_cpacr_get_cp(struct FPU_CPACR_Type* p) { return (p->CPACR & FPU_CPACR_CPACR_CP) >> 20 ; }

/* General-purpose I/Os */
struct GPIOA_Type {
	__IO uint32_t MODER; // @0 GPIO port mode register
	__IO uint16_t OTYPER; // @4 GPIO port output type register
	 uint8_t RESERVED0[2]; // @6 
	__IO uint32_t OSPEEDR; // @8 GPIO port output speed register
	__IO uint32_t PUPDR; // @12 GPIO port pull-up/pull-down register
	__I uint16_t IDR; // @16 GPIO port input data register
	 uint8_t RESERVED1[2]; // @18 
	__IO uint16_t ODR; // @20 GPIO port output data register
	 uint8_t RESERVED2[2]; // @22 
	__O uint32_t BSRR; // @24 GPIO port bit set/reset register
	__IO uint32_t LCKR; // @28 GPIO port configuration lock register
	__IO uint32_t AFRL; // @32 GPIO alternate function low register
	__IO uint32_t AFRH; // @36 GPIO alternate function high register
};

// GPIOA->MODER GPIO port mode register
enum {
	GPIOA_MODER_MODER15 = ((1UL<<2)-1) << 30, // Port x configuration bits (y = 0..15)
	GPIOA_MODER_MODER14 = ((1UL<<2)-1) << 28, // Port x configuration bits (y = 0..15)
	GPIOA_MODER_MODER13 = ((1UL<<2)-1) << 26, // Port x configuration bits (y = 0..15)
	GPIOA_MODER_MODER12 = ((1UL<<2)-1) << 24, // Port x configuration bits (y = 0..15)
	GPIOA_MODER_MODER11 = ((1UL<<2)-1) << 22, // Port x configuration bits (y = 0..15)
	GPIOA_MODER_MODER10 = ((1UL<<2)-1) << 20, // Port x configuration bits (y = 0..15)
	GPIOA_MODER_MODER9 = ((1UL<<2)-1) << 18, // Port x configuration bits (y = 0..15)
	GPIOA_MODER_MODER8 = ((1UL<<2)-1) << 16, // Port x configuration bits (y = 0..15)
	GPIOA_MODER_MODER7 = ((1UL<<2)-1) << 14, // Port x configuration bits (y = 0..15)
	GPIOA_MODER_MODER6 = ((1UL<<2)-1) << 12, // Port x configuration bits (y = 0..15)
	GPIOA_MODER_MODER5 = ((1UL<<2)-1) << 10, // Port x configuration bits (y = 0..15)
	GPIOA_MODER_MODER4 = ((1UL<<2)-1) << 8, // Port x configuration bits (y = 0..15)
	GPIOA_MODER_MODER3 = ((1UL<<2)-1) << 6, // Port x configuration bits (y = 0..15)
	GPIOA_MODER_MODER2 = ((1UL<<2)-1) << 4, // Port x configuration bits (y = 0..15)
	GPIOA_MODER_MODER1 = ((1UL<<2)-1) << 2, // Port x configuration bits (y = 0..15)
	GPIOA_MODER_MODER0 = ((1UL<<2)-1) << 0, // Port x configuration bits (y = 0..15)		
};
inline void gpioa_moder_set_moder15(struct GPIOA_Type* p, uint32_t val) { p->MODER = (p->MODER & ~GPIOA_MODER_MODER15) | ((val<<30) & GPIOA_MODER_MODER15); }
inline void gpioa_moder_set_moder14(struct GPIOA_Type* p, uint32_t val) { p->MODER = (p->MODER & ~GPIOA_MODER_MODER14) | ((val<<28) & GPIOA_MODER_MODER14); }
inline void gpioa_moder_set_moder13(struct GPIOA_Type* p, uint32_t val) { p->MODER = (p->MODER & ~GPIOA_MODER_MODER13) | ((val<<26) & GPIOA_MODER_MODER13); }
inline void gpioa_moder_set_moder12(struct GPIOA_Type* p, uint32_t val) { p->MODER = (p->MODER & ~GPIOA_MODER_MODER12) | ((val<<24) & GPIOA_MODER_MODER12); }
inline void gpioa_moder_set_moder11(struct GPIOA_Type* p, uint32_t val) { p->MODER = (p->MODER & ~GPIOA_MODER_MODER11) | ((val<<22) & GPIOA_MODER_MODER11); }
inline void gpioa_moder_set_moder10(struct GPIOA_Type* p, uint32_t val) { p->MODER = (p->MODER & ~GPIOA_MODER_MODER10) | ((val<<20) & GPIOA_MODER_MODER10); }
inline void gpioa_moder_set_moder9(struct GPIOA_Type* p, uint32_t val) { p->MODER = (p->MODER & ~GPIOA_MODER_MODER9) | ((val<<18) & GPIOA_MODER_MODER9); }
inline void gpioa_moder_set_moder8(struct GPIOA_Type* p, uint32_t val) { p->MODER = (p->MODER & ~GPIOA_MODER_MODER8) | ((val<<16) & GPIOA_MODER_MODER8); }
inline void gpioa_moder_set_moder7(struct GPIOA_Type* p, uint32_t val) { p->MODER = (p->MODER & ~GPIOA_MODER_MODER7) | ((val<<14) & GPIOA_MODER_MODER7); }
inline void gpioa_moder_set_moder6(struct GPIOA_Type* p, uint32_t val) { p->MODER = (p->MODER & ~GPIOA_MODER_MODER6) | ((val<<12) & GPIOA_MODER_MODER6); }
inline void gpioa_moder_set_moder5(struct GPIOA_Type* p, uint32_t val) { p->MODER = (p->MODER & ~GPIOA_MODER_MODER5) | ((val<<10) & GPIOA_MODER_MODER5); }
inline void gpioa_moder_set_moder4(struct GPIOA_Type* p, uint32_t val) { p->MODER = (p->MODER & ~GPIOA_MODER_MODER4) | ((val<<8) & GPIOA_MODER_MODER4); }
inline void gpioa_moder_set_moder3(struct GPIOA_Type* p, uint32_t val) { p->MODER = (p->MODER & ~GPIOA_MODER_MODER3) | ((val<<6) & GPIOA_MODER_MODER3); }
inline void gpioa_moder_set_moder2(struct GPIOA_Type* p, uint32_t val) { p->MODER = (p->MODER & ~GPIOA_MODER_MODER2) | ((val<<4) & GPIOA_MODER_MODER2); }
inline void gpioa_moder_set_moder1(struct GPIOA_Type* p, uint32_t val) { p->MODER = (p->MODER & ~GPIOA_MODER_MODER1) | ((val<<2) & GPIOA_MODER_MODER1); }
inline void gpioa_moder_set_moder0(struct GPIOA_Type* p, uint32_t val) { p->MODER = (p->MODER & ~GPIOA_MODER_MODER0) | ((val<<0) & GPIOA_MODER_MODER0); }
inline uint32_t gpioa_moder_get_moder15(struct GPIOA_Type* p) { return (p->MODER & GPIOA_MODER_MODER15) >> 30 ; }
inline uint32_t gpioa_moder_get_moder14(struct GPIOA_Type* p) { return (p->MODER & GPIOA_MODER_MODER14) >> 28 ; }
inline uint32_t gpioa_moder_get_moder13(struct GPIOA_Type* p) { return (p->MODER & GPIOA_MODER_MODER13) >> 26 ; }
inline uint32_t gpioa_moder_get_moder12(struct GPIOA_Type* p) { return (p->MODER & GPIOA_MODER_MODER12) >> 24 ; }
inline uint32_t gpioa_moder_get_moder11(struct GPIOA_Type* p) { return (p->MODER & GPIOA_MODER_MODER11) >> 22 ; }
inline uint32_t gpioa_moder_get_moder10(struct GPIOA_Type* p) { return (p->MODER & GPIOA_MODER_MODER10) >> 20 ; }
inline uint32_t gpioa_moder_get_moder9(struct GPIOA_Type* p) { return (p->MODER & GPIOA_MODER_MODER9) >> 18 ; }
inline uint32_t gpioa_moder_get_moder8(struct GPIOA_Type* p) { return (p->MODER & GPIOA_MODER_MODER8) >> 16 ; }
inline uint32_t gpioa_moder_get_moder7(struct GPIOA_Type* p) { return (p->MODER & GPIOA_MODER_MODER7) >> 14 ; }
inline uint32_t gpioa_moder_get_moder6(struct GPIOA_Type* p) { return (p->MODER & GPIOA_MODER_MODER6) >> 12 ; }
inline uint32_t gpioa_moder_get_moder5(struct GPIOA_Type* p) { return (p->MODER & GPIOA_MODER_MODER5) >> 10 ; }
inline uint32_t gpioa_moder_get_moder4(struct GPIOA_Type* p) { return (p->MODER & GPIOA_MODER_MODER4) >> 8 ; }
inline uint32_t gpioa_moder_get_moder3(struct GPIOA_Type* p) { return (p->MODER & GPIOA_MODER_MODER3) >> 6 ; }
inline uint32_t gpioa_moder_get_moder2(struct GPIOA_Type* p) { return (p->MODER & GPIOA_MODER_MODER2) >> 4 ; }
inline uint32_t gpioa_moder_get_moder1(struct GPIOA_Type* p) { return (p->MODER & GPIOA_MODER_MODER1) >> 2 ; }
inline uint32_t gpioa_moder_get_moder0(struct GPIOA_Type* p) { return (p->MODER & GPIOA_MODER_MODER0) >> 0 ; }

// GPIOA->OSPEEDR GPIO port output speed register
enum {
	GPIOA_OSPEEDR_OSPEEDR15 = ((1UL<<2)-1) << 30, // Port x configuration bits (y = 0..15)
	GPIOA_OSPEEDR_OSPEEDR14 = ((1UL<<2)-1) << 28, // Port x configuration bits (y = 0..15)
	GPIOA_OSPEEDR_OSPEEDR13 = ((1UL<<2)-1) << 26, // Port x configuration bits (y = 0..15)
	GPIOA_OSPEEDR_OSPEEDR12 = ((1UL<<2)-1) << 24, // Port x configuration bits (y = 0..15)
	GPIOA_OSPEEDR_OSPEEDR11 = ((1UL<<2)-1) << 22, // Port x configuration bits (y = 0..15)
	GPIOA_OSPEEDR_OSPEEDR10 = ((1UL<<2)-1) << 20, // Port x configuration bits (y = 0..15)
	GPIOA_OSPEEDR_OSPEEDR9 = ((1UL<<2)-1) << 18, // Port x configuration bits (y = 0..15)
	GPIOA_OSPEEDR_OSPEEDR8 = ((1UL<<2)-1) << 16, // Port x configuration bits (y = 0..15)
	GPIOA_OSPEEDR_OSPEEDR7 = ((1UL<<2)-1) << 14, // Port x configuration bits (y = 0..15)
	GPIOA_OSPEEDR_OSPEEDR6 = ((1UL<<2)-1) << 12, // Port x configuration bits (y = 0..15)
	GPIOA_OSPEEDR_OSPEEDR5 = ((1UL<<2)-1) << 10, // Port x configuration bits (y = 0..15)
	GPIOA_OSPEEDR_OSPEEDR4 = ((1UL<<2)-1) << 8, // Port x configuration bits (y = 0..15)
	GPIOA_OSPEEDR_OSPEEDR3 = ((1UL<<2)-1) << 6, // Port x configuration bits (y = 0..15)
	GPIOA_OSPEEDR_OSPEEDR2 = ((1UL<<2)-1) << 4, // Port x configuration bits (y = 0..15)
	GPIOA_OSPEEDR_OSPEEDR1 = ((1UL<<2)-1) << 2, // Port x configuration bits (y = 0..15)
	GPIOA_OSPEEDR_OSPEEDR0 = ((1UL<<2)-1) << 0, // Port x configuration bits (y = 0..15)		
};
inline void gpioa_ospeedr_set_ospeedr15(struct GPIOA_Type* p, uint32_t val) { p->OSPEEDR = (p->OSPEEDR & ~GPIOA_OSPEEDR_OSPEEDR15) | ((val<<30) & GPIOA_OSPEEDR_OSPEEDR15); }
inline void gpioa_ospeedr_set_ospeedr14(struct GPIOA_Type* p, uint32_t val) { p->OSPEEDR = (p->OSPEEDR & ~GPIOA_OSPEEDR_OSPEEDR14) | ((val<<28) & GPIOA_OSPEEDR_OSPEEDR14); }
inline void gpioa_ospeedr_set_ospeedr13(struct GPIOA_Type* p, uint32_t val) { p->OSPEEDR = (p->OSPEEDR & ~GPIOA_OSPEEDR_OSPEEDR13) | ((val<<26) & GPIOA_OSPEEDR_OSPEEDR13); }
inline void gpioa_ospeedr_set_ospeedr12(struct GPIOA_Type* p, uint32_t val) { p->OSPEEDR = (p->OSPEEDR & ~GPIOA_OSPEEDR_OSPEEDR12) | ((val<<24) & GPIOA_OSPEEDR_OSPEEDR12); }
inline void gpioa_ospeedr_set_ospeedr11(struct GPIOA_Type* p, uint32_t val) { p->OSPEEDR = (p->OSPEEDR & ~GPIOA_OSPEEDR_OSPEEDR11) | ((val<<22) & GPIOA_OSPEEDR_OSPEEDR11); }
inline void gpioa_ospeedr_set_ospeedr10(struct GPIOA_Type* p, uint32_t val) { p->OSPEEDR = (p->OSPEEDR & ~GPIOA_OSPEEDR_OSPEEDR10) | ((val<<20) & GPIOA_OSPEEDR_OSPEEDR10); }
inline void gpioa_ospeedr_set_ospeedr9(struct GPIOA_Type* p, uint32_t val) { p->OSPEEDR = (p->OSPEEDR & ~GPIOA_OSPEEDR_OSPEEDR9) | ((val<<18) & GPIOA_OSPEEDR_OSPEEDR9); }
inline void gpioa_ospeedr_set_ospeedr8(struct GPIOA_Type* p, uint32_t val) { p->OSPEEDR = (p->OSPEEDR & ~GPIOA_OSPEEDR_OSPEEDR8) | ((val<<16) & GPIOA_OSPEEDR_OSPEEDR8); }
inline void gpioa_ospeedr_set_ospeedr7(struct GPIOA_Type* p, uint32_t val) { p->OSPEEDR = (p->OSPEEDR & ~GPIOA_OSPEEDR_OSPEEDR7) | ((val<<14) & GPIOA_OSPEEDR_OSPEEDR7); }
inline void gpioa_ospeedr_set_ospeedr6(struct GPIOA_Type* p, uint32_t val) { p->OSPEEDR = (p->OSPEEDR & ~GPIOA_OSPEEDR_OSPEEDR6) | ((val<<12) & GPIOA_OSPEEDR_OSPEEDR6); }
inline void gpioa_ospeedr_set_ospeedr5(struct GPIOA_Type* p, uint32_t val) { p->OSPEEDR = (p->OSPEEDR & ~GPIOA_OSPEEDR_OSPEEDR5) | ((val<<10) & GPIOA_OSPEEDR_OSPEEDR5); }
inline void gpioa_ospeedr_set_ospeedr4(struct GPIOA_Type* p, uint32_t val) { p->OSPEEDR = (p->OSPEEDR & ~GPIOA_OSPEEDR_OSPEEDR4) | ((val<<8) & GPIOA_OSPEEDR_OSPEEDR4); }
inline void gpioa_ospeedr_set_ospeedr3(struct GPIOA_Type* p, uint32_t val) { p->OSPEEDR = (p->OSPEEDR & ~GPIOA_OSPEEDR_OSPEEDR3) | ((val<<6) & GPIOA_OSPEEDR_OSPEEDR3); }
inline void gpioa_ospeedr_set_ospeedr2(struct GPIOA_Type* p, uint32_t val) { p->OSPEEDR = (p->OSPEEDR & ~GPIOA_OSPEEDR_OSPEEDR2) | ((val<<4) & GPIOA_OSPEEDR_OSPEEDR2); }
inline void gpioa_ospeedr_set_ospeedr1(struct GPIOA_Type* p, uint32_t val) { p->OSPEEDR = (p->OSPEEDR & ~GPIOA_OSPEEDR_OSPEEDR1) | ((val<<2) & GPIOA_OSPEEDR_OSPEEDR1); }
inline void gpioa_ospeedr_set_ospeedr0(struct GPIOA_Type* p, uint32_t val) { p->OSPEEDR = (p->OSPEEDR & ~GPIOA_OSPEEDR_OSPEEDR0) | ((val<<0) & GPIOA_OSPEEDR_OSPEEDR0); }
inline uint32_t gpioa_ospeedr_get_ospeedr15(struct GPIOA_Type* p) { return (p->OSPEEDR & GPIOA_OSPEEDR_OSPEEDR15) >> 30 ; }
inline uint32_t gpioa_ospeedr_get_ospeedr14(struct GPIOA_Type* p) { return (p->OSPEEDR & GPIOA_OSPEEDR_OSPEEDR14) >> 28 ; }
inline uint32_t gpioa_ospeedr_get_ospeedr13(struct GPIOA_Type* p) { return (p->OSPEEDR & GPIOA_OSPEEDR_OSPEEDR13) >> 26 ; }
inline uint32_t gpioa_ospeedr_get_ospeedr12(struct GPIOA_Type* p) { return (p->OSPEEDR & GPIOA_OSPEEDR_OSPEEDR12) >> 24 ; }
inline uint32_t gpioa_ospeedr_get_ospeedr11(struct GPIOA_Type* p) { return (p->OSPEEDR & GPIOA_OSPEEDR_OSPEEDR11) >> 22 ; }
inline uint32_t gpioa_ospeedr_get_ospeedr10(struct GPIOA_Type* p) { return (p->OSPEEDR & GPIOA_OSPEEDR_OSPEEDR10) >> 20 ; }
inline uint32_t gpioa_ospeedr_get_ospeedr9(struct GPIOA_Type* p) { return (p->OSPEEDR & GPIOA_OSPEEDR_OSPEEDR9) >> 18 ; }
inline uint32_t gpioa_ospeedr_get_ospeedr8(struct GPIOA_Type* p) { return (p->OSPEEDR & GPIOA_OSPEEDR_OSPEEDR8) >> 16 ; }
inline uint32_t gpioa_ospeedr_get_ospeedr7(struct GPIOA_Type* p) { return (p->OSPEEDR & GPIOA_OSPEEDR_OSPEEDR7) >> 14 ; }
inline uint32_t gpioa_ospeedr_get_ospeedr6(struct GPIOA_Type* p) { return (p->OSPEEDR & GPIOA_OSPEEDR_OSPEEDR6) >> 12 ; }
inline uint32_t gpioa_ospeedr_get_ospeedr5(struct GPIOA_Type* p) { return (p->OSPEEDR & GPIOA_OSPEEDR_OSPEEDR5) >> 10 ; }
inline uint32_t gpioa_ospeedr_get_ospeedr4(struct GPIOA_Type* p) { return (p->OSPEEDR & GPIOA_OSPEEDR_OSPEEDR4) >> 8 ; }
inline uint32_t gpioa_ospeedr_get_ospeedr3(struct GPIOA_Type* p) { return (p->OSPEEDR & GPIOA_OSPEEDR_OSPEEDR3) >> 6 ; }
inline uint32_t gpioa_ospeedr_get_ospeedr2(struct GPIOA_Type* p) { return (p->OSPEEDR & GPIOA_OSPEEDR_OSPEEDR2) >> 4 ; }
inline uint32_t gpioa_ospeedr_get_ospeedr1(struct GPIOA_Type* p) { return (p->OSPEEDR & GPIOA_OSPEEDR_OSPEEDR1) >> 2 ; }
inline uint32_t gpioa_ospeedr_get_ospeedr0(struct GPIOA_Type* p) { return (p->OSPEEDR & GPIOA_OSPEEDR_OSPEEDR0) >> 0 ; }

// GPIOA->PUPDR GPIO port pull-up/pull-down register
enum {
	GPIOA_PUPDR_PUPDR15 = ((1UL<<2)-1) << 30, // Port x configuration bits (y = 0..15)
	GPIOA_PUPDR_PUPDR14 = ((1UL<<2)-1) << 28, // Port x configuration bits (y = 0..15)
	GPIOA_PUPDR_PUPDR13 = ((1UL<<2)-1) << 26, // Port x configuration bits (y = 0..15)
	GPIOA_PUPDR_PUPDR12 = ((1UL<<2)-1) << 24, // Port x configuration bits (y = 0..15)
	GPIOA_PUPDR_PUPDR11 = ((1UL<<2)-1) << 22, // Port x configuration bits (y = 0..15)
	GPIOA_PUPDR_PUPDR10 = ((1UL<<2)-1) << 20, // Port x configuration bits (y = 0..15)
	GPIOA_PUPDR_PUPDR9 = ((1UL<<2)-1) << 18, // Port x configuration bits (y = 0..15)
	GPIOA_PUPDR_PUPDR8 = ((1UL<<2)-1) << 16, // Port x configuration bits (y = 0..15)
	GPIOA_PUPDR_PUPDR7 = ((1UL<<2)-1) << 14, // Port x configuration bits (y = 0..15)
	GPIOA_PUPDR_PUPDR6 = ((1UL<<2)-1) << 12, // Port x configuration bits (y = 0..15)
	GPIOA_PUPDR_PUPDR5 = ((1UL<<2)-1) << 10, // Port x configuration bits (y = 0..15)
	GPIOA_PUPDR_PUPDR4 = ((1UL<<2)-1) << 8, // Port x configuration bits (y = 0..15)
	GPIOA_PUPDR_PUPDR3 = ((1UL<<2)-1) << 6, // Port x configuration bits (y = 0..15)
	GPIOA_PUPDR_PUPDR2 = ((1UL<<2)-1) << 4, // Port x configuration bits (y = 0..15)
	GPIOA_PUPDR_PUPDR1 = ((1UL<<2)-1) << 2, // Port x configuration bits (y = 0..15)
	GPIOA_PUPDR_PUPDR0 = ((1UL<<2)-1) << 0, // Port x configuration bits (y = 0..15)		
};
inline void gpioa_pupdr_set_pupdr15(struct GPIOA_Type* p, uint32_t val) { p->PUPDR = (p->PUPDR & ~GPIOA_PUPDR_PUPDR15) | ((val<<30) & GPIOA_PUPDR_PUPDR15); }
inline void gpioa_pupdr_set_pupdr14(struct GPIOA_Type* p, uint32_t val) { p->PUPDR = (p->PUPDR & ~GPIOA_PUPDR_PUPDR14) | ((val<<28) & GPIOA_PUPDR_PUPDR14); }
inline void gpioa_pupdr_set_pupdr13(struct GPIOA_Type* p, uint32_t val) { p->PUPDR = (p->PUPDR & ~GPIOA_PUPDR_PUPDR13) | ((val<<26) & GPIOA_PUPDR_PUPDR13); }
inline void gpioa_pupdr_set_pupdr12(struct GPIOA_Type* p, uint32_t val) { p->PUPDR = (p->PUPDR & ~GPIOA_PUPDR_PUPDR12) | ((val<<24) & GPIOA_PUPDR_PUPDR12); }
inline void gpioa_pupdr_set_pupdr11(struct GPIOA_Type* p, uint32_t val) { p->PUPDR = (p->PUPDR & ~GPIOA_PUPDR_PUPDR11) | ((val<<22) & GPIOA_PUPDR_PUPDR11); }
inline void gpioa_pupdr_set_pupdr10(struct GPIOA_Type* p, uint32_t val) { p->PUPDR = (p->PUPDR & ~GPIOA_PUPDR_PUPDR10) | ((val<<20) & GPIOA_PUPDR_PUPDR10); }
inline void gpioa_pupdr_set_pupdr9(struct GPIOA_Type* p, uint32_t val) { p->PUPDR = (p->PUPDR & ~GPIOA_PUPDR_PUPDR9) | ((val<<18) & GPIOA_PUPDR_PUPDR9); }
inline void gpioa_pupdr_set_pupdr8(struct GPIOA_Type* p, uint32_t val) { p->PUPDR = (p->PUPDR & ~GPIOA_PUPDR_PUPDR8) | ((val<<16) & GPIOA_PUPDR_PUPDR8); }
inline void gpioa_pupdr_set_pupdr7(struct GPIOA_Type* p, uint32_t val) { p->PUPDR = (p->PUPDR & ~GPIOA_PUPDR_PUPDR7) | ((val<<14) & GPIOA_PUPDR_PUPDR7); }
inline void gpioa_pupdr_set_pupdr6(struct GPIOA_Type* p, uint32_t val) { p->PUPDR = (p->PUPDR & ~GPIOA_PUPDR_PUPDR6) | ((val<<12) & GPIOA_PUPDR_PUPDR6); }
inline void gpioa_pupdr_set_pupdr5(struct GPIOA_Type* p, uint32_t val) { p->PUPDR = (p->PUPDR & ~GPIOA_PUPDR_PUPDR5) | ((val<<10) & GPIOA_PUPDR_PUPDR5); }
inline void gpioa_pupdr_set_pupdr4(struct GPIOA_Type* p, uint32_t val) { p->PUPDR = (p->PUPDR & ~GPIOA_PUPDR_PUPDR4) | ((val<<8) & GPIOA_PUPDR_PUPDR4); }
inline void gpioa_pupdr_set_pupdr3(struct GPIOA_Type* p, uint32_t val) { p->PUPDR = (p->PUPDR & ~GPIOA_PUPDR_PUPDR3) | ((val<<6) & GPIOA_PUPDR_PUPDR3); }
inline void gpioa_pupdr_set_pupdr2(struct GPIOA_Type* p, uint32_t val) { p->PUPDR = (p->PUPDR & ~GPIOA_PUPDR_PUPDR2) | ((val<<4) & GPIOA_PUPDR_PUPDR2); }
inline void gpioa_pupdr_set_pupdr1(struct GPIOA_Type* p, uint32_t val) { p->PUPDR = (p->PUPDR & ~GPIOA_PUPDR_PUPDR1) | ((val<<2) & GPIOA_PUPDR_PUPDR1); }
inline void gpioa_pupdr_set_pupdr0(struct GPIOA_Type* p, uint32_t val) { p->PUPDR = (p->PUPDR & ~GPIOA_PUPDR_PUPDR0) | ((val<<0) & GPIOA_PUPDR_PUPDR0); }
inline uint32_t gpioa_pupdr_get_pupdr15(struct GPIOA_Type* p) { return (p->PUPDR & GPIOA_PUPDR_PUPDR15) >> 30 ; }
inline uint32_t gpioa_pupdr_get_pupdr14(struct GPIOA_Type* p) { return (p->PUPDR & GPIOA_PUPDR_PUPDR14) >> 28 ; }
inline uint32_t gpioa_pupdr_get_pupdr13(struct GPIOA_Type* p) { return (p->PUPDR & GPIOA_PUPDR_PUPDR13) >> 26 ; }
inline uint32_t gpioa_pupdr_get_pupdr12(struct GPIOA_Type* p) { return (p->PUPDR & GPIOA_PUPDR_PUPDR12) >> 24 ; }
inline uint32_t gpioa_pupdr_get_pupdr11(struct GPIOA_Type* p) { return (p->PUPDR & GPIOA_PUPDR_PUPDR11) >> 22 ; }
inline uint32_t gpioa_pupdr_get_pupdr10(struct GPIOA_Type* p) { return (p->PUPDR & GPIOA_PUPDR_PUPDR10) >> 20 ; }
inline uint32_t gpioa_pupdr_get_pupdr9(struct GPIOA_Type* p) { return (p->PUPDR & GPIOA_PUPDR_PUPDR9) >> 18 ; }
inline uint32_t gpioa_pupdr_get_pupdr8(struct GPIOA_Type* p) { return (p->PUPDR & GPIOA_PUPDR_PUPDR8) >> 16 ; }
inline uint32_t gpioa_pupdr_get_pupdr7(struct GPIOA_Type* p) { return (p->PUPDR & GPIOA_PUPDR_PUPDR7) >> 14 ; }
inline uint32_t gpioa_pupdr_get_pupdr6(struct GPIOA_Type* p) { return (p->PUPDR & GPIOA_PUPDR_PUPDR6) >> 12 ; }
inline uint32_t gpioa_pupdr_get_pupdr5(struct GPIOA_Type* p) { return (p->PUPDR & GPIOA_PUPDR_PUPDR5) >> 10 ; }
inline uint32_t gpioa_pupdr_get_pupdr4(struct GPIOA_Type* p) { return (p->PUPDR & GPIOA_PUPDR_PUPDR4) >> 8 ; }
inline uint32_t gpioa_pupdr_get_pupdr3(struct GPIOA_Type* p) { return (p->PUPDR & GPIOA_PUPDR_PUPDR3) >> 6 ; }
inline uint32_t gpioa_pupdr_get_pupdr2(struct GPIOA_Type* p) { return (p->PUPDR & GPIOA_PUPDR_PUPDR2) >> 4 ; }
inline uint32_t gpioa_pupdr_get_pupdr1(struct GPIOA_Type* p) { return (p->PUPDR & GPIOA_PUPDR_PUPDR1) >> 2 ; }
inline uint32_t gpioa_pupdr_get_pupdr0(struct GPIOA_Type* p) { return (p->PUPDR & GPIOA_PUPDR_PUPDR0) >> 0 ; }

// GPIOA->BSRR GPIO port bit set/reset register
enum {
	GPIOA_BSRR_BR15 = 1UL<<31, // Port x reset bit y (y = 0..15)
	GPIOA_BSRR_BR14 = 1UL<<30, // Port x reset bit y (y = 0..15)
	GPIOA_BSRR_BR13 = 1UL<<29, // Port x reset bit y (y = 0..15)
	GPIOA_BSRR_BR12 = 1UL<<28, // Port x reset bit y (y = 0..15)
	GPIOA_BSRR_BR11 = 1UL<<27, // Port x reset bit y (y = 0..15)
	GPIOA_BSRR_BR10 = 1UL<<26, // Port x reset bit y (y = 0..15)
	GPIOA_BSRR_BR9 = 1UL<<25, // Port x reset bit y (y = 0..15)
	GPIOA_BSRR_BR8 = 1UL<<24, // Port x reset bit y (y = 0..15)
	GPIOA_BSRR_BR7 = 1UL<<23, // Port x reset bit y (y = 0..15)
	GPIOA_BSRR_BR6 = 1UL<<22, // Port x reset bit y (y = 0..15)
	GPIOA_BSRR_BR5 = 1UL<<21, // Port x reset bit y (y = 0..15)
	GPIOA_BSRR_BR4 = 1UL<<20, // Port x reset bit y (y = 0..15)
	GPIOA_BSRR_BR3 = 1UL<<19, // Port x reset bit y (y = 0..15)
	GPIOA_BSRR_BR2 = 1UL<<18, // Port x reset bit y (y = 0..15)
	GPIOA_BSRR_BR1 = 1UL<<17, // Port x reset bit y (y = 0..15)
	GPIOA_BSRR_BR0 = 1UL<<16, // Port x set bit y (y= 0..15)
	GPIOA_BSRR_BS15 = 1UL<<15, // Port x set bit y (y= 0..15)
	GPIOA_BSRR_BS14 = 1UL<<14, // Port x set bit y (y= 0..15)
	GPIOA_BSRR_BS13 = 1UL<<13, // Port x set bit y (y= 0..15)
	GPIOA_BSRR_BS12 = 1UL<<12, // Port x set bit y (y= 0..15)
	GPIOA_BSRR_BS11 = 1UL<<11, // Port x set bit y (y= 0..15)
	GPIOA_BSRR_BS10 = 1UL<<10, // Port x set bit y (y= 0..15)
	GPIOA_BSRR_BS9 = 1UL<<9, // Port x set bit y (y= 0..15)
	GPIOA_BSRR_BS8 = 1UL<<8, // Port x set bit y (y= 0..15)
	GPIOA_BSRR_BS7 = 1UL<<7, // Port x set bit y (y= 0..15)
	GPIOA_BSRR_BS6 = 1UL<<6, // Port x set bit y (y= 0..15)
	GPIOA_BSRR_BS5 = 1UL<<5, // Port x set bit y (y= 0..15)
	GPIOA_BSRR_BS4 = 1UL<<4, // Port x set bit y (y= 0..15)
	GPIOA_BSRR_BS3 = 1UL<<3, // Port x set bit y (y= 0..15)
	GPIOA_BSRR_BS2 = 1UL<<2, // Port x set bit y (y= 0..15)
	GPIOA_BSRR_BS1 = 1UL<<1, // Port x set bit y (y= 0..15)
	GPIOA_BSRR_BS0 = 1UL<<0, // Port x set bit y (y= 0..15)		
};

// GPIOA->LCKR GPIO port configuration lock register
enum {
	GPIOA_LCKR_LCKK = 1UL<<16, // Port x lock bit y (y= 0..15)
	GPIOA_LCKR_LCK15 = 1UL<<15, // Port x lock bit y (y= 0..15)
	GPIOA_LCKR_LCK14 = 1UL<<14, // Port x lock bit y (y= 0..15)
	GPIOA_LCKR_LCK13 = 1UL<<13, // Port x lock bit y (y= 0..15)
	GPIOA_LCKR_LCK12 = 1UL<<12, // Port x lock bit y (y= 0..15)
	GPIOA_LCKR_LCK11 = 1UL<<11, // Port x lock bit y (y= 0..15)
	GPIOA_LCKR_LCK10 = 1UL<<10, // Port x lock bit y (y= 0..15)
	GPIOA_LCKR_LCK9 = 1UL<<9, // Port x lock bit y (y= 0..15)
	GPIOA_LCKR_LCK8 = 1UL<<8, // Port x lock bit y (y= 0..15)
	GPIOA_LCKR_LCK7 = 1UL<<7, // Port x lock bit y (y= 0..15)
	GPIOA_LCKR_LCK6 = 1UL<<6, // Port x lock bit y (y= 0..15)
	GPIOA_LCKR_LCK5 = 1UL<<5, // Port x lock bit y (y= 0..15)
	GPIOA_LCKR_LCK4 = 1UL<<4, // Port x lock bit y (y= 0..15)
	GPIOA_LCKR_LCK3 = 1UL<<3, // Port x lock bit y (y= 0..15)
	GPIOA_LCKR_LCK2 = 1UL<<2, // Port x lock bit y (y= 0..15)
	GPIOA_LCKR_LCK1 = 1UL<<1, // Port x lock bit y (y= 0..15)
	GPIOA_LCKR_LCK0 = 1UL<<0, // Port x lock bit y (y= 0..15)		
};

// GPIOA->AFRL GPIO alternate function low register
enum {
	GPIOA_AFRL_AFRL7 = ((1UL<<4)-1) << 28, // Alternate function selection for port x bit y (y = 0..7)
	GPIOA_AFRL_AFRL6 = ((1UL<<4)-1) << 24, // Alternate function selection for port x bit y (y = 0..7)
	GPIOA_AFRL_AFRL5 = ((1UL<<4)-1) << 20, // Alternate function selection for port x bit y (y = 0..7)
	GPIOA_AFRL_AFRL4 = ((1UL<<4)-1) << 16, // Alternate function selection for port x bit y (y = 0..7)
	GPIOA_AFRL_AFRL3 = ((1UL<<4)-1) << 12, // Alternate function selection for port x bit y (y = 0..7)
	GPIOA_AFRL_AFRL2 = ((1UL<<4)-1) << 8, // Alternate function selection for port x bit y (y = 0..7)
	GPIOA_AFRL_AFRL1 = ((1UL<<4)-1) << 4, // Alternate function selection for port x bit y (y = 0..7)
	GPIOA_AFRL_AFRL0 = ((1UL<<4)-1) << 0, // Alternate function selection for port x bit y (y = 0..7)		
};
inline void gpioa_afrl_set_afrl7(struct GPIOA_Type* p, uint32_t val) { p->AFRL = (p->AFRL & ~GPIOA_AFRL_AFRL7) | ((val<<28) & GPIOA_AFRL_AFRL7); }
inline void gpioa_afrl_set_afrl6(struct GPIOA_Type* p, uint32_t val) { p->AFRL = (p->AFRL & ~GPIOA_AFRL_AFRL6) | ((val<<24) & GPIOA_AFRL_AFRL6); }
inline void gpioa_afrl_set_afrl5(struct GPIOA_Type* p, uint32_t val) { p->AFRL = (p->AFRL & ~GPIOA_AFRL_AFRL5) | ((val<<20) & GPIOA_AFRL_AFRL5); }
inline void gpioa_afrl_set_afrl4(struct GPIOA_Type* p, uint32_t val) { p->AFRL = (p->AFRL & ~GPIOA_AFRL_AFRL4) | ((val<<16) & GPIOA_AFRL_AFRL4); }
inline void gpioa_afrl_set_afrl3(struct GPIOA_Type* p, uint32_t val) { p->AFRL = (p->AFRL & ~GPIOA_AFRL_AFRL3) | ((val<<12) & GPIOA_AFRL_AFRL3); }
inline void gpioa_afrl_set_afrl2(struct GPIOA_Type* p, uint32_t val) { p->AFRL = (p->AFRL & ~GPIOA_AFRL_AFRL2) | ((val<<8) & GPIOA_AFRL_AFRL2); }
inline void gpioa_afrl_set_afrl1(struct GPIOA_Type* p, uint32_t val) { p->AFRL = (p->AFRL & ~GPIOA_AFRL_AFRL1) | ((val<<4) & GPIOA_AFRL_AFRL1); }
inline void gpioa_afrl_set_afrl0(struct GPIOA_Type* p, uint32_t val) { p->AFRL = (p->AFRL & ~GPIOA_AFRL_AFRL0) | ((val<<0) & GPIOA_AFRL_AFRL0); }
inline uint32_t gpioa_afrl_get_afrl7(struct GPIOA_Type* p) { return (p->AFRL & GPIOA_AFRL_AFRL7) >> 28 ; }
inline uint32_t gpioa_afrl_get_afrl6(struct GPIOA_Type* p) { return (p->AFRL & GPIOA_AFRL_AFRL6) >> 24 ; }
inline uint32_t gpioa_afrl_get_afrl5(struct GPIOA_Type* p) { return (p->AFRL & GPIOA_AFRL_AFRL5) >> 20 ; }
inline uint32_t gpioa_afrl_get_afrl4(struct GPIOA_Type* p) { return (p->AFRL & GPIOA_AFRL_AFRL4) >> 16 ; }
inline uint32_t gpioa_afrl_get_afrl3(struct GPIOA_Type* p) { return (p->AFRL & GPIOA_AFRL_AFRL3) >> 12 ; }
inline uint32_t gpioa_afrl_get_afrl2(struct GPIOA_Type* p) { return (p->AFRL & GPIOA_AFRL_AFRL2) >> 8 ; }
inline uint32_t gpioa_afrl_get_afrl1(struct GPIOA_Type* p) { return (p->AFRL & GPIOA_AFRL_AFRL1) >> 4 ; }
inline uint32_t gpioa_afrl_get_afrl0(struct GPIOA_Type* p) { return (p->AFRL & GPIOA_AFRL_AFRL0) >> 0 ; }

// GPIOA->AFRH GPIO alternate function high register
enum {
	GPIOA_AFRH_AFRH15 = ((1UL<<4)-1) << 28, // Alternate function selection for port x bit y (y = 8..15)
	GPIOA_AFRH_AFRH14 = ((1UL<<4)-1) << 24, // Alternate function selection for port x bit y (y = 8..15)
	GPIOA_AFRH_AFRH13 = ((1UL<<4)-1) << 20, // Alternate function selection for port x bit y (y = 8..15)
	GPIOA_AFRH_AFRH12 = ((1UL<<4)-1) << 16, // Alternate function selection for port x bit y (y = 8..15)
	GPIOA_AFRH_AFRH11 = ((1UL<<4)-1) << 12, // Alternate function selection for port x bit y (y = 8..15)
	GPIOA_AFRH_AFRH10 = ((1UL<<4)-1) << 8, // Alternate function selection for port x bit y (y = 8..15)
	GPIOA_AFRH_AFRH9 = ((1UL<<4)-1) << 4, // Alternate function selection for port x bit y (y = 8..15)
	GPIOA_AFRH_AFRH8 = ((1UL<<4)-1) << 0, // Alternate function selection for port x bit y (y = 8..15)		
};
inline void gpioa_afrh_set_afrh15(struct GPIOA_Type* p, uint32_t val) { p->AFRH = (p->AFRH & ~GPIOA_AFRH_AFRH15) | ((val<<28) & GPIOA_AFRH_AFRH15); }
inline void gpioa_afrh_set_afrh14(struct GPIOA_Type* p, uint32_t val) { p->AFRH = (p->AFRH & ~GPIOA_AFRH_AFRH14) | ((val<<24) & GPIOA_AFRH_AFRH14); }
inline void gpioa_afrh_set_afrh13(struct GPIOA_Type* p, uint32_t val) { p->AFRH = (p->AFRH & ~GPIOA_AFRH_AFRH13) | ((val<<20) & GPIOA_AFRH_AFRH13); }
inline void gpioa_afrh_set_afrh12(struct GPIOA_Type* p, uint32_t val) { p->AFRH = (p->AFRH & ~GPIOA_AFRH_AFRH12) | ((val<<16) & GPIOA_AFRH_AFRH12); }
inline void gpioa_afrh_set_afrh11(struct GPIOA_Type* p, uint32_t val) { p->AFRH = (p->AFRH & ~GPIOA_AFRH_AFRH11) | ((val<<12) & GPIOA_AFRH_AFRH11); }
inline void gpioa_afrh_set_afrh10(struct GPIOA_Type* p, uint32_t val) { p->AFRH = (p->AFRH & ~GPIOA_AFRH_AFRH10) | ((val<<8) & GPIOA_AFRH_AFRH10); }
inline void gpioa_afrh_set_afrh9(struct GPIOA_Type* p, uint32_t val) { p->AFRH = (p->AFRH & ~GPIOA_AFRH_AFRH9) | ((val<<4) & GPIOA_AFRH_AFRH9); }
inline void gpioa_afrh_set_afrh8(struct GPIOA_Type* p, uint32_t val) { p->AFRH = (p->AFRH & ~GPIOA_AFRH_AFRH8) | ((val<<0) & GPIOA_AFRH_AFRH8); }
inline uint32_t gpioa_afrh_get_afrh15(struct GPIOA_Type* p) { return (p->AFRH & GPIOA_AFRH_AFRH15) >> 28 ; }
inline uint32_t gpioa_afrh_get_afrh14(struct GPIOA_Type* p) { return (p->AFRH & GPIOA_AFRH_AFRH14) >> 24 ; }
inline uint32_t gpioa_afrh_get_afrh13(struct GPIOA_Type* p) { return (p->AFRH & GPIOA_AFRH_AFRH13) >> 20 ; }
inline uint32_t gpioa_afrh_get_afrh12(struct GPIOA_Type* p) { return (p->AFRH & GPIOA_AFRH_AFRH12) >> 16 ; }
inline uint32_t gpioa_afrh_get_afrh11(struct GPIOA_Type* p) { return (p->AFRH & GPIOA_AFRH_AFRH11) >> 12 ; }
inline uint32_t gpioa_afrh_get_afrh10(struct GPIOA_Type* p) { return (p->AFRH & GPIOA_AFRH_AFRH10) >> 8 ; }
inline uint32_t gpioa_afrh_get_afrh9(struct GPIOA_Type* p) { return (p->AFRH & GPIOA_AFRH_AFRH9) >> 4 ; }
inline uint32_t gpioa_afrh_get_afrh8(struct GPIOA_Type* p) { return (p->AFRH & GPIOA_AFRH_AFRH8) >> 0 ; }






/* Inter-integrated circuit */
struct I2C1_Type {
	__IO uint32_t CR1; // @0 Control register 1
	__IO uint32_t CR2; // @4 Control register 2
	__IO uint16_t OAR1; // @8 Own address register 1
	 uint8_t RESERVED0[2]; // @10 
	__IO uint16_t OAR2; // @12 Own address register 2
	 uint8_t RESERVED1[2]; // @14 
	__IO uint32_t TIMINGR; // @16 Timing register
	__IO uint32_t TIMEOUTR; // @20 Status register 1
	__IO uint32_t ISR; // @24 Interrupt and Status register
	__O uint16_t ICR; // @28 Interrupt clear register
	 uint8_t RESERVED2[2]; // @30 
	__I uint8_t PECR; // @32 PEC register
	 uint8_t RESERVED3[3]; // @33 
	__I uint8_t RXDR; // @36 Receive data register
	 uint8_t RESERVED4[3]; // @37 
	__IO uint8_t TXDR; // @40 Transmit data register
};

// I2C1->CR1 Control register 1
enum {
	I2C1_CR1_PECEN = 1UL<<23, // PEC enable
	I2C1_CR1_ALERTEN = 1UL<<22, // SMBUS alert enable
	I2C1_CR1_SMBDEN = 1UL<<21, // SMBus Device Default address enable
	I2C1_CR1_SMBHEN = 1UL<<20, // SMBus Host address enable
	I2C1_CR1_GCEN = 1UL<<19, // General call enable
	I2C1_CR1_WUPEN = 1UL<<18, // Wakeup from STOP enable
	I2C1_CR1_NOSTRETCH = 1UL<<17, // Clock stretching disable
	I2C1_CR1_SBC = 1UL<<16, // Slave byte control
	I2C1_CR1_RXDMAEN = 1UL<<15, // DMA reception requests enable
	I2C1_CR1_TXDMAEN = 1UL<<14, // DMA transmission requests enable
	I2C1_CR1_ANFOFF = 1UL<<12, // Analog noise filter OFF
	I2C1_CR1_DNF = ((1UL<<4)-1) << 8, // Digital noise filter
	I2C1_CR1_ERRIE = 1UL<<7, // Error interrupts enable
	I2C1_CR1_TCIE = 1UL<<6, // Transfer Complete interrupt enable
	I2C1_CR1_STOPIE = 1UL<<5, // STOP detection Interrupt enable
	I2C1_CR1_NACKIE = 1UL<<4, // Not acknowledge received interrupt enable
	I2C1_CR1_ADDRIE = 1UL<<3, // Address match interrupt enable (slave only)
	I2C1_CR1_RXIE = 1UL<<2, // RX Interrupt enable
	I2C1_CR1_TXIE = 1UL<<1, // TX Interrupt enable
	I2C1_CR1_PE = 1UL<<0, // Peripheral enable		
};
inline void i2c1_cr1_set_dnf(struct I2C1_Type* p, uint32_t val) { p->CR1 = (p->CR1 & ~I2C1_CR1_DNF) | ((val<<8) & I2C1_CR1_DNF); }
inline uint32_t i2c1_cr1_get_dnf(struct I2C1_Type* p) { return (p->CR1 & I2C1_CR1_DNF) >> 8 ; }

// I2C1->CR2 Control register 2
enum {
	I2C1_CR2_PECBYTE = 1UL<<26, // Packet error checking byte
	I2C1_CR2_AUTOEND = 1UL<<25, // Automatic end mode (master mode)
	I2C1_CR2_RELOAD = 1UL<<24, // NBYTES reload mode
	I2C1_CR2_NBYTES = ((1UL<<8)-1) << 16, // Number of bytes
	I2C1_CR2_NACK = 1UL<<15, // NACK generation (slave mode)
	I2C1_CR2_STOP = 1UL<<14, // Stop generation (master mode)
	I2C1_CR2_START = 1UL<<13, // Start generation
	I2C1_CR2_HEAD10R = 1UL<<12, // 10-bit address header only read direction (master receiver mode)
	I2C1_CR2_ADD10 = 1UL<<11, // 10-bit addressing mode (master mode)
	I2C1_CR2_RD_WRN = 1UL<<10, // Transfer direction (master mode)
	I2C1_CR2_SADD = ((1UL<<10)-1) << 0, // Slave address bit (master mode)		
};
inline void i2c1_cr2_set_nbytes(struct I2C1_Type* p, uint32_t val) { p->CR2 = (p->CR2 & ~I2C1_CR2_NBYTES) | ((val<<16) & I2C1_CR2_NBYTES); }
inline void i2c1_cr2_set_sadd(struct I2C1_Type* p, uint32_t val) { p->CR2 = (p->CR2 & ~I2C1_CR2_SADD) | ((val<<0) & I2C1_CR2_SADD); }
inline uint32_t i2c1_cr2_get_nbytes(struct I2C1_Type* p) { return (p->CR2 & I2C1_CR2_NBYTES) >> 16 ; }
inline uint32_t i2c1_cr2_get_sadd(struct I2C1_Type* p) { return (p->CR2 & I2C1_CR2_SADD) >> 0 ; }

// I2C1->OAR1 Own address register 1
enum {
	I2C1_OAR1_OA1EN = 1UL<<15, // Own Address 1 enable
	I2C1_OAR1_OA1MODE = 1UL<<10, // Own Address 1 10-bit mode
	I2C1_OAR1_OA1 = ((1UL<<10)-1) << 0, // Interface address		
};
inline void i2c1_oar1_set_oa1(struct I2C1_Type* p, uint32_t val) { p->OAR1 = (p->OAR1 & ~I2C1_OAR1_OA1) | ((val<<0) & I2C1_OAR1_OA1); }
inline uint32_t i2c1_oar1_get_oa1(struct I2C1_Type* p) { return (p->OAR1 & I2C1_OAR1_OA1) >> 0 ; }

// I2C1->OAR2 Own address register 2
enum {
	I2C1_OAR2_OA2EN = 1UL<<15, // Own Address 2 enable
	I2C1_OAR2_OA2MSK = ((1UL<<3)-1) << 8, // Own Address 2 masks
	I2C1_OAR2_OA2 = ((1UL<<7)-1) << 1, // Interface address		
};
inline void i2c1_oar2_set_oa2msk(struct I2C1_Type* p, uint32_t val) { p->OAR2 = (p->OAR2 & ~I2C1_OAR2_OA2MSK) | ((val<<8) & I2C1_OAR2_OA2MSK); }
inline void i2c1_oar2_set_oa2(struct I2C1_Type* p, uint32_t val) { p->OAR2 = (p->OAR2 & ~I2C1_OAR2_OA2) | ((val<<1) & I2C1_OAR2_OA2); }
inline uint32_t i2c1_oar2_get_oa2msk(struct I2C1_Type* p) { return (p->OAR2 & I2C1_OAR2_OA2MSK) >> 8 ; }
inline uint32_t i2c1_oar2_get_oa2(struct I2C1_Type* p) { return (p->OAR2 & I2C1_OAR2_OA2) >> 1 ; }

// I2C1->TIMINGR Timing register
enum {
	I2C1_TIMINGR_PRESC = ((1UL<<4)-1) << 28, // Timing prescaler
	I2C1_TIMINGR_SCLDEL = ((1UL<<4)-1) << 20, // Data setup time
	I2C1_TIMINGR_SDADEL = ((1UL<<4)-1) << 16, // Data hold time
	I2C1_TIMINGR_SCLH = ((1UL<<8)-1) << 8, // SCL high period (master mode)
	I2C1_TIMINGR_SCLL = ((1UL<<8)-1) << 0, // SCL low period (master mode)		
};
inline void i2c1_timingr_set_presc(struct I2C1_Type* p, uint32_t val) { p->TIMINGR = (p->TIMINGR & ~I2C1_TIMINGR_PRESC) | ((val<<28) & I2C1_TIMINGR_PRESC); }
inline void i2c1_timingr_set_scldel(struct I2C1_Type* p, uint32_t val) { p->TIMINGR = (p->TIMINGR & ~I2C1_TIMINGR_SCLDEL) | ((val<<20) & I2C1_TIMINGR_SCLDEL); }
inline void i2c1_timingr_set_sdadel(struct I2C1_Type* p, uint32_t val) { p->TIMINGR = (p->TIMINGR & ~I2C1_TIMINGR_SDADEL) | ((val<<16) & I2C1_TIMINGR_SDADEL); }
inline void i2c1_timingr_set_sclh(struct I2C1_Type* p, uint32_t val) { p->TIMINGR = (p->TIMINGR & ~I2C1_TIMINGR_SCLH) | ((val<<8) & I2C1_TIMINGR_SCLH); }
inline void i2c1_timingr_set_scll(struct I2C1_Type* p, uint32_t val) { p->TIMINGR = (p->TIMINGR & ~I2C1_TIMINGR_SCLL) | ((val<<0) & I2C1_TIMINGR_SCLL); }
inline uint32_t i2c1_timingr_get_presc(struct I2C1_Type* p) { return (p->TIMINGR & I2C1_TIMINGR_PRESC) >> 28 ; }
inline uint32_t i2c1_timingr_get_scldel(struct I2C1_Type* p) { return (p->TIMINGR & I2C1_TIMINGR_SCLDEL) >> 20 ; }
inline uint32_t i2c1_timingr_get_sdadel(struct I2C1_Type* p) { return (p->TIMINGR & I2C1_TIMINGR_SDADEL) >> 16 ; }
inline uint32_t i2c1_timingr_get_sclh(struct I2C1_Type* p) { return (p->TIMINGR & I2C1_TIMINGR_SCLH) >> 8 ; }
inline uint32_t i2c1_timingr_get_scll(struct I2C1_Type* p) { return (p->TIMINGR & I2C1_TIMINGR_SCLL) >> 0 ; }

// I2C1->TIMEOUTR Status register 1
enum {
	I2C1_TIMEOUTR_TEXTEN = 1UL<<31, // Extended clock timeout enable
	I2C1_TIMEOUTR_TIMEOUTB = ((1UL<<12)-1) << 16, // Bus timeout B
	I2C1_TIMEOUTR_TIMOUTEN = 1UL<<15, // Clock timeout enable
	I2C1_TIMEOUTR_TIDLE = 1UL<<12, // Idle clock timeout detection
	I2C1_TIMEOUTR_TIMEOUTA = ((1UL<<12)-1) << 0, // Bus timeout A		
};
inline void i2c1_timeoutr_set_timeoutb(struct I2C1_Type* p, uint32_t val) { p->TIMEOUTR = (p->TIMEOUTR & ~I2C1_TIMEOUTR_TIMEOUTB) | ((val<<16) & I2C1_TIMEOUTR_TIMEOUTB); }
inline void i2c1_timeoutr_set_timeouta(struct I2C1_Type* p, uint32_t val) { p->TIMEOUTR = (p->TIMEOUTR & ~I2C1_TIMEOUTR_TIMEOUTA) | ((val<<0) & I2C1_TIMEOUTR_TIMEOUTA); }
inline uint32_t i2c1_timeoutr_get_timeoutb(struct I2C1_Type* p) { return (p->TIMEOUTR & I2C1_TIMEOUTR_TIMEOUTB) >> 16 ; }
inline uint32_t i2c1_timeoutr_get_timeouta(struct I2C1_Type* p) { return (p->TIMEOUTR & I2C1_TIMEOUTR_TIMEOUTA) >> 0 ; }

// I2C1->ISR Interrupt and Status register
enum {
	I2C1_ISR_ADDCODE = ((1UL<<7)-1) << 17, // Address match code (Slave mode)
	I2C1_ISR_DIR = 1UL<<16, // Transfer direction (Slave mode)
	I2C1_ISR_BUSY = 1UL<<15, // Bus busy
	I2C1_ISR_ALERT = 1UL<<13, // SMBus alert
	I2C1_ISR_TIMEOUT = 1UL<<12, // Timeout or t_low detection flag
	I2C1_ISR_PECERR = 1UL<<11, // PEC Error in reception
	I2C1_ISR_OVR = 1UL<<10, // Overrun/Underrun (slave mode)
	I2C1_ISR_ARLO = 1UL<<9, // Arbitration lost
	I2C1_ISR_BERR = 1UL<<8, // Bus error
	I2C1_ISR_TCR = 1UL<<7, // Transfer Complete Reload
	I2C1_ISR_TC = 1UL<<6, // Transfer Complete (master mode)
	I2C1_ISR_STOPF = 1UL<<5, // Stop detection flag
	I2C1_ISR_NACKF = 1UL<<4, // Not acknowledge received flag
	I2C1_ISR_ADDR = 1UL<<3, // Address matched (slave mode)
	I2C1_ISR_RXNE = 1UL<<2, // Receive data register not empty (receivers)
	I2C1_ISR_TXIS = 1UL<<1, // Transmit interrupt status (transmitters)
	I2C1_ISR_TXE = 1UL<<0, // Transmit data register empty (transmitters)		
};
inline void i2c1_isr_set_addcode(struct I2C1_Type* p, uint32_t val) { p->ISR = (p->ISR & ~I2C1_ISR_ADDCODE) | ((val<<17) & I2C1_ISR_ADDCODE); }
inline uint32_t i2c1_isr_get_addcode(struct I2C1_Type* p) { return (p->ISR & I2C1_ISR_ADDCODE) >> 17 ; }

// I2C1->ICR Interrupt clear register
enum {
	I2C1_ICR_ALERTCF = 1UL<<13, // Alert flag clear
	I2C1_ICR_TIMOUTCF = 1UL<<12, // Timeout detection flag clear
	I2C1_ICR_PECCF = 1UL<<11, // PEC Error flag clear
	I2C1_ICR_OVRCF = 1UL<<10, // Overrun/Underrun flag clear
	I2C1_ICR_ARLOCF = 1UL<<9, // Arbitration lost flag clear
	I2C1_ICR_BERRCF = 1UL<<8, // Bus error flag clear
	I2C1_ICR_STOPCF = 1UL<<5, // Stop detection flag clear
	I2C1_ICR_NACKCF = 1UL<<4, // Not Acknowledge flag clear
	I2C1_ICR_ADDRCF = 1UL<<3, // Address Matched flag clear		
};




/* Independent watchdog */
struct IWDG_Type {
	__O uint16_t KR; // @0 Key register
	 uint8_t RESERVED0[2]; // @2 
	__IO uint8_t PR; // @4 Prescaler register
	 uint8_t RESERVED1[3]; // @5 
	__IO uint16_t RLR; // @8 Reload register
	 uint8_t RESERVED2[2]; // @10 
	__I uint8_t SR; // @12 Status register
	 uint8_t RESERVED3[3]; // @13 
	__IO uint16_t WINR; // @16 Window register
};

// IWDG->PR Prescaler register
enum {
	IWDG_PR_PR = ((1UL<<3)-1) << 0, // Prescaler divider		
};
inline void iwdg_pr_set_pr(struct IWDG_Type* p, uint32_t val) { p->PR = (p->PR & ~IWDG_PR_PR) | ((val<<0) & IWDG_PR_PR); }
inline uint32_t iwdg_pr_get_pr(struct IWDG_Type* p) { return (p->PR & IWDG_PR_PR) >> 0 ; }

// IWDG->RLR Reload register
enum {
	IWDG_RLR_RL = ((1UL<<12)-1) << 0, // Watchdog counter reload value		
};
inline void iwdg_rlr_set_rl(struct IWDG_Type* p, uint32_t val) { p->RLR = (p->RLR & ~IWDG_RLR_RL) | ((val<<0) & IWDG_RLR_RL); }
inline uint32_t iwdg_rlr_get_rl(struct IWDG_Type* p) { return (p->RLR & IWDG_RLR_RL) >> 0 ; }

// IWDG->SR Status register
enum {
	IWDG_SR_WVU = 1UL<<2, // Watchdog counter window value update
	IWDG_SR_RVU = 1UL<<1, // Watchdog counter reload value update
	IWDG_SR_PVU = 1UL<<0, // Watchdog prescaler value update		
};

// IWDG->WINR Window register
enum {
	IWDG_WINR_WIN = ((1UL<<12)-1) << 0, // Watchdog counter window value		
};
inline void iwdg_winr_set_win(struct IWDG_Type* p, uint32_t val) { p->WINR = (p->WINR & ~IWDG_WINR_WIN) | ((val<<0) & IWDG_WINR_WIN); }
inline uint32_t iwdg_winr_get_win(struct IWDG_Type* p) { return (p->WINR & IWDG_WINR_WIN) >> 0 ; }

/* Liquid crystal display controller */
struct LCD_Type {
	__IO uint16_t CR; // @0 control register
	 uint8_t RESERVED0[2]; // @2 
	__IO uint32_t FCR; // @4 frame control register
	__IO uint8_t SR; // @8 status register
	 uint8_t RESERVED1[3]; // @9 
	__O uint8_t CLR; // @12 clear register
	 uint8_t RESERVED2[7]; // @13 
	__IO uint32_t RAM_COM0; // @20 display memory
	 uint8_t RESERVED3[4]; // @24 
	__IO uint32_t RAM_COM1; // @28 display memory
	 uint8_t RESERVED4[4]; // @32 
	__IO uint32_t RAM_COM2; // @36 display memory
	 uint8_t RESERVED5[4]; // @40 
	__IO uint32_t RAM_COM3; // @44 display memory
	 uint8_t RESERVED6[4]; // @48 
	__IO uint32_t RAM_COM4; // @52 display memory
	 uint8_t RESERVED7[4]; // @56 
	__IO uint32_t RAM_COM5; // @60 display memory
	 uint8_t RESERVED8[4]; // @64 
	__IO uint32_t RAM_COM6; // @68 display memory
	 uint8_t RESERVED9[4]; // @72 
	__IO uint32_t RAM_COM7; // @76 display memory
};

// LCD->CR control register
enum {
	LCD_CR_BUFEN = 1UL<<8, // Voltage output buffer enable
	LCD_CR_MUX_SEG = 1UL<<7, // Mux segment enable
	LCD_CR_BIAS = ((1UL<<2)-1) << 5, // Bias selector
	LCD_CR_DUTY = ((1UL<<3)-1) << 2, // Duty selection
	LCD_CR_VSEL = 1UL<<1, // Voltage source selection
	LCD_CR_LCDEN = 1UL<<0, // LCD controller enable		
};
inline void lcd_cr_set_bias(struct LCD_Type* p, uint32_t val) { p->CR = (p->CR & ~LCD_CR_BIAS) | ((val<<5) & LCD_CR_BIAS); }
inline void lcd_cr_set_duty(struct LCD_Type* p, uint32_t val) { p->CR = (p->CR & ~LCD_CR_DUTY) | ((val<<2) & LCD_CR_DUTY); }
inline uint32_t lcd_cr_get_bias(struct LCD_Type* p) { return (p->CR & LCD_CR_BIAS) >> 5 ; }
inline uint32_t lcd_cr_get_duty(struct LCD_Type* p) { return (p->CR & LCD_CR_DUTY) >> 2 ; }

// LCD->FCR frame control register
enum {
	LCD_FCR_PS = ((1UL<<4)-1) << 22, // PS 16-bit prescaler
	LCD_FCR_DIV = ((1UL<<4)-1) << 18, // DIV clock divider
	LCD_FCR_BLINK = ((1UL<<2)-1) << 16, // Blink mode selection
	LCD_FCR_BLINKF = ((1UL<<3)-1) << 13, // Blink frequency selection
	LCD_FCR_CC = ((1UL<<3)-1) << 10, // Contrast control
	LCD_FCR_DEAD = ((1UL<<3)-1) << 7, // Dead time duration
	LCD_FCR_PON = ((1UL<<3)-1) << 4, // Pulse ON duration
	LCD_FCR_UDDIE = 1UL<<3, // Update display done interrupt enable
	LCD_FCR_SOFIE = 1UL<<1, // Start of frame interrupt enable
	LCD_FCR_HD = 1UL<<0, // High drive enable		
};
inline void lcd_fcr_set_ps(struct LCD_Type* p, uint32_t val) { p->FCR = (p->FCR & ~LCD_FCR_PS) | ((val<<22) & LCD_FCR_PS); }
inline void lcd_fcr_set_div(struct LCD_Type* p, uint32_t val) { p->FCR = (p->FCR & ~LCD_FCR_DIV) | ((val<<18) & LCD_FCR_DIV); }
inline void lcd_fcr_set_blink(struct LCD_Type* p, uint32_t val) { p->FCR = (p->FCR & ~LCD_FCR_BLINK) | ((val<<16) & LCD_FCR_BLINK); }
inline void lcd_fcr_set_blinkf(struct LCD_Type* p, uint32_t val) { p->FCR = (p->FCR & ~LCD_FCR_BLINKF) | ((val<<13) & LCD_FCR_BLINKF); }
inline void lcd_fcr_set_cc(struct LCD_Type* p, uint32_t val) { p->FCR = (p->FCR & ~LCD_FCR_CC) | ((val<<10) & LCD_FCR_CC); }
inline void lcd_fcr_set_dead(struct LCD_Type* p, uint32_t val) { p->FCR = (p->FCR & ~LCD_FCR_DEAD) | ((val<<7) & LCD_FCR_DEAD); }
inline void lcd_fcr_set_pon(struct LCD_Type* p, uint32_t val) { p->FCR = (p->FCR & ~LCD_FCR_PON) | ((val<<4) & LCD_FCR_PON); }
inline uint32_t lcd_fcr_get_ps(struct LCD_Type* p) { return (p->FCR & LCD_FCR_PS) >> 22 ; }
inline uint32_t lcd_fcr_get_div(struct LCD_Type* p) { return (p->FCR & LCD_FCR_DIV) >> 18 ; }
inline uint32_t lcd_fcr_get_blink(struct LCD_Type* p) { return (p->FCR & LCD_FCR_BLINK) >> 16 ; }
inline uint32_t lcd_fcr_get_blinkf(struct LCD_Type* p) { return (p->FCR & LCD_FCR_BLINKF) >> 13 ; }
inline uint32_t lcd_fcr_get_cc(struct LCD_Type* p) { return (p->FCR & LCD_FCR_CC) >> 10 ; }
inline uint32_t lcd_fcr_get_dead(struct LCD_Type* p) { return (p->FCR & LCD_FCR_DEAD) >> 7 ; }
inline uint32_t lcd_fcr_get_pon(struct LCD_Type* p) { return (p->FCR & LCD_FCR_PON) >> 4 ; }

// LCD->SR status register
enum {
	LCD_SR_FCRSF = 1UL<<5, // LCD Frame Control Register Synchronization flag
	LCD_SR_RDY = 1UL<<4, // Ready flag
	LCD_SR_UDD = 1UL<<3, // Update Display Done
	LCD_SR_UDR = 1UL<<2, // Update display request
	LCD_SR_SOF = 1UL<<1, // Start of frame flag
	LCD_SR_ENS = 1UL<<0, // ENS		
};

// LCD->CLR clear register
enum {
	LCD_CLR_UDDC = 1UL<<3, // Update display done clear
	LCD_CLR_SOFC = 1UL<<1, // Start of frame flag clear		
};

// LCD->RAM_COM0 display memory
enum {
	LCD_RAM_COM0_SX  = ((1UL<<31)-1) << 0, // Merged S30		
};
inline void lcd_ram_com0_set_sx (struct LCD_Type* p, uint32_t val) { p->RAM_COM0 = (p->RAM_COM0 & ~LCD_RAM_COM0_SX ) | ((val<<0) & LCD_RAM_COM0_SX ); }
inline uint32_t lcd_ram_com0_get_sx (struct LCD_Type* p) { return (p->RAM_COM0 & LCD_RAM_COM0_SX ) >> 0 ; }

/* Low power timer */
struct LPTIM1_Type {
	__I uint8_t ISR; // @0 Interrupt and Status Register
	 uint8_t RESERVED0[3]; // @1 
	__O uint8_t ICR; // @4 Interrupt Clear Register
	 uint8_t RESERVED1[3]; // @5 
	__IO uint8_t IER; // @8 Interrupt Enable Register
	 uint8_t RESERVED2[3]; // @9 
	__IO uint32_t CFGR; // @12 Configuration Register
	__IO uint8_t CR; // @16 Control Register
	 uint8_t RESERVED3[3]; // @17 
	__IO uint16_t CMP; // @20 Compare Register
	 uint8_t RESERVED4[2]; // @22 
	__IO uint16_t ARR; // @24 Autoreload Register
	 uint8_t RESERVED5[2]; // @26 
	__I uint16_t CNT; // @28 Counter Register
};

// LPTIM1->ISR Interrupt and Status Register
enum {
	LPTIM1_ISR_DOWN = 1UL<<6, // Counter direction change up to down
	LPTIM1_ISR_UP = 1UL<<5, // Counter direction change down to up
	LPTIM1_ISR_ARROK = 1UL<<4, // Autoreload register update OK
	LPTIM1_ISR_CMPOK = 1UL<<3, // Compare register update OK
	LPTIM1_ISR_EXTTRIG = 1UL<<2, // External trigger edge event
	LPTIM1_ISR_ARRM = 1UL<<1, // Autoreload match
	LPTIM1_ISR_CMPM = 1UL<<0, // Compare match		
};

// LPTIM1->ICR Interrupt Clear Register
enum {
	LPTIM1_ICR_DOWNCF = 1UL<<6, // Direction change to down Clear Flag
	LPTIM1_ICR_UPCF = 1UL<<5, // Direction change to UP Clear Flag
	LPTIM1_ICR_ARROKCF = 1UL<<4, // Autoreload register update OK Clear Flag
	LPTIM1_ICR_CMPOKCF = 1UL<<3, // Compare register update OK Clear Flag
	LPTIM1_ICR_EXTTRIGCF = 1UL<<2, // External trigger valid edge Clear Flag
	LPTIM1_ICR_ARRMCF = 1UL<<1, // Autoreload match Clear Flag
	LPTIM1_ICR_CMPMCF = 1UL<<0, // compare match Clear Flag		
};

// LPTIM1->IER Interrupt Enable Register
enum {
	LPTIM1_IER_DOWNIE = 1UL<<6, // Direction change to down Interrupt Enable
	LPTIM1_IER_UPIE = 1UL<<5, // Direction change to UP Interrupt Enable
	LPTIM1_IER_ARROKIE = 1UL<<4, // Autoreload register update OK Interrupt Enable
	LPTIM1_IER_CMPOKIE = 1UL<<3, // Compare register update OK Interrupt Enable
	LPTIM1_IER_EXTTRIGIE = 1UL<<2, // External trigger valid edge Interrupt Enable
	LPTIM1_IER_ARRMIE = 1UL<<1, // Autoreload match Interrupt Enable
	LPTIM1_IER_CMPMIE = 1UL<<0, // Compare match Interrupt Enable		
};

// LPTIM1->CFGR Configuration Register
enum {
	LPTIM1_CFGR_ENC = 1UL<<24, // Encoder mode enable
	LPTIM1_CFGR_COUNTMODE = 1UL<<23, // counter mode enabled
	LPTIM1_CFGR_PRELOAD = 1UL<<22, // Registers update mode
	LPTIM1_CFGR_WAVPOL = 1UL<<21, // Waveform shape polarity
	LPTIM1_CFGR_WAVE = 1UL<<20, // Waveform shape
	LPTIM1_CFGR_TIMOUT = 1UL<<19, // Timeout enable
	LPTIM1_CFGR_TRIGEN = ((1UL<<2)-1) << 17, // Trigger enable and polarity
	LPTIM1_CFGR_TRIGSEL = ((1UL<<3)-1) << 13, // Trigger selector
	LPTIM1_CFGR_PRESC = ((1UL<<3)-1) << 9, // Clock prescaler
	LPTIM1_CFGR_TRGFLT = ((1UL<<2)-1) << 6, // Configurable digital filter for trigger
	LPTIM1_CFGR_CKFLT = ((1UL<<2)-1) << 3, // Configurable digital filter for external clock
	LPTIM1_CFGR_CKPOL = ((1UL<<2)-1) << 1, // Clock Polarity
	LPTIM1_CFGR_CKSEL = 1UL<<0, // Clock selector		
};
inline void lptim1_cfgr_set_trigen(struct LPTIM1_Type* p, uint32_t val) { p->CFGR = (p->CFGR & ~LPTIM1_CFGR_TRIGEN) | ((val<<17) & LPTIM1_CFGR_TRIGEN); }
inline void lptim1_cfgr_set_trigsel(struct LPTIM1_Type* p, uint32_t val) { p->CFGR = (p->CFGR & ~LPTIM1_CFGR_TRIGSEL) | ((val<<13) & LPTIM1_CFGR_TRIGSEL); }
inline void lptim1_cfgr_set_presc(struct LPTIM1_Type* p, uint32_t val) { p->CFGR = (p->CFGR & ~LPTIM1_CFGR_PRESC) | ((val<<9) & LPTIM1_CFGR_PRESC); }
inline void lptim1_cfgr_set_trgflt(struct LPTIM1_Type* p, uint32_t val) { p->CFGR = (p->CFGR & ~LPTIM1_CFGR_TRGFLT) | ((val<<6) & LPTIM1_CFGR_TRGFLT); }
inline void lptim1_cfgr_set_ckflt(struct LPTIM1_Type* p, uint32_t val) { p->CFGR = (p->CFGR & ~LPTIM1_CFGR_CKFLT) | ((val<<3) & LPTIM1_CFGR_CKFLT); }
inline void lptim1_cfgr_set_ckpol(struct LPTIM1_Type* p, uint32_t val) { p->CFGR = (p->CFGR & ~LPTIM1_CFGR_CKPOL) | ((val<<1) & LPTIM1_CFGR_CKPOL); }
inline uint32_t lptim1_cfgr_get_trigen(struct LPTIM1_Type* p) { return (p->CFGR & LPTIM1_CFGR_TRIGEN) >> 17 ; }
inline uint32_t lptim1_cfgr_get_trigsel(struct LPTIM1_Type* p) { return (p->CFGR & LPTIM1_CFGR_TRIGSEL) >> 13 ; }
inline uint32_t lptim1_cfgr_get_presc(struct LPTIM1_Type* p) { return (p->CFGR & LPTIM1_CFGR_PRESC) >> 9 ; }
inline uint32_t lptim1_cfgr_get_trgflt(struct LPTIM1_Type* p) { return (p->CFGR & LPTIM1_CFGR_TRGFLT) >> 6 ; }
inline uint32_t lptim1_cfgr_get_ckflt(struct LPTIM1_Type* p) { return (p->CFGR & LPTIM1_CFGR_CKFLT) >> 3 ; }
inline uint32_t lptim1_cfgr_get_ckpol(struct LPTIM1_Type* p) { return (p->CFGR & LPTIM1_CFGR_CKPOL) >> 1 ; }

// LPTIM1->CR Control Register
enum {
	LPTIM1_CR_CNTSTRT = 1UL<<2, // Timer start in continuous mode
	LPTIM1_CR_SNGSTRT = 1UL<<1, // LPTIM start in single mode
	LPTIM1_CR_ENABLE = 1UL<<0, // LPTIM Enable		
};


/* Universal synchronous asynchronous receiver transmitter */
struct LPUART1_Type {
	__IO uint32_t CR1; // @0 Control register 1
	__IO uint32_t CR2; // @4 Control register 2
	__IO uint32_t CR3; // @8 Control register 3
	__IO uint32_t BRR; // @12 Baud rate register
	 uint8_t RESERVED0[8]; // @16 
	__O uint8_t RQR; // @24 Request register
	 uint8_t RESERVED1[3]; // @25 
	__I uint32_t ISR; // @28 Interrupt & status register
	__O uint32_t ICR; // @32 Interrupt flag clear register
	__I uint16_t RDR; // @36 Receive data register
	 uint8_t RESERVED2[2]; // @38 
	__IO uint16_t TDR; // @40 Transmit data register
};

// LPUART1->CR1 Control register 1
enum {
	LPUART1_CR1_M1 = 1UL<<28, // Word length
	LPUART1_CR1_DEAT4 = 1UL<<25, // Driver Enable assertion time
	LPUART1_CR1_DEAT3 = 1UL<<24, // DEAT3
	LPUART1_CR1_DEAT2 = 1UL<<23, // DEAT2
	LPUART1_CR1_DEAT1 = 1UL<<22, // DEAT1
	LPUART1_CR1_DEAT0 = 1UL<<21, // DEAT0
	LPUART1_CR1_DEDT4 = 1UL<<20, // Driver Enable de-assertion time
	LPUART1_CR1_DEDT3 = 1UL<<19, // DEDT3
	LPUART1_CR1_DEDT2 = 1UL<<18, // DEDT2
	LPUART1_CR1_DEDT1 = 1UL<<17, // DEDT1
	LPUART1_CR1_DEDT0 = 1UL<<16, // DEDT0
	LPUART1_CR1_CMIE = 1UL<<14, // Character match interrupt enable
	LPUART1_CR1_MME = 1UL<<13, // Mute mode enable
	LPUART1_CR1_M0 = 1UL<<12, // Word length
	LPUART1_CR1_WAKE = 1UL<<11, // Receiver wakeup method
	LPUART1_CR1_PCE = 1UL<<10, // Parity control enable
	LPUART1_CR1_PS = 1UL<<9, // Parity selection
	LPUART1_CR1_PEIE = 1UL<<8, // PE interrupt enable
	LPUART1_CR1_TXEIE = 1UL<<7, // interrupt enable
	LPUART1_CR1_TCIE = 1UL<<6, // Transmission complete interrupt enable
	LPUART1_CR1_RXNEIE = 1UL<<5, // RXNE interrupt enable
	LPUART1_CR1_IDLEIE = 1UL<<4, // IDLE interrupt enable
	LPUART1_CR1_TE = 1UL<<3, // Transmitter enable
	LPUART1_CR1_RE = 1UL<<2, // Receiver enable
	LPUART1_CR1_UESM = 1UL<<1, // USART enable in Stop mode
	LPUART1_CR1_UE = 1UL<<0, // USART enable		
};

// LPUART1->CR2 Control register 2
enum {
	LPUART1_CR2_ADD4_7 = ((1UL<<4)-1) << 28, // Address of the USART node
	LPUART1_CR2_ADD0_3 = ((1UL<<4)-1) << 24, // Address of the USART node
	LPUART1_CR2_MSBFIRST = 1UL<<19, // Most significant bit first
	LPUART1_CR2_TAINV = 1UL<<18, // Binary data inversion
	LPUART1_CR2_TXINV = 1UL<<17, // TX pin active level inversion
	LPUART1_CR2_RXINV = 1UL<<16, // RX pin active level inversion
	LPUART1_CR2_SWAP = 1UL<<15, // Swap TX/RX pins
	LPUART1_CR2_STOP = ((1UL<<2)-1) << 12, // STOP bits
	LPUART1_CR2_CLKEN = 1UL<<11, // Clock enable
	LPUART1_CR2_ADDM7 = 1UL<<4, // 7-bit Address Detection/4-bit Address Detection		
};
inline void lpuart1_cr2_set_add4_7(struct LPUART1_Type* p, uint32_t val) { p->CR2 = (p->CR2 & ~LPUART1_CR2_ADD4_7) | ((val<<28) & LPUART1_CR2_ADD4_7); }
inline void lpuart1_cr2_set_add0_3(struct LPUART1_Type* p, uint32_t val) { p->CR2 = (p->CR2 & ~LPUART1_CR2_ADD0_3) | ((val<<24) & LPUART1_CR2_ADD0_3); }
inline void lpuart1_cr2_set_stop(struct LPUART1_Type* p, uint32_t val) { p->CR2 = (p->CR2 & ~LPUART1_CR2_STOP) | ((val<<12) & LPUART1_CR2_STOP); }
inline uint32_t lpuart1_cr2_get_add4_7(struct LPUART1_Type* p) { return (p->CR2 & LPUART1_CR2_ADD4_7) >> 28 ; }
inline uint32_t lpuart1_cr2_get_add0_3(struct LPUART1_Type* p) { return (p->CR2 & LPUART1_CR2_ADD0_3) >> 24 ; }
inline uint32_t lpuart1_cr2_get_stop(struct LPUART1_Type* p) { return (p->CR2 & LPUART1_CR2_STOP) >> 12 ; }

// LPUART1->CR3 Control register 3
enum {
	LPUART1_CR3_WUFIE = 1UL<<22, // Wakeup from Stop mode interrupt enable
	LPUART1_CR3_WUS = ((1UL<<2)-1) << 20, // Wakeup from Stop mode interrupt flag selection
	LPUART1_CR3_DEP = 1UL<<15, // Driver enable polarity selection
	LPUART1_CR3_DEM = 1UL<<14, // Driver enable mode
	LPUART1_CR3_DDRE = 1UL<<13, // DMA Disable on Reception Error
	LPUART1_CR3_OVRDIS = 1UL<<12, // Overrun Disable
	LPUART1_CR3_CTSIE = 1UL<<10, // CTS interrupt enable
	LPUART1_CR3_CTSE = 1UL<<9, // CTS enable
	LPUART1_CR3_RTSE = 1UL<<8, // RTS enable
	LPUART1_CR3_DMAT = 1UL<<7, // DMA enable transmitter
	LPUART1_CR3_DMAR = 1UL<<6, // DMA enable receiver
	LPUART1_CR3_HDSEL = 1UL<<3, // Half-duplex selection
	LPUART1_CR3_EIE = 1UL<<0, // Error interrupt enable		
};
inline void lpuart1_cr3_set_wus(struct LPUART1_Type* p, uint32_t val) { p->CR3 = (p->CR3 & ~LPUART1_CR3_WUS) | ((val<<20) & LPUART1_CR3_WUS); }
inline uint32_t lpuart1_cr3_get_wus(struct LPUART1_Type* p) { return (p->CR3 & LPUART1_CR3_WUS) >> 20 ; }

// LPUART1->BRR Baud rate register
enum {
	LPUART1_BRR_BRR = ((1UL<<20)-1) << 0, // BRR		
};
inline void lpuart1_brr_set_brr(struct LPUART1_Type* p, uint32_t val) { p->BRR = (p->BRR & ~LPUART1_BRR_BRR) | ((val<<0) & LPUART1_BRR_BRR); }
inline uint32_t lpuart1_brr_get_brr(struct LPUART1_Type* p) { return (p->BRR & LPUART1_BRR_BRR) >> 0 ; }

// LPUART1->RQR Request register
enum {
	LPUART1_RQR_RXFRQ = 1UL<<3, // Receive data flush request
	LPUART1_RQR_MMRQ = 1UL<<2, // Mute mode request
	LPUART1_RQR_SBKRQ = 1UL<<1, // Send break request		
};

// LPUART1->ISR Interrupt & status register
enum {
	LPUART1_ISR_REACK = 1UL<<22, // REACK
	LPUART1_ISR_TEACK = 1UL<<21, // TEACK
	LPUART1_ISR_WUF = 1UL<<20, // WUF
	LPUART1_ISR_RWU = 1UL<<19, // RWU
	LPUART1_ISR_SBKF = 1UL<<18, // SBKF
	LPUART1_ISR_CMF = 1UL<<17, // CMF
	LPUART1_ISR_BUSY = 1UL<<16, // BUSY
	LPUART1_ISR_CTS = 1UL<<10, // CTS
	LPUART1_ISR_CTSIF = 1UL<<9, // CTSIF
	LPUART1_ISR_TXE = 1UL<<7, // TXE
	LPUART1_ISR_TC = 1UL<<6, // TC
	LPUART1_ISR_RXNE = 1UL<<5, // RXNE
	LPUART1_ISR_IDLE = 1UL<<4, // IDLE
	LPUART1_ISR_ORE = 1UL<<3, // ORE
	LPUART1_ISR_NF = 1UL<<2, // NF
	LPUART1_ISR_FE = 1UL<<1, // FE
	LPUART1_ISR_PE = 1UL<<0, // PE		
};

// LPUART1->ICR Interrupt flag clear register
enum {
	LPUART1_ICR_WUCF = 1UL<<20, // Wakeup from Stop mode clear flag
	LPUART1_ICR_CMCF = 1UL<<17, // Character match clear flag
	LPUART1_ICR_CTSCF = 1UL<<9, // CTS clear flag
	LPUART1_ICR_TCCF = 1UL<<6, // Transmission complete clear flag
	LPUART1_ICR_IDLECF = 1UL<<4, // Idle line detected clear flag
	LPUART1_ICR_ORECF = 1UL<<3, // Overrun error clear flag
	LPUART1_ICR_NCF = 1UL<<2, // Noise detected clear flag
	LPUART1_ICR_FECF = 1UL<<1, // Framing error clear flag
	LPUART1_ICR_PECF = 1UL<<0, // Parity error clear flag		
};

// LPUART1->RDR Receive data register
enum {
	LPUART1_RDR_RDR = ((1UL<<9)-1) << 0, // Receive data value		
};
inline uint32_t lpuart1_rdr_get_rdr(struct LPUART1_Type* p) { return (p->RDR & LPUART1_RDR_RDR) >> 0 ; }

// LPUART1->TDR Transmit data register
enum {
	LPUART1_TDR_TDR = ((1UL<<9)-1) << 0, // Transmit data value		
};
inline void lpuart1_tdr_set_tdr(struct LPUART1_Type* p, uint32_t val) { p->TDR = (p->TDR & ~LPUART1_TDR_TDR) | ((val<<0) & LPUART1_TDR_TDR); }
inline uint32_t lpuart1_tdr_get_tdr(struct LPUART1_Type* p) { return (p->TDR & LPUART1_TDR_TDR) >> 0 ; }

/* Memory protection unit */
struct MPU_Type {
	__I uint32_t TYPER; // @0 MPU type register
	__I uint8_t CTRL; // @4 MPU control register
	 uint8_t RESERVED0[3]; // @5 
	__IO uint8_t RNR; // @8 MPU region number register
	 uint8_t RESERVED1[3]; // @9 
	__IO uint32_t RBAR; // @12 MPU region base address register
	__IO uint32_t RASR; // @16 MPU region attribute and size register
};

// MPU->TYPER MPU type register
enum {
	MPU_TYPER_IREGION = ((1UL<<8)-1) << 16, // Number of MPU instruction regions
	MPU_TYPER_DREGION = ((1UL<<8)-1) << 8, // Number of MPU data regions
	MPU_TYPER_SEPARATE = 1UL<<0, // Separate flag		
};
inline uint32_t mpu_typer_get_iregion(struct MPU_Type* p) { return (p->TYPER & MPU_TYPER_IREGION) >> 16 ; }
inline uint32_t mpu_typer_get_dregion(struct MPU_Type* p) { return (p->TYPER & MPU_TYPER_DREGION) >> 8 ; }

// MPU->CTRL MPU control register
enum {
	MPU_CTRL_PRIVDEFENA = 1UL<<2, // Enable priviliged software access to default memory map
	MPU_CTRL_HFNMIENA = 1UL<<1, // Enables the operation of MPU during hard fault
	MPU_CTRL_ENABLE = 1UL<<0, // Enables the MPU		
};

// MPU->RBAR MPU region base address register
enum {
	MPU_RBAR_ADDR = ((1UL<<27)-1) << 5, // Region base address field
	MPU_RBAR_VALID = 1UL<<4, // MPU region number valid
	MPU_RBAR_REGION = ((1UL<<4)-1) << 0, // MPU region field		
};
inline void mpu_rbar_set_addr(struct MPU_Type* p, uint32_t val) { p->RBAR = (p->RBAR & ~MPU_RBAR_ADDR) | ((val<<5) & MPU_RBAR_ADDR); }
inline void mpu_rbar_set_region(struct MPU_Type* p, uint32_t val) { p->RBAR = (p->RBAR & ~MPU_RBAR_REGION) | ((val<<0) & MPU_RBAR_REGION); }
inline uint32_t mpu_rbar_get_addr(struct MPU_Type* p) { return (p->RBAR & MPU_RBAR_ADDR) >> 5 ; }
inline uint32_t mpu_rbar_get_region(struct MPU_Type* p) { return (p->RBAR & MPU_RBAR_REGION) >> 0 ; }

// MPU->RASR MPU region attribute and size register
enum {
	MPU_RASR_XN = 1UL<<28, // Instruction access disable bit
	MPU_RASR_AP = ((1UL<<3)-1) << 24, // Access permission
	MPU_RASR_TEX = ((1UL<<3)-1) << 19, // memory attribute
	MPU_RASR_S = 1UL<<18, // Shareable memory attribute
	MPU_RASR_C = 1UL<<17, // memory attribute
	MPU_RASR_B = 1UL<<16, // memory attribute
	MPU_RASR_SRD = ((1UL<<8)-1) << 8, // Subregion disable bits
	MPU_RASR_SIZE = ((1UL<<5)-1) << 1, // Size of the MPU protection region
	MPU_RASR_ENABLE = 1UL<<0, // Region enable bit.		
};
inline void mpu_rasr_set_ap(struct MPU_Type* p, uint32_t val) { p->RASR = (p->RASR & ~MPU_RASR_AP) | ((val<<24) & MPU_RASR_AP); }
inline void mpu_rasr_set_tex(struct MPU_Type* p, uint32_t val) { p->RASR = (p->RASR & ~MPU_RASR_TEX) | ((val<<19) & MPU_RASR_TEX); }
inline void mpu_rasr_set_srd(struct MPU_Type* p, uint32_t val) { p->RASR = (p->RASR & ~MPU_RASR_SRD) | ((val<<8) & MPU_RASR_SRD); }
inline void mpu_rasr_set_size(struct MPU_Type* p, uint32_t val) { p->RASR = (p->RASR & ~MPU_RASR_SIZE) | ((val<<1) & MPU_RASR_SIZE); }
inline uint32_t mpu_rasr_get_ap(struct MPU_Type* p) { return (p->RASR & MPU_RASR_AP) >> 24 ; }
inline uint32_t mpu_rasr_get_tex(struct MPU_Type* p) { return (p->RASR & MPU_RASR_TEX) >> 19 ; }
inline uint32_t mpu_rasr_get_srd(struct MPU_Type* p) { return (p->RASR & MPU_RASR_SRD) >> 8 ; }
inline uint32_t mpu_rasr_get_size(struct MPU_Type* p) { return (p->RASR & MPU_RASR_SIZE) >> 1 ; }

/* Nested Vectored Interrupt Controller */
struct NVIC_Type {
	__IO uint32_t ISER0; // @0 Interrupt Set-Enable Register
	__IO uint32_t ISER1; // @4 Interrupt Set-Enable Register
	__IO uint32_t ISER2; // @8 Interrupt Set-Enable Register
	 uint8_t RESERVED0[116]; // @12 
	__IO uint32_t ICER0; // @128 Interrupt Clear-Enable Register
	__IO uint32_t ICER1; // @132 Interrupt Clear-Enable Register
	__IO uint32_t ICER2; // @136 Interrupt Clear-Enable Register
	 uint8_t RESERVED1[116]; // @140 
	__IO uint32_t ISPR0; // @256 Interrupt Set-Pending Register
	__IO uint32_t ISPR1; // @260 Interrupt Set-Pending Register
	__IO uint32_t ISPR2; // @264 Interrupt Set-Pending Register
	 uint8_t RESERVED2[116]; // @268 
	__IO uint32_t ICPR0; // @384 Interrupt Clear-Pending Register
	__IO uint32_t ICPR1; // @388 Interrupt Clear-Pending Register
	__IO uint32_t ICPR2; // @392 Interrupt Clear-Pending Register
	 uint8_t RESERVED3[116]; // @396 
	__I uint32_t IABR0; // @512 Interrupt Active Bit Register
	__I uint32_t IABR1; // @516 Interrupt Active Bit Register
	__I uint32_t IABR2; // @520 Interrupt Active Bit Register
	 uint8_t RESERVED4[244]; // @524 
	__IO uint32_t IPR0; // @768 Interrupt Priority Register
	__IO uint32_t IPR1; // @772 Interrupt Priority Register
	__IO uint32_t IPR2; // @776 Interrupt Priority Register
	__IO uint32_t IPR3; // @780 Interrupt Priority Register
	__IO uint32_t IPR4; // @784 Interrupt Priority Register
	__IO uint32_t IPR5; // @788 Interrupt Priority Register
	__IO uint32_t IPR6; // @792 Interrupt Priority Register
	__IO uint32_t IPR7; // @796 Interrupt Priority Register
	__IO uint32_t IPR8; // @800 Interrupt Priority Register
	__IO uint32_t IPR9; // @804 Interrupt Priority Register
	__IO uint32_t IPR10; // @808 Interrupt Priority Register
	__IO uint32_t IPR11; // @812 Interrupt Priority Register
	__IO uint32_t IPR12; // @816 Interrupt Priority Register
	__IO uint32_t IPR13; // @820 Interrupt Priority Register
	__IO uint32_t IPR14; // @824 Interrupt Priority Register
	__IO uint32_t IPR15; // @828 Interrupt Priority Register
	__IO uint32_t IPR16; // @832 Interrupt Priority Register
	__IO uint32_t IPR17; // @836 Interrupt Priority Register
	__IO uint32_t IPR18; // @840 Interrupt Priority Register
	__IO uint32_t IPR19; // @844 Interrupt Priority Register
	__IO uint32_t IPR20; // @848 Interrupt Priority Register
};

// NVIC->IPR0 Interrupt Priority Register
enum {
	NVIC_IPR0_IPR_N3 = ((1UL<<8)-1) << 24, // IPR_N3
	NVIC_IPR0_IPR_N2 = ((1UL<<8)-1) << 16, // IPR_N2
	NVIC_IPR0_IPR_N1 = ((1UL<<8)-1) << 8, // IPR_N1
	NVIC_IPR0_IPR_N0 = ((1UL<<8)-1) << 0, // IPR_N0		
};
inline void nvic_ipr0_set_ipr_n3(struct NVIC_Type* p, uint32_t val) { p->IPR0 = (p->IPR0 & ~NVIC_IPR0_IPR_N3) | ((val<<24) & NVIC_IPR0_IPR_N3); }
inline void nvic_ipr0_set_ipr_n2(struct NVIC_Type* p, uint32_t val) { p->IPR0 = (p->IPR0 & ~NVIC_IPR0_IPR_N2) | ((val<<16) & NVIC_IPR0_IPR_N2); }
inline void nvic_ipr0_set_ipr_n1(struct NVIC_Type* p, uint32_t val) { p->IPR0 = (p->IPR0 & ~NVIC_IPR0_IPR_N1) | ((val<<8) & NVIC_IPR0_IPR_N1); }
inline void nvic_ipr0_set_ipr_n0(struct NVIC_Type* p, uint32_t val) { p->IPR0 = (p->IPR0 & ~NVIC_IPR0_IPR_N0) | ((val<<0) & NVIC_IPR0_IPR_N0); }
inline uint32_t nvic_ipr0_get_ipr_n3(struct NVIC_Type* p) { return (p->IPR0 & NVIC_IPR0_IPR_N3) >> 24 ; }
inline uint32_t nvic_ipr0_get_ipr_n2(struct NVIC_Type* p) { return (p->IPR0 & NVIC_IPR0_IPR_N2) >> 16 ; }
inline uint32_t nvic_ipr0_get_ipr_n1(struct NVIC_Type* p) { return (p->IPR0 & NVIC_IPR0_IPR_N1) >> 8 ; }
inline uint32_t nvic_ipr0_get_ipr_n0(struct NVIC_Type* p) { return (p->IPR0 & NVIC_IPR0_IPR_N0) >> 0 ; }

// NVIC->IPR1 Interrupt Priority Register
enum {
	NVIC_IPR1_IPR_N3 = ((1UL<<8)-1) << 24, // IPR_N3
	NVIC_IPR1_IPR_N2 = ((1UL<<8)-1) << 16, // IPR_N2
	NVIC_IPR1_IPR_N1 = ((1UL<<8)-1) << 8, // IPR_N1
	NVIC_IPR1_IPR_N0 = ((1UL<<8)-1) << 0, // IPR_N0		
};
inline void nvic_ipr1_set_ipr_n3(struct NVIC_Type* p, uint32_t val) { p->IPR1 = (p->IPR1 & ~NVIC_IPR1_IPR_N3) | ((val<<24) & NVIC_IPR1_IPR_N3); }
inline void nvic_ipr1_set_ipr_n2(struct NVIC_Type* p, uint32_t val) { p->IPR1 = (p->IPR1 & ~NVIC_IPR1_IPR_N2) | ((val<<16) & NVIC_IPR1_IPR_N2); }
inline void nvic_ipr1_set_ipr_n1(struct NVIC_Type* p, uint32_t val) { p->IPR1 = (p->IPR1 & ~NVIC_IPR1_IPR_N1) | ((val<<8) & NVIC_IPR1_IPR_N1); }
inline void nvic_ipr1_set_ipr_n0(struct NVIC_Type* p, uint32_t val) { p->IPR1 = (p->IPR1 & ~NVIC_IPR1_IPR_N0) | ((val<<0) & NVIC_IPR1_IPR_N0); }
inline uint32_t nvic_ipr1_get_ipr_n3(struct NVIC_Type* p) { return (p->IPR1 & NVIC_IPR1_IPR_N3) >> 24 ; }
inline uint32_t nvic_ipr1_get_ipr_n2(struct NVIC_Type* p) { return (p->IPR1 & NVIC_IPR1_IPR_N2) >> 16 ; }
inline uint32_t nvic_ipr1_get_ipr_n1(struct NVIC_Type* p) { return (p->IPR1 & NVIC_IPR1_IPR_N1) >> 8 ; }
inline uint32_t nvic_ipr1_get_ipr_n0(struct NVIC_Type* p) { return (p->IPR1 & NVIC_IPR1_IPR_N0) >> 0 ; }

// NVIC->IPR2 Interrupt Priority Register
enum {
	NVIC_IPR2_IPR_N3 = ((1UL<<8)-1) << 24, // IPR_N3
	NVIC_IPR2_IPR_N2 = ((1UL<<8)-1) << 16, // IPR_N2
	NVIC_IPR2_IPR_N1 = ((1UL<<8)-1) << 8, // IPR_N1
	NVIC_IPR2_IPR_N0 = ((1UL<<8)-1) << 0, // IPR_N0		
};
inline void nvic_ipr2_set_ipr_n3(struct NVIC_Type* p, uint32_t val) { p->IPR2 = (p->IPR2 & ~NVIC_IPR2_IPR_N3) | ((val<<24) & NVIC_IPR2_IPR_N3); }
inline void nvic_ipr2_set_ipr_n2(struct NVIC_Type* p, uint32_t val) { p->IPR2 = (p->IPR2 & ~NVIC_IPR2_IPR_N2) | ((val<<16) & NVIC_IPR2_IPR_N2); }
inline void nvic_ipr2_set_ipr_n1(struct NVIC_Type* p, uint32_t val) { p->IPR2 = (p->IPR2 & ~NVIC_IPR2_IPR_N1) | ((val<<8) & NVIC_IPR2_IPR_N1); }
inline void nvic_ipr2_set_ipr_n0(struct NVIC_Type* p, uint32_t val) { p->IPR2 = (p->IPR2 & ~NVIC_IPR2_IPR_N0) | ((val<<0) & NVIC_IPR2_IPR_N0); }
inline uint32_t nvic_ipr2_get_ipr_n3(struct NVIC_Type* p) { return (p->IPR2 & NVIC_IPR2_IPR_N3) >> 24 ; }
inline uint32_t nvic_ipr2_get_ipr_n2(struct NVIC_Type* p) { return (p->IPR2 & NVIC_IPR2_IPR_N2) >> 16 ; }
inline uint32_t nvic_ipr2_get_ipr_n1(struct NVIC_Type* p) { return (p->IPR2 & NVIC_IPR2_IPR_N1) >> 8 ; }
inline uint32_t nvic_ipr2_get_ipr_n0(struct NVIC_Type* p) { return (p->IPR2 & NVIC_IPR2_IPR_N0) >> 0 ; }

// NVIC->IPR3 Interrupt Priority Register
enum {
	NVIC_IPR3_IPR_N3 = ((1UL<<8)-1) << 24, // IPR_N3
	NVIC_IPR3_IPR_N2 = ((1UL<<8)-1) << 16, // IPR_N2
	NVIC_IPR3_IPR_N1 = ((1UL<<8)-1) << 8, // IPR_N1
	NVIC_IPR3_IPR_N0 = ((1UL<<8)-1) << 0, // IPR_N0		
};
inline void nvic_ipr3_set_ipr_n3(struct NVIC_Type* p, uint32_t val) { p->IPR3 = (p->IPR3 & ~NVIC_IPR3_IPR_N3) | ((val<<24) & NVIC_IPR3_IPR_N3); }
inline void nvic_ipr3_set_ipr_n2(struct NVIC_Type* p, uint32_t val) { p->IPR3 = (p->IPR3 & ~NVIC_IPR3_IPR_N2) | ((val<<16) & NVIC_IPR3_IPR_N2); }
inline void nvic_ipr3_set_ipr_n1(struct NVIC_Type* p, uint32_t val) { p->IPR3 = (p->IPR3 & ~NVIC_IPR3_IPR_N1) | ((val<<8) & NVIC_IPR3_IPR_N1); }
inline void nvic_ipr3_set_ipr_n0(struct NVIC_Type* p, uint32_t val) { p->IPR3 = (p->IPR3 & ~NVIC_IPR3_IPR_N0) | ((val<<0) & NVIC_IPR3_IPR_N0); }
inline uint32_t nvic_ipr3_get_ipr_n3(struct NVIC_Type* p) { return (p->IPR3 & NVIC_IPR3_IPR_N3) >> 24 ; }
inline uint32_t nvic_ipr3_get_ipr_n2(struct NVIC_Type* p) { return (p->IPR3 & NVIC_IPR3_IPR_N2) >> 16 ; }
inline uint32_t nvic_ipr3_get_ipr_n1(struct NVIC_Type* p) { return (p->IPR3 & NVIC_IPR3_IPR_N1) >> 8 ; }
inline uint32_t nvic_ipr3_get_ipr_n0(struct NVIC_Type* p) { return (p->IPR3 & NVIC_IPR3_IPR_N0) >> 0 ; }

// NVIC->IPR4 Interrupt Priority Register
enum {
	NVIC_IPR4_IPR_N3 = ((1UL<<8)-1) << 24, // IPR_N3
	NVIC_IPR4_IPR_N2 = ((1UL<<8)-1) << 16, // IPR_N2
	NVIC_IPR4_IPR_N1 = ((1UL<<8)-1) << 8, // IPR_N1
	NVIC_IPR4_IPR_N0 = ((1UL<<8)-1) << 0, // IPR_N0		
};
inline void nvic_ipr4_set_ipr_n3(struct NVIC_Type* p, uint32_t val) { p->IPR4 = (p->IPR4 & ~NVIC_IPR4_IPR_N3) | ((val<<24) & NVIC_IPR4_IPR_N3); }
inline void nvic_ipr4_set_ipr_n2(struct NVIC_Type* p, uint32_t val) { p->IPR4 = (p->IPR4 & ~NVIC_IPR4_IPR_N2) | ((val<<16) & NVIC_IPR4_IPR_N2); }
inline void nvic_ipr4_set_ipr_n1(struct NVIC_Type* p, uint32_t val) { p->IPR4 = (p->IPR4 & ~NVIC_IPR4_IPR_N1) | ((val<<8) & NVIC_IPR4_IPR_N1); }
inline void nvic_ipr4_set_ipr_n0(struct NVIC_Type* p, uint32_t val) { p->IPR4 = (p->IPR4 & ~NVIC_IPR4_IPR_N0) | ((val<<0) & NVIC_IPR4_IPR_N0); }
inline uint32_t nvic_ipr4_get_ipr_n3(struct NVIC_Type* p) { return (p->IPR4 & NVIC_IPR4_IPR_N3) >> 24 ; }
inline uint32_t nvic_ipr4_get_ipr_n2(struct NVIC_Type* p) { return (p->IPR4 & NVIC_IPR4_IPR_N2) >> 16 ; }
inline uint32_t nvic_ipr4_get_ipr_n1(struct NVIC_Type* p) { return (p->IPR4 & NVIC_IPR4_IPR_N1) >> 8 ; }
inline uint32_t nvic_ipr4_get_ipr_n0(struct NVIC_Type* p) { return (p->IPR4 & NVIC_IPR4_IPR_N0) >> 0 ; }

// NVIC->IPR5 Interrupt Priority Register
enum {
	NVIC_IPR5_IPR_N3 = ((1UL<<8)-1) << 24, // IPR_N3
	NVIC_IPR5_IPR_N2 = ((1UL<<8)-1) << 16, // IPR_N2
	NVIC_IPR5_IPR_N1 = ((1UL<<8)-1) << 8, // IPR_N1
	NVIC_IPR5_IPR_N0 = ((1UL<<8)-1) << 0, // IPR_N0		
};
inline void nvic_ipr5_set_ipr_n3(struct NVIC_Type* p, uint32_t val) { p->IPR5 = (p->IPR5 & ~NVIC_IPR5_IPR_N3) | ((val<<24) & NVIC_IPR5_IPR_N3); }
inline void nvic_ipr5_set_ipr_n2(struct NVIC_Type* p, uint32_t val) { p->IPR5 = (p->IPR5 & ~NVIC_IPR5_IPR_N2) | ((val<<16) & NVIC_IPR5_IPR_N2); }
inline void nvic_ipr5_set_ipr_n1(struct NVIC_Type* p, uint32_t val) { p->IPR5 = (p->IPR5 & ~NVIC_IPR5_IPR_N1) | ((val<<8) & NVIC_IPR5_IPR_N1); }
inline void nvic_ipr5_set_ipr_n0(struct NVIC_Type* p, uint32_t val) { p->IPR5 = (p->IPR5 & ~NVIC_IPR5_IPR_N0) | ((val<<0) & NVIC_IPR5_IPR_N0); }
inline uint32_t nvic_ipr5_get_ipr_n3(struct NVIC_Type* p) { return (p->IPR5 & NVIC_IPR5_IPR_N3) >> 24 ; }
inline uint32_t nvic_ipr5_get_ipr_n2(struct NVIC_Type* p) { return (p->IPR5 & NVIC_IPR5_IPR_N2) >> 16 ; }
inline uint32_t nvic_ipr5_get_ipr_n1(struct NVIC_Type* p) { return (p->IPR5 & NVIC_IPR5_IPR_N1) >> 8 ; }
inline uint32_t nvic_ipr5_get_ipr_n0(struct NVIC_Type* p) { return (p->IPR5 & NVIC_IPR5_IPR_N0) >> 0 ; }

// NVIC->IPR6 Interrupt Priority Register
enum {
	NVIC_IPR6_IPR_N3 = ((1UL<<8)-1) << 24, // IPR_N3
	NVIC_IPR6_IPR_N2 = ((1UL<<8)-1) << 16, // IPR_N2
	NVIC_IPR6_IPR_N1 = ((1UL<<8)-1) << 8, // IPR_N1
	NVIC_IPR6_IPR_N0 = ((1UL<<8)-1) << 0, // IPR_N0		
};
inline void nvic_ipr6_set_ipr_n3(struct NVIC_Type* p, uint32_t val) { p->IPR6 = (p->IPR6 & ~NVIC_IPR6_IPR_N3) | ((val<<24) & NVIC_IPR6_IPR_N3); }
inline void nvic_ipr6_set_ipr_n2(struct NVIC_Type* p, uint32_t val) { p->IPR6 = (p->IPR6 & ~NVIC_IPR6_IPR_N2) | ((val<<16) & NVIC_IPR6_IPR_N2); }
inline void nvic_ipr6_set_ipr_n1(struct NVIC_Type* p, uint32_t val) { p->IPR6 = (p->IPR6 & ~NVIC_IPR6_IPR_N1) | ((val<<8) & NVIC_IPR6_IPR_N1); }
inline void nvic_ipr6_set_ipr_n0(struct NVIC_Type* p, uint32_t val) { p->IPR6 = (p->IPR6 & ~NVIC_IPR6_IPR_N0) | ((val<<0) & NVIC_IPR6_IPR_N0); }
inline uint32_t nvic_ipr6_get_ipr_n3(struct NVIC_Type* p) { return (p->IPR6 & NVIC_IPR6_IPR_N3) >> 24 ; }
inline uint32_t nvic_ipr6_get_ipr_n2(struct NVIC_Type* p) { return (p->IPR6 & NVIC_IPR6_IPR_N2) >> 16 ; }
inline uint32_t nvic_ipr6_get_ipr_n1(struct NVIC_Type* p) { return (p->IPR6 & NVIC_IPR6_IPR_N1) >> 8 ; }
inline uint32_t nvic_ipr6_get_ipr_n0(struct NVIC_Type* p) { return (p->IPR6 & NVIC_IPR6_IPR_N0) >> 0 ; }

// NVIC->IPR7 Interrupt Priority Register
enum {
	NVIC_IPR7_IPR_N3 = ((1UL<<8)-1) << 24, // IPR_N3
	NVIC_IPR7_IPR_N2 = ((1UL<<8)-1) << 16, // IPR_N2
	NVIC_IPR7_IPR_N1 = ((1UL<<8)-1) << 8, // IPR_N1
	NVIC_IPR7_IPR_N0 = ((1UL<<8)-1) << 0, // IPR_N0		
};
inline void nvic_ipr7_set_ipr_n3(struct NVIC_Type* p, uint32_t val) { p->IPR7 = (p->IPR7 & ~NVIC_IPR7_IPR_N3) | ((val<<24) & NVIC_IPR7_IPR_N3); }
inline void nvic_ipr7_set_ipr_n2(struct NVIC_Type* p, uint32_t val) { p->IPR7 = (p->IPR7 & ~NVIC_IPR7_IPR_N2) | ((val<<16) & NVIC_IPR7_IPR_N2); }
inline void nvic_ipr7_set_ipr_n1(struct NVIC_Type* p, uint32_t val) { p->IPR7 = (p->IPR7 & ~NVIC_IPR7_IPR_N1) | ((val<<8) & NVIC_IPR7_IPR_N1); }
inline void nvic_ipr7_set_ipr_n0(struct NVIC_Type* p, uint32_t val) { p->IPR7 = (p->IPR7 & ~NVIC_IPR7_IPR_N0) | ((val<<0) & NVIC_IPR7_IPR_N0); }
inline uint32_t nvic_ipr7_get_ipr_n3(struct NVIC_Type* p) { return (p->IPR7 & NVIC_IPR7_IPR_N3) >> 24 ; }
inline uint32_t nvic_ipr7_get_ipr_n2(struct NVIC_Type* p) { return (p->IPR7 & NVIC_IPR7_IPR_N2) >> 16 ; }
inline uint32_t nvic_ipr7_get_ipr_n1(struct NVIC_Type* p) { return (p->IPR7 & NVIC_IPR7_IPR_N1) >> 8 ; }
inline uint32_t nvic_ipr7_get_ipr_n0(struct NVIC_Type* p) { return (p->IPR7 & NVIC_IPR7_IPR_N0) >> 0 ; }

// NVIC->IPR8 Interrupt Priority Register
enum {
	NVIC_IPR8_IPR_N3 = ((1UL<<8)-1) << 24, // IPR_N3
	NVIC_IPR8_IPR_N2 = ((1UL<<8)-1) << 16, // IPR_N2
	NVIC_IPR8_IPR_N1 = ((1UL<<8)-1) << 8, // IPR_N1
	NVIC_IPR8_IPR_N0 = ((1UL<<8)-1) << 0, // IPR_N0		
};
inline void nvic_ipr8_set_ipr_n3(struct NVIC_Type* p, uint32_t val) { p->IPR8 = (p->IPR8 & ~NVIC_IPR8_IPR_N3) | ((val<<24) & NVIC_IPR8_IPR_N3); }
inline void nvic_ipr8_set_ipr_n2(struct NVIC_Type* p, uint32_t val) { p->IPR8 = (p->IPR8 & ~NVIC_IPR8_IPR_N2) | ((val<<16) & NVIC_IPR8_IPR_N2); }
inline void nvic_ipr8_set_ipr_n1(struct NVIC_Type* p, uint32_t val) { p->IPR8 = (p->IPR8 & ~NVIC_IPR8_IPR_N1) | ((val<<8) & NVIC_IPR8_IPR_N1); }
inline void nvic_ipr8_set_ipr_n0(struct NVIC_Type* p, uint32_t val) { p->IPR8 = (p->IPR8 & ~NVIC_IPR8_IPR_N0) | ((val<<0) & NVIC_IPR8_IPR_N0); }
inline uint32_t nvic_ipr8_get_ipr_n3(struct NVIC_Type* p) { return (p->IPR8 & NVIC_IPR8_IPR_N3) >> 24 ; }
inline uint32_t nvic_ipr8_get_ipr_n2(struct NVIC_Type* p) { return (p->IPR8 & NVIC_IPR8_IPR_N2) >> 16 ; }
inline uint32_t nvic_ipr8_get_ipr_n1(struct NVIC_Type* p) { return (p->IPR8 & NVIC_IPR8_IPR_N1) >> 8 ; }
inline uint32_t nvic_ipr8_get_ipr_n0(struct NVIC_Type* p) { return (p->IPR8 & NVIC_IPR8_IPR_N0) >> 0 ; }

// NVIC->IPR9 Interrupt Priority Register
enum {
	NVIC_IPR9_IPR_N3 = ((1UL<<8)-1) << 24, // IPR_N3
	NVIC_IPR9_IPR_N2 = ((1UL<<8)-1) << 16, // IPR_N2
	NVIC_IPR9_IPR_N1 = ((1UL<<8)-1) << 8, // IPR_N1
	NVIC_IPR9_IPR_N0 = ((1UL<<8)-1) << 0, // IPR_N0		
};
inline void nvic_ipr9_set_ipr_n3(struct NVIC_Type* p, uint32_t val) { p->IPR9 = (p->IPR9 & ~NVIC_IPR9_IPR_N3) | ((val<<24) & NVIC_IPR9_IPR_N3); }
inline void nvic_ipr9_set_ipr_n2(struct NVIC_Type* p, uint32_t val) { p->IPR9 = (p->IPR9 & ~NVIC_IPR9_IPR_N2) | ((val<<16) & NVIC_IPR9_IPR_N2); }
inline void nvic_ipr9_set_ipr_n1(struct NVIC_Type* p, uint32_t val) { p->IPR9 = (p->IPR9 & ~NVIC_IPR9_IPR_N1) | ((val<<8) & NVIC_IPR9_IPR_N1); }
inline void nvic_ipr9_set_ipr_n0(struct NVIC_Type* p, uint32_t val) { p->IPR9 = (p->IPR9 & ~NVIC_IPR9_IPR_N0) | ((val<<0) & NVIC_IPR9_IPR_N0); }
inline uint32_t nvic_ipr9_get_ipr_n3(struct NVIC_Type* p) { return (p->IPR9 & NVIC_IPR9_IPR_N3) >> 24 ; }
inline uint32_t nvic_ipr9_get_ipr_n2(struct NVIC_Type* p) { return (p->IPR9 & NVIC_IPR9_IPR_N2) >> 16 ; }
inline uint32_t nvic_ipr9_get_ipr_n1(struct NVIC_Type* p) { return (p->IPR9 & NVIC_IPR9_IPR_N1) >> 8 ; }
inline uint32_t nvic_ipr9_get_ipr_n0(struct NVIC_Type* p) { return (p->IPR9 & NVIC_IPR9_IPR_N0) >> 0 ; }

// NVIC->IPR10 Interrupt Priority Register
enum {
	NVIC_IPR10_IPR_N3 = ((1UL<<8)-1) << 24, // IPR_N3
	NVIC_IPR10_IPR_N2 = ((1UL<<8)-1) << 16, // IPR_N2
	NVIC_IPR10_IPR_N1 = ((1UL<<8)-1) << 8, // IPR_N1
	NVIC_IPR10_IPR_N0 = ((1UL<<8)-1) << 0, // IPR_N0		
};
inline void nvic_ipr10_set_ipr_n3(struct NVIC_Type* p, uint32_t val) { p->IPR10 = (p->IPR10 & ~NVIC_IPR10_IPR_N3) | ((val<<24) & NVIC_IPR10_IPR_N3); }
inline void nvic_ipr10_set_ipr_n2(struct NVIC_Type* p, uint32_t val) { p->IPR10 = (p->IPR10 & ~NVIC_IPR10_IPR_N2) | ((val<<16) & NVIC_IPR10_IPR_N2); }
inline void nvic_ipr10_set_ipr_n1(struct NVIC_Type* p, uint32_t val) { p->IPR10 = (p->IPR10 & ~NVIC_IPR10_IPR_N1) | ((val<<8) & NVIC_IPR10_IPR_N1); }
inline void nvic_ipr10_set_ipr_n0(struct NVIC_Type* p, uint32_t val) { p->IPR10 = (p->IPR10 & ~NVIC_IPR10_IPR_N0) | ((val<<0) & NVIC_IPR10_IPR_N0); }
inline uint32_t nvic_ipr10_get_ipr_n3(struct NVIC_Type* p) { return (p->IPR10 & NVIC_IPR10_IPR_N3) >> 24 ; }
inline uint32_t nvic_ipr10_get_ipr_n2(struct NVIC_Type* p) { return (p->IPR10 & NVIC_IPR10_IPR_N2) >> 16 ; }
inline uint32_t nvic_ipr10_get_ipr_n1(struct NVIC_Type* p) { return (p->IPR10 & NVIC_IPR10_IPR_N1) >> 8 ; }
inline uint32_t nvic_ipr10_get_ipr_n0(struct NVIC_Type* p) { return (p->IPR10 & NVIC_IPR10_IPR_N0) >> 0 ; }

// NVIC->IPR11 Interrupt Priority Register
enum {
	NVIC_IPR11_IPR_N3 = ((1UL<<8)-1) << 24, // IPR_N3
	NVIC_IPR11_IPR_N2 = ((1UL<<8)-1) << 16, // IPR_N2
	NVIC_IPR11_IPR_N1 = ((1UL<<8)-1) << 8, // IPR_N1
	NVIC_IPR11_IPR_N0 = ((1UL<<8)-1) << 0, // IPR_N0		
};
inline void nvic_ipr11_set_ipr_n3(struct NVIC_Type* p, uint32_t val) { p->IPR11 = (p->IPR11 & ~NVIC_IPR11_IPR_N3) | ((val<<24) & NVIC_IPR11_IPR_N3); }
inline void nvic_ipr11_set_ipr_n2(struct NVIC_Type* p, uint32_t val) { p->IPR11 = (p->IPR11 & ~NVIC_IPR11_IPR_N2) | ((val<<16) & NVIC_IPR11_IPR_N2); }
inline void nvic_ipr11_set_ipr_n1(struct NVIC_Type* p, uint32_t val) { p->IPR11 = (p->IPR11 & ~NVIC_IPR11_IPR_N1) | ((val<<8) & NVIC_IPR11_IPR_N1); }
inline void nvic_ipr11_set_ipr_n0(struct NVIC_Type* p, uint32_t val) { p->IPR11 = (p->IPR11 & ~NVIC_IPR11_IPR_N0) | ((val<<0) & NVIC_IPR11_IPR_N0); }
inline uint32_t nvic_ipr11_get_ipr_n3(struct NVIC_Type* p) { return (p->IPR11 & NVIC_IPR11_IPR_N3) >> 24 ; }
inline uint32_t nvic_ipr11_get_ipr_n2(struct NVIC_Type* p) { return (p->IPR11 & NVIC_IPR11_IPR_N2) >> 16 ; }
inline uint32_t nvic_ipr11_get_ipr_n1(struct NVIC_Type* p) { return (p->IPR11 & NVIC_IPR11_IPR_N1) >> 8 ; }
inline uint32_t nvic_ipr11_get_ipr_n0(struct NVIC_Type* p) { return (p->IPR11 & NVIC_IPR11_IPR_N0) >> 0 ; }

// NVIC->IPR12 Interrupt Priority Register
enum {
	NVIC_IPR12_IPR_N3 = ((1UL<<8)-1) << 24, // IPR_N3
	NVIC_IPR12_IPR_N2 = ((1UL<<8)-1) << 16, // IPR_N2
	NVIC_IPR12_IPR_N1 = ((1UL<<8)-1) << 8, // IPR_N1
	NVIC_IPR12_IPR_N0 = ((1UL<<8)-1) << 0, // IPR_N0		
};
inline void nvic_ipr12_set_ipr_n3(struct NVIC_Type* p, uint32_t val) { p->IPR12 = (p->IPR12 & ~NVIC_IPR12_IPR_N3) | ((val<<24) & NVIC_IPR12_IPR_N3); }
inline void nvic_ipr12_set_ipr_n2(struct NVIC_Type* p, uint32_t val) { p->IPR12 = (p->IPR12 & ~NVIC_IPR12_IPR_N2) | ((val<<16) & NVIC_IPR12_IPR_N2); }
inline void nvic_ipr12_set_ipr_n1(struct NVIC_Type* p, uint32_t val) { p->IPR12 = (p->IPR12 & ~NVIC_IPR12_IPR_N1) | ((val<<8) & NVIC_IPR12_IPR_N1); }
inline void nvic_ipr12_set_ipr_n0(struct NVIC_Type* p, uint32_t val) { p->IPR12 = (p->IPR12 & ~NVIC_IPR12_IPR_N0) | ((val<<0) & NVIC_IPR12_IPR_N0); }
inline uint32_t nvic_ipr12_get_ipr_n3(struct NVIC_Type* p) { return (p->IPR12 & NVIC_IPR12_IPR_N3) >> 24 ; }
inline uint32_t nvic_ipr12_get_ipr_n2(struct NVIC_Type* p) { return (p->IPR12 & NVIC_IPR12_IPR_N2) >> 16 ; }
inline uint32_t nvic_ipr12_get_ipr_n1(struct NVIC_Type* p) { return (p->IPR12 & NVIC_IPR12_IPR_N1) >> 8 ; }
inline uint32_t nvic_ipr12_get_ipr_n0(struct NVIC_Type* p) { return (p->IPR12 & NVIC_IPR12_IPR_N0) >> 0 ; }

// NVIC->IPR13 Interrupt Priority Register
enum {
	NVIC_IPR13_IPR_N3 = ((1UL<<8)-1) << 24, // IPR_N3
	NVIC_IPR13_IPR_N2 = ((1UL<<8)-1) << 16, // IPR_N2
	NVIC_IPR13_IPR_N1 = ((1UL<<8)-1) << 8, // IPR_N1
	NVIC_IPR13_IPR_N0 = ((1UL<<8)-1) << 0, // IPR_N0		
};
inline void nvic_ipr13_set_ipr_n3(struct NVIC_Type* p, uint32_t val) { p->IPR13 = (p->IPR13 & ~NVIC_IPR13_IPR_N3) | ((val<<24) & NVIC_IPR13_IPR_N3); }
inline void nvic_ipr13_set_ipr_n2(struct NVIC_Type* p, uint32_t val) { p->IPR13 = (p->IPR13 & ~NVIC_IPR13_IPR_N2) | ((val<<16) & NVIC_IPR13_IPR_N2); }
inline void nvic_ipr13_set_ipr_n1(struct NVIC_Type* p, uint32_t val) { p->IPR13 = (p->IPR13 & ~NVIC_IPR13_IPR_N1) | ((val<<8) & NVIC_IPR13_IPR_N1); }
inline void nvic_ipr13_set_ipr_n0(struct NVIC_Type* p, uint32_t val) { p->IPR13 = (p->IPR13 & ~NVIC_IPR13_IPR_N0) | ((val<<0) & NVIC_IPR13_IPR_N0); }
inline uint32_t nvic_ipr13_get_ipr_n3(struct NVIC_Type* p) { return (p->IPR13 & NVIC_IPR13_IPR_N3) >> 24 ; }
inline uint32_t nvic_ipr13_get_ipr_n2(struct NVIC_Type* p) { return (p->IPR13 & NVIC_IPR13_IPR_N2) >> 16 ; }
inline uint32_t nvic_ipr13_get_ipr_n1(struct NVIC_Type* p) { return (p->IPR13 & NVIC_IPR13_IPR_N1) >> 8 ; }
inline uint32_t nvic_ipr13_get_ipr_n0(struct NVIC_Type* p) { return (p->IPR13 & NVIC_IPR13_IPR_N0) >> 0 ; }

// NVIC->IPR14 Interrupt Priority Register
enum {
	NVIC_IPR14_IPR_N3 = ((1UL<<8)-1) << 24, // IPR_N3
	NVIC_IPR14_IPR_N2 = ((1UL<<8)-1) << 16, // IPR_N2
	NVIC_IPR14_IPR_N1 = ((1UL<<8)-1) << 8, // IPR_N1
	NVIC_IPR14_IPR_N0 = ((1UL<<8)-1) << 0, // IPR_N0		
};
inline void nvic_ipr14_set_ipr_n3(struct NVIC_Type* p, uint32_t val) { p->IPR14 = (p->IPR14 & ~NVIC_IPR14_IPR_N3) | ((val<<24) & NVIC_IPR14_IPR_N3); }
inline void nvic_ipr14_set_ipr_n2(struct NVIC_Type* p, uint32_t val) { p->IPR14 = (p->IPR14 & ~NVIC_IPR14_IPR_N2) | ((val<<16) & NVIC_IPR14_IPR_N2); }
inline void nvic_ipr14_set_ipr_n1(struct NVIC_Type* p, uint32_t val) { p->IPR14 = (p->IPR14 & ~NVIC_IPR14_IPR_N1) | ((val<<8) & NVIC_IPR14_IPR_N1); }
inline void nvic_ipr14_set_ipr_n0(struct NVIC_Type* p, uint32_t val) { p->IPR14 = (p->IPR14 & ~NVIC_IPR14_IPR_N0) | ((val<<0) & NVIC_IPR14_IPR_N0); }
inline uint32_t nvic_ipr14_get_ipr_n3(struct NVIC_Type* p) { return (p->IPR14 & NVIC_IPR14_IPR_N3) >> 24 ; }
inline uint32_t nvic_ipr14_get_ipr_n2(struct NVIC_Type* p) { return (p->IPR14 & NVIC_IPR14_IPR_N2) >> 16 ; }
inline uint32_t nvic_ipr14_get_ipr_n1(struct NVIC_Type* p) { return (p->IPR14 & NVIC_IPR14_IPR_N1) >> 8 ; }
inline uint32_t nvic_ipr14_get_ipr_n0(struct NVIC_Type* p) { return (p->IPR14 & NVIC_IPR14_IPR_N0) >> 0 ; }

// NVIC->IPR15 Interrupt Priority Register
enum {
	NVIC_IPR15_IPR_N3 = ((1UL<<8)-1) << 24, // IPR_N3
	NVIC_IPR15_IPR_N2 = ((1UL<<8)-1) << 16, // IPR_N2
	NVIC_IPR15_IPR_N1 = ((1UL<<8)-1) << 8, // IPR_N1
	NVIC_IPR15_IPR_N0 = ((1UL<<8)-1) << 0, // IPR_N0		
};
inline void nvic_ipr15_set_ipr_n3(struct NVIC_Type* p, uint32_t val) { p->IPR15 = (p->IPR15 & ~NVIC_IPR15_IPR_N3) | ((val<<24) & NVIC_IPR15_IPR_N3); }
inline void nvic_ipr15_set_ipr_n2(struct NVIC_Type* p, uint32_t val) { p->IPR15 = (p->IPR15 & ~NVIC_IPR15_IPR_N2) | ((val<<16) & NVIC_IPR15_IPR_N2); }
inline void nvic_ipr15_set_ipr_n1(struct NVIC_Type* p, uint32_t val) { p->IPR15 = (p->IPR15 & ~NVIC_IPR15_IPR_N1) | ((val<<8) & NVIC_IPR15_IPR_N1); }
inline void nvic_ipr15_set_ipr_n0(struct NVIC_Type* p, uint32_t val) { p->IPR15 = (p->IPR15 & ~NVIC_IPR15_IPR_N0) | ((val<<0) & NVIC_IPR15_IPR_N0); }
inline uint32_t nvic_ipr15_get_ipr_n3(struct NVIC_Type* p) { return (p->IPR15 & NVIC_IPR15_IPR_N3) >> 24 ; }
inline uint32_t nvic_ipr15_get_ipr_n2(struct NVIC_Type* p) { return (p->IPR15 & NVIC_IPR15_IPR_N2) >> 16 ; }
inline uint32_t nvic_ipr15_get_ipr_n1(struct NVIC_Type* p) { return (p->IPR15 & NVIC_IPR15_IPR_N1) >> 8 ; }
inline uint32_t nvic_ipr15_get_ipr_n0(struct NVIC_Type* p) { return (p->IPR15 & NVIC_IPR15_IPR_N0) >> 0 ; }

// NVIC->IPR16 Interrupt Priority Register
enum {
	NVIC_IPR16_IPR_N3 = ((1UL<<8)-1) << 24, // IPR_N3
	NVIC_IPR16_IPR_N2 = ((1UL<<8)-1) << 16, // IPR_N2
	NVIC_IPR16_IPR_N1 = ((1UL<<8)-1) << 8, // IPR_N1
	NVIC_IPR16_IPR_N0 = ((1UL<<8)-1) << 0, // IPR_N0		
};
inline void nvic_ipr16_set_ipr_n3(struct NVIC_Type* p, uint32_t val) { p->IPR16 = (p->IPR16 & ~NVIC_IPR16_IPR_N3) | ((val<<24) & NVIC_IPR16_IPR_N3); }
inline void nvic_ipr16_set_ipr_n2(struct NVIC_Type* p, uint32_t val) { p->IPR16 = (p->IPR16 & ~NVIC_IPR16_IPR_N2) | ((val<<16) & NVIC_IPR16_IPR_N2); }
inline void nvic_ipr16_set_ipr_n1(struct NVIC_Type* p, uint32_t val) { p->IPR16 = (p->IPR16 & ~NVIC_IPR16_IPR_N1) | ((val<<8) & NVIC_IPR16_IPR_N1); }
inline void nvic_ipr16_set_ipr_n0(struct NVIC_Type* p, uint32_t val) { p->IPR16 = (p->IPR16 & ~NVIC_IPR16_IPR_N0) | ((val<<0) & NVIC_IPR16_IPR_N0); }
inline uint32_t nvic_ipr16_get_ipr_n3(struct NVIC_Type* p) { return (p->IPR16 & NVIC_IPR16_IPR_N3) >> 24 ; }
inline uint32_t nvic_ipr16_get_ipr_n2(struct NVIC_Type* p) { return (p->IPR16 & NVIC_IPR16_IPR_N2) >> 16 ; }
inline uint32_t nvic_ipr16_get_ipr_n1(struct NVIC_Type* p) { return (p->IPR16 & NVIC_IPR16_IPR_N1) >> 8 ; }
inline uint32_t nvic_ipr16_get_ipr_n0(struct NVIC_Type* p) { return (p->IPR16 & NVIC_IPR16_IPR_N0) >> 0 ; }

// NVIC->IPR17 Interrupt Priority Register
enum {
	NVIC_IPR17_IPR_N3 = ((1UL<<8)-1) << 24, // IPR_N3
	NVIC_IPR17_IPR_N2 = ((1UL<<8)-1) << 16, // IPR_N2
	NVIC_IPR17_IPR_N1 = ((1UL<<8)-1) << 8, // IPR_N1
	NVIC_IPR17_IPR_N0 = ((1UL<<8)-1) << 0, // IPR_N0		
};
inline void nvic_ipr17_set_ipr_n3(struct NVIC_Type* p, uint32_t val) { p->IPR17 = (p->IPR17 & ~NVIC_IPR17_IPR_N3) | ((val<<24) & NVIC_IPR17_IPR_N3); }
inline void nvic_ipr17_set_ipr_n2(struct NVIC_Type* p, uint32_t val) { p->IPR17 = (p->IPR17 & ~NVIC_IPR17_IPR_N2) | ((val<<16) & NVIC_IPR17_IPR_N2); }
inline void nvic_ipr17_set_ipr_n1(struct NVIC_Type* p, uint32_t val) { p->IPR17 = (p->IPR17 & ~NVIC_IPR17_IPR_N1) | ((val<<8) & NVIC_IPR17_IPR_N1); }
inline void nvic_ipr17_set_ipr_n0(struct NVIC_Type* p, uint32_t val) { p->IPR17 = (p->IPR17 & ~NVIC_IPR17_IPR_N0) | ((val<<0) & NVIC_IPR17_IPR_N0); }
inline uint32_t nvic_ipr17_get_ipr_n3(struct NVIC_Type* p) { return (p->IPR17 & NVIC_IPR17_IPR_N3) >> 24 ; }
inline uint32_t nvic_ipr17_get_ipr_n2(struct NVIC_Type* p) { return (p->IPR17 & NVIC_IPR17_IPR_N2) >> 16 ; }
inline uint32_t nvic_ipr17_get_ipr_n1(struct NVIC_Type* p) { return (p->IPR17 & NVIC_IPR17_IPR_N1) >> 8 ; }
inline uint32_t nvic_ipr17_get_ipr_n0(struct NVIC_Type* p) { return (p->IPR17 & NVIC_IPR17_IPR_N0) >> 0 ; }

// NVIC->IPR18 Interrupt Priority Register
enum {
	NVIC_IPR18_IPR_N3 = ((1UL<<8)-1) << 24, // IPR_N3
	NVIC_IPR18_IPR_N2 = ((1UL<<8)-1) << 16, // IPR_N2
	NVIC_IPR18_IPR_N1 = ((1UL<<8)-1) << 8, // IPR_N1
	NVIC_IPR18_IPR_N0 = ((1UL<<8)-1) << 0, // IPR_N0		
};
inline void nvic_ipr18_set_ipr_n3(struct NVIC_Type* p, uint32_t val) { p->IPR18 = (p->IPR18 & ~NVIC_IPR18_IPR_N3) | ((val<<24) & NVIC_IPR18_IPR_N3); }
inline void nvic_ipr18_set_ipr_n2(struct NVIC_Type* p, uint32_t val) { p->IPR18 = (p->IPR18 & ~NVIC_IPR18_IPR_N2) | ((val<<16) & NVIC_IPR18_IPR_N2); }
inline void nvic_ipr18_set_ipr_n1(struct NVIC_Type* p, uint32_t val) { p->IPR18 = (p->IPR18 & ~NVIC_IPR18_IPR_N1) | ((val<<8) & NVIC_IPR18_IPR_N1); }
inline void nvic_ipr18_set_ipr_n0(struct NVIC_Type* p, uint32_t val) { p->IPR18 = (p->IPR18 & ~NVIC_IPR18_IPR_N0) | ((val<<0) & NVIC_IPR18_IPR_N0); }
inline uint32_t nvic_ipr18_get_ipr_n3(struct NVIC_Type* p) { return (p->IPR18 & NVIC_IPR18_IPR_N3) >> 24 ; }
inline uint32_t nvic_ipr18_get_ipr_n2(struct NVIC_Type* p) { return (p->IPR18 & NVIC_IPR18_IPR_N2) >> 16 ; }
inline uint32_t nvic_ipr18_get_ipr_n1(struct NVIC_Type* p) { return (p->IPR18 & NVIC_IPR18_IPR_N1) >> 8 ; }
inline uint32_t nvic_ipr18_get_ipr_n0(struct NVIC_Type* p) { return (p->IPR18 & NVIC_IPR18_IPR_N0) >> 0 ; }

// NVIC->IPR19 Interrupt Priority Register
enum {
	NVIC_IPR19_IPR_N3 = ((1UL<<8)-1) << 24, // IPR_N3
	NVIC_IPR19_IPR_N2 = ((1UL<<8)-1) << 16, // IPR_N2
	NVIC_IPR19_IPR_N1 = ((1UL<<8)-1) << 8, // IPR_N1
	NVIC_IPR19_IPR_N0 = ((1UL<<8)-1) << 0, // IPR_N0		
};
inline void nvic_ipr19_set_ipr_n3(struct NVIC_Type* p, uint32_t val) { p->IPR19 = (p->IPR19 & ~NVIC_IPR19_IPR_N3) | ((val<<24) & NVIC_IPR19_IPR_N3); }
inline void nvic_ipr19_set_ipr_n2(struct NVIC_Type* p, uint32_t val) { p->IPR19 = (p->IPR19 & ~NVIC_IPR19_IPR_N2) | ((val<<16) & NVIC_IPR19_IPR_N2); }
inline void nvic_ipr19_set_ipr_n1(struct NVIC_Type* p, uint32_t val) { p->IPR19 = (p->IPR19 & ~NVIC_IPR19_IPR_N1) | ((val<<8) & NVIC_IPR19_IPR_N1); }
inline void nvic_ipr19_set_ipr_n0(struct NVIC_Type* p, uint32_t val) { p->IPR19 = (p->IPR19 & ~NVIC_IPR19_IPR_N0) | ((val<<0) & NVIC_IPR19_IPR_N0); }
inline uint32_t nvic_ipr19_get_ipr_n3(struct NVIC_Type* p) { return (p->IPR19 & NVIC_IPR19_IPR_N3) >> 24 ; }
inline uint32_t nvic_ipr19_get_ipr_n2(struct NVIC_Type* p) { return (p->IPR19 & NVIC_IPR19_IPR_N2) >> 16 ; }
inline uint32_t nvic_ipr19_get_ipr_n1(struct NVIC_Type* p) { return (p->IPR19 & NVIC_IPR19_IPR_N1) >> 8 ; }
inline uint32_t nvic_ipr19_get_ipr_n0(struct NVIC_Type* p) { return (p->IPR19 & NVIC_IPR19_IPR_N0) >> 0 ; }

// NVIC->IPR20 Interrupt Priority Register
enum {
	NVIC_IPR20_IPR_N3 = ((1UL<<8)-1) << 24, // IPR_N3
	NVIC_IPR20_IPR_N2 = ((1UL<<8)-1) << 16, // IPR_N2
	NVIC_IPR20_IPR_N1 = ((1UL<<8)-1) << 8, // IPR_N1
	NVIC_IPR20_IPR_N0 = ((1UL<<8)-1) << 0, // IPR_N0		
};
inline void nvic_ipr20_set_ipr_n3(struct NVIC_Type* p, uint32_t val) { p->IPR20 = (p->IPR20 & ~NVIC_IPR20_IPR_N3) | ((val<<24) & NVIC_IPR20_IPR_N3); }
inline void nvic_ipr20_set_ipr_n2(struct NVIC_Type* p, uint32_t val) { p->IPR20 = (p->IPR20 & ~NVIC_IPR20_IPR_N2) | ((val<<16) & NVIC_IPR20_IPR_N2); }
inline void nvic_ipr20_set_ipr_n1(struct NVIC_Type* p, uint32_t val) { p->IPR20 = (p->IPR20 & ~NVIC_IPR20_IPR_N1) | ((val<<8) & NVIC_IPR20_IPR_N1); }
inline void nvic_ipr20_set_ipr_n0(struct NVIC_Type* p, uint32_t val) { p->IPR20 = (p->IPR20 & ~NVIC_IPR20_IPR_N0) | ((val<<0) & NVIC_IPR20_IPR_N0); }
inline uint32_t nvic_ipr20_get_ipr_n3(struct NVIC_Type* p) { return (p->IPR20 & NVIC_IPR20_IPR_N3) >> 24 ; }
inline uint32_t nvic_ipr20_get_ipr_n2(struct NVIC_Type* p) { return (p->IPR20 & NVIC_IPR20_IPR_N2) >> 16 ; }
inline uint32_t nvic_ipr20_get_ipr_n1(struct NVIC_Type* p) { return (p->IPR20 & NVIC_IPR20_IPR_N1) >> 8 ; }
inline uint32_t nvic_ipr20_get_ipr_n0(struct NVIC_Type* p) { return (p->IPR20 & NVIC_IPR20_IPR_N0) >> 0 ; }

/* Nested vectored interrupt controller */
struct NVIC_STIR_Type {
	__IO uint16_t STIR; // @0 Software trigger interrupt register
};

// NVIC_STIR->STIR Software trigger interrupt register
enum {
	NVIC_STIR_STIR_INTID = ((1UL<<9)-1) << 0, // Software generated interrupt ID		
};
inline void nvic_stir_stir_set_intid(struct NVIC_STIR_Type* p, uint32_t val) { p->STIR = (p->STIR & ~NVIC_STIR_STIR_INTID) | ((val<<0) & NVIC_STIR_STIR_INTID); }
inline uint32_t nvic_stir_stir_get_intid(struct NVIC_STIR_Type* p) { return (p->STIR & NVIC_STIR_STIR_INTID) >> 0 ; }

/* Operational amplifiers */
struct OPAMP_Type {
	__IO uint32_t OPAMP1_CSR; // @0 OPAMP1 control/status register
	__IO uint16_t OPAMP1_OTR; // @4 OPAMP1 offset trimming register in normal mode
	 uint8_t RESERVED0[2]; // @6 
	__IO uint16_t OPAMP1_LPOTR; // @8 OPAMP1 offset trimming register in low-power mode
	 uint8_t RESERVED1[6]; // @10 
	__IO uint16_t OPAMP2_CSR; // @16 OPAMP2 control/status register
	 uint8_t RESERVED2[2]; // @18 
	__IO uint16_t OPAMP2_OTR; // @20 OPAMP2 offset trimming register in normal mode
	 uint8_t RESERVED3[2]; // @22 
	__IO uint16_t OPAMP2_LPOTR; // @24 OPAMP2 offset trimming register in low-power mode
};

// OPAMP->OPAMP1_CSR OPAMP1 control/status register
enum {
	OPAMP_OPAMP1_CSR_OPA_RANGE = 1UL<<31, // Operational amplifier power supply range for stability
	OPAMP_OPAMP1_CSR_CALOUT = 1UL<<15, // Operational amplifier calibration output
	OPAMP_OPAMP1_CSR_USERTRIM = 1UL<<14, // allows to switch from AOP offset trimmed values to AOP offset
	OPAMP_OPAMP1_CSR_CALSEL = 1UL<<13, // Calibration selection
	OPAMP_OPAMP1_CSR_CALON = 1UL<<12, // Calibration mode enabled
	OPAMP_OPAMP1_CSR_VP_SEL = 1UL<<10, // Non inverted input selection
	OPAMP_OPAMP1_CSR_VM_SEL = ((1UL<<2)-1) << 8, // Inverting input selection
	OPAMP_OPAMP1_CSR_PGA_GAIN = ((1UL<<2)-1) << 4, // Operational amplifier Programmable amplifier gain value
	OPAMP_OPAMP1_CSR_OPAMODE = ((1UL<<2)-1) << 2, // Operational amplifier PGA mode
	OPAMP_OPAMP1_CSR_OPALPM = 1UL<<1, // Operational amplifier Low Power Mode
	OPAMP_OPAMP1_CSR_OPAEN = 1UL<<0, // Operational amplifier Enable		
};
inline void opamp_opamp1_csr_set_vm_sel(struct OPAMP_Type* p, uint32_t val) { p->OPAMP1_CSR = (p->OPAMP1_CSR & ~OPAMP_OPAMP1_CSR_VM_SEL) | ((val<<8) & OPAMP_OPAMP1_CSR_VM_SEL); }
inline void opamp_opamp1_csr_set_pga_gain(struct OPAMP_Type* p, uint32_t val) { p->OPAMP1_CSR = (p->OPAMP1_CSR & ~OPAMP_OPAMP1_CSR_PGA_GAIN) | ((val<<4) & OPAMP_OPAMP1_CSR_PGA_GAIN); }
inline void opamp_opamp1_csr_set_opamode(struct OPAMP_Type* p, uint32_t val) { p->OPAMP1_CSR = (p->OPAMP1_CSR & ~OPAMP_OPAMP1_CSR_OPAMODE) | ((val<<2) & OPAMP_OPAMP1_CSR_OPAMODE); }
inline uint32_t opamp_opamp1_csr_get_vm_sel(struct OPAMP_Type* p) { return (p->OPAMP1_CSR & OPAMP_OPAMP1_CSR_VM_SEL) >> 8 ; }
inline uint32_t opamp_opamp1_csr_get_pga_gain(struct OPAMP_Type* p) { return (p->OPAMP1_CSR & OPAMP_OPAMP1_CSR_PGA_GAIN) >> 4 ; }
inline uint32_t opamp_opamp1_csr_get_opamode(struct OPAMP_Type* p) { return (p->OPAMP1_CSR & OPAMP_OPAMP1_CSR_OPAMODE) >> 2 ; }

// OPAMP->OPAMP1_OTR OPAMP1 offset trimming register in normal mode
enum {
	OPAMP_OPAMP1_OTR_TRIMOFFSETP = ((1UL<<5)-1) << 8, // Trim for PMOS differential pairs
	OPAMP_OPAMP1_OTR_TRIMOFFSETN = ((1UL<<5)-1) << 0, // Trim for NMOS differential pairs		
};
inline void opamp_opamp1_otr_set_trimoffsetp(struct OPAMP_Type* p, uint32_t val) { p->OPAMP1_OTR = (p->OPAMP1_OTR & ~OPAMP_OPAMP1_OTR_TRIMOFFSETP) | ((val<<8) & OPAMP_OPAMP1_OTR_TRIMOFFSETP); }
inline void opamp_opamp1_otr_set_trimoffsetn(struct OPAMP_Type* p, uint32_t val) { p->OPAMP1_OTR = (p->OPAMP1_OTR & ~OPAMP_OPAMP1_OTR_TRIMOFFSETN) | ((val<<0) & OPAMP_OPAMP1_OTR_TRIMOFFSETN); }
inline uint32_t opamp_opamp1_otr_get_trimoffsetp(struct OPAMP_Type* p) { return (p->OPAMP1_OTR & OPAMP_OPAMP1_OTR_TRIMOFFSETP) >> 8 ; }
inline uint32_t opamp_opamp1_otr_get_trimoffsetn(struct OPAMP_Type* p) { return (p->OPAMP1_OTR & OPAMP_OPAMP1_OTR_TRIMOFFSETN) >> 0 ; }

// OPAMP->OPAMP1_LPOTR OPAMP1 offset trimming register in low-power mode
enum {
	OPAMP_OPAMP1_LPOTR_TRIMLPOFFSETP = ((1UL<<5)-1) << 8, // Trim for PMOS differential pairs
	OPAMP_OPAMP1_LPOTR_TRIMLPOFFSETN = ((1UL<<5)-1) << 0, // Trim for NMOS differential pairs		
};
inline void opamp_opamp1_lpotr_set_trimlpoffsetp(struct OPAMP_Type* p, uint32_t val) { p->OPAMP1_LPOTR = (p->OPAMP1_LPOTR & ~OPAMP_OPAMP1_LPOTR_TRIMLPOFFSETP) | ((val<<8) & OPAMP_OPAMP1_LPOTR_TRIMLPOFFSETP); }
inline void opamp_opamp1_lpotr_set_trimlpoffsetn(struct OPAMP_Type* p, uint32_t val) { p->OPAMP1_LPOTR = (p->OPAMP1_LPOTR & ~OPAMP_OPAMP1_LPOTR_TRIMLPOFFSETN) | ((val<<0) & OPAMP_OPAMP1_LPOTR_TRIMLPOFFSETN); }
inline uint32_t opamp_opamp1_lpotr_get_trimlpoffsetp(struct OPAMP_Type* p) { return (p->OPAMP1_LPOTR & OPAMP_OPAMP1_LPOTR_TRIMLPOFFSETP) >> 8 ; }
inline uint32_t opamp_opamp1_lpotr_get_trimlpoffsetn(struct OPAMP_Type* p) { return (p->OPAMP1_LPOTR & OPAMP_OPAMP1_LPOTR_TRIMLPOFFSETN) >> 0 ; }

// OPAMP->OPAMP2_CSR OPAMP2 control/status register
enum {
	OPAMP_OPAMP2_CSR_CALOUT = 1UL<<15, // Operational amplifier calibration output
	OPAMP_OPAMP2_CSR_USERTRIM = 1UL<<14, // allows to switch from AOP offset trimmed values to AOP offset
	OPAMP_OPAMP2_CSR_CALSEL = 1UL<<13, // Calibration selection
	OPAMP_OPAMP2_CSR_CALON = 1UL<<12, // Calibration mode enabled
	OPAMP_OPAMP2_CSR_VP_SEL = 1UL<<10, // Non inverted input selection
	OPAMP_OPAMP2_CSR_VM_SEL = ((1UL<<2)-1) << 8, // Inverting input selection
	OPAMP_OPAMP2_CSR_PGA_GAIN = ((1UL<<2)-1) << 4, // Operational amplifier Programmable amplifier gain value
	OPAMP_OPAMP2_CSR_OPAMODE = ((1UL<<2)-1) << 2, // Operational amplifier PGA mode
	OPAMP_OPAMP2_CSR_OPALPM = 1UL<<1, // Operational amplifier Low Power Mode
	OPAMP_OPAMP2_CSR_OPAEN = 1UL<<0, // Operational amplifier Enable		
};
inline void opamp_opamp2_csr_set_vm_sel(struct OPAMP_Type* p, uint32_t val) { p->OPAMP2_CSR = (p->OPAMP2_CSR & ~OPAMP_OPAMP2_CSR_VM_SEL) | ((val<<8) & OPAMP_OPAMP2_CSR_VM_SEL); }
inline void opamp_opamp2_csr_set_pga_gain(struct OPAMP_Type* p, uint32_t val) { p->OPAMP2_CSR = (p->OPAMP2_CSR & ~OPAMP_OPAMP2_CSR_PGA_GAIN) | ((val<<4) & OPAMP_OPAMP2_CSR_PGA_GAIN); }
inline void opamp_opamp2_csr_set_opamode(struct OPAMP_Type* p, uint32_t val) { p->OPAMP2_CSR = (p->OPAMP2_CSR & ~OPAMP_OPAMP2_CSR_OPAMODE) | ((val<<2) & OPAMP_OPAMP2_CSR_OPAMODE); }
inline uint32_t opamp_opamp2_csr_get_vm_sel(struct OPAMP_Type* p) { return (p->OPAMP2_CSR & OPAMP_OPAMP2_CSR_VM_SEL) >> 8 ; }
inline uint32_t opamp_opamp2_csr_get_pga_gain(struct OPAMP_Type* p) { return (p->OPAMP2_CSR & OPAMP_OPAMP2_CSR_PGA_GAIN) >> 4 ; }
inline uint32_t opamp_opamp2_csr_get_opamode(struct OPAMP_Type* p) { return (p->OPAMP2_CSR & OPAMP_OPAMP2_CSR_OPAMODE) >> 2 ; }

// OPAMP->OPAMP2_OTR OPAMP2 offset trimming register in normal mode
enum {
	OPAMP_OPAMP2_OTR_TRIMOFFSETP = ((1UL<<5)-1) << 8, // Trim for PMOS differential pairs
	OPAMP_OPAMP2_OTR_TRIMOFFSETN = ((1UL<<5)-1) << 0, // Trim for NMOS differential pairs		
};
inline void opamp_opamp2_otr_set_trimoffsetp(struct OPAMP_Type* p, uint32_t val) { p->OPAMP2_OTR = (p->OPAMP2_OTR & ~OPAMP_OPAMP2_OTR_TRIMOFFSETP) | ((val<<8) & OPAMP_OPAMP2_OTR_TRIMOFFSETP); }
inline void opamp_opamp2_otr_set_trimoffsetn(struct OPAMP_Type* p, uint32_t val) { p->OPAMP2_OTR = (p->OPAMP2_OTR & ~OPAMP_OPAMP2_OTR_TRIMOFFSETN) | ((val<<0) & OPAMP_OPAMP2_OTR_TRIMOFFSETN); }
inline uint32_t opamp_opamp2_otr_get_trimoffsetp(struct OPAMP_Type* p) { return (p->OPAMP2_OTR & OPAMP_OPAMP2_OTR_TRIMOFFSETP) >> 8 ; }
inline uint32_t opamp_opamp2_otr_get_trimoffsetn(struct OPAMP_Type* p) { return (p->OPAMP2_OTR & OPAMP_OPAMP2_OTR_TRIMOFFSETN) >> 0 ; }

// OPAMP->OPAMP2_LPOTR OPAMP2 offset trimming register in low-power mode
enum {
	OPAMP_OPAMP2_LPOTR_TRIMLPOFFSETP = ((1UL<<5)-1) << 8, // Trim for PMOS differential pairs
	OPAMP_OPAMP2_LPOTR_TRIMLPOFFSETN = ((1UL<<5)-1) << 0, // Trim for NMOS differential pairs		
};
inline void opamp_opamp2_lpotr_set_trimlpoffsetp(struct OPAMP_Type* p, uint32_t val) { p->OPAMP2_LPOTR = (p->OPAMP2_LPOTR & ~OPAMP_OPAMP2_LPOTR_TRIMLPOFFSETP) | ((val<<8) & OPAMP_OPAMP2_LPOTR_TRIMLPOFFSETP); }
inline void opamp_opamp2_lpotr_set_trimlpoffsetn(struct OPAMP_Type* p, uint32_t val) { p->OPAMP2_LPOTR = (p->OPAMP2_LPOTR & ~OPAMP_OPAMP2_LPOTR_TRIMLPOFFSETN) | ((val<<0) & OPAMP_OPAMP2_LPOTR_TRIMLPOFFSETN); }
inline uint32_t opamp_opamp2_lpotr_get_trimlpoffsetp(struct OPAMP_Type* p) { return (p->OPAMP2_LPOTR & OPAMP_OPAMP2_LPOTR_TRIMLPOFFSETP) >> 8 ; }
inline uint32_t opamp_opamp2_lpotr_get_trimlpoffsetn(struct OPAMP_Type* p) { return (p->OPAMP2_LPOTR & OPAMP_OPAMP2_LPOTR_TRIMLPOFFSETN) >> 0 ; }

/* Power control */
struct PWR_Type {
	__IO uint16_t CR1; // @0 Power control register 1
	 uint8_t RESERVED0[2]; // @2 
	__IO uint16_t CR2; // @4 Power control register 2
	 uint8_t RESERVED1[2]; // @6 
	__IO uint16_t CR3; // @8 Power control register 3
	 uint8_t RESERVED2[2]; // @10 
	__IO uint16_t CR4; // @12 Power control register 4
	 uint8_t RESERVED3[2]; // @14 
	__I uint16_t SR1; // @16 Power status register 1
	 uint8_t RESERVED4[2]; // @18 
	__I uint16_t SR2; // @20 Power status register 2
	 uint8_t RESERVED5[2]; // @22 
	__O uint16_t SCR; // @24 Power status clear register
	 uint8_t RESERVED6[6]; // @26 
	__IO uint16_t PUCRA; // @32 Power Port A pull-up control register
	 uint8_t RESERVED7[2]; // @34 
	__IO uint16_t PDCRA; // @36 Power Port A pull-down control register
	 uint8_t RESERVED8[2]; // @38 
	__IO uint16_t PUCRB; // @40 Power Port B pull-up control register
	 uint8_t RESERVED9[2]; // @42 
	__IO uint16_t PDCRB; // @44 Power Port B pull-down control register
	 uint8_t RESERVED10[2]; // @46 
	__IO uint16_t PUCRC; // @48 Power Port C pull-up control register
	 uint8_t RESERVED11[2]; // @50 
	__IO uint16_t PDCRC; // @52 Power Port C pull-down control register
	 uint8_t RESERVED12[2]; // @54 
	__IO uint16_t PUCRD; // @56 Power Port D pull-up control register
	 uint8_t RESERVED13[2]; // @58 
	__IO uint16_t PDCRD; // @60 Power Port D pull-down control register
	 uint8_t RESERVED14[2]; // @62 
	__IO uint16_t PUCRE; // @64 Power Port E pull-up control register
	 uint8_t RESERVED15[2]; // @66 
	__IO uint16_t PDCRE; // @68 Power Port E pull-down control register
	 uint8_t RESERVED16[2]; // @70 
	__IO uint16_t PUCRF; // @72 Power Port F pull-up control register
	 uint8_t RESERVED17[2]; // @74 
	__IO uint16_t PDCRF; // @76 Power Port F pull-down control register
	 uint8_t RESERVED18[2]; // @78 
	__IO uint16_t PUCRG; // @80 Power Port G pull-up control register
	 uint8_t RESERVED19[2]; // @82 
	__IO uint16_t PDCRG; // @84 Power Port G pull-down control register
	 uint8_t RESERVED20[2]; // @86 
	__IO uint8_t PUCRH; // @88 Power Port H pull-up control register
	 uint8_t RESERVED21[3]; // @89 
	__IO uint8_t PDCRH; // @92 Power Port H pull-down control register
};

// PWR->CR1 Power control register 1
enum {
	PWR_CR1_LPR = 1UL<<14, // Low-power run
	PWR_CR1_VOS = ((1UL<<2)-1) << 9, // Voltage scaling range selection
	PWR_CR1_DBP = 1UL<<8, // Disable backup domain write protection
	PWR_CR1_LPMS = ((1UL<<3)-1) << 0, // Low-power mode selection		
};
inline void pwr_cr1_set_vos(struct PWR_Type* p, uint32_t val) { p->CR1 = (p->CR1 & ~PWR_CR1_VOS) | ((val<<9) & PWR_CR1_VOS); }
inline void pwr_cr1_set_lpms(struct PWR_Type* p, uint32_t val) { p->CR1 = (p->CR1 & ~PWR_CR1_LPMS) | ((val<<0) & PWR_CR1_LPMS); }
inline uint32_t pwr_cr1_get_vos(struct PWR_Type* p) { return (p->CR1 & PWR_CR1_VOS) >> 9 ; }
inline uint32_t pwr_cr1_get_lpms(struct PWR_Type* p) { return (p->CR1 & PWR_CR1_LPMS) >> 0 ; }

// PWR->CR2 Power control register 2
enum {
	PWR_CR2_USV = 1UL<<10, // VDDUSB USB supply valid
	PWR_CR2_IOSV = 1UL<<9, // VDDIO2 Independent I/Os supply valid
	PWR_CR2_PVME4 = 1UL<<7, // Peripheral voltage monitoring 4 enable: VDDA vs. 2.2V
	PWR_CR2_PVME3 = 1UL<<6, // Peripheral voltage monitoring 3 enable: VDDA vs. 1.62V
	PWR_CR2_PVME2 = 1UL<<5, // Peripheral voltage monitoring 2 enable: VDDIO2 vs. 0.9V
	PWR_CR2_PVME1 = 1UL<<4, // Peripheral voltage monitoring 1 enable: VDDUSB vs. 1.2V
	PWR_CR2_PLS = ((1UL<<3)-1) << 1, // Power voltage detector level selection
	PWR_CR2_PVDE = 1UL<<0, // Power voltage detector enable		
};
inline void pwr_cr2_set_pls(struct PWR_Type* p, uint32_t val) { p->CR2 = (p->CR2 & ~PWR_CR2_PLS) | ((val<<1) & PWR_CR2_PLS); }
inline uint32_t pwr_cr2_get_pls(struct PWR_Type* p) { return (p->CR2 & PWR_CR2_PLS) >> 1 ; }

// PWR->CR3 Power control register 3
enum {
	PWR_CR3_EWF = 1UL<<15, // Enable internal wakeup line
	PWR_CR3_APC = 1UL<<10, // Apply pull-up and pull-down configuration
	PWR_CR3_RRS = 1UL<<8, // SRAM2 retention in Standby mode
	PWR_CR3_EWUP5 = 1UL<<4, // Enable Wakeup pin WKUP5
	PWR_CR3_EWUP4 = 1UL<<3, // Enable Wakeup pin WKUP4
	PWR_CR3_EWUP3 = 1UL<<2, // Enable Wakeup pin WKUP3
	PWR_CR3_EWUP2 = 1UL<<1, // Enable Wakeup pin WKUP2
	PWR_CR3_EWUP1 = 1UL<<0, // Enable Wakeup pin WKUP1		
};

// PWR->CR4 Power control register 4
enum {
	PWR_CR4_VBRS = 1UL<<9, // VBAT battery charging resistor selection
	PWR_CR4_VBE = 1UL<<8, // VBAT battery charging enable
	PWR_CR4_WP5 = 1UL<<4, // Wakeup pin WKUP5 polarity
	PWR_CR4_WP4 = 1UL<<3, // Wakeup pin WKUP4 polarity
	PWR_CR4_WP3 = 1UL<<2, // Wakeup pin WKUP3 polarity
	PWR_CR4_WP2 = 1UL<<1, // Wakeup pin WKUP2 polarity
	PWR_CR4_WP1 = 1UL<<0, // Wakeup pin WKUP1 polarity		
};

// PWR->SR1 Power status register 1
enum {
	PWR_SR1_WUFI = 1UL<<15, // Wakeup flag internal
	PWR_SR1_CSBF = 1UL<<8, // Standby flag
	PWR_SR1_CWUF5 = 1UL<<4, // Wakeup flag 5
	PWR_SR1_CWUF4 = 1UL<<3, // Wakeup flag 4
	PWR_SR1_CWUF3 = 1UL<<2, // Wakeup flag 3
	PWR_SR1_CWUF2 = 1UL<<1, // Wakeup flag 2
	PWR_SR1_CWUF1 = 1UL<<0, // Wakeup flag 1		
};

// PWR->SR2 Power status register 2
enum {
	PWR_SR2_PVMO4 = 1UL<<15, // Peripheral voltage monitoring output: VDDA vs. 2.2 V
	PWR_SR2_PVMO3 = 1UL<<14, // Peripheral voltage monitoring output: VDDA vs. 1.62 V
	PWR_SR2_PVMO2 = 1UL<<13, // Peripheral voltage monitoring output: VDDIO2 vs. 0.9 V
	PWR_SR2_PVMO1 = 1UL<<12, // Peripheral voltage monitoring output: VDDUSB vs. 1.2 V
	PWR_SR2_PVDO = 1UL<<11, // Power voltage detector output
	PWR_SR2_VOSF = 1UL<<10, // Voltage scaling flag
	PWR_SR2_REGLPF = 1UL<<9, // Low-power regulator flag
	PWR_SR2_REGLPS = 1UL<<8, // Low-power regulator started		
};

// PWR->SCR Power status clear register
enum {
	PWR_SCR_SBF = 1UL<<8, // Clear standby flag
	PWR_SCR_WUF5 = 1UL<<4, // Clear wakeup flag 5
	PWR_SCR_WUF4 = 1UL<<3, // Clear wakeup flag 4
	PWR_SCR_WUF3 = 1UL<<2, // Clear wakeup flag 3
	PWR_SCR_WUF2 = 1UL<<1, // Clear wakeup flag 2
	PWR_SCR_WUF1 = 1UL<<0, // Clear wakeup flag 1		
};

// PWR->PUCRH Power Port H pull-up control register
enum {
	PWR_PUCRH_PUX  = ((1UL<<2)-1) << 0, // Merged Port H pull-up bit y (y=0..1)		
};
inline void pwr_pucrh_set_pux (struct PWR_Type* p, uint32_t val) { p->PUCRH = (p->PUCRH & ~PWR_PUCRH_PUX ) | ((val<<0) & PWR_PUCRH_PUX ); }
inline uint32_t pwr_pucrh_get_pux (struct PWR_Type* p) { return (p->PUCRH & PWR_PUCRH_PUX ) >> 0 ; }

// PWR->PDCRH Power Port H pull-down control register
enum {
	PWR_PDCRH_PDX  = ((1UL<<2)-1) << 0, // Merged Port H pull-down bit y (y=0..1)		
};
inline void pwr_pdcrh_set_pdx (struct PWR_Type* p, uint32_t val) { p->PDCRH = (p->PDCRH & ~PWR_PDCRH_PDX ) | ((val<<0) & PWR_PDCRH_PDX ); }
inline uint32_t pwr_pdcrh_get_pdx (struct PWR_Type* p) { return (p->PDCRH & PWR_PDCRH_PDX ) >> 0 ; }

/* QuadSPI interface */
struct QUADSPI_Type {
	__IO uint32_t CR; // @0 control register
	__IO uint32_t DCR; // @4 device configuration register
	__I uint16_t SR; // @8 status register
	 uint8_t RESERVED0[2]; // @10 
	__IO uint8_t FCR; // @12 flag clear register
	 uint8_t RESERVED1[3]; // @13 
	__IO uint32_t DLR; // @16 data length register
	__IO uint32_t CCR; // @20 communication configuration register
	__IO uint32_t AR; // @24 address register
	__IO uint32_t ABR; // @28 ABR
	__IO uint32_t DR; // @32 data register
	__IO uint32_t PSMKR; // @36 polling status mask register
	__IO uint32_t PSMAR; // @40 polling status match register
	__IO uint16_t PIR; // @44 polling interval register
	 uint8_t RESERVED2[2]; // @46 
	__IO uint16_t LPTR; // @48 low-power timeout register
};

// QUADSPI->CR control register
enum {
	QUADSPI_CR_PRESCALER = ((1UL<<8)-1) << 24, // Clock prescaler
	QUADSPI_CR_PMM = 1UL<<23, // Polling match mode
	QUADSPI_CR_APMS = 1UL<<22, // Automatic poll mode stop
	QUADSPI_CR_TOIE = 1UL<<20, // TimeOut interrupt enable
	QUADSPI_CR_SMIE = 1UL<<19, // Status match interrupt enable
	QUADSPI_CR_FTIE = 1UL<<18, // FIFO threshold interrupt enable
	QUADSPI_CR_TCIE = 1UL<<17, // Transfer complete interrupt enable
	QUADSPI_CR_TEIE = 1UL<<16, // Transfer error interrupt enable
	QUADSPI_CR_FTHRES = ((1UL<<5)-1) << 8, // IFO threshold level
	QUADSPI_CR_FSEL = 1UL<<7, // FLASH memory selection
	QUADSPI_CR_DFM = 1UL<<6, // Dual-flash mode
	QUADSPI_CR_SSHIFT = 1UL<<4, // Sample shift
	QUADSPI_CR_TCEN = 1UL<<3, // Timeout counter enable
	QUADSPI_CR_DMAEN = 1UL<<2, // DMA enable
	QUADSPI_CR_ABORT = 1UL<<1, // Abort request
	QUADSPI_CR_EN = 1UL<<0, // Enable		
};
inline void quadspi_cr_set_prescaler(struct QUADSPI_Type* p, uint32_t val) { p->CR = (p->CR & ~QUADSPI_CR_PRESCALER) | ((val<<24) & QUADSPI_CR_PRESCALER); }
inline void quadspi_cr_set_fthres(struct QUADSPI_Type* p, uint32_t val) { p->CR = (p->CR & ~QUADSPI_CR_FTHRES) | ((val<<8) & QUADSPI_CR_FTHRES); }
inline uint32_t quadspi_cr_get_prescaler(struct QUADSPI_Type* p) { return (p->CR & QUADSPI_CR_PRESCALER) >> 24 ; }
inline uint32_t quadspi_cr_get_fthres(struct QUADSPI_Type* p) { return (p->CR & QUADSPI_CR_FTHRES) >> 8 ; }

// QUADSPI->DCR device configuration register
enum {
	QUADSPI_DCR_FSIZE = ((1UL<<5)-1) << 16, // FLASH memory size
	QUADSPI_DCR_CSHT = ((1UL<<3)-1) << 8, // Chip select high time
	QUADSPI_DCR_CKMODE = 1UL<<0, // Mode 0 / mode 3		
};
inline void quadspi_dcr_set_fsize(struct QUADSPI_Type* p, uint32_t val) { p->DCR = (p->DCR & ~QUADSPI_DCR_FSIZE) | ((val<<16) & QUADSPI_DCR_FSIZE); }
inline void quadspi_dcr_set_csht(struct QUADSPI_Type* p, uint32_t val) { p->DCR = (p->DCR & ~QUADSPI_DCR_CSHT) | ((val<<8) & QUADSPI_DCR_CSHT); }
inline uint32_t quadspi_dcr_get_fsize(struct QUADSPI_Type* p) { return (p->DCR & QUADSPI_DCR_FSIZE) >> 16 ; }
inline uint32_t quadspi_dcr_get_csht(struct QUADSPI_Type* p) { return (p->DCR & QUADSPI_DCR_CSHT) >> 8 ; }

// QUADSPI->SR status register
enum {
	QUADSPI_SR_FLEVEL = ((1UL<<7)-1) << 8, // FIFO level
	QUADSPI_SR_BUSY = 1UL<<5, // Busy
	QUADSPI_SR_TOF = 1UL<<4, // Timeout flag
	QUADSPI_SR_SMF = 1UL<<3, // Status match flag
	QUADSPI_SR_FTF = 1UL<<2, // FIFO threshold flag
	QUADSPI_SR_TCF = 1UL<<1, // Transfer complete flag
	QUADSPI_SR_TEF = 1UL<<0, // Transfer error flag		
};
inline uint32_t quadspi_sr_get_flevel(struct QUADSPI_Type* p) { return (p->SR & QUADSPI_SR_FLEVEL) >> 8 ; }

// QUADSPI->FCR flag clear register
enum {
	QUADSPI_FCR_CTOF = 1UL<<4, // Clear timeout flag
	QUADSPI_FCR_CSMF = 1UL<<3, // Clear status match flag
	QUADSPI_FCR_CTCF = 1UL<<1, // Clear transfer complete flag
	QUADSPI_FCR_CTEF = 1UL<<0, // Clear transfer error flag		
};

// QUADSPI->CCR communication configuration register
enum {
	QUADSPI_CCR_DDRM = 1UL<<31, // Double data rate mode
	QUADSPI_CCR_DHHC = 1UL<<30, // DDR hold half cycle
	QUADSPI_CCR_SIOO = 1UL<<28, // Send instruction only once mode
	QUADSPI_CCR_FMODE = ((1UL<<2)-1) << 26, // Functional mode
	QUADSPI_CCR_DMODE = ((1UL<<2)-1) << 24, // Data mode
	QUADSPI_CCR_DCYC = ((1UL<<5)-1) << 18, // Number of dummy cycles
	QUADSPI_CCR_ABSIZE = ((1UL<<2)-1) << 16, // Alternate bytes size
	QUADSPI_CCR_ABMODE = ((1UL<<2)-1) << 14, // Alternate bytes mode
	QUADSPI_CCR_ADSIZE = ((1UL<<2)-1) << 12, // Address size
	QUADSPI_CCR_ADMODE = ((1UL<<2)-1) << 10, // Address mode
	QUADSPI_CCR_IMODE = ((1UL<<2)-1) << 8, // Instruction mode
	QUADSPI_CCR_INSTRUCTION = ((1UL<<8)-1) << 0, // Instruction		
};
inline void quadspi_ccr_set_fmode(struct QUADSPI_Type* p, uint32_t val) { p->CCR = (p->CCR & ~QUADSPI_CCR_FMODE) | ((val<<26) & QUADSPI_CCR_FMODE); }
inline void quadspi_ccr_set_dmode(struct QUADSPI_Type* p, uint32_t val) { p->CCR = (p->CCR & ~QUADSPI_CCR_DMODE) | ((val<<24) & QUADSPI_CCR_DMODE); }
inline void quadspi_ccr_set_dcyc(struct QUADSPI_Type* p, uint32_t val) { p->CCR = (p->CCR & ~QUADSPI_CCR_DCYC) | ((val<<18) & QUADSPI_CCR_DCYC); }
inline void quadspi_ccr_set_absize(struct QUADSPI_Type* p, uint32_t val) { p->CCR = (p->CCR & ~QUADSPI_CCR_ABSIZE) | ((val<<16) & QUADSPI_CCR_ABSIZE); }
inline void quadspi_ccr_set_abmode(struct QUADSPI_Type* p, uint32_t val) { p->CCR = (p->CCR & ~QUADSPI_CCR_ABMODE) | ((val<<14) & QUADSPI_CCR_ABMODE); }
inline void quadspi_ccr_set_adsize(struct QUADSPI_Type* p, uint32_t val) { p->CCR = (p->CCR & ~QUADSPI_CCR_ADSIZE) | ((val<<12) & QUADSPI_CCR_ADSIZE); }
inline void quadspi_ccr_set_admode(struct QUADSPI_Type* p, uint32_t val) { p->CCR = (p->CCR & ~QUADSPI_CCR_ADMODE) | ((val<<10) & QUADSPI_CCR_ADMODE); }
inline void quadspi_ccr_set_imode(struct QUADSPI_Type* p, uint32_t val) { p->CCR = (p->CCR & ~QUADSPI_CCR_IMODE) | ((val<<8) & QUADSPI_CCR_IMODE); }
inline void quadspi_ccr_set_instruction(struct QUADSPI_Type* p, uint32_t val) { p->CCR = (p->CCR & ~QUADSPI_CCR_INSTRUCTION) | ((val<<0) & QUADSPI_CCR_INSTRUCTION); }
inline uint32_t quadspi_ccr_get_fmode(struct QUADSPI_Type* p) { return (p->CCR & QUADSPI_CCR_FMODE) >> 26 ; }
inline uint32_t quadspi_ccr_get_dmode(struct QUADSPI_Type* p) { return (p->CCR & QUADSPI_CCR_DMODE) >> 24 ; }
inline uint32_t quadspi_ccr_get_dcyc(struct QUADSPI_Type* p) { return (p->CCR & QUADSPI_CCR_DCYC) >> 18 ; }
inline uint32_t quadspi_ccr_get_absize(struct QUADSPI_Type* p) { return (p->CCR & QUADSPI_CCR_ABSIZE) >> 16 ; }
inline uint32_t quadspi_ccr_get_abmode(struct QUADSPI_Type* p) { return (p->CCR & QUADSPI_CCR_ABMODE) >> 14 ; }
inline uint32_t quadspi_ccr_get_adsize(struct QUADSPI_Type* p) { return (p->CCR & QUADSPI_CCR_ADSIZE) >> 12 ; }
inline uint32_t quadspi_ccr_get_admode(struct QUADSPI_Type* p) { return (p->CCR & QUADSPI_CCR_ADMODE) >> 10 ; }
inline uint32_t quadspi_ccr_get_imode(struct QUADSPI_Type* p) { return (p->CCR & QUADSPI_CCR_IMODE) >> 8 ; }
inline uint32_t quadspi_ccr_get_instruction(struct QUADSPI_Type* p) { return (p->CCR & QUADSPI_CCR_INSTRUCTION) >> 0 ; }

/* Reset and clock control */
struct RCC_Type {
	__IO uint32_t CR; // @0 Clock control register
	__IO uint32_t ICSCR; // @4 Internal clock sources calibration register
	__IO uint32_t CFGR; // @8 Clock configuration register
	__IO uint32_t PLLCFGR; // @12 PLL configuration register
	__IO uint32_t PLLSAI1CFGR; // @16 PLLSAI1 configuration register
	 uint8_t RESERVED0[4]; // @20 
	__IO uint16_t CIER; // @24 Clock interrupt enable register
	 uint8_t RESERVED1[2]; // @26 
	__I uint16_t CIFR; // @28 Clock interrupt flag register
	 uint8_t RESERVED2[2]; // @30 
	__O uint16_t CICR; // @32 Clock interrupt clear register
	 uint8_t RESERVED3[6]; // @34 
	__IO uint32_t AHB1RSTR; // @40 AHB1 peripheral reset register
	__IO uint32_t AHB2RSTR; // @44 AHB2 peripheral reset register
	__IO uint16_t AHB3RSTR; // @48 AHB3 peripheral reset register
	 uint8_t RESERVED4[6]; // @50 
	__IO uint32_t APB1RSTR1; // @56 APB1 peripheral reset register 1
	__IO uint8_t APB1RSTR2; // @60 APB1 peripheral reset register 2
	 uint8_t RESERVED5[3]; // @61 
	__IO uint32_t APB2RSTR; // @64 APB2 peripheral reset register
	 uint8_t RESERVED6[4]; // @68 
	__IO uint32_t AHB1ENR; // @72 AHB1 peripheral clock enable register
	__IO uint32_t AHB2ENR; // @76 AHB2 peripheral clock enable register
	__IO uint16_t AHB3ENR; // @80 AHB3 peripheral clock enable register
	 uint8_t RESERVED7[6]; // @82 
	__IO uint32_t APB1ENR1; // @88 APB1ENR1
	__IO uint32_t APB1ENR2; // @92 APB1 peripheral clock enable register 2
	__IO uint32_t APB2ENR; // @96 APB2ENR
	 uint8_t RESERVED8[4]; // @100 
	__IO uint32_t AHB1SMENR; // @104 AHB1 peripheral clocks enable in Sleep and Stop modes register
	__IO uint32_t AHB2SMENR; // @108 AHB2 peripheral clocks enable in Sleep and Stop modes register
	__IO uint16_t AHB3SMENR; // @112 AHB3 peripheral clocks enable in Sleep and Stop modes register
	 uint8_t RESERVED9[6]; // @114 
	__IO uint32_t APB1SMENR1; // @120 APB1SMENR1
	__IO uint8_t APB1SMENR2; // @124 APB1 peripheral clocks enable in Sleep and Stop modes register 2
	 uint8_t RESERVED10[3]; // @125 
	__IO uint32_t APB2SMENR; // @128 APB2SMENR
	 uint8_t RESERVED11[4]; // @132 
	__IO uint32_t CCIPR; // @136 CCIPR
	 uint8_t RESERVED12[4]; // @140 
	__IO uint32_t BDCR; // @144 BDCR
	__IO uint32_t CSR; // @148 CSR
	__IO uint16_t CRRCR; // @152 Clock recovery RC register
};

// RCC->CR Clock control register
enum {
	RCC_CR_PLLSAI1RDY = 1UL<<27, // SAI1 PLL clock ready flag
	RCC_CR_PLLSAI1ON = 1UL<<26, // SAI1 PLL enable
	RCC_CR_PLLRDY = 1UL<<25, // Main PLL clock ready flag
	RCC_CR_PLLON = 1UL<<24, // Main PLL enable
	RCC_CR_CSSON = 1UL<<19, // Clock security system enable
	RCC_CR_HSEBYP = 1UL<<18, // HSE crystal oscillator bypass
	RCC_CR_HSERDY = 1UL<<17, // HSE clock ready flag
	RCC_CR_HSEON = 1UL<<16, // HSE clock enable
	RCC_CR_HSIASFS = 1UL<<11, // HSI automatic start from Stop
	RCC_CR_HSIRDY = 1UL<<10, // HSI clock ready flag
	RCC_CR_HSIKERON = 1UL<<9, // HSI always enable for peripheral kernels
	RCC_CR_HSION = 1UL<<8, // HSI clock enable
	RCC_CR_MSIRANGE = ((1UL<<4)-1) << 4, // MSI clock ranges
	RCC_CR_MSIRGSEL = 1UL<<3, // MSI clock range selection
	RCC_CR_MSIPLLEN = 1UL<<2, // MSI clock PLL enable
	RCC_CR_MSIRDY = 1UL<<1, // MSI clock ready flag
	RCC_CR_MSION = 1UL<<0, // MSI clock enable		
};
inline void rcc_cr_set_msirange(struct RCC_Type* p, uint32_t val) { p->CR = (p->CR & ~RCC_CR_MSIRANGE) | ((val<<4) & RCC_CR_MSIRANGE); }
inline uint32_t rcc_cr_get_msirange(struct RCC_Type* p) { return (p->CR & RCC_CR_MSIRANGE) >> 4 ; }

// RCC->ICSCR Internal clock sources calibration register
enum {
	RCC_ICSCR_HSITRIM = ((1UL<<5)-1) << 24, // HSI clock trimming
	RCC_ICSCR_HSICAL = ((1UL<<8)-1) << 16, // HSI clock calibration
	RCC_ICSCR_MSITRIM = ((1UL<<8)-1) << 8, // MSI clock trimming
	RCC_ICSCR_MSICAL = ((1UL<<8)-1) << 0, // MSI clock calibration		
};
inline void rcc_icscr_set_hsitrim(struct RCC_Type* p, uint32_t val) { p->ICSCR = (p->ICSCR & ~RCC_ICSCR_HSITRIM) | ((val<<24) & RCC_ICSCR_HSITRIM); }
inline void rcc_icscr_set_hsical(struct RCC_Type* p, uint32_t val) { p->ICSCR = (p->ICSCR & ~RCC_ICSCR_HSICAL) | ((val<<16) & RCC_ICSCR_HSICAL); }
inline void rcc_icscr_set_msitrim(struct RCC_Type* p, uint32_t val) { p->ICSCR = (p->ICSCR & ~RCC_ICSCR_MSITRIM) | ((val<<8) & RCC_ICSCR_MSITRIM); }
inline void rcc_icscr_set_msical(struct RCC_Type* p, uint32_t val) { p->ICSCR = (p->ICSCR & ~RCC_ICSCR_MSICAL) | ((val<<0) & RCC_ICSCR_MSICAL); }
inline uint32_t rcc_icscr_get_hsitrim(struct RCC_Type* p) { return (p->ICSCR & RCC_ICSCR_HSITRIM) >> 24 ; }
inline uint32_t rcc_icscr_get_hsical(struct RCC_Type* p) { return (p->ICSCR & RCC_ICSCR_HSICAL) >> 16 ; }
inline uint32_t rcc_icscr_get_msitrim(struct RCC_Type* p) { return (p->ICSCR & RCC_ICSCR_MSITRIM) >> 8 ; }
inline uint32_t rcc_icscr_get_msical(struct RCC_Type* p) { return (p->ICSCR & RCC_ICSCR_MSICAL) >> 0 ; }

// RCC->CFGR Clock configuration register
enum {
	RCC_CFGR_MCOPRE = ((1UL<<3)-1) << 28, // Microcontroller clock output prescaler
	RCC_CFGR_MCOSEL = ((1UL<<3)-1) << 24, // Microcontroller clock output
	RCC_CFGR_STOPWUCK = 1UL<<15, // Wakeup from Stop and CSS backup clock selection
	RCC_CFGR_PPRE2 = ((1UL<<3)-1) << 11, // APB high-speed prescaler (APB2)
	RCC_CFGR_PPRE1 = ((1UL<<3)-1) << 8, // PB low-speed prescaler (APB1)
	RCC_CFGR_HPRE = ((1UL<<4)-1) << 4, // AHB prescaler
	RCC_CFGR_SWS = ((1UL<<2)-1) << 2, // System clock switch status
	RCC_CFGR_SW = ((1UL<<2)-1) << 0, // System clock switch		
};
inline void rcc_cfgr_set_mcopre(struct RCC_Type* p, uint32_t val) { p->CFGR = (p->CFGR & ~RCC_CFGR_MCOPRE) | ((val<<28) & RCC_CFGR_MCOPRE); }
inline void rcc_cfgr_set_mcosel(struct RCC_Type* p, uint32_t val) { p->CFGR = (p->CFGR & ~RCC_CFGR_MCOSEL) | ((val<<24) & RCC_CFGR_MCOSEL); }
inline void rcc_cfgr_set_ppre2(struct RCC_Type* p, uint32_t val) { p->CFGR = (p->CFGR & ~RCC_CFGR_PPRE2) | ((val<<11) & RCC_CFGR_PPRE2); }
inline void rcc_cfgr_set_ppre1(struct RCC_Type* p, uint32_t val) { p->CFGR = (p->CFGR & ~RCC_CFGR_PPRE1) | ((val<<8) & RCC_CFGR_PPRE1); }
inline void rcc_cfgr_set_hpre(struct RCC_Type* p, uint32_t val) { p->CFGR = (p->CFGR & ~RCC_CFGR_HPRE) | ((val<<4) & RCC_CFGR_HPRE); }
inline void rcc_cfgr_set_sws(struct RCC_Type* p, uint32_t val) { p->CFGR = (p->CFGR & ~RCC_CFGR_SWS) | ((val<<2) & RCC_CFGR_SWS); }
inline void rcc_cfgr_set_sw(struct RCC_Type* p, uint32_t val) { p->CFGR = (p->CFGR & ~RCC_CFGR_SW) | ((val<<0) & RCC_CFGR_SW); }
inline uint32_t rcc_cfgr_get_mcopre(struct RCC_Type* p) { return (p->CFGR & RCC_CFGR_MCOPRE) >> 28 ; }
inline uint32_t rcc_cfgr_get_mcosel(struct RCC_Type* p) { return (p->CFGR & RCC_CFGR_MCOSEL) >> 24 ; }
inline uint32_t rcc_cfgr_get_ppre2(struct RCC_Type* p) { return (p->CFGR & RCC_CFGR_PPRE2) >> 11 ; }
inline uint32_t rcc_cfgr_get_ppre1(struct RCC_Type* p) { return (p->CFGR & RCC_CFGR_PPRE1) >> 8 ; }
inline uint32_t rcc_cfgr_get_hpre(struct RCC_Type* p) { return (p->CFGR & RCC_CFGR_HPRE) >> 4 ; }
inline uint32_t rcc_cfgr_get_sws(struct RCC_Type* p) { return (p->CFGR & RCC_CFGR_SWS) >> 2 ; }
inline uint32_t rcc_cfgr_get_sw(struct RCC_Type* p) { return (p->CFGR & RCC_CFGR_SW) >> 0 ; }

// RCC->PLLCFGR PLL configuration register
enum {
	RCC_PLLCFGR_PLLPDIV = ((1UL<<5)-1) << 27, // Main PLL division factor for PLLSAI2CLK
	RCC_PLLCFGR_PLLR = ((1UL<<2)-1) << 25, // Main PLL division factor for PLLCLK (system clock)
	RCC_PLLCFGR_PLLREN = 1UL<<24, // Main PLL PLLCLK output enable
	RCC_PLLCFGR_PLLQ = ((1UL<<2)-1) << 21, // Main PLL division factor for PLLUSB1CLK(48 MHz clock)
	RCC_PLLCFGR_PLLQEN = 1UL<<20, // Main PLL PLLUSB1CLK output enable
	RCC_PLLCFGR_PLLP = 1UL<<17, // Main PLL division factor for PLLSAI3CLK (SAI1 and SAI2 clock)
	RCC_PLLCFGR_PLLPEN = 1UL<<16, // Main PLL PLLSAI3CLK output enable
	RCC_PLLCFGR_PLLN = ((1UL<<7)-1) << 8, // Main PLL multiplication factor for VCO
	RCC_PLLCFGR_PLLM = ((1UL<<3)-1) << 4, // Division factor for the main PLL and audio PLL (PLLSAI1 and PLLSAI2) input clock
	RCC_PLLCFGR_PLLSRC = ((1UL<<2)-1) << 0, // Main PLL, PLLSAI1 and PLLSAI2 entry clock source		
};
inline void rcc_pllcfgr_set_pllpdiv(struct RCC_Type* p, uint32_t val) { p->PLLCFGR = (p->PLLCFGR & ~RCC_PLLCFGR_PLLPDIV) | ((val<<27) & RCC_PLLCFGR_PLLPDIV); }
inline void rcc_pllcfgr_set_pllr(struct RCC_Type* p, uint32_t val) { p->PLLCFGR = (p->PLLCFGR & ~RCC_PLLCFGR_PLLR) | ((val<<25) & RCC_PLLCFGR_PLLR); }
inline void rcc_pllcfgr_set_pllq(struct RCC_Type* p, uint32_t val) { p->PLLCFGR = (p->PLLCFGR & ~RCC_PLLCFGR_PLLQ) | ((val<<21) & RCC_PLLCFGR_PLLQ); }
inline void rcc_pllcfgr_set_plln(struct RCC_Type* p, uint32_t val) { p->PLLCFGR = (p->PLLCFGR & ~RCC_PLLCFGR_PLLN) | ((val<<8) & RCC_PLLCFGR_PLLN); }
inline void rcc_pllcfgr_set_pllm(struct RCC_Type* p, uint32_t val) { p->PLLCFGR = (p->PLLCFGR & ~RCC_PLLCFGR_PLLM) | ((val<<4) & RCC_PLLCFGR_PLLM); }
inline void rcc_pllcfgr_set_pllsrc(struct RCC_Type* p, uint32_t val) { p->PLLCFGR = (p->PLLCFGR & ~RCC_PLLCFGR_PLLSRC) | ((val<<0) & RCC_PLLCFGR_PLLSRC); }
inline uint32_t rcc_pllcfgr_get_pllpdiv(struct RCC_Type* p) { return (p->PLLCFGR & RCC_PLLCFGR_PLLPDIV) >> 27 ; }
inline uint32_t rcc_pllcfgr_get_pllr(struct RCC_Type* p) { return (p->PLLCFGR & RCC_PLLCFGR_PLLR) >> 25 ; }
inline uint32_t rcc_pllcfgr_get_pllq(struct RCC_Type* p) { return (p->PLLCFGR & RCC_PLLCFGR_PLLQ) >> 21 ; }
inline uint32_t rcc_pllcfgr_get_plln(struct RCC_Type* p) { return (p->PLLCFGR & RCC_PLLCFGR_PLLN) >> 8 ; }
inline uint32_t rcc_pllcfgr_get_pllm(struct RCC_Type* p) { return (p->PLLCFGR & RCC_PLLCFGR_PLLM) >> 4 ; }
inline uint32_t rcc_pllcfgr_get_pllsrc(struct RCC_Type* p) { return (p->PLLCFGR & RCC_PLLCFGR_PLLSRC) >> 0 ; }

// RCC->PLLSAI1CFGR PLLSAI1 configuration register
enum {
	RCC_PLLSAI1CFGR_PLLSAI1PDIV = ((1UL<<5)-1) << 27, // PLLSAI1 division factor for PLLSAI1CLK
	RCC_PLLSAI1CFGR_PLLSAI1R = ((1UL<<2)-1) << 25, // PLLSAI1 division factor for PLLADC1CLK (ADC clock)
	RCC_PLLSAI1CFGR_PLLSAI1REN = 1UL<<24, // PLLSAI1 PLLADC1CLK output enable
	RCC_PLLSAI1CFGR_PLLSAI1Q = ((1UL<<2)-1) << 21, // SAI1PLL division factor for PLLUSB2CLK (48 MHz clock)
	RCC_PLLSAI1CFGR_PLLSAI1QEN = 1UL<<20, // SAI1PLL PLLUSB2CLK output enable
	RCC_PLLSAI1CFGR_PLLSAI1P = 1UL<<17, // SAI1PLL division factor for PLLSAI1CLK (SAI1 or SAI2 clock)
	RCC_PLLSAI1CFGR_PLLSAI1PEN = 1UL<<16, // SAI1PLL PLLSAI1CLK output enable
	RCC_PLLSAI1CFGR_PLLSAI1N = ((1UL<<7)-1) << 8, // SAI1PLL multiplication factor for VCO		
};
inline void rcc_pllsai1cfgr_set_pllsai1pdiv(struct RCC_Type* p, uint32_t val) { p->PLLSAI1CFGR = (p->PLLSAI1CFGR & ~RCC_PLLSAI1CFGR_PLLSAI1PDIV) | ((val<<27) & RCC_PLLSAI1CFGR_PLLSAI1PDIV); }
inline void rcc_pllsai1cfgr_set_pllsai1r(struct RCC_Type* p, uint32_t val) { p->PLLSAI1CFGR = (p->PLLSAI1CFGR & ~RCC_PLLSAI1CFGR_PLLSAI1R) | ((val<<25) & RCC_PLLSAI1CFGR_PLLSAI1R); }
inline void rcc_pllsai1cfgr_set_pllsai1q(struct RCC_Type* p, uint32_t val) { p->PLLSAI1CFGR = (p->PLLSAI1CFGR & ~RCC_PLLSAI1CFGR_PLLSAI1Q) | ((val<<21) & RCC_PLLSAI1CFGR_PLLSAI1Q); }
inline void rcc_pllsai1cfgr_set_pllsai1n(struct RCC_Type* p, uint32_t val) { p->PLLSAI1CFGR = (p->PLLSAI1CFGR & ~RCC_PLLSAI1CFGR_PLLSAI1N) | ((val<<8) & RCC_PLLSAI1CFGR_PLLSAI1N); }
inline uint32_t rcc_pllsai1cfgr_get_pllsai1pdiv(struct RCC_Type* p) { return (p->PLLSAI1CFGR & RCC_PLLSAI1CFGR_PLLSAI1PDIV) >> 27 ; }
inline uint32_t rcc_pllsai1cfgr_get_pllsai1r(struct RCC_Type* p) { return (p->PLLSAI1CFGR & RCC_PLLSAI1CFGR_PLLSAI1R) >> 25 ; }
inline uint32_t rcc_pllsai1cfgr_get_pllsai1q(struct RCC_Type* p) { return (p->PLLSAI1CFGR & RCC_PLLSAI1CFGR_PLLSAI1Q) >> 21 ; }
inline uint32_t rcc_pllsai1cfgr_get_pllsai1n(struct RCC_Type* p) { return (p->PLLSAI1CFGR & RCC_PLLSAI1CFGR_PLLSAI1N) >> 8 ; }

// RCC->CIER Clock interrupt enable register
enum {
	RCC_CIER_HSI48RDYIE = 1UL<<10, // HSI48 ready interrupt enable
	RCC_CIER_LSECSSIE = 1UL<<9, // LSE clock security system interrupt enable
	RCC_CIER_PLLSAI1RDYIE = 1UL<<6, // PLLSAI1 ready interrupt enable
	RCC_CIER_PLLRDYIE = 1UL<<5, // PLL ready interrupt enable
	RCC_CIER_HSERDYIE = 1UL<<4, // HSE ready interrupt enable
	RCC_CIER_HSIRDYIE = 1UL<<3, // HSI ready interrupt enable
	RCC_CIER_MSIRDYIE = 1UL<<2, // MSI ready interrupt enable
	RCC_CIER_LSERDYIE = 1UL<<1, // LSE ready interrupt enable
	RCC_CIER_LSIRDYIE = 1UL<<0, // LSI ready interrupt enable		
};

// RCC->CIFR Clock interrupt flag register
enum {
	RCC_CIFR_HSI48RDYF = 1UL<<10, // HSI48 ready interrupt flag
	RCC_CIFR_LSECSSF = 1UL<<9, // LSE Clock security system interrupt flag
	RCC_CIFR_CSSF = 1UL<<8, // Clock security system interrupt flag
	RCC_CIFR_PLLSAI1RDYF = 1UL<<6, // PLLSAI1 ready interrupt flag
	RCC_CIFR_PLLRDYF = 1UL<<5, // PLL ready interrupt flag
	RCC_CIFR_HSERDYF = 1UL<<4, // HSE ready interrupt flag
	RCC_CIFR_HSIRDYF = 1UL<<3, // HSI ready interrupt flag
	RCC_CIFR_MSIRDYF = 1UL<<2, // MSI ready interrupt flag
	RCC_CIFR_LSERDYF = 1UL<<1, // LSE ready interrupt flag
	RCC_CIFR_LSIRDYF = 1UL<<0, // LSI ready interrupt flag		
};

// RCC->CICR Clock interrupt clear register
enum {
	RCC_CICR_HSI48RDYC = 1UL<<10, // HSI48 oscillator ready interrupt clear
	RCC_CICR_LSECSSC = 1UL<<9, // LSE Clock security system interrupt clear
	RCC_CICR_CSSC = 1UL<<8, // Clock security system interrupt clear
	RCC_CICR_PLLSAI1RDYC = 1UL<<6, // PLLSAI1 ready interrupt clear
	RCC_CICR_PLLRDYC = 1UL<<5, // PLL ready interrupt clear
	RCC_CICR_HSERDYC = 1UL<<4, // HSE ready interrupt clear
	RCC_CICR_HSIRDYC = 1UL<<3, // HSI ready interrupt clear
	RCC_CICR_MSIRDYC = 1UL<<2, // MSI ready interrupt clear
	RCC_CICR_LSERDYC = 1UL<<1, // LSE ready interrupt clear
	RCC_CICR_LSIRDYC = 1UL<<0, // LSI ready interrupt clear		
};

// RCC->AHB1RSTR AHB1 peripheral reset register
enum {
	RCC_AHB1RSTR_TSCRST = 1UL<<16, // Touch Sensing Controller reset
	RCC_AHB1RSTR_CRCRST = 1UL<<11, // CRC reset
	RCC_AHB1RSTR_FLASHRST = 1UL<<8, // Flash memory interface reset
	RCC_AHB1RSTR_DMA2RST = 1UL<<1, // DMA2 reset
	RCC_AHB1RSTR_DMA1RST = 1UL<<0, // DMA1 reset		
};

// RCC->AHB2RSTR AHB2 peripheral reset register
enum {
	RCC_AHB2RSTR_RNGRST = 1UL<<18, // Random number generator reset
	RCC_AHB2RSTR_AESRST = 1UL<<16, // AES hardware accelerator reset
	RCC_AHB2RSTR_ADCRST = 1UL<<13, // ADC reset
	RCC_AHB2RSTR_GPIOHRST = 1UL<<7, // IO port H reset
	RCC_AHB2RSTR_GPIOERST = 1UL<<4, // IO port E reset
	RCC_AHB2RSTR_GPIODRST = 1UL<<3, // IO port D reset
	RCC_AHB2RSTR_GPIOCRST = 1UL<<2, // IO port C reset
	RCC_AHB2RSTR_GPIOBRST = 1UL<<1, // IO port B reset
	RCC_AHB2RSTR_GPIOARST = 1UL<<0, // IO port A reset		
};

// RCC->AHB3RSTR AHB3 peripheral reset register
enum {
	RCC_AHB3RSTR_QSPIRST = 1UL<<8, // Quad SPI memory interface reset		
};

// RCC->APB1RSTR1 APB1 peripheral reset register 1
enum {
	RCC_APB1RSTR1_LPTIM1RST = 1UL<<31, // Low Power Timer 1 reset
	RCC_APB1RSTR1_OPAMPRST = 1UL<<30, // OPAMP interface reset
	RCC_APB1RSTR1_DAC1RST = 1UL<<29, // DAC1 interface reset
	RCC_APB1RSTR1_PWRRST = 1UL<<28, // Power interface reset
	RCC_APB1RSTR1_USBFSRST = 1UL<<26, // USB FS reset
	RCC_APB1RSTR1_CAN1RST = 1UL<<25, // CAN1 reset
	RCC_APB1RSTR1_CRSRST = 1UL<<24, // CRS reset
	RCC_APB1RSTR1_I2C3RST = 1UL<<23, // I2C3 reset
	RCC_APB1RSTR1_I2C2RST = 1UL<<22, // I2C2 reset
	RCC_APB1RSTR1_I2C1RST = 1UL<<21, // I2C1 reset
	RCC_APB1RSTR1_USART4RST = 1UL<<19, // USART4 reset.
	RCC_APB1RSTR1_USART1RST = 1UL<<18, // USART1 reset
	RCC_APB1RSTR1_USART2RST = 1UL<<17, // USART2 reset
	RCC_APB1RSTR1_SPI3RST = 1UL<<15, // SPI3 reset
	RCC_APB1RSTR1_SPI2RST = 1UL<<14, // SPI2 reset
	RCC_APB1RSTR1_LCDRST = 1UL<<9, // LCD interface reset
	RCC_APB1RSTR1_TIM7RST = 1UL<<5, // TIM7 timer reset
	RCC_APB1RSTR1_TIM6RST = 1UL<<4, // TIM6 timer reset
	RCC_APB1RSTR1_TIM2RST = 1UL<<0, // TIM2 timer reset		
};

// RCC->APB1RSTR2 APB1 peripheral reset register 2
enum {
	RCC_APB1RSTR2_LPTIM2RST = 1UL<<5, // Low-power timer 2 reset
	RCC_APB1RSTR2_SWPMI1RST = 1UL<<2, // Single wire protocol reset
	RCC_APB1RSTR2_I2C4RST = 1UL<<1, // I2C4 reset
	RCC_APB1RSTR2_LPUART1RST = 1UL<<0, // Low-power UART 1 reset		
};

// RCC->APB2RSTR APB2 peripheral reset register
enum {
	RCC_APB2RSTR_DFSDMRST = 1UL<<24, // DFSDM filter reset
	RCC_APB2RSTR_SAI1RST = 1UL<<21, // Serial audio interface 1 (SAI1) reset
	RCC_APB2RSTR_TIM16RST = 1UL<<17, // TIM16 timer reset
	RCC_APB2RSTR_TIM15RST = 1UL<<16, // TIM15 timer reset
	RCC_APB2RSTR_USART1RST = 1UL<<14, // USART1 reset
	RCC_APB2RSTR_SPI1RST = 1UL<<12, // SPI1 reset
	RCC_APB2RSTR_TIM1RST = 1UL<<11, // TIM1 timer reset
	RCC_APB2RSTR_SDMMCRST = 1UL<<10, // SDMMC reset
	RCC_APB2RSTR_SYSCFGRST = 1UL<<0, // System configuration (SYSCFG) reset		
};

// RCC->AHB1ENR AHB1 peripheral clock enable register
enum {
	RCC_AHB1ENR_TSCEN = 1UL<<16, // Touch Sensing Controller clock enable
	RCC_AHB1ENR_CRCEN = 1UL<<12, // CRC clock enable
	RCC_AHB1ENR_FLASHEN = 1UL<<8, // Flash memory interface clock enable
	RCC_AHB1ENR_DMA2EN = 1UL<<1, // DMA2 clock enable
	RCC_AHB1ENR_DMA1EN = 1UL<<0, // DMA1 clock enable		
};

// RCC->AHB2ENR AHB2 peripheral clock enable register
enum {
	RCC_AHB2ENR_RNGEN = 1UL<<18, // Random Number Generator clock enable
	RCC_AHB2ENR_AESEN = 1UL<<16, // AES accelerator clock enable
	RCC_AHB2ENR_ADCEN = 1UL<<13, // ADC clock enable
	RCC_AHB2ENR_GPIOHEN = 1UL<<7, // IO port H clock enable
	RCC_AHB2ENR_GPIOEEN = 1UL<<4, // IO port E clock enable
	RCC_AHB2ENR_GPIODEN = 1UL<<3, // IO port D clock enable
	RCC_AHB2ENR_GPIOCEN = 1UL<<2, // IO port C clock enable
	RCC_AHB2ENR_GPIOBEN = 1UL<<1, // IO port B clock enable
	RCC_AHB2ENR_GPIOAEN = 1UL<<0, // IO port A clock enable		
};

// RCC->AHB3ENR AHB3 peripheral clock enable register
enum {
	RCC_AHB3ENR_QSPIEN = 1UL<<8, // QSPIEN		
};

// RCC->APB1ENR1 APB1ENR1
enum {
	RCC_APB1ENR1_LPTIM1EN = 1UL<<31, // Low power timer 1 clock enable
	RCC_APB1ENR1_OPAMPEN = 1UL<<30, // OPAMP interface clock enable
	RCC_APB1ENR1_DAC1EN = 1UL<<29, // DAC1 interface clock enable
	RCC_APB1ENR1_PWREN = 1UL<<28, // Power interface clock enable
	RCC_APB1ENR1_USBF = 1UL<<26, // USB FS clock enable
	RCC_APB1ENR1_CAN1EN = 1UL<<25, // CAN1 clock enable
	RCC_APB1ENR1_CRSEN = 1UL<<24, // CRS clock enable
	RCC_APB1ENR1_I2C3EN = 1UL<<23, // I2C3 clock enable
	RCC_APB1ENR1_I2C2EN = 1UL<<22, // I2C2 clock enable
	RCC_APB1ENR1_I2C1EN = 1UL<<21, // I2C1 clock enable
	RCC_APB1ENR1_UART4EN = 1UL<<19, // UART4 clock enable
	RCC_APB1ENR1_USART3EN = 1UL<<18, // USART3 clock enable
	RCC_APB1ENR1_USART2EN = 1UL<<17, // USART2 clock enable
	RCC_APB1ENR1_SPI3EN = 1UL<<15, // SPI3 clock enable
	RCC_APB1ENR1_SPI2EN = 1UL<<14, // SPI2 clock enable
	RCC_APB1ENR1_WWDGEN = 1UL<<11, // Window watchdog clock enable
	RCC_APB1ENR1_RTCAPBEN = 1UL<<10, // RTC APB clock enable
	RCC_APB1ENR1_LCDEN = 1UL<<9, // LCD clock enable
	RCC_APB1ENR1_TIM7EN = 1UL<<5, // TIM7 timer clock enable
	RCC_APB1ENR1_TIM6EN = 1UL<<4, // TIM6 timer clock enable
	RCC_APB1ENR1_TIM3EN = 1UL<<1, // TIM3 timer clock enable
	RCC_APB1ENR1_TIM2EN = 1UL<<0, // TIM2 timer clock enable		
};

// RCC->APB1ENR2 APB1 peripheral clock enable register 2
enum {
	RCC_APB1ENR2_DFSDMEN = 1UL<<24, // DFSDMEN enable
	RCC_APB1ENR2_LPTIM2EN = 1UL<<5, // LPTIM2EN
	RCC_APB1ENR2_SWPMI1EN = 1UL<<2, // Single wire protocol clock enable
	RCC_APB1ENR2_I2C4EN = 1UL<<1, // I2C4 clock enable
	RCC_APB1ENR2_LPUART1EN = 1UL<<0, // Low power UART 1 clock enable		
};

// RCC->APB2ENR APB2ENR
enum {
	RCC_APB2ENR_SAI1EN = 1UL<<21, // SAI1 clock enable
	RCC_APB2ENR_TIM16EN = 1UL<<17, // TIM16 timer clock enable
	RCC_APB2ENR_TIM15EN = 1UL<<16, // TIM15 timer clock enable
	RCC_APB2ENR_USART1EN = 1UL<<14, // USART1clock enable
	RCC_APB2ENR_SPI1EN = 1UL<<12, // SPI1 clock enable
	RCC_APB2ENR_TIM1EN = 1UL<<11, // TIM1 timer clock enable
	RCC_APB2ENR_SDMMCEN = 1UL<<10, // SDMMC clock enable
	RCC_APB2ENR_FIREWALLEN = 1UL<<7, // Firewall clock enable
	RCC_APB2ENR_SYSCFGEN = 1UL<<0, // SYSCFG clock enable		
};

// RCC->AHB1SMENR AHB1 peripheral clocks enable in Sleep and Stop modes register
enum {
	RCC_AHB1SMENR_TSCSMEN = 1UL<<16, // Touch Sensing Controller clocks enable during Sleep and Stop modes
	RCC_AHB1SMENR_CRCSMEN = 1UL<<12, // CRCSMEN
	RCC_AHB1SMENR_SRAM1SMEN = 1UL<<9, // SRAM1 interface clocks enable during Sleep and Stop modes
	RCC_AHB1SMENR_FLASHSMEN = 1UL<<8, // Flash memory interface clocks enable during Sleep and Stop modes
	RCC_AHB1SMENR_DMA2SMEN = 1UL<<1, // DMA2 clocks enable during Sleep and Stop modes
	RCC_AHB1SMENR_DMA1SMEN = 1UL<<0, // DMA1 clocks enable during Sleep and Stop modes		
};

// RCC->AHB2SMENR AHB2 peripheral clocks enable in Sleep and Stop modes register
enum {
	RCC_AHB2SMENR_RNGSMEN = 1UL<<18, // Random Number Generator clocks enable during Sleep and Stop modes
	RCC_AHB2SMENR_AESSMEN = 1UL<<16, // AES accelerator clocks enable during Sleep and Stop modes
	RCC_AHB2SMENR_ADCFSSMEN = 1UL<<13, // ADC clocks enable during Sleep and Stop modes
	RCC_AHB2SMENR_SRAM2SMEN = 1UL<<9, // SRAM2 interface clocks enable during Sleep and Stop modes
	RCC_AHB2SMENR_GPIOHSMEN = 1UL<<7, // IO port H clocks enable during Sleep and Stop modes
	RCC_AHB2SMENR_GPIOESMEN = 1UL<<4, // IO port E clocks enable during Sleep and Stop modes
	RCC_AHB2SMENR_GPIODSMEN = 1UL<<3, // IO port D clocks enable during Sleep and Stop modes
	RCC_AHB2SMENR_GPIOCSMEN = 1UL<<2, // IO port C clocks enable during Sleep and Stop modes
	RCC_AHB2SMENR_GPIOBSMEN = 1UL<<1, // IO port B clocks enable during Sleep and Stop modes
	RCC_AHB2SMENR_GPIOASMEN = 1UL<<0, // IO port A clocks enable during Sleep and Stop modes		
};

// RCC->AHB3SMENR AHB3 peripheral clocks enable in Sleep and Stop modes register
enum {
	RCC_AHB3SMENR_QSPISMEN = 1UL<<8, // QSPISMEN		
};

// RCC->APB1SMENR1 APB1SMENR1
enum {
	RCC_APB1SMENR1_LPTIM1SMEN = 1UL<<31, // Low power timer 1 clocks enable during Sleep and Stop modes
	RCC_APB1SMENR1_OPAMPSMEN = 1UL<<30, // OPAMP interface clocks enable during Sleep and Stop modes
	RCC_APB1SMENR1_DAC1SMEN = 1UL<<29, // DAC1 interface clocks enable during Sleep and Stop modes
	RCC_APB1SMENR1_PWRSMEN = 1UL<<28, // Power interface clocks enable during Sleep and Stop modes
	RCC_APB1SMENR1_USBFSSMEN = 1UL<<26, // USB FS clock enable during Sleep and Stop modes
	RCC_APB1SMENR1_CAN1SMEN = 1UL<<25, // CAN1 clocks enable during Sleep and Stop modes
	RCC_APB1SMENR1_CRSSMEN = 1UL<<24, // CRS clock enable during Sleep and Stop modes
	RCC_APB1SMENR1_I2C3SMEN = 1UL<<23, // I2C3 clocks enable during Sleep and Stop modes
	RCC_APB1SMENR1_I2C2SMEN = 1UL<<22, // I2C2 clocks enable during Sleep and Stop modes
	RCC_APB1SMENR1_I2C1SMEN = 1UL<<21, // I2C1 clocks enable during Sleep and Stop modes
	RCC_APB1SMENR1_USART2SMEN = 1UL<<18, // USART2 clocks enable during Sleep and Stop modes
	RCC_APB1SMENR1_USART1SMEN = 1UL<<17, // USART1 clocks enable during Sleep and Stop modes
	RCC_APB1SMENR1_SPI3SMEN = 1UL<<15, // SPI3 clocks enable during Sleep and Stop modes
	RCC_APB1SMENR1_SPI2SMEN = 1UL<<14, // SPI2 clocks enable during Sleep and Stop modes
	RCC_APB1SMENR1_WWDGSMEN = 1UL<<11, // Window watchdog clocks enable during Sleep and Stop modes
	RCC_APB1SMENR1_RTCAPBSMEN = 1UL<<10, // RTC APB clock enable during Sleep and Stop modes
	RCC_APB1SMENR1_LCDSMEN = 1UL<<9, // LCD clocks enable during Sleep and Stop modes
	RCC_APB1SMENR1_TIM7SMEN = 1UL<<5, // TIM7 timer clocks enable during Sleep and Stop modes
	RCC_APB1SMENR1_TIM6SMEN = 1UL<<4, // TIM6 timer clocks enable during Sleep and Stop modes
	RCC_APB1SMENR1_TIM2SMEN = 1UL<<0, // TIM2 timer clocks enable during Sleep and Stop modes		
};

// RCC->APB1SMENR2 APB1 peripheral clocks enable in Sleep and Stop modes register 2
enum {
	RCC_APB1SMENR2_LPTIM2SMEN = 1UL<<5, // LPTIM2SMEN
	RCC_APB1SMENR2_SWPMI1SMEN = 1UL<<2, // Single wire protocol clocks enable during Sleep and Stop modes
	RCC_APB1SMENR2_LPUART1SMEN = 1UL<<0, // Low power UART 1 clocks enable during Sleep and Stop modes		
};

// RCC->APB2SMENR APB2SMENR
enum {
	RCC_APB2SMENR_SAI1SMEN = 1UL<<21, // SAI1 clocks enable during Sleep and Stop modes
	RCC_APB2SMENR_TIM16SMEN = 1UL<<17, // TIM16 timer clocks enable during Sleep and Stop modes
	RCC_APB2SMENR_TIM15SMEN = 1UL<<16, // TIM15 timer clocks enable during Sleep and Stop modes
	RCC_APB2SMENR_USART1SMEN = 1UL<<14, // USART1clocks enable during Sleep and Stop modes
	RCC_APB2SMENR_SPI1SMEN = 1UL<<12, // SPI1 clocks enable during Sleep and Stop modes
	RCC_APB2SMENR_TIM1SMEN = 1UL<<11, // TIM1 timer clocks enable during Sleep and Stop modes
	RCC_APB2SMENR_SDMMCSMEN = 1UL<<10, // SDMMC clocks enable during Sleep and Stop modes
	RCC_APB2SMENR_SYSCFGSMEN = 1UL<<0, // SYSCFG clocks enable during Sleep and Stop modes		
};

// RCC->CCIPR CCIPR
enum {
	RCC_CCIPR_SWPMI1SEL = 1UL<<30, // SWPMI1 clock source selection
	RCC_CCIPR_ADCSEL = ((1UL<<2)-1) << 28, // ADCs clock source selection
	RCC_CCIPR_CLK48SEL = ((1UL<<2)-1) << 26, // 48 MHz clock source selection
	RCC_CCIPR_SAI1SEL = ((1UL<<2)-1) << 22, // SAI1 clock source selection
	RCC_CCIPR_LPTIM2SEL = ((1UL<<2)-1) << 20, // Low power timer 2 clock source selection
	RCC_CCIPR_LPTIM1SEL = ((1UL<<2)-1) << 18, // Low power timer 1 clock source selection
	RCC_CCIPR_I2C3SEL = ((1UL<<2)-1) << 16, // I2C3 clock source selection
	RCC_CCIPR_I2C2SEL = ((1UL<<2)-1) << 14, // I2C2 clock source selection
	RCC_CCIPR_I2C1SEL = ((1UL<<2)-1) << 12, // I2C1 clock source selection
	RCC_CCIPR_LPUART1SEL = ((1UL<<2)-1) << 10, // LPUART1 clock source selection
	RCC_CCIPR_USART4SEL = ((1UL<<2)-1) << 6, // USART4 clock source selection
	RCC_CCIPR_USART3SEL = ((1UL<<2)-1) << 4, // USART3 clock source selection
	RCC_CCIPR_USART2SEL = ((1UL<<2)-1) << 2, // USART2 clock source selection
	RCC_CCIPR_USART1SEL = ((1UL<<2)-1) << 0, // USART1 clock source selection		
};
inline void rcc_ccipr_set_adcsel(struct RCC_Type* p, uint32_t val) { p->CCIPR = (p->CCIPR & ~RCC_CCIPR_ADCSEL) | ((val<<28) & RCC_CCIPR_ADCSEL); }
inline void rcc_ccipr_set_clk48sel(struct RCC_Type* p, uint32_t val) { p->CCIPR = (p->CCIPR & ~RCC_CCIPR_CLK48SEL) | ((val<<26) & RCC_CCIPR_CLK48SEL); }
inline void rcc_ccipr_set_sai1sel(struct RCC_Type* p, uint32_t val) { p->CCIPR = (p->CCIPR & ~RCC_CCIPR_SAI1SEL) | ((val<<22) & RCC_CCIPR_SAI1SEL); }
inline void rcc_ccipr_set_lptim2sel(struct RCC_Type* p, uint32_t val) { p->CCIPR = (p->CCIPR & ~RCC_CCIPR_LPTIM2SEL) | ((val<<20) & RCC_CCIPR_LPTIM2SEL); }
inline void rcc_ccipr_set_lptim1sel(struct RCC_Type* p, uint32_t val) { p->CCIPR = (p->CCIPR & ~RCC_CCIPR_LPTIM1SEL) | ((val<<18) & RCC_CCIPR_LPTIM1SEL); }
inline void rcc_ccipr_set_i2c3sel(struct RCC_Type* p, uint32_t val) { p->CCIPR = (p->CCIPR & ~RCC_CCIPR_I2C3SEL) | ((val<<16) & RCC_CCIPR_I2C3SEL); }
inline void rcc_ccipr_set_i2c2sel(struct RCC_Type* p, uint32_t val) { p->CCIPR = (p->CCIPR & ~RCC_CCIPR_I2C2SEL) | ((val<<14) & RCC_CCIPR_I2C2SEL); }
inline void rcc_ccipr_set_i2c1sel(struct RCC_Type* p, uint32_t val) { p->CCIPR = (p->CCIPR & ~RCC_CCIPR_I2C1SEL) | ((val<<12) & RCC_CCIPR_I2C1SEL); }
inline void rcc_ccipr_set_lpuart1sel(struct RCC_Type* p, uint32_t val) { p->CCIPR = (p->CCIPR & ~RCC_CCIPR_LPUART1SEL) | ((val<<10) & RCC_CCIPR_LPUART1SEL); }
inline void rcc_ccipr_set_usart4sel(struct RCC_Type* p, uint32_t val) { p->CCIPR = (p->CCIPR & ~RCC_CCIPR_USART4SEL) | ((val<<6) & RCC_CCIPR_USART4SEL); }
inline void rcc_ccipr_set_usart3sel(struct RCC_Type* p, uint32_t val) { p->CCIPR = (p->CCIPR & ~RCC_CCIPR_USART3SEL) | ((val<<4) & RCC_CCIPR_USART3SEL); }
inline void rcc_ccipr_set_usart2sel(struct RCC_Type* p, uint32_t val) { p->CCIPR = (p->CCIPR & ~RCC_CCIPR_USART2SEL) | ((val<<2) & RCC_CCIPR_USART2SEL); }
inline void rcc_ccipr_set_usart1sel(struct RCC_Type* p, uint32_t val) { p->CCIPR = (p->CCIPR & ~RCC_CCIPR_USART1SEL) | ((val<<0) & RCC_CCIPR_USART1SEL); }
inline uint32_t rcc_ccipr_get_adcsel(struct RCC_Type* p) { return (p->CCIPR & RCC_CCIPR_ADCSEL) >> 28 ; }
inline uint32_t rcc_ccipr_get_clk48sel(struct RCC_Type* p) { return (p->CCIPR & RCC_CCIPR_CLK48SEL) >> 26 ; }
inline uint32_t rcc_ccipr_get_sai1sel(struct RCC_Type* p) { return (p->CCIPR & RCC_CCIPR_SAI1SEL) >> 22 ; }
inline uint32_t rcc_ccipr_get_lptim2sel(struct RCC_Type* p) { return (p->CCIPR & RCC_CCIPR_LPTIM2SEL) >> 20 ; }
inline uint32_t rcc_ccipr_get_lptim1sel(struct RCC_Type* p) { return (p->CCIPR & RCC_CCIPR_LPTIM1SEL) >> 18 ; }
inline uint32_t rcc_ccipr_get_i2c3sel(struct RCC_Type* p) { return (p->CCIPR & RCC_CCIPR_I2C3SEL) >> 16 ; }
inline uint32_t rcc_ccipr_get_i2c2sel(struct RCC_Type* p) { return (p->CCIPR & RCC_CCIPR_I2C2SEL) >> 14 ; }
inline uint32_t rcc_ccipr_get_i2c1sel(struct RCC_Type* p) { return (p->CCIPR & RCC_CCIPR_I2C1SEL) >> 12 ; }
inline uint32_t rcc_ccipr_get_lpuart1sel(struct RCC_Type* p) { return (p->CCIPR & RCC_CCIPR_LPUART1SEL) >> 10 ; }
inline uint32_t rcc_ccipr_get_usart4sel(struct RCC_Type* p) { return (p->CCIPR & RCC_CCIPR_USART4SEL) >> 6 ; }
inline uint32_t rcc_ccipr_get_usart3sel(struct RCC_Type* p) { return (p->CCIPR & RCC_CCIPR_USART3SEL) >> 4 ; }
inline uint32_t rcc_ccipr_get_usart2sel(struct RCC_Type* p) { return (p->CCIPR & RCC_CCIPR_USART2SEL) >> 2 ; }
inline uint32_t rcc_ccipr_get_usart1sel(struct RCC_Type* p) { return (p->CCIPR & RCC_CCIPR_USART1SEL) >> 0 ; }

// RCC->BDCR BDCR
enum {
	RCC_BDCR_LSCOSEL = 1UL<<25, // Low speed clock output selection
	RCC_BDCR_LSCOEN = 1UL<<24, // Low speed clock output enable
	RCC_BDCR_BDRST = 1UL<<16, // Backup domain software reset
	RCC_BDCR_RTCEN = 1UL<<15, // RTC clock enable
	RCC_BDCR_RTCSEL = ((1UL<<2)-1) << 8, // RTC clock source selection
	RCC_BDCR_LSECSSD = 1UL<<6, // LSECSSD
	RCC_BDCR_LSECSSON = 1UL<<5, // LSECSSON
	RCC_BDCR_LSEDRV = ((1UL<<2)-1) << 3, // SE oscillator drive capability
	RCC_BDCR_LSEBYP = 1UL<<2, // LSE oscillator bypass
	RCC_BDCR_LSERDY = 1UL<<1, // LSE oscillator ready
	RCC_BDCR_LSEON = 1UL<<0, // LSE oscillator enable		
};
inline void rcc_bdcr_set_rtcsel(struct RCC_Type* p, uint32_t val) { p->BDCR = (p->BDCR & ~RCC_BDCR_RTCSEL) | ((val<<8) & RCC_BDCR_RTCSEL); }
inline void rcc_bdcr_set_lsedrv(struct RCC_Type* p, uint32_t val) { p->BDCR = (p->BDCR & ~RCC_BDCR_LSEDRV) | ((val<<3) & RCC_BDCR_LSEDRV); }
inline uint32_t rcc_bdcr_get_rtcsel(struct RCC_Type* p) { return (p->BDCR & RCC_BDCR_RTCSEL) >> 8 ; }
inline uint32_t rcc_bdcr_get_lsedrv(struct RCC_Type* p) { return (p->BDCR & RCC_BDCR_LSEDRV) >> 3 ; }

// RCC->CSR CSR
enum {
	RCC_CSR_LPWRSTF = 1UL<<31, // Low-power reset flag
	RCC_CSR_WWDGRSTF = 1UL<<30, // Window watchdog reset flag
	RCC_CSR_IWDGRSTF = 1UL<<29, // Independent window watchdog reset flag
	RCC_CSR_SFTRSTF = 1UL<<28, // Software reset flag
	RCC_CSR_BORRSTF = 1UL<<27, // BOR flag
	RCC_CSR_PINRSTF = 1UL<<26, // Pin reset flag
	RCC_CSR_OBLRSTF = 1UL<<25, // Option byte loader reset flag
	RCC_CSR_FIREWALLRSTF = 1UL<<24, // Firewall reset flag
	RCC_CSR_RMVF = 1UL<<23, // Remove reset flag
	RCC_CSR_MSISRANGE = ((1UL<<4)-1) << 8, // SI range after Standby mode
	RCC_CSR_LSIRDY = 1UL<<1, // LSI oscillator ready
	RCC_CSR_LSION = 1UL<<0, // LSI oscillator enable		
};
inline void rcc_csr_set_msisrange(struct RCC_Type* p, uint32_t val) { p->CSR = (p->CSR & ~RCC_CSR_MSISRANGE) | ((val<<8) & RCC_CSR_MSISRANGE); }
inline uint32_t rcc_csr_get_msisrange(struct RCC_Type* p) { return (p->CSR & RCC_CSR_MSISRANGE) >> 8 ; }

// RCC->CRRCR Clock recovery RC register
enum {
	RCC_CRRCR_HSI48CAL = ((1UL<<9)-1) << 7, // HSI48 clock calibration
	RCC_CRRCR_HSI48RDY = 1UL<<1, // HSI48 clock ready flag
	RCC_CRRCR_HSI48ON = 1UL<<0, // HSI48 clock enable		
};
inline void rcc_crrcr_set_hsi48cal(struct RCC_Type* p, uint32_t val) { p->CRRCR = (p->CRRCR & ~RCC_CRRCR_HSI48CAL) | ((val<<7) & RCC_CRRCR_HSI48CAL); }
inline uint32_t rcc_crrcr_get_hsi48cal(struct RCC_Type* p) { return (p->CRRCR & RCC_CRRCR_HSI48CAL) >> 7 ; }

/* Random number generator */
struct RNG_Type {
	__IO uint8_t CR; // @0 control register
	 uint8_t RESERVED0[3]; // @1 
	__IO uint8_t SR; // @4 status register
	 uint8_t RESERVED1[3]; // @5 
	__I uint32_t DR; // @8 data register
};

// RNG->CR control register
enum {
	RNG_CR_IE = 1UL<<3, // Interrupt enable
	RNG_CR_RNGEN = 1UL<<2, // Random number generator enable		
};

// RNG->SR status register
enum {
	RNG_SR_SEIS = 1UL<<6, // Seed error interrupt status
	RNG_SR_CEIS = 1UL<<5, // Clock error interrupt status
	RNG_SR_SECS = 1UL<<2, // Seed error current status
	RNG_SR_CECS = 1UL<<1, // Clock error current status
	RNG_SR_DRDY = 1UL<<0, // Data ready		
};

/* Real-time clock */
struct RTC_Type {
	__IO uint32_t TR; // @0 time register
	__IO uint32_t DR; // @4 date register
	__IO uint32_t CR; // @8 control register
	__IO uint32_t ISR; // @12 initialization and status register
	__IO uint32_t PRER; // @16 prescaler register
	__IO uint16_t WUTR; // @20 wakeup timer register
	 uint8_t RESERVED0[6]; // @22 
	__IO uint32_t ALRMAR; // @28 alarm A register
	__IO uint32_t ALRMBR; // @32 alarm B register
	__O uint8_t WPR; // @36 write protection register
	 uint8_t RESERVED1[3]; // @37 
	__I uint16_t SSR; // @40 sub second register
	 uint8_t RESERVED2[2]; // @42 
	__O uint32_t SHIFTR; // @44 shift control register
	__I uint32_t TSTR; // @48 time stamp time register
	__I uint16_t TSDR; // @52 time stamp date register
	 uint8_t RESERVED3[2]; // @54 
	__I uint16_t TSSSR; // @56 timestamp sub second register
	 uint8_t RESERVED4[2]; // @58 
	__IO uint16_t CALR; // @60 calibration register
	 uint8_t RESERVED5[2]; // @62 
	__IO uint32_t TAMPCR; // @64 tamper configuration register
	__IO uint32_t ALRMASSR; // @68 alarm A sub second register
	__IO uint32_t ALRMBSSR; // @72 alarm B sub second register
	__IO uint8_t OR; // @76 option register
	 uint8_t RESERVED6[3]; // @77 
	__IO uint32_t BKP0R; // @80 backup register
	__IO uint32_t BKP1R; // @84 backup register
	__IO uint32_t BKP2R; // @88 backup register
	__IO uint32_t BKP3R; // @92 backup register
	__IO uint32_t BKP4R; // @96 backup register
	__IO uint32_t BKP5R; // @100 backup register
	__IO uint32_t BKP6R; // @104 backup register
	__IO uint32_t BKP7R; // @108 backup register
	__IO uint32_t BKP8R; // @112 backup register
	__IO uint32_t BKP9R; // @116 backup register
	__IO uint32_t BKP10R; // @120 backup register
	__IO uint32_t BKP11R; // @124 backup register
	__IO uint32_t BKP12R; // @128 backup register
	__IO uint32_t BKP13R; // @132 backup register
	__IO uint32_t BKP14R; // @136 backup register
	__IO uint32_t BKP15R; // @140 backup register
	__IO uint32_t BKP16R; // @144 backup register
	__IO uint32_t BKP17R; // @148 backup register
	__IO uint32_t BKP18R; // @152 backup register
	__IO uint32_t BKP19R; // @156 backup register
	__IO uint32_t BKP20R; // @160 backup register
	__IO uint32_t BKP21R; // @164 backup register
	__IO uint32_t BKP22R; // @168 backup register
	__IO uint32_t BKP23R; // @172 backup register
	__IO uint32_t BKP24R; // @176 backup register
	__IO uint32_t BKP25R; // @180 backup register
	__IO uint32_t BKP26R; // @184 backup register
	__IO uint32_t BKP27R; // @188 backup register
	__IO uint32_t BKP28R; // @192 backup register
	__IO uint32_t BKP29R; // @196 backup register
	__IO uint32_t BKP30R; // @200 backup register
	__IO uint32_t BKP31R; // @204 backup register
};

// RTC->TR time register
enum {
	RTC_TR_PM = 1UL<<22, // AM/PM notation
	RTC_TR_HT = ((1UL<<2)-1) << 20, // Hour tens in BCD format
	RTC_TR_HU = ((1UL<<4)-1) << 16, // Hour units in BCD format
	RTC_TR_MNT = ((1UL<<3)-1) << 12, // Minute tens in BCD format
	RTC_TR_MNU = ((1UL<<4)-1) << 8, // Minute units in BCD format
	RTC_TR_ST = ((1UL<<3)-1) << 4, // Second tens in BCD format
	RTC_TR_SU = ((1UL<<4)-1) << 0, // Second units in BCD format		
};
inline void rtc_tr_set_ht(struct RTC_Type* p, uint32_t val) { p->TR = (p->TR & ~RTC_TR_HT) | ((val<<20) & RTC_TR_HT); }
inline void rtc_tr_set_hu(struct RTC_Type* p, uint32_t val) { p->TR = (p->TR & ~RTC_TR_HU) | ((val<<16) & RTC_TR_HU); }
inline void rtc_tr_set_mnt(struct RTC_Type* p, uint32_t val) { p->TR = (p->TR & ~RTC_TR_MNT) | ((val<<12) & RTC_TR_MNT); }
inline void rtc_tr_set_mnu(struct RTC_Type* p, uint32_t val) { p->TR = (p->TR & ~RTC_TR_MNU) | ((val<<8) & RTC_TR_MNU); }
inline void rtc_tr_set_st(struct RTC_Type* p, uint32_t val) { p->TR = (p->TR & ~RTC_TR_ST) | ((val<<4) & RTC_TR_ST); }
inline void rtc_tr_set_su(struct RTC_Type* p, uint32_t val) { p->TR = (p->TR & ~RTC_TR_SU) | ((val<<0) & RTC_TR_SU); }
inline uint32_t rtc_tr_get_ht(struct RTC_Type* p) { return (p->TR & RTC_TR_HT) >> 20 ; }
inline uint32_t rtc_tr_get_hu(struct RTC_Type* p) { return (p->TR & RTC_TR_HU) >> 16 ; }
inline uint32_t rtc_tr_get_mnt(struct RTC_Type* p) { return (p->TR & RTC_TR_MNT) >> 12 ; }
inline uint32_t rtc_tr_get_mnu(struct RTC_Type* p) { return (p->TR & RTC_TR_MNU) >> 8 ; }
inline uint32_t rtc_tr_get_st(struct RTC_Type* p) { return (p->TR & RTC_TR_ST) >> 4 ; }
inline uint32_t rtc_tr_get_su(struct RTC_Type* p) { return (p->TR & RTC_TR_SU) >> 0 ; }

// RTC->DR date register
enum {
	RTC_DR_YT = ((1UL<<4)-1) << 20, // Year tens in BCD format
	RTC_DR_YU = ((1UL<<4)-1) << 16, // Year units in BCD format
	RTC_DR_WDU = ((1UL<<3)-1) << 13, // Week day units
	RTC_DR_MT = 1UL<<12, // Month tens in BCD format
	RTC_DR_MU = ((1UL<<4)-1) << 8, // Month units in BCD format
	RTC_DR_DT = ((1UL<<2)-1) << 4, // Date tens in BCD format
	RTC_DR_DU = ((1UL<<4)-1) << 0, // Date units in BCD format		
};
inline void rtc_dr_set_yt(struct RTC_Type* p, uint32_t val) { p->DR = (p->DR & ~RTC_DR_YT) | ((val<<20) & RTC_DR_YT); }
inline void rtc_dr_set_yu(struct RTC_Type* p, uint32_t val) { p->DR = (p->DR & ~RTC_DR_YU) | ((val<<16) & RTC_DR_YU); }
inline void rtc_dr_set_wdu(struct RTC_Type* p, uint32_t val) { p->DR = (p->DR & ~RTC_DR_WDU) | ((val<<13) & RTC_DR_WDU); }
inline void rtc_dr_set_mu(struct RTC_Type* p, uint32_t val) { p->DR = (p->DR & ~RTC_DR_MU) | ((val<<8) & RTC_DR_MU); }
inline void rtc_dr_set_dt(struct RTC_Type* p, uint32_t val) { p->DR = (p->DR & ~RTC_DR_DT) | ((val<<4) & RTC_DR_DT); }
inline void rtc_dr_set_du(struct RTC_Type* p, uint32_t val) { p->DR = (p->DR & ~RTC_DR_DU) | ((val<<0) & RTC_DR_DU); }
inline uint32_t rtc_dr_get_yt(struct RTC_Type* p) { return (p->DR & RTC_DR_YT) >> 20 ; }
inline uint32_t rtc_dr_get_yu(struct RTC_Type* p) { return (p->DR & RTC_DR_YU) >> 16 ; }
inline uint32_t rtc_dr_get_wdu(struct RTC_Type* p) { return (p->DR & RTC_DR_WDU) >> 13 ; }
inline uint32_t rtc_dr_get_mu(struct RTC_Type* p) { return (p->DR & RTC_DR_MU) >> 8 ; }
inline uint32_t rtc_dr_get_dt(struct RTC_Type* p) { return (p->DR & RTC_DR_DT) >> 4 ; }
inline uint32_t rtc_dr_get_du(struct RTC_Type* p) { return (p->DR & RTC_DR_DU) >> 0 ; }

// RTC->CR control register
enum {
	RTC_CR_ITSE = 1UL<<24, // timestamp on internal event enable
	RTC_CR_COE = 1UL<<23, // Calibration output enable
	RTC_CR_OSEL = ((1UL<<2)-1) << 21, // Output selection
	RTC_CR_POL = 1UL<<20, // Output polarity
	RTC_CR_COSEL = 1UL<<19, // Calibration output selection
	RTC_CR_BKP = 1UL<<18, // Backup
	RTC_CR_SUB1H = 1UL<<17, // Subtract 1 hour (winter time change)
	RTC_CR_ADD1H = 1UL<<16, // Add 1 hour (summer time change)
	RTC_CR_TSIE = 1UL<<15, // Time-stamp interrupt enable
	RTC_CR_WUTIE = 1UL<<14, // Wakeup timer interrupt enable
	RTC_CR_ALRBIE = 1UL<<13, // Alarm B interrupt enable
	RTC_CR_ALRAIE = 1UL<<12, // Alarm A interrupt enable
	RTC_CR_TSE = 1UL<<11, // Time stamp enable
	RTC_CR_WUTE = 1UL<<10, // Wakeup timer enable
	RTC_CR_ALRBE = 1UL<<9, // Alarm B enable
	RTC_CR_ALRAE = 1UL<<8, // Alarm A enable
	RTC_CR_FMT = 1UL<<6, // Hour format
	RTC_CR_BYPSHAD = 1UL<<5, // Bypass the shadow registers
	RTC_CR_REFCKON = 1UL<<4, // Reference clock detection enable (50 or 60 Hz)
	RTC_CR_TSEDGE = 1UL<<3, // Time-stamp event active edge
	RTC_CR_WCKSEL = ((1UL<<3)-1) << 0, // Wakeup clock selection		
};
inline void rtc_cr_set_osel(struct RTC_Type* p, uint32_t val) { p->CR = (p->CR & ~RTC_CR_OSEL) | ((val<<21) & RTC_CR_OSEL); }
inline void rtc_cr_set_wcksel(struct RTC_Type* p, uint32_t val) { p->CR = (p->CR & ~RTC_CR_WCKSEL) | ((val<<0) & RTC_CR_WCKSEL); }
inline uint32_t rtc_cr_get_osel(struct RTC_Type* p) { return (p->CR & RTC_CR_OSEL) >> 21 ; }
inline uint32_t rtc_cr_get_wcksel(struct RTC_Type* p) { return (p->CR & RTC_CR_WCKSEL) >> 0 ; }

// RTC->ISR initialization and status register
enum {
	RTC_ISR_RECALPF = 1UL<<16, // Recalibration pending Flag
	RTC_ISR_TAMP3F = 1UL<<15, // RTC_TAMP3 detection flag
	RTC_ISR_TAMP2F = 1UL<<14, // RTC_TAMP2 detection flag
	RTC_ISR_TAMP1F = 1UL<<13, // Tamper detection flag
	RTC_ISR_TSOVF = 1UL<<12, // Time-stamp overflow flag
	RTC_ISR_TSF = 1UL<<11, // Time-stamp flag
	RTC_ISR_WUTF = 1UL<<10, // Wakeup timer flag
	RTC_ISR_ALRBF = 1UL<<9, // Alarm B flag
	RTC_ISR_ALRAF = 1UL<<8, // Alarm A flag
	RTC_ISR_INIT = 1UL<<7, // Initialization mode
	RTC_ISR_INITF = 1UL<<6, // Initialization flag
	RTC_ISR_RSF = 1UL<<5, // Registers synchronization flag
	RTC_ISR_INITS = 1UL<<4, // Initialization status flag
	RTC_ISR_SHPF = 1UL<<3, // Shift operation pending
	RTC_ISR_WUTWF = 1UL<<2, // Wakeup timer write flag
	RTC_ISR_ALRBWF = 1UL<<1, // Alarm B write flag
	RTC_ISR_ALRAWF = 1UL<<0, // Alarm A write flag		
};

// RTC->PRER prescaler register
enum {
	RTC_PRER_PREDIV_A = ((1UL<<7)-1) << 16, // Asynchronous prescaler factor
	RTC_PRER_PREDIV_S = ((1UL<<15)-1) << 0, // Synchronous prescaler factor		
};
inline void rtc_prer_set_prediv_a(struct RTC_Type* p, uint32_t val) { p->PRER = (p->PRER & ~RTC_PRER_PREDIV_A) | ((val<<16) & RTC_PRER_PREDIV_A); }
inline void rtc_prer_set_prediv_s(struct RTC_Type* p, uint32_t val) { p->PRER = (p->PRER & ~RTC_PRER_PREDIV_S) | ((val<<0) & RTC_PRER_PREDIV_S); }
inline uint32_t rtc_prer_get_prediv_a(struct RTC_Type* p) { return (p->PRER & RTC_PRER_PREDIV_A) >> 16 ; }
inline uint32_t rtc_prer_get_prediv_s(struct RTC_Type* p) { return (p->PRER & RTC_PRER_PREDIV_S) >> 0 ; }

// RTC->ALRMAR alarm A register
enum {
	RTC_ALRMAR_MSK4 = 1UL<<31, // Alarm A date mask
	RTC_ALRMAR_WDSEL = 1UL<<30, // Week day selection
	RTC_ALRMAR_DT = ((1UL<<2)-1) << 28, // Date tens in BCD format
	RTC_ALRMAR_DU = ((1UL<<4)-1) << 24, // Date units or day in BCD format
	RTC_ALRMAR_MSK3 = 1UL<<23, // Alarm A hours mask
	RTC_ALRMAR_PM = 1UL<<22, // AM/PM notation
	RTC_ALRMAR_HT = ((1UL<<2)-1) << 20, // Hour tens in BCD format
	RTC_ALRMAR_HU = ((1UL<<4)-1) << 16, // Hour units in BCD format
	RTC_ALRMAR_MSK2 = 1UL<<15, // Alarm A minutes mask
	RTC_ALRMAR_MNT = ((1UL<<3)-1) << 12, // Minute tens in BCD format
	RTC_ALRMAR_MNU = ((1UL<<4)-1) << 8, // Minute units in BCD format
	RTC_ALRMAR_MSK1 = 1UL<<7, // Alarm A seconds mask
	RTC_ALRMAR_ST = ((1UL<<3)-1) << 4, // Second tens in BCD format
	RTC_ALRMAR_SU = ((1UL<<4)-1) << 0, // Second units in BCD format		
};
inline void rtc_alrmar_set_dt(struct RTC_Type* p, uint32_t val) { p->ALRMAR = (p->ALRMAR & ~RTC_ALRMAR_DT) | ((val<<28) & RTC_ALRMAR_DT); }
inline void rtc_alrmar_set_du(struct RTC_Type* p, uint32_t val) { p->ALRMAR = (p->ALRMAR & ~RTC_ALRMAR_DU) | ((val<<24) & RTC_ALRMAR_DU); }
inline void rtc_alrmar_set_ht(struct RTC_Type* p, uint32_t val) { p->ALRMAR = (p->ALRMAR & ~RTC_ALRMAR_HT) | ((val<<20) & RTC_ALRMAR_HT); }
inline void rtc_alrmar_set_hu(struct RTC_Type* p, uint32_t val) { p->ALRMAR = (p->ALRMAR & ~RTC_ALRMAR_HU) | ((val<<16) & RTC_ALRMAR_HU); }
inline void rtc_alrmar_set_mnt(struct RTC_Type* p, uint32_t val) { p->ALRMAR = (p->ALRMAR & ~RTC_ALRMAR_MNT) | ((val<<12) & RTC_ALRMAR_MNT); }
inline void rtc_alrmar_set_mnu(struct RTC_Type* p, uint32_t val) { p->ALRMAR = (p->ALRMAR & ~RTC_ALRMAR_MNU) | ((val<<8) & RTC_ALRMAR_MNU); }
inline void rtc_alrmar_set_st(struct RTC_Type* p, uint32_t val) { p->ALRMAR = (p->ALRMAR & ~RTC_ALRMAR_ST) | ((val<<4) & RTC_ALRMAR_ST); }
inline void rtc_alrmar_set_su(struct RTC_Type* p, uint32_t val) { p->ALRMAR = (p->ALRMAR & ~RTC_ALRMAR_SU) | ((val<<0) & RTC_ALRMAR_SU); }
inline uint32_t rtc_alrmar_get_dt(struct RTC_Type* p) { return (p->ALRMAR & RTC_ALRMAR_DT) >> 28 ; }
inline uint32_t rtc_alrmar_get_du(struct RTC_Type* p) { return (p->ALRMAR & RTC_ALRMAR_DU) >> 24 ; }
inline uint32_t rtc_alrmar_get_ht(struct RTC_Type* p) { return (p->ALRMAR & RTC_ALRMAR_HT) >> 20 ; }
inline uint32_t rtc_alrmar_get_hu(struct RTC_Type* p) { return (p->ALRMAR & RTC_ALRMAR_HU) >> 16 ; }
inline uint32_t rtc_alrmar_get_mnt(struct RTC_Type* p) { return (p->ALRMAR & RTC_ALRMAR_MNT) >> 12 ; }
inline uint32_t rtc_alrmar_get_mnu(struct RTC_Type* p) { return (p->ALRMAR & RTC_ALRMAR_MNU) >> 8 ; }
inline uint32_t rtc_alrmar_get_st(struct RTC_Type* p) { return (p->ALRMAR & RTC_ALRMAR_ST) >> 4 ; }
inline uint32_t rtc_alrmar_get_su(struct RTC_Type* p) { return (p->ALRMAR & RTC_ALRMAR_SU) >> 0 ; }

// RTC->ALRMBR alarm B register
enum {
	RTC_ALRMBR_MSK4 = 1UL<<31, // Alarm B date mask
	RTC_ALRMBR_WDSEL = 1UL<<30, // Week day selection
	RTC_ALRMBR_DT = ((1UL<<2)-1) << 28, // Date tens in BCD format
	RTC_ALRMBR_DU = ((1UL<<4)-1) << 24, // Date units or day in BCD format
	RTC_ALRMBR_MSK3 = 1UL<<23, // Alarm B hours mask
	RTC_ALRMBR_PM = 1UL<<22, // AM/PM notation
	RTC_ALRMBR_HT = ((1UL<<2)-1) << 20, // Hour tens in BCD format
	RTC_ALRMBR_HU = ((1UL<<4)-1) << 16, // Hour units in BCD format
	RTC_ALRMBR_MSK2 = 1UL<<15, // Alarm B minutes mask
	RTC_ALRMBR_MNT = ((1UL<<3)-1) << 12, // Minute tens in BCD format
	RTC_ALRMBR_MNU = ((1UL<<4)-1) << 8, // Minute units in BCD format
	RTC_ALRMBR_MSK1 = 1UL<<7, // Alarm B seconds mask
	RTC_ALRMBR_ST = ((1UL<<3)-1) << 4, // Second tens in BCD format
	RTC_ALRMBR_SU = ((1UL<<4)-1) << 0, // Second units in BCD format		
};
inline void rtc_alrmbr_set_dt(struct RTC_Type* p, uint32_t val) { p->ALRMBR = (p->ALRMBR & ~RTC_ALRMBR_DT) | ((val<<28) & RTC_ALRMBR_DT); }
inline void rtc_alrmbr_set_du(struct RTC_Type* p, uint32_t val) { p->ALRMBR = (p->ALRMBR & ~RTC_ALRMBR_DU) | ((val<<24) & RTC_ALRMBR_DU); }
inline void rtc_alrmbr_set_ht(struct RTC_Type* p, uint32_t val) { p->ALRMBR = (p->ALRMBR & ~RTC_ALRMBR_HT) | ((val<<20) & RTC_ALRMBR_HT); }
inline void rtc_alrmbr_set_hu(struct RTC_Type* p, uint32_t val) { p->ALRMBR = (p->ALRMBR & ~RTC_ALRMBR_HU) | ((val<<16) & RTC_ALRMBR_HU); }
inline void rtc_alrmbr_set_mnt(struct RTC_Type* p, uint32_t val) { p->ALRMBR = (p->ALRMBR & ~RTC_ALRMBR_MNT) | ((val<<12) & RTC_ALRMBR_MNT); }
inline void rtc_alrmbr_set_mnu(struct RTC_Type* p, uint32_t val) { p->ALRMBR = (p->ALRMBR & ~RTC_ALRMBR_MNU) | ((val<<8) & RTC_ALRMBR_MNU); }
inline void rtc_alrmbr_set_st(struct RTC_Type* p, uint32_t val) { p->ALRMBR = (p->ALRMBR & ~RTC_ALRMBR_ST) | ((val<<4) & RTC_ALRMBR_ST); }
inline void rtc_alrmbr_set_su(struct RTC_Type* p, uint32_t val) { p->ALRMBR = (p->ALRMBR & ~RTC_ALRMBR_SU) | ((val<<0) & RTC_ALRMBR_SU); }
inline uint32_t rtc_alrmbr_get_dt(struct RTC_Type* p) { return (p->ALRMBR & RTC_ALRMBR_DT) >> 28 ; }
inline uint32_t rtc_alrmbr_get_du(struct RTC_Type* p) { return (p->ALRMBR & RTC_ALRMBR_DU) >> 24 ; }
inline uint32_t rtc_alrmbr_get_ht(struct RTC_Type* p) { return (p->ALRMBR & RTC_ALRMBR_HT) >> 20 ; }
inline uint32_t rtc_alrmbr_get_hu(struct RTC_Type* p) { return (p->ALRMBR & RTC_ALRMBR_HU) >> 16 ; }
inline uint32_t rtc_alrmbr_get_mnt(struct RTC_Type* p) { return (p->ALRMBR & RTC_ALRMBR_MNT) >> 12 ; }
inline uint32_t rtc_alrmbr_get_mnu(struct RTC_Type* p) { return (p->ALRMBR & RTC_ALRMBR_MNU) >> 8 ; }
inline uint32_t rtc_alrmbr_get_st(struct RTC_Type* p) { return (p->ALRMBR & RTC_ALRMBR_ST) >> 4 ; }
inline uint32_t rtc_alrmbr_get_su(struct RTC_Type* p) { return (p->ALRMBR & RTC_ALRMBR_SU) >> 0 ; }

// RTC->SHIFTR shift control register
enum {
	RTC_SHIFTR_ADD1S = 1UL<<31, // Add one second
	RTC_SHIFTR_SUBFS = ((1UL<<15)-1) << 0, // Subtract a fraction of a second		
};
inline void rtc_shiftr_set_subfs(struct RTC_Type* p, uint32_t val) { p->SHIFTR = (p->SHIFTR & ~RTC_SHIFTR_SUBFS) | ((val<<0) & RTC_SHIFTR_SUBFS); }
inline uint32_t rtc_shiftr_get_subfs(struct RTC_Type* p) { return (p->SHIFTR & RTC_SHIFTR_SUBFS) >> 0 ; }

// RTC->TSTR time stamp time register
enum {
	RTC_TSTR_PM = 1UL<<22, // AM/PM notation
	RTC_TSTR_HT = ((1UL<<2)-1) << 20, // Hour tens in BCD format
	RTC_TSTR_HU = ((1UL<<4)-1) << 16, // Hour units in BCD format
	RTC_TSTR_MNT = ((1UL<<3)-1) << 12, // Minute tens in BCD format
	RTC_TSTR_MNU = ((1UL<<4)-1) << 8, // Minute units in BCD format
	RTC_TSTR_ST = ((1UL<<3)-1) << 4, // Second tens in BCD format
	RTC_TSTR_SU = ((1UL<<4)-1) << 0, // Second units in BCD format		
};
inline uint32_t rtc_tstr_get_ht(struct RTC_Type* p) { return (p->TSTR & RTC_TSTR_HT) >> 20 ; }
inline uint32_t rtc_tstr_get_hu(struct RTC_Type* p) { return (p->TSTR & RTC_TSTR_HU) >> 16 ; }
inline uint32_t rtc_tstr_get_mnt(struct RTC_Type* p) { return (p->TSTR & RTC_TSTR_MNT) >> 12 ; }
inline uint32_t rtc_tstr_get_mnu(struct RTC_Type* p) { return (p->TSTR & RTC_TSTR_MNU) >> 8 ; }
inline uint32_t rtc_tstr_get_st(struct RTC_Type* p) { return (p->TSTR & RTC_TSTR_ST) >> 4 ; }
inline uint32_t rtc_tstr_get_su(struct RTC_Type* p) { return (p->TSTR & RTC_TSTR_SU) >> 0 ; }

// RTC->TSDR time stamp date register
enum {
	RTC_TSDR_WDU = ((1UL<<3)-1) << 13, // Week day units
	RTC_TSDR_MT = 1UL<<12, // Month tens in BCD format
	RTC_TSDR_MU = ((1UL<<4)-1) << 8, // Month units in BCD format
	RTC_TSDR_DT = ((1UL<<2)-1) << 4, // Date tens in BCD format
	RTC_TSDR_DU = ((1UL<<4)-1) << 0, // Date units in BCD format		
};
inline uint32_t rtc_tsdr_get_wdu(struct RTC_Type* p) { return (p->TSDR & RTC_TSDR_WDU) >> 13 ; }
inline uint32_t rtc_tsdr_get_mu(struct RTC_Type* p) { return (p->TSDR & RTC_TSDR_MU) >> 8 ; }
inline uint32_t rtc_tsdr_get_dt(struct RTC_Type* p) { return (p->TSDR & RTC_TSDR_DT) >> 4 ; }
inline uint32_t rtc_tsdr_get_du(struct RTC_Type* p) { return (p->TSDR & RTC_TSDR_DU) >> 0 ; }

// RTC->CALR calibration register
enum {
	RTC_CALR_CALP = 1UL<<15, // Increase frequency of RTC by 488.5 ppm
	RTC_CALR_CALW8 = 1UL<<14, // Use an 8-second calibration cycle period
	RTC_CALR_CALW16 = 1UL<<13, // Use a 16-second calibration cycle period
	RTC_CALR_CALM = ((1UL<<9)-1) << 0, // Calibration minus		
};
inline void rtc_calr_set_calm(struct RTC_Type* p, uint32_t val) { p->CALR = (p->CALR & ~RTC_CALR_CALM) | ((val<<0) & RTC_CALR_CALM); }
inline uint32_t rtc_calr_get_calm(struct RTC_Type* p) { return (p->CALR & RTC_CALR_CALM) >> 0 ; }

// RTC->TAMPCR tamper configuration register
enum {
	RTC_TAMPCR_TAMP3MF = 1UL<<24, // Tamper 3 mask flag
	RTC_TAMPCR_TAMP3NOERASE = 1UL<<23, // Tamper 3 no erase
	RTC_TAMPCR_TAMP3IE = 1UL<<22, // Tamper 3 interrupt enable
	RTC_TAMPCR_TAMP2MF = 1UL<<21, // Tamper 2 mask flag
	RTC_TAMPCR_TAMP2NOERASE = 1UL<<20, // Tamper 2 no erase
	RTC_TAMPCR_TAMP2IE = 1UL<<19, // Tamper 2 interrupt enable
	RTC_TAMPCR_TAMP1MF = 1UL<<18, // Tamper 1 mask flag
	RTC_TAMPCR_TAMP1NOERASE = 1UL<<17, // Tamper 1 no erase
	RTC_TAMPCR_TAMP1IE = 1UL<<16, // Tamper 1 interrupt enable
	RTC_TAMPCR_TAMPPUDIS = 1UL<<15, // TAMPER pull-up disable
	RTC_TAMPCR_TAMPPRCH = ((1UL<<2)-1) << 13, // Tamper precharge duration
	RTC_TAMPCR_TAMPFLT = ((1UL<<2)-1) << 11, // Tamper filter count
	RTC_TAMPCR_TAMPFREQ = ((1UL<<3)-1) << 8, // Tamper sampling frequency
	RTC_TAMPCR_TAMPTS = 1UL<<7, // Activate timestamp on tamper detection event
	RTC_TAMPCR_TAMP3TRG = 1UL<<6, // Active level for tamper 3
	RTC_TAMPCR_TAMP3E = 1UL<<5, // Tamper 3 detection enable
	RTC_TAMPCR_TAMP2TRG = 1UL<<4, // Active level for tamper 2
	RTC_TAMPCR_TAMP2E = 1UL<<3, // Tamper 2 detection enable
	RTC_TAMPCR_TAMPIE = 1UL<<2, // Tamper interrupt enable
	RTC_TAMPCR_TAMP1TRG = 1UL<<1, // Active level for tamper 1
	RTC_TAMPCR_TAMP1E = 1UL<<0, // Tamper 1 detection enable		
};
inline void rtc_tampcr_set_tampprch(struct RTC_Type* p, uint32_t val) { p->TAMPCR = (p->TAMPCR & ~RTC_TAMPCR_TAMPPRCH) | ((val<<13) & RTC_TAMPCR_TAMPPRCH); }
inline void rtc_tampcr_set_tampflt(struct RTC_Type* p, uint32_t val) { p->TAMPCR = (p->TAMPCR & ~RTC_TAMPCR_TAMPFLT) | ((val<<11) & RTC_TAMPCR_TAMPFLT); }
inline void rtc_tampcr_set_tampfreq(struct RTC_Type* p, uint32_t val) { p->TAMPCR = (p->TAMPCR & ~RTC_TAMPCR_TAMPFREQ) | ((val<<8) & RTC_TAMPCR_TAMPFREQ); }
inline uint32_t rtc_tampcr_get_tampprch(struct RTC_Type* p) { return (p->TAMPCR & RTC_TAMPCR_TAMPPRCH) >> 13 ; }
inline uint32_t rtc_tampcr_get_tampflt(struct RTC_Type* p) { return (p->TAMPCR & RTC_TAMPCR_TAMPFLT) >> 11 ; }
inline uint32_t rtc_tampcr_get_tampfreq(struct RTC_Type* p) { return (p->TAMPCR & RTC_TAMPCR_TAMPFREQ) >> 8 ; }

// RTC->ALRMASSR alarm A sub second register
enum {
	RTC_ALRMASSR_MASKSS = ((1UL<<4)-1) << 24, // Mask the most-significant bits starting at this bit
	RTC_ALRMASSR_SS = ((1UL<<15)-1) << 0, // Sub seconds value		
};
inline void rtc_alrmassr_set_maskss(struct RTC_Type* p, uint32_t val) { p->ALRMASSR = (p->ALRMASSR & ~RTC_ALRMASSR_MASKSS) | ((val<<24) & RTC_ALRMASSR_MASKSS); }
inline void rtc_alrmassr_set_ss(struct RTC_Type* p, uint32_t val) { p->ALRMASSR = (p->ALRMASSR & ~RTC_ALRMASSR_SS) | ((val<<0) & RTC_ALRMASSR_SS); }
inline uint32_t rtc_alrmassr_get_maskss(struct RTC_Type* p) { return (p->ALRMASSR & RTC_ALRMASSR_MASKSS) >> 24 ; }
inline uint32_t rtc_alrmassr_get_ss(struct RTC_Type* p) { return (p->ALRMASSR & RTC_ALRMASSR_SS) >> 0 ; }

// RTC->ALRMBSSR alarm B sub second register
enum {
	RTC_ALRMBSSR_MASKSS = ((1UL<<4)-1) << 24, // Mask the most-significant bits starting at this bit
	RTC_ALRMBSSR_SS = ((1UL<<15)-1) << 0, // Sub seconds value		
};
inline void rtc_alrmbssr_set_maskss(struct RTC_Type* p, uint32_t val) { p->ALRMBSSR = (p->ALRMBSSR & ~RTC_ALRMBSSR_MASKSS) | ((val<<24) & RTC_ALRMBSSR_MASKSS); }
inline void rtc_alrmbssr_set_ss(struct RTC_Type* p, uint32_t val) { p->ALRMBSSR = (p->ALRMBSSR & ~RTC_ALRMBSSR_SS) | ((val<<0) & RTC_ALRMBSSR_SS); }
inline uint32_t rtc_alrmbssr_get_maskss(struct RTC_Type* p) { return (p->ALRMBSSR & RTC_ALRMBSSR_MASKSS) >> 24 ; }
inline uint32_t rtc_alrmbssr_get_ss(struct RTC_Type* p) { return (p->ALRMBSSR & RTC_ALRMBSSR_SS) >> 0 ; }

// RTC->OR option register
enum {
	RTC_OR_RTC_OUT_RMP = 1UL<<1, // RTC_OUT remap
	RTC_OR_RTC_ALARM_TYPE = 1UL<<0, // RTC_ALARM on PC13 output type		
};

/* Serial audio interface */
struct SAI1_Type {
	 uint8_t RESERVED0[4]; // @0 
	__IO uint32_t ACR1; // @4 AConfiguration register 1
	__IO uint16_t ACR2; // @8 AConfiguration register 2
	 uint8_t RESERVED1[2]; // @10 
	__IO uint32_t AFRCR; // @12 AFRCR
	__IO uint32_t ASLOTR; // @16 ASlot register
	__IO uint8_t AIM; // @20 AInterrupt mask register2
	 uint8_t RESERVED2[3]; // @21 
	__IO uint32_t ASR; // @24 AStatus register
	__IO uint8_t ACLRFR; // @28 AClear flag register
	 uint8_t RESERVED3[3]; // @29 
	__IO uint32_t ADR; // @32 AData register
	__IO uint32_t BCR1; // @36 BConfiguration register 1
	__IO uint16_t BCR2; // @40 BConfiguration register 2
	 uint8_t RESERVED4[2]; // @42 
	__IO uint32_t BFRCR; // @44 BFRCR
	__IO uint32_t BSLOTR; // @48 BSlot register
	__IO uint8_t BIM; // @52 BInterrupt mask register2
	 uint8_t RESERVED5[3]; // @53 
	__I uint32_t BSR; // @56 BStatus register
	__O uint8_t BCLRFR; // @60 BClear flag register
	 uint8_t RESERVED6[3]; // @61 
	__IO uint32_t BDR; // @64 BData register
};

// SAI1->ACR1 AConfiguration register 1
enum {
	SAI1_ACR1_MCJDIV = ((1UL<<4)-1) << 20, // Master clock divider
	SAI1_ACR1_NODIV = 1UL<<19, // No divider
	SAI1_ACR1_DMAEN = 1UL<<17, // DMA enable
	SAI1_ACR1_SAIAEN = 1UL<<16, // Audio block A enable
	SAI1_ACR1_OUTDRI = 1UL<<13, // Output drive
	SAI1_ACR1_MONO = 1UL<<12, // Mono mode
	SAI1_ACR1_SYNCEN = ((1UL<<2)-1) << 10, // Synchronization enable
	SAI1_ACR1_CKSTR = 1UL<<9, // Clock strobing edge
	SAI1_ACR1_LSBFIRST = 1UL<<8, // Least significant bit first
	SAI1_ACR1_DS = ((1UL<<3)-1) << 5, // Data size
	SAI1_ACR1_PRTCFG = ((1UL<<2)-1) << 2, // Protocol configuration
	SAI1_ACR1_MODE = ((1UL<<2)-1) << 0, // Audio block mode		
};
inline void sai1_acr1_set_mcjdiv(struct SAI1_Type* p, uint32_t val) { p->ACR1 = (p->ACR1 & ~SAI1_ACR1_MCJDIV) | ((val<<20) & SAI1_ACR1_MCJDIV); }
inline void sai1_acr1_set_syncen(struct SAI1_Type* p, uint32_t val) { p->ACR1 = (p->ACR1 & ~SAI1_ACR1_SYNCEN) | ((val<<10) & SAI1_ACR1_SYNCEN); }
inline void sai1_acr1_set_ds(struct SAI1_Type* p, uint32_t val) { p->ACR1 = (p->ACR1 & ~SAI1_ACR1_DS) | ((val<<5) & SAI1_ACR1_DS); }
inline void sai1_acr1_set_prtcfg(struct SAI1_Type* p, uint32_t val) { p->ACR1 = (p->ACR1 & ~SAI1_ACR1_PRTCFG) | ((val<<2) & SAI1_ACR1_PRTCFG); }
inline void sai1_acr1_set_mode(struct SAI1_Type* p, uint32_t val) { p->ACR1 = (p->ACR1 & ~SAI1_ACR1_MODE) | ((val<<0) & SAI1_ACR1_MODE); }
inline uint32_t sai1_acr1_get_mcjdiv(struct SAI1_Type* p) { return (p->ACR1 & SAI1_ACR1_MCJDIV) >> 20 ; }
inline uint32_t sai1_acr1_get_syncen(struct SAI1_Type* p) { return (p->ACR1 & SAI1_ACR1_SYNCEN) >> 10 ; }
inline uint32_t sai1_acr1_get_ds(struct SAI1_Type* p) { return (p->ACR1 & SAI1_ACR1_DS) >> 5 ; }
inline uint32_t sai1_acr1_get_prtcfg(struct SAI1_Type* p) { return (p->ACR1 & SAI1_ACR1_PRTCFG) >> 2 ; }
inline uint32_t sai1_acr1_get_mode(struct SAI1_Type* p) { return (p->ACR1 & SAI1_ACR1_MODE) >> 0 ; }

// SAI1->ACR2 AConfiguration register 2
enum {
	SAI1_ACR2_COMP = ((1UL<<2)-1) << 14, // Companding mode
	SAI1_ACR2_CPL = 1UL<<13, // Complement bit
	SAI1_ACR2_MUTECN = ((1UL<<6)-1) << 7, // Mute counter
	SAI1_ACR2_MUTEVAL = 1UL<<6, // Mute value
	SAI1_ACR2_MUTE = 1UL<<5, // Mute
	SAI1_ACR2_TRIS = 1UL<<4, // Tristate management on data line
	SAI1_ACR2_FFLUS = 1UL<<3, // FIFO flush
	SAI1_ACR2_FTH = ((1UL<<3)-1) << 0, // FIFO threshold		
};
inline void sai1_acr2_set_comp(struct SAI1_Type* p, uint32_t val) { p->ACR2 = (p->ACR2 & ~SAI1_ACR2_COMP) | ((val<<14) & SAI1_ACR2_COMP); }
inline void sai1_acr2_set_mutecn(struct SAI1_Type* p, uint32_t val) { p->ACR2 = (p->ACR2 & ~SAI1_ACR2_MUTECN) | ((val<<7) & SAI1_ACR2_MUTECN); }
inline void sai1_acr2_set_fth(struct SAI1_Type* p, uint32_t val) { p->ACR2 = (p->ACR2 & ~SAI1_ACR2_FTH) | ((val<<0) & SAI1_ACR2_FTH); }
inline uint32_t sai1_acr2_get_comp(struct SAI1_Type* p) { return (p->ACR2 & SAI1_ACR2_COMP) >> 14 ; }
inline uint32_t sai1_acr2_get_mutecn(struct SAI1_Type* p) { return (p->ACR2 & SAI1_ACR2_MUTECN) >> 7 ; }
inline uint32_t sai1_acr2_get_fth(struct SAI1_Type* p) { return (p->ACR2 & SAI1_ACR2_FTH) >> 0 ; }

// SAI1->AFRCR AFRCR
enum {
	SAI1_AFRCR_FSOFF = 1UL<<18, // Frame synchronization offset
	SAI1_AFRCR_FSPOL = 1UL<<17, // Frame synchronization polarity
	SAI1_AFRCR_FSDEF = 1UL<<16, // Frame synchronization definition
	SAI1_AFRCR_FSALL = ((1UL<<7)-1) << 8, // Frame synchronization active level length
	SAI1_AFRCR_FRL = ((1UL<<8)-1) << 0, // Frame length		
};
inline void sai1_afrcr_set_fsall(struct SAI1_Type* p, uint32_t val) { p->AFRCR = (p->AFRCR & ~SAI1_AFRCR_FSALL) | ((val<<8) & SAI1_AFRCR_FSALL); }
inline void sai1_afrcr_set_frl(struct SAI1_Type* p, uint32_t val) { p->AFRCR = (p->AFRCR & ~SAI1_AFRCR_FRL) | ((val<<0) & SAI1_AFRCR_FRL); }
inline uint32_t sai1_afrcr_get_fsall(struct SAI1_Type* p) { return (p->AFRCR & SAI1_AFRCR_FSALL) >> 8 ; }
inline uint32_t sai1_afrcr_get_frl(struct SAI1_Type* p) { return (p->AFRCR & SAI1_AFRCR_FRL) >> 0 ; }

// SAI1->ASLOTR ASlot register
enum {
	SAI1_ASLOTR_SLOTEN = ((1UL<<16)-1) << 16, // Slot enable
	SAI1_ASLOTR_NBSLOT = ((1UL<<4)-1) << 8, // Number of slots in an audio frame
	SAI1_ASLOTR_SLOTSZ = ((1UL<<2)-1) << 6, // Slot size
	SAI1_ASLOTR_FBOFF = ((1UL<<5)-1) << 0, // First bit offset		
};
inline void sai1_aslotr_set_sloten(struct SAI1_Type* p, uint32_t val) { p->ASLOTR = (p->ASLOTR & ~SAI1_ASLOTR_SLOTEN) | ((val<<16) & SAI1_ASLOTR_SLOTEN); }
inline void sai1_aslotr_set_nbslot(struct SAI1_Type* p, uint32_t val) { p->ASLOTR = (p->ASLOTR & ~SAI1_ASLOTR_NBSLOT) | ((val<<8) & SAI1_ASLOTR_NBSLOT); }
inline void sai1_aslotr_set_slotsz(struct SAI1_Type* p, uint32_t val) { p->ASLOTR = (p->ASLOTR & ~SAI1_ASLOTR_SLOTSZ) | ((val<<6) & SAI1_ASLOTR_SLOTSZ); }
inline void sai1_aslotr_set_fboff(struct SAI1_Type* p, uint32_t val) { p->ASLOTR = (p->ASLOTR & ~SAI1_ASLOTR_FBOFF) | ((val<<0) & SAI1_ASLOTR_FBOFF); }
inline uint32_t sai1_aslotr_get_sloten(struct SAI1_Type* p) { return (p->ASLOTR & SAI1_ASLOTR_SLOTEN) >> 16 ; }
inline uint32_t sai1_aslotr_get_nbslot(struct SAI1_Type* p) { return (p->ASLOTR & SAI1_ASLOTR_NBSLOT) >> 8 ; }
inline uint32_t sai1_aslotr_get_slotsz(struct SAI1_Type* p) { return (p->ASLOTR & SAI1_ASLOTR_SLOTSZ) >> 6 ; }
inline uint32_t sai1_aslotr_get_fboff(struct SAI1_Type* p) { return (p->ASLOTR & SAI1_ASLOTR_FBOFF) >> 0 ; }

// SAI1->AIM AInterrupt mask register2
enum {
	SAI1_AIM_LFSDET = 1UL<<6, // Late frame synchronization detection interrupt enable
	SAI1_AIM_AFSDETIE = 1UL<<5, // Anticipated frame synchronization detection interrupt enable
	SAI1_AIM_CNRDYIE = 1UL<<4, // Codec not ready interrupt enable
	SAI1_AIM_FREQIE = 1UL<<3, // FIFO request interrupt enable
	SAI1_AIM_WCKCFG = 1UL<<2, // Wrong clock configuration interrupt enable
	SAI1_AIM_MUTEDET = 1UL<<1, // Mute detection interrupt enable
	SAI1_AIM_OVRUDRIE = 1UL<<0, // Overrun/underrun interrupt enable		
};

// SAI1->ASR AStatus register
enum {
	SAI1_ASR_FLVL = ((1UL<<3)-1) << 16, // FIFO level threshold
	SAI1_ASR_LFSDET = 1UL<<6, // Late frame synchronization detection
	SAI1_ASR_AFSDET = 1UL<<5, // Anticipated frame synchronization detection
	SAI1_ASR_CNRDY = 1UL<<4, // Codec not ready
	SAI1_ASR_FREQ = 1UL<<3, // FIFO request
	SAI1_ASR_WCKCFG = 1UL<<2, // Wrong clock configuration flag. This bit is read only
	SAI1_ASR_MUTEDET = 1UL<<1, // Mute detection
	SAI1_ASR_OVRUDR = 1UL<<0, // Overrun / underrun		
};
inline void sai1_asr_set_flvl(struct SAI1_Type* p, uint32_t val) { p->ASR = (p->ASR & ~SAI1_ASR_FLVL) | ((val<<16) & SAI1_ASR_FLVL); }
inline uint32_t sai1_asr_get_flvl(struct SAI1_Type* p) { return (p->ASR & SAI1_ASR_FLVL) >> 16 ; }

// SAI1->ACLRFR AClear flag register
enum {
	SAI1_ACLRFR_LFSDET = 1UL<<6, // Clear late frame synchronization detection flag
	SAI1_ACLRFR_CAFSDET = 1UL<<5, // Clear anticipated frame synchronization detection flag
	SAI1_ACLRFR_CNRDY = 1UL<<4, // Clear codec not ready flag
	SAI1_ACLRFR_WCKCFG = 1UL<<2, // Clear wrong clock configuration flag
	SAI1_ACLRFR_MUTEDET = 1UL<<1, // Mute detection flag
	SAI1_ACLRFR_OVRUDR = 1UL<<0, // Clear overrun / underrun		
};

// SAI1->BCR1 BConfiguration register 1
enum {
	SAI1_BCR1_MCJDIV = ((1UL<<4)-1) << 20, // Master clock divider
	SAI1_BCR1_NODIV = 1UL<<19, // No divider
	SAI1_BCR1_DMAEN = 1UL<<17, // DMA enable
	SAI1_BCR1_SAIBEN = 1UL<<16, // Audio block B enable
	SAI1_BCR1_OUTDRI = 1UL<<13, // Output drive
	SAI1_BCR1_MONO = 1UL<<12, // Mono mode
	SAI1_BCR1_SYNCEN = ((1UL<<2)-1) << 10, // Synchronization enable
	SAI1_BCR1_CKSTR = 1UL<<9, // Clock strobing edge
	SAI1_BCR1_LSBFIRST = 1UL<<8, // Least significant bit first
	SAI1_BCR1_DS = ((1UL<<3)-1) << 5, // Data size
	SAI1_BCR1_PRTCFG = ((1UL<<2)-1) << 2, // Protocol configuration
	SAI1_BCR1_MODE = ((1UL<<2)-1) << 0, // Audio block mode		
};
inline void sai1_bcr1_set_mcjdiv(struct SAI1_Type* p, uint32_t val) { p->BCR1 = (p->BCR1 & ~SAI1_BCR1_MCJDIV) | ((val<<20) & SAI1_BCR1_MCJDIV); }
inline void sai1_bcr1_set_syncen(struct SAI1_Type* p, uint32_t val) { p->BCR1 = (p->BCR1 & ~SAI1_BCR1_SYNCEN) | ((val<<10) & SAI1_BCR1_SYNCEN); }
inline void sai1_bcr1_set_ds(struct SAI1_Type* p, uint32_t val) { p->BCR1 = (p->BCR1 & ~SAI1_BCR1_DS) | ((val<<5) & SAI1_BCR1_DS); }
inline void sai1_bcr1_set_prtcfg(struct SAI1_Type* p, uint32_t val) { p->BCR1 = (p->BCR1 & ~SAI1_BCR1_PRTCFG) | ((val<<2) & SAI1_BCR1_PRTCFG); }
inline void sai1_bcr1_set_mode(struct SAI1_Type* p, uint32_t val) { p->BCR1 = (p->BCR1 & ~SAI1_BCR1_MODE) | ((val<<0) & SAI1_BCR1_MODE); }
inline uint32_t sai1_bcr1_get_mcjdiv(struct SAI1_Type* p) { return (p->BCR1 & SAI1_BCR1_MCJDIV) >> 20 ; }
inline uint32_t sai1_bcr1_get_syncen(struct SAI1_Type* p) { return (p->BCR1 & SAI1_BCR1_SYNCEN) >> 10 ; }
inline uint32_t sai1_bcr1_get_ds(struct SAI1_Type* p) { return (p->BCR1 & SAI1_BCR1_DS) >> 5 ; }
inline uint32_t sai1_bcr1_get_prtcfg(struct SAI1_Type* p) { return (p->BCR1 & SAI1_BCR1_PRTCFG) >> 2 ; }
inline uint32_t sai1_bcr1_get_mode(struct SAI1_Type* p) { return (p->BCR1 & SAI1_BCR1_MODE) >> 0 ; }

// SAI1->BCR2 BConfiguration register 2
enum {
	SAI1_BCR2_COMP = ((1UL<<2)-1) << 14, // Companding mode
	SAI1_BCR2_CPL = 1UL<<13, // Complement bit
	SAI1_BCR2_MUTECN = ((1UL<<6)-1) << 7, // Mute counter
	SAI1_BCR2_MUTEVAL = 1UL<<6, // Mute value
	SAI1_BCR2_MUTE = 1UL<<5, // Mute
	SAI1_BCR2_TRIS = 1UL<<4, // Tristate management on data line
	SAI1_BCR2_FFLUS = 1UL<<3, // FIFO flush
	SAI1_BCR2_FTH = ((1UL<<3)-1) << 0, // FIFO threshold		
};
inline void sai1_bcr2_set_comp(struct SAI1_Type* p, uint32_t val) { p->BCR2 = (p->BCR2 & ~SAI1_BCR2_COMP) | ((val<<14) & SAI1_BCR2_COMP); }
inline void sai1_bcr2_set_mutecn(struct SAI1_Type* p, uint32_t val) { p->BCR2 = (p->BCR2 & ~SAI1_BCR2_MUTECN) | ((val<<7) & SAI1_BCR2_MUTECN); }
inline void sai1_bcr2_set_fth(struct SAI1_Type* p, uint32_t val) { p->BCR2 = (p->BCR2 & ~SAI1_BCR2_FTH) | ((val<<0) & SAI1_BCR2_FTH); }
inline uint32_t sai1_bcr2_get_comp(struct SAI1_Type* p) { return (p->BCR2 & SAI1_BCR2_COMP) >> 14 ; }
inline uint32_t sai1_bcr2_get_mutecn(struct SAI1_Type* p) { return (p->BCR2 & SAI1_BCR2_MUTECN) >> 7 ; }
inline uint32_t sai1_bcr2_get_fth(struct SAI1_Type* p) { return (p->BCR2 & SAI1_BCR2_FTH) >> 0 ; }

// SAI1->BFRCR BFRCR
enum {
	SAI1_BFRCR_FSOFF = 1UL<<18, // Frame synchronization offset
	SAI1_BFRCR_FSPOL = 1UL<<17, // Frame synchronization polarity
	SAI1_BFRCR_FSDEF = 1UL<<16, // Frame synchronization definition
	SAI1_BFRCR_FSALL = ((1UL<<7)-1) << 8, // Frame synchronization active level length
	SAI1_BFRCR_FRL = ((1UL<<8)-1) << 0, // Frame length		
};
inline void sai1_bfrcr_set_fsall(struct SAI1_Type* p, uint32_t val) { p->BFRCR = (p->BFRCR & ~SAI1_BFRCR_FSALL) | ((val<<8) & SAI1_BFRCR_FSALL); }
inline void sai1_bfrcr_set_frl(struct SAI1_Type* p, uint32_t val) { p->BFRCR = (p->BFRCR & ~SAI1_BFRCR_FRL) | ((val<<0) & SAI1_BFRCR_FRL); }
inline uint32_t sai1_bfrcr_get_fsall(struct SAI1_Type* p) { return (p->BFRCR & SAI1_BFRCR_FSALL) >> 8 ; }
inline uint32_t sai1_bfrcr_get_frl(struct SAI1_Type* p) { return (p->BFRCR & SAI1_BFRCR_FRL) >> 0 ; }

// SAI1->BSLOTR BSlot register
enum {
	SAI1_BSLOTR_SLOTEN = ((1UL<<16)-1) << 16, // Slot enable
	SAI1_BSLOTR_NBSLOT = ((1UL<<4)-1) << 8, // Number of slots in an audio frame
	SAI1_BSLOTR_SLOTSZ = ((1UL<<2)-1) << 6, // Slot size
	SAI1_BSLOTR_FBOFF = ((1UL<<5)-1) << 0, // First bit offset		
};
inline void sai1_bslotr_set_sloten(struct SAI1_Type* p, uint32_t val) { p->BSLOTR = (p->BSLOTR & ~SAI1_BSLOTR_SLOTEN) | ((val<<16) & SAI1_BSLOTR_SLOTEN); }
inline void sai1_bslotr_set_nbslot(struct SAI1_Type* p, uint32_t val) { p->BSLOTR = (p->BSLOTR & ~SAI1_BSLOTR_NBSLOT) | ((val<<8) & SAI1_BSLOTR_NBSLOT); }
inline void sai1_bslotr_set_slotsz(struct SAI1_Type* p, uint32_t val) { p->BSLOTR = (p->BSLOTR & ~SAI1_BSLOTR_SLOTSZ) | ((val<<6) & SAI1_BSLOTR_SLOTSZ); }
inline void sai1_bslotr_set_fboff(struct SAI1_Type* p, uint32_t val) { p->BSLOTR = (p->BSLOTR & ~SAI1_BSLOTR_FBOFF) | ((val<<0) & SAI1_BSLOTR_FBOFF); }
inline uint32_t sai1_bslotr_get_sloten(struct SAI1_Type* p) { return (p->BSLOTR & SAI1_BSLOTR_SLOTEN) >> 16 ; }
inline uint32_t sai1_bslotr_get_nbslot(struct SAI1_Type* p) { return (p->BSLOTR & SAI1_BSLOTR_NBSLOT) >> 8 ; }
inline uint32_t sai1_bslotr_get_slotsz(struct SAI1_Type* p) { return (p->BSLOTR & SAI1_BSLOTR_SLOTSZ) >> 6 ; }
inline uint32_t sai1_bslotr_get_fboff(struct SAI1_Type* p) { return (p->BSLOTR & SAI1_BSLOTR_FBOFF) >> 0 ; }

// SAI1->BIM BInterrupt mask register2
enum {
	SAI1_BIM_LFSDETIE = 1UL<<6, // Late frame synchronization detection interrupt enable
	SAI1_BIM_AFSDETIE = 1UL<<5, // Anticipated frame synchronization detection interrupt enable
	SAI1_BIM_CNRDYIE = 1UL<<4, // Codec not ready interrupt enable
	SAI1_BIM_FREQIE = 1UL<<3, // FIFO request interrupt enable
	SAI1_BIM_WCKCFG = 1UL<<2, // Wrong clock configuration interrupt enable
	SAI1_BIM_MUTEDET = 1UL<<1, // Mute detection interrupt enable
	SAI1_BIM_OVRUDRIE = 1UL<<0, // Overrun/underrun interrupt enable		
};

// SAI1->BSR BStatus register
enum {
	SAI1_BSR_FLVL = ((1UL<<3)-1) << 16, // FIFO level threshold
	SAI1_BSR_LFSDET = 1UL<<6, // Late frame synchronization detection
	SAI1_BSR_AFSDET = 1UL<<5, // Anticipated frame synchronization detection
	SAI1_BSR_CNRDY = 1UL<<4, // Codec not ready
	SAI1_BSR_FREQ = 1UL<<3, // FIFO request
	SAI1_BSR_WCKCFG = 1UL<<2, // Wrong clock configuration flag
	SAI1_BSR_MUTEDET = 1UL<<1, // Mute detection
	SAI1_BSR_OVRUDR = 1UL<<0, // Overrun / underrun		
};
inline uint32_t sai1_bsr_get_flvl(struct SAI1_Type* p) { return (p->BSR & SAI1_BSR_FLVL) >> 16 ; }

// SAI1->BCLRFR BClear flag register
enum {
	SAI1_BCLRFR_LFSDET = 1UL<<6, // Clear late frame synchronization detection flag
	SAI1_BCLRFR_CAFSDET = 1UL<<5, // Clear anticipated frame synchronization detection flag
	SAI1_BCLRFR_CNRDY = 1UL<<4, // Clear codec not ready flag
	SAI1_BCLRFR_WCKCFG = 1UL<<2, // Clear wrong clock configuration flag
	SAI1_BCLRFR_MUTEDET = 1UL<<1, // Mute detection flag
	SAI1_BCLRFR_OVRUDR = 1UL<<0, // Clear overrun / underrun		
};

/* System control block */
struct SCB_Type {
	__I uint32_t CPUID; // @0 CPUID base register
	__IO uint32_t ICSR; // @4 Interrupt control and state register
	__IO uint32_t VTOR; // @8 Vector table offset register
	__IO uint32_t AIRCR; // @12 Application interrupt and reset control register
	__IO uint8_t SCR; // @16 System control register
	 uint8_t RESERVED0[3]; // @17 
	__IO uint16_t CCR; // @20 Configuration and control register
	 uint8_t RESERVED1[2]; // @22 
	__IO uint32_t SHPR1; // @24 System handler priority registers
	__IO uint32_t SHPR2; // @28 System handler priority registers
	__IO uint32_t SHPR3; // @32 System handler priority registers
	__IO uint32_t SHCSR; // @36 System handler control and state register
	__IO uint32_t CFSR_UFSR_BFSR_MMFSR; // @40 Configurable fault status register
	__IO uint32_t HFSR; // @44 Hard fault status register
	 uint8_t RESERVED2[4]; // @48 
	__IO uint32_t MMFAR; // @52 Memory management fault address register
	__IO uint32_t BFAR; // @56 Bus fault address register
	__IO uint32_t AFSR; // @60 Auxiliary fault status register
};

// SCB->CPUID CPUID base register
enum {
	SCB_CPUID_IMPLEMENTER = ((1UL<<8)-1) << 24, // Implementer code
	SCB_CPUID_VARIANT = ((1UL<<4)-1) << 20, // Variant number
	SCB_CPUID_CONSTANT = ((1UL<<4)-1) << 16, // Reads as 0xF
	SCB_CPUID_PARTNO = ((1UL<<12)-1) << 4, // Part number of the processor
	SCB_CPUID_REVISION = ((1UL<<4)-1) << 0, // Revision number		
};
inline uint32_t scb_cpuid_get_implementer(struct SCB_Type* p) { return (p->CPUID & SCB_CPUID_IMPLEMENTER) >> 24 ; }
inline uint32_t scb_cpuid_get_variant(struct SCB_Type* p) { return (p->CPUID & SCB_CPUID_VARIANT) >> 20 ; }
inline uint32_t scb_cpuid_get_constant(struct SCB_Type* p) { return (p->CPUID & SCB_CPUID_CONSTANT) >> 16 ; }
inline uint32_t scb_cpuid_get_partno(struct SCB_Type* p) { return (p->CPUID & SCB_CPUID_PARTNO) >> 4 ; }
inline uint32_t scb_cpuid_get_revision(struct SCB_Type* p) { return (p->CPUID & SCB_CPUID_REVISION) >> 0 ; }

// SCB->ICSR Interrupt control and state register
enum {
	SCB_ICSR_NMIPENDSET = 1UL<<31, // NMI set-pending bit.
	SCB_ICSR_PENDSVSET = 1UL<<28, // PendSV set-pending bit
	SCB_ICSR_PENDSVCLR = 1UL<<27, // PendSV clear-pending bit
	SCB_ICSR_PENDSTSET = 1UL<<26, // SysTick exception set-pending bit
	SCB_ICSR_PENDSTCLR = 1UL<<25, // SysTick exception clear-pending bit
	SCB_ICSR_ISRPENDING = 1UL<<22, // Interrupt pending flag
	SCB_ICSR_VECTPENDING = ((1UL<<7)-1) << 12, // Pending vector
	SCB_ICSR_RETTOBASE = 1UL<<11, // Return to base level
	SCB_ICSR_VECTACTIVE = ((1UL<<9)-1) << 0, // Active vector		
};
inline void scb_icsr_set_vectpending(struct SCB_Type* p, uint32_t val) { p->ICSR = (p->ICSR & ~SCB_ICSR_VECTPENDING) | ((val<<12) & SCB_ICSR_VECTPENDING); }
inline void scb_icsr_set_vectactive(struct SCB_Type* p, uint32_t val) { p->ICSR = (p->ICSR & ~SCB_ICSR_VECTACTIVE) | ((val<<0) & SCB_ICSR_VECTACTIVE); }
inline uint32_t scb_icsr_get_vectpending(struct SCB_Type* p) { return (p->ICSR & SCB_ICSR_VECTPENDING) >> 12 ; }
inline uint32_t scb_icsr_get_vectactive(struct SCB_Type* p) { return (p->ICSR & SCB_ICSR_VECTACTIVE) >> 0 ; }

// SCB->VTOR Vector table offset register
enum {
	SCB_VTOR_TBLOFF = ((1UL<<21)-1) << 9, // Vector table base offset field		
};
inline void scb_vtor_set_tbloff(struct SCB_Type* p, uint32_t val) { p->VTOR = (p->VTOR & ~SCB_VTOR_TBLOFF) | ((val<<9) & SCB_VTOR_TBLOFF); }
inline uint32_t scb_vtor_get_tbloff(struct SCB_Type* p) { return (p->VTOR & SCB_VTOR_TBLOFF) >> 9 ; }

// SCB->AIRCR Application interrupt and reset control register
enum {
	SCB_AIRCR_VECTKEYSTAT = ((1UL<<16)-1) << 16, // Register key
	SCB_AIRCR_ENDIANESS = 1UL<<15, // ENDIANESS
	SCB_AIRCR_PRIGROUP = ((1UL<<3)-1) << 8, // PRIGROUP
	SCB_AIRCR_SYSRESETREQ = 1UL<<2, // SYSRESETREQ
	SCB_AIRCR_VECTCLRACTIVE = 1UL<<1, // VECTCLRACTIVE
	SCB_AIRCR_VECTRESET = 1UL<<0, // VECTRESET		
};
inline void scb_aircr_set_vectkeystat(struct SCB_Type* p, uint32_t val) { p->AIRCR = (p->AIRCR & ~SCB_AIRCR_VECTKEYSTAT) | ((val<<16) & SCB_AIRCR_VECTKEYSTAT); }
inline void scb_aircr_set_prigroup(struct SCB_Type* p, uint32_t val) { p->AIRCR = (p->AIRCR & ~SCB_AIRCR_PRIGROUP) | ((val<<8) & SCB_AIRCR_PRIGROUP); }
inline uint32_t scb_aircr_get_vectkeystat(struct SCB_Type* p) { return (p->AIRCR & SCB_AIRCR_VECTKEYSTAT) >> 16 ; }
inline uint32_t scb_aircr_get_prigroup(struct SCB_Type* p) { return (p->AIRCR & SCB_AIRCR_PRIGROUP) >> 8 ; }

// SCB->SCR System control register
enum {
	SCB_SCR_SEVEONPEND = 1UL<<4, // Send Event on Pending bit
	SCB_SCR_SLEEPDEEP = 1UL<<2, // SLEEPDEEP
	SCB_SCR_SLEEPONEXIT = 1UL<<1, // SLEEPONEXIT		
};

// SCB->CCR Configuration and control register
enum {
	SCB_CCR_STKALIGN = 1UL<<9, // STKALIGN
	SCB_CCR_BFHFNMIGN = 1UL<<8, // BFHFNMIGN
	SCB_CCR_DIV_0_TRP = 1UL<<4, // DIV_0_TRP
	SCB_CCR_UNALIGN__TRP = 1UL<<3, // UNALIGN_ TRP
	SCB_CCR_USERSETMPEND = 1UL<<1, // USERSETMPEND
	SCB_CCR_NONBASETHRDENA = 1UL<<0, // Configures how the processor enters Thread mode		
};

// SCB->SHPR1 System handler priority registers
enum {
	SCB_SHPR1_PRI_6 = ((1UL<<8)-1) << 16, // Priority of system handler 6
	SCB_SHPR1_PRI_5 = ((1UL<<8)-1) << 8, // Priority of system handler 5
	SCB_SHPR1_PRI_4 = ((1UL<<8)-1) << 0, // Priority of system handler 4		
};
inline void scb_shpr1_set_pri_6(struct SCB_Type* p, uint32_t val) { p->SHPR1 = (p->SHPR1 & ~SCB_SHPR1_PRI_6) | ((val<<16) & SCB_SHPR1_PRI_6); }
inline void scb_shpr1_set_pri_5(struct SCB_Type* p, uint32_t val) { p->SHPR1 = (p->SHPR1 & ~SCB_SHPR1_PRI_5) | ((val<<8) & SCB_SHPR1_PRI_5); }
inline void scb_shpr1_set_pri_4(struct SCB_Type* p, uint32_t val) { p->SHPR1 = (p->SHPR1 & ~SCB_SHPR1_PRI_4) | ((val<<0) & SCB_SHPR1_PRI_4); }
inline uint32_t scb_shpr1_get_pri_6(struct SCB_Type* p) { return (p->SHPR1 & SCB_SHPR1_PRI_6) >> 16 ; }
inline uint32_t scb_shpr1_get_pri_5(struct SCB_Type* p) { return (p->SHPR1 & SCB_SHPR1_PRI_5) >> 8 ; }
inline uint32_t scb_shpr1_get_pri_4(struct SCB_Type* p) { return (p->SHPR1 & SCB_SHPR1_PRI_4) >> 0 ; }

// SCB->SHPR2 System handler priority registers
enum {
	SCB_SHPR2_PRI_11 = ((1UL<<8)-1) << 24, // Priority of system handler 11		
};
inline void scb_shpr2_set_pri_11(struct SCB_Type* p, uint32_t val) { p->SHPR2 = (p->SHPR2 & ~SCB_SHPR2_PRI_11) | ((val<<24) & SCB_SHPR2_PRI_11); }
inline uint32_t scb_shpr2_get_pri_11(struct SCB_Type* p) { return (p->SHPR2 & SCB_SHPR2_PRI_11) >> 24 ; }

// SCB->SHPR3 System handler priority registers
enum {
	SCB_SHPR3_PRI_15 = ((1UL<<8)-1) << 24, // Priority of system handler 15
	SCB_SHPR3_PRI_14 = ((1UL<<8)-1) << 16, // Priority of system handler 14		
};
inline void scb_shpr3_set_pri_15(struct SCB_Type* p, uint32_t val) { p->SHPR3 = (p->SHPR3 & ~SCB_SHPR3_PRI_15) | ((val<<24) & SCB_SHPR3_PRI_15); }
inline void scb_shpr3_set_pri_14(struct SCB_Type* p, uint32_t val) { p->SHPR3 = (p->SHPR3 & ~SCB_SHPR3_PRI_14) | ((val<<16) & SCB_SHPR3_PRI_14); }
inline uint32_t scb_shpr3_get_pri_15(struct SCB_Type* p) { return (p->SHPR3 & SCB_SHPR3_PRI_15) >> 24 ; }
inline uint32_t scb_shpr3_get_pri_14(struct SCB_Type* p) { return (p->SHPR3 & SCB_SHPR3_PRI_14) >> 16 ; }

// SCB->SHCSR System handler control and state register
enum {
	SCB_SHCSR_USGFAULTENA = 1UL<<18, // Usage fault enable bit
	SCB_SHCSR_BUSFAULTENA = 1UL<<17, // Bus fault enable bit
	SCB_SHCSR_MEMFAULTENA = 1UL<<16, // Memory management fault enable bit
	SCB_SHCSR_SVCALLPENDED = 1UL<<15, // SVC call pending bit
	SCB_SHCSR_BUSFAULTPENDED = 1UL<<14, // Bus fault exception pending bit
	SCB_SHCSR_MEMFAULTPENDED = 1UL<<13, // Memory management fault exception pending bit
	SCB_SHCSR_USGFAULTPENDED = 1UL<<12, // Usage fault exception pending bit
	SCB_SHCSR_SYSTICKACT = 1UL<<11, // SysTick exception active bit
	SCB_SHCSR_PENDSVACT = 1UL<<10, // PendSV exception active bit
	SCB_SHCSR_MONITORACT = 1UL<<8, // Debug monitor active bit
	SCB_SHCSR_SVCALLACT = 1UL<<7, // SVC call active bit
	SCB_SHCSR_USGFAULTACT = 1UL<<3, // Usage fault exception active bit
	SCB_SHCSR_BUSFAULTACT = 1UL<<1, // Bus fault exception active bit
	SCB_SHCSR_MEMFAULTACT = 1UL<<0, // Memory management fault exception active bit		
};

// SCB->CFSR_UFSR_BFSR_MMFSR Configurable fault status register
enum {
	SCB_CFSR_UFSR_BFSR_MMFSR_DIVBYZERO = 1UL<<25, // Divide by zero usage fault
	SCB_CFSR_UFSR_BFSR_MMFSR_UNALIGNED = 1UL<<24, // Unaligned access usage fault
	SCB_CFSR_UFSR_BFSR_MMFSR_NOCP = 1UL<<19, // No coprocessor usage fault.
	SCB_CFSR_UFSR_BFSR_MMFSR_INVPC = 1UL<<18, // Invalid PC load usage fault
	SCB_CFSR_UFSR_BFSR_MMFSR_INVSTATE = 1UL<<17, // Invalid state usage fault
	SCB_CFSR_UFSR_BFSR_MMFSR_UNDEFINSTR = 1UL<<16, // Undefined instruction usage fault
	SCB_CFSR_UFSR_BFSR_MMFSR_BFARVALID = 1UL<<15, // Bus Fault Address Register (BFAR) valid flag
	SCB_CFSR_UFSR_BFSR_MMFSR_LSPERR = 1UL<<13, // Bus fault on floating-point lazy state preservation
	SCB_CFSR_UFSR_BFSR_MMFSR_STKERR = 1UL<<12, // Bus fault on stacking for exception entry
	SCB_CFSR_UFSR_BFSR_MMFSR_UNSTKERR = 1UL<<11, // Bus fault on unstacking for a return from exception
	SCB_CFSR_UFSR_BFSR_MMFSR_IMPRECISERR = 1UL<<10, // Imprecise data bus error
	SCB_CFSR_UFSR_BFSR_MMFSR_PRECISERR = 1UL<<9, // Precise data bus error
	SCB_CFSR_UFSR_BFSR_MMFSR_IBUSERR = 1UL<<8, // Instruction bus error
	SCB_CFSR_UFSR_BFSR_MMFSR_MMARVALID = 1UL<<7, // Memory Management Fault Address Register (MMAR) valid flag
	SCB_CFSR_UFSR_BFSR_MMFSR_MLSPERR = 1UL<<5, // MLSPERR
	SCB_CFSR_UFSR_BFSR_MMFSR_MSTKERR = 1UL<<4, // Memory manager fault on stacking for exception entry.
	SCB_CFSR_UFSR_BFSR_MMFSR_MUNSTKERR = 1UL<<3, // Memory manager fault on unstacking for a return from exception
	SCB_CFSR_UFSR_BFSR_MMFSR_IACCVIOL = 1UL<<1, // Instruction access violation flag		
};

// SCB->HFSR Hard fault status register
enum {
	SCB_HFSR_DEBUG_VT = 1UL<<31, // Reserved for Debug use
	SCB_HFSR_FORCED = 1UL<<30, // Forced hard fault
	SCB_HFSR_VECTTBL = 1UL<<1, // Vector table hard fault		
};

/* System control block ACTLR */
struct SCB_ACTRL_Type {
	__IO uint16_t ACTRL; // @0 Auxiliary control register
};

// SCB_ACTRL->ACTRL Auxiliary control register
enum {
	SCB_ACTRL_ACTRL_DISOOFP = 1UL<<9, // DISOOFP
	SCB_ACTRL_ACTRL_DISFPCA = 1UL<<8, // DISFPCA
	SCB_ACTRL_ACTRL_DISFOLD = 1UL<<2, // DISFOLD
	SCB_ACTRL_ACTRL_DISDEFWBUF = 1UL<<1, // DISDEFWBUF
	SCB_ACTRL_ACTRL_DISMCYCINT = 1UL<<0, // DISMCYCINT		
};

/* Secure digital input/output interface */
struct SDMMC_Type {
	__IO uint8_t POWER; // @0 power control register
	 uint8_t RESERVED0[3]; // @1 
	__IO uint16_t CLKCR; // @4 SDI clock control register
	 uint8_t RESERVED1[2]; // @6 
	__IO uint32_t ARG; // @8 argument register
	__IO uint16_t CMD; // @12 command register
	 uint8_t RESERVED2[2]; // @14 
	__I uint8_t RESPCMD; // @16 command response register
	 uint8_t RESERVED3[3]; // @17 
	__I uint32_t RESP1; // @20 response 1..4 register
	__I uint32_t RESP2; // @24 response 1..4 register
	__I uint32_t RESP3; // @28 response 1..4 register
	__I uint32_t RESP4; // @32 response 1..4 register
	__IO uint32_t DTIMER; // @36 data timer register
	__IO uint32_t DLEN; // @40 data length register
	__IO uint16_t DCTRL; // @44 data control register
	 uint8_t RESERVED4[2]; // @46 
	__I uint32_t DCOUNT; // @48 data counter register
	__I uint32_t STA; // @52 status register
	__IO uint32_t ICR; // @56 interrupt clear register
	__IO uint32_t MASK; // @60 mask register
	 uint8_t RESERVED5[8]; // @64 
	__I uint32_t FIFOCNT; // @72 FIFO counter register
	 uint8_t RESERVED6[52]; // @76 
	__IO uint32_t FIFO; // @128 data FIFO register
};

// SDMMC->POWER power control register
enum {
	SDMMC_POWER_PWRCTRL = ((1UL<<2)-1) << 0, // PWRCTRL		
};
inline void sdmmc_power_set_pwrctrl(struct SDMMC_Type* p, uint32_t val) { p->POWER = (p->POWER & ~SDMMC_POWER_PWRCTRL) | ((val<<0) & SDMMC_POWER_PWRCTRL); }
inline uint32_t sdmmc_power_get_pwrctrl(struct SDMMC_Type* p) { return (p->POWER & SDMMC_POWER_PWRCTRL) >> 0 ; }

// SDMMC->CLKCR SDI clock control register
enum {
	SDMMC_CLKCR_HWFC_EN = 1UL<<14, // HW Flow Control enable
	SDMMC_CLKCR_NEGEDGE = 1UL<<13, // SDIO_CK dephasing selection bit
	SDMMC_CLKCR_WIDBUS = ((1UL<<2)-1) << 11, // Wide bus mode enable bit
	SDMMC_CLKCR_BYPASS = 1UL<<10, // Clock divider bypass enable bit
	SDMMC_CLKCR_PWRSAV = 1UL<<9, // Power saving configuration bit
	SDMMC_CLKCR_CLKEN = 1UL<<8, // Clock enable bit
	SDMMC_CLKCR_CLKDIV = ((1UL<<8)-1) << 0, // Clock divide factor		
};
inline void sdmmc_clkcr_set_widbus(struct SDMMC_Type* p, uint32_t val) { p->CLKCR = (p->CLKCR & ~SDMMC_CLKCR_WIDBUS) | ((val<<11) & SDMMC_CLKCR_WIDBUS); }
inline void sdmmc_clkcr_set_clkdiv(struct SDMMC_Type* p, uint32_t val) { p->CLKCR = (p->CLKCR & ~SDMMC_CLKCR_CLKDIV) | ((val<<0) & SDMMC_CLKCR_CLKDIV); }
inline uint32_t sdmmc_clkcr_get_widbus(struct SDMMC_Type* p) { return (p->CLKCR & SDMMC_CLKCR_WIDBUS) >> 11 ; }
inline uint32_t sdmmc_clkcr_get_clkdiv(struct SDMMC_Type* p) { return (p->CLKCR & SDMMC_CLKCR_CLKDIV) >> 0 ; }

// SDMMC->CMD command register
enum {
	SDMMC_CMD_CE_ATACMD = 1UL<<14, // CE-ATA command
	SDMMC_CMD_NIEN = 1UL<<13, // not Interrupt Enable
	SDMMC_CMD_ENCMDCOMPL = 1UL<<12, // Enable CMD completion
	SDMMC_CMD_SDIOSUSPEND = 1UL<<11, // SD I/O suspend command
	SDMMC_CMD_CPSMEN = 1UL<<10, // Command path state machine (CPSM) Enable bit
	SDMMC_CMD_WAITPEND = 1UL<<9, // CPSM Waits for ends of data transfer (CmdPend internal signal)
	SDMMC_CMD_WAITINT = 1UL<<8, // CPSM waits for interrupt request
	SDMMC_CMD_WAITRESP = ((1UL<<2)-1) << 6, // Wait for response bits
	SDMMC_CMD_CMDINDEX = ((1UL<<6)-1) << 0, // Command index		
};
inline void sdmmc_cmd_set_waitresp(struct SDMMC_Type* p, uint32_t val) { p->CMD = (p->CMD & ~SDMMC_CMD_WAITRESP) | ((val<<6) & SDMMC_CMD_WAITRESP); }
inline void sdmmc_cmd_set_cmdindex(struct SDMMC_Type* p, uint32_t val) { p->CMD = (p->CMD & ~SDMMC_CMD_CMDINDEX) | ((val<<0) & SDMMC_CMD_CMDINDEX); }
inline uint32_t sdmmc_cmd_get_waitresp(struct SDMMC_Type* p) { return (p->CMD & SDMMC_CMD_WAITRESP) >> 6 ; }
inline uint32_t sdmmc_cmd_get_cmdindex(struct SDMMC_Type* p) { return (p->CMD & SDMMC_CMD_CMDINDEX) >> 0 ; }

// SDMMC->RESPCMD command response register
enum {
	SDMMC_RESPCMD_RESPCMD = ((1UL<<6)-1) << 0, // Response command index		
};
inline uint32_t sdmmc_respcmd_get_respcmd(struct SDMMC_Type* p) { return (p->RESPCMD & SDMMC_RESPCMD_RESPCMD) >> 0 ; }

// SDMMC->DLEN data length register
enum {
	SDMMC_DLEN_DATALENGTH = ((1UL<<25)-1) << 0, // Data length value		
};
inline void sdmmc_dlen_set_datalength(struct SDMMC_Type* p, uint32_t val) { p->DLEN = (p->DLEN & ~SDMMC_DLEN_DATALENGTH) | ((val<<0) & SDMMC_DLEN_DATALENGTH); }
inline uint32_t sdmmc_dlen_get_datalength(struct SDMMC_Type* p) { return (p->DLEN & SDMMC_DLEN_DATALENGTH) >> 0 ; }

// SDMMC->DCTRL data control register
enum {
	SDMMC_DCTRL_SDIOEN = 1UL<<11, // SD I/O enable functions
	SDMMC_DCTRL_RWMOD = 1UL<<10, // Read wait mode
	SDMMC_DCTRL_RWSTOP = 1UL<<9, // Read wait stop
	SDMMC_DCTRL_RWSTART = 1UL<<8, // Read wait start
	SDMMC_DCTRL_DBLOCKSIZE = ((1UL<<4)-1) << 4, // Data block size
	SDMMC_DCTRL_DMAEN = 1UL<<3, // DMA enable bit
	SDMMC_DCTRL_DTMODE = 1UL<<2, // Data transfer mode selection 1: Stream or SDIO multibyte data transfer
	SDMMC_DCTRL_DTDIR = 1UL<<1, // Data transfer direction selection
	SDMMC_DCTRL_DTEN = 1UL<<0, // DTEN		
};
inline void sdmmc_dctrl_set_dblocksize(struct SDMMC_Type* p, uint32_t val) { p->DCTRL = (p->DCTRL & ~SDMMC_DCTRL_DBLOCKSIZE) | ((val<<4) & SDMMC_DCTRL_DBLOCKSIZE); }
inline uint32_t sdmmc_dctrl_get_dblocksize(struct SDMMC_Type* p) { return (p->DCTRL & SDMMC_DCTRL_DBLOCKSIZE) >> 4 ; }

// SDMMC->DCOUNT data counter register
enum {
	SDMMC_DCOUNT_DATACOUNT = ((1UL<<25)-1) << 0, // Data count value		
};
inline uint32_t sdmmc_dcount_get_datacount(struct SDMMC_Type* p) { return (p->DCOUNT & SDMMC_DCOUNT_DATACOUNT) >> 0 ; }

// SDMMC->STA status register
enum {
	SDMMC_STA_CEATAEND = 1UL<<23, // CE-ATA command completion signal received for CMD61
	SDMMC_STA_SDIOIT = 1UL<<22, // SDIO interrupt received
	SDMMC_STA_RXDAVL = 1UL<<21, // Data available in receive FIFO
	SDMMC_STA_TXDAVL = 1UL<<20, // Data available in transmit FIFO
	SDMMC_STA_RXFIFOE = 1UL<<19, // Receive FIFO empty
	SDMMC_STA_TXFIFOE = 1UL<<18, // Transmit FIFO empty
	SDMMC_STA_RXFIFOF = 1UL<<17, // Receive FIFO full
	SDMMC_STA_TXFIFOF = 1UL<<16, // Transmit FIFO full
	SDMMC_STA_RXFIFOHF = 1UL<<15, // Receive FIFO half full: there are at least 8 words in the FIFO
	SDMMC_STA_TXFIFOHE = 1UL<<14, // Transmit FIFO half empty: at least 8 words can be written into the FIFO
	SDMMC_STA_RXACT = 1UL<<13, // Data receive in progress
	SDMMC_STA_TXACT = 1UL<<12, // Data transmit in progress
	SDMMC_STA_CMDACT = 1UL<<11, // Command transfer in progress
	SDMMC_STA_DBCKEND = 1UL<<10, // Data block sent/received (CRC check passed)
	SDMMC_STA_STBITERR = 1UL<<9, // Start bit not detected on all data signals in wide bus mode
	SDMMC_STA_DATAEND = 1UL<<8, // Data end (data counter, SDIDCOUNT, is zero)
	SDMMC_STA_CMDSENT = 1UL<<7, // Command sent (no response required)
	SDMMC_STA_CMDREND = 1UL<<6, // Command response received (CRC check passed)
	SDMMC_STA_RXOVERR = 1UL<<5, // Received FIFO overrun error
	SDMMC_STA_TXUNDERR = 1UL<<4, // Transmit FIFO underrun error
	SDMMC_STA_DTIMEOUT = 1UL<<3, // Data timeout
	SDMMC_STA_CTIMEOUT = 1UL<<2, // Command response timeout
	SDMMC_STA_DCRCFAIL = 1UL<<1, // Data block sent/received (CRC check failed)
	SDMMC_STA_CCRCFAIL = 1UL<<0, // Command response received (CRC check failed)		
};

// SDMMC->ICR interrupt clear register
enum {
	SDMMC_ICR_CEATAENDC = 1UL<<23, // CEATAEND flag clear bit
	SDMMC_ICR_SDIOITC = 1UL<<22, // SDIOIT flag clear bit
	SDMMC_ICR_DBCKENDC = 1UL<<10, // DBCKEND flag clear bit
	SDMMC_ICR_STBITERRC = 1UL<<9, // STBITERR flag clear bit
	SDMMC_ICR_DATAENDC = 1UL<<8, // DATAEND flag clear bit
	SDMMC_ICR_CMDSENTC = 1UL<<7, // CMDSENT flag clear bit
	SDMMC_ICR_CMDRENDC = 1UL<<6, // CMDREND flag clear bit
	SDMMC_ICR_RXOVERRC = 1UL<<5, // RXOVERR flag clear bit
	SDMMC_ICR_TXUNDERRC = 1UL<<4, // TXUNDERR flag clear bit
	SDMMC_ICR_DTIMEOUTC = 1UL<<3, // DTIMEOUT flag clear bit
	SDMMC_ICR_CTIMEOUTC = 1UL<<2, // CTIMEOUT flag clear bit
	SDMMC_ICR_DCRCFAILC = 1UL<<1, // DCRCFAIL flag clear bit
	SDMMC_ICR_CCRCFAILC = 1UL<<0, // CCRCFAIL flag clear bit		
};

// SDMMC->MASK mask register
enum {
	SDMMC_MASK_CEATAENDIE = 1UL<<23, // CE-ATA command completion signal received interrupt enable
	SDMMC_MASK_SDIOITIE = 1UL<<22, // SDIO mode interrupt received interrupt enable
	SDMMC_MASK_RXDAVLIE = 1UL<<21, // Data available in Rx FIFO interrupt enable
	SDMMC_MASK_TXDAVLIE = 1UL<<20, // Data available in Tx FIFO interrupt enable
	SDMMC_MASK_RXFIFOEIE = 1UL<<19, // Rx FIFO empty interrupt enable
	SDMMC_MASK_TXFIFOEIE = 1UL<<18, // Tx FIFO empty interrupt enable
	SDMMC_MASK_RXFIFOFIE = 1UL<<17, // Rx FIFO full interrupt enable
	SDMMC_MASK_TXFIFOFIE = 1UL<<16, // Tx FIFO full interrupt enable
	SDMMC_MASK_RXFIFOHFIE = 1UL<<15, // Rx FIFO half full interrupt enable
	SDMMC_MASK_TXFIFOHEIE = 1UL<<14, // Tx FIFO half empty interrupt enable
	SDMMC_MASK_RXACTIE = 1UL<<13, // Data receive acting interrupt enable
	SDMMC_MASK_TXACTIE = 1UL<<12, // Data transmit acting interrupt enable
	SDMMC_MASK_CMDACTIE = 1UL<<11, // Command acting interrupt enable
	SDMMC_MASK_DBCKENDIE = 1UL<<10, // Data block end interrupt enable
	SDMMC_MASK_STBITERRIE = 1UL<<9, // Start bit error interrupt enable
	SDMMC_MASK_DATAENDIE = 1UL<<8, // Data end interrupt enable
	SDMMC_MASK_CMDSENTIE = 1UL<<7, // Command sent interrupt enable
	SDMMC_MASK_CMDRENDIE = 1UL<<6, // Command response received interrupt enable
	SDMMC_MASK_RXOVERRIE = 1UL<<5, // Rx FIFO overrun error interrupt enable
	SDMMC_MASK_TXUNDERRIE = 1UL<<4, // Tx FIFO underrun error interrupt enable
	SDMMC_MASK_DTIMEOUTIE = 1UL<<3, // Data timeout interrupt enable
	SDMMC_MASK_CTIMEOUTIE = 1UL<<2, // Command timeout interrupt enable
	SDMMC_MASK_DCRCFAILIE = 1UL<<1, // Data CRC fail interrupt enable
	SDMMC_MASK_CCRCFAILIE = 1UL<<0, // Command CRC fail interrupt enable		
};

// SDMMC->FIFOCNT FIFO counter register
enum {
	SDMMC_FIFOCNT_FIFOCOUNT = ((1UL<<24)-1) << 0, // Remaining number of words to be written to or read from the FIFO		
};
inline uint32_t sdmmc_fifocnt_get_fifocount(struct SDMMC_Type* p) { return (p->FIFOCNT & SDMMC_FIFOCNT_FIFOCOUNT) >> 0 ; }

/* Serial peripheral interface/Inter-IC sound */
struct SPI1_Type {
	__IO uint16_t CR1; // @0 control register 1
	 uint8_t RESERVED0[2]; // @2 
	__IO uint16_t CR2; // @4 control register 2
	 uint8_t RESERVED1[2]; // @6 
	__IO uint16_t SR; // @8 status register
	 uint8_t RESERVED2[2]; // @10 
	__IO uint16_t DR; // @12 data register
	 uint8_t RESERVED3[2]; // @14 
	__IO uint16_t CRCPR; // @16 CRC polynomial register
	 uint8_t RESERVED4[2]; // @18 
	__I uint16_t RXCRCR; // @20 RX CRC register
	 uint8_t RESERVED5[2]; // @22 
	__I uint16_t TXCRCR; // @24 TX CRC register
};

// SPI1->CR1 control register 1
enum {
	SPI1_CR1_BIDIMODE = 1UL<<15, // Bidirectional data mode enable
	SPI1_CR1_BIDIOE = 1UL<<14, // Output enable in bidirectional mode
	SPI1_CR1_CRCEN = 1UL<<13, // Hardware CRC calculation enable
	SPI1_CR1_CRCNEXT = 1UL<<12, // CRC transfer next
	SPI1_CR1_DFF = 1UL<<11, // Data frame format
	SPI1_CR1_RXONLY = 1UL<<10, // Receive only
	SPI1_CR1_SSM = 1UL<<9, // Software slave management
	SPI1_CR1_SSI = 1UL<<8, // Internal slave select
	SPI1_CR1_LSBFIRST = 1UL<<7, // Frame format
	SPI1_CR1_SPE = 1UL<<6, // SPI enable
	SPI1_CR1_BR = ((1UL<<3)-1) << 3, // Baud rate control
	SPI1_CR1_MSTR = 1UL<<2, // Master selection
	SPI1_CR1_CPOL = 1UL<<1, // Clock polarity
	SPI1_CR1_CPHA = 1UL<<0, // Clock phase		
};
inline void spi1_cr1_set_br(struct SPI1_Type* p, uint32_t val) { p->CR1 = (p->CR1 & ~SPI1_CR1_BR) | ((val<<3) & SPI1_CR1_BR); }
inline uint32_t spi1_cr1_get_br(struct SPI1_Type* p) { return (p->CR1 & SPI1_CR1_BR) >> 3 ; }

// SPI1->CR2 control register 2
enum {
	SPI1_CR2_LDMA_TX = 1UL<<14, // Last DMA transfer for transmission
	SPI1_CR2_LDMA_RX = 1UL<<13, // Last DMA transfer for reception
	SPI1_CR2_FRXTH = 1UL<<12, // FIFO reception threshold
	SPI1_CR2_DS = ((1UL<<4)-1) << 8, // Data size
	SPI1_CR2_TXEIE = 1UL<<7, // Tx buffer empty interrupt enable
	SPI1_CR2_RXNEIE = 1UL<<6, // RX buffer not empty interrupt enable
	SPI1_CR2_ERRIE = 1UL<<5, // Error interrupt enable
	SPI1_CR2_FRF = 1UL<<4, // Frame format
	SPI1_CR2_NSSP = 1UL<<3, // NSS pulse management
	SPI1_CR2_SSOE = 1UL<<2, // SS output enable
	SPI1_CR2_TXDMAEN = 1UL<<1, // Tx buffer DMA enable
	SPI1_CR2_RXDMAEN = 1UL<<0, // Rx buffer DMA enable		
};
inline void spi1_cr2_set_ds(struct SPI1_Type* p, uint32_t val) { p->CR2 = (p->CR2 & ~SPI1_CR2_DS) | ((val<<8) & SPI1_CR2_DS); }
inline uint32_t spi1_cr2_get_ds(struct SPI1_Type* p) { return (p->CR2 & SPI1_CR2_DS) >> 8 ; }

// SPI1->SR status register
enum {
	SPI1_SR_FTLVL = ((1UL<<2)-1) << 11, // FIFO transmission level
	SPI1_SR_FRLVL = ((1UL<<2)-1) << 9, // FIFO reception level
	SPI1_SR_TIFRFE = 1UL<<8, // TI frame format error
	SPI1_SR_BSY = 1UL<<7, // Busy flag
	SPI1_SR_OVR = 1UL<<6, // Overrun flag
	SPI1_SR_MODF = 1UL<<5, // Mode fault
	SPI1_SR_CRCERR = 1UL<<4, // CRC error flag
	SPI1_SR_TXE = 1UL<<1, // Transmit buffer empty
	SPI1_SR_RXNE = 1UL<<0, // Receive buffer not empty		
};
inline void spi1_sr_set_ftlvl(struct SPI1_Type* p, uint32_t val) { p->SR = (p->SR & ~SPI1_SR_FTLVL) | ((val<<11) & SPI1_SR_FTLVL); }
inline void spi1_sr_set_frlvl(struct SPI1_Type* p, uint32_t val) { p->SR = (p->SR & ~SPI1_SR_FRLVL) | ((val<<9) & SPI1_SR_FRLVL); }
inline uint32_t spi1_sr_get_ftlvl(struct SPI1_Type* p) { return (p->SR & SPI1_SR_FTLVL) >> 11 ; }
inline uint32_t spi1_sr_get_frlvl(struct SPI1_Type* p) { return (p->SR & SPI1_SR_FRLVL) >> 9 ; }



/* SysTick timer */
struct STK_Type {
	__IO uint32_t CTRL; // @0 SysTick control and status register
	__IO uint32_t LOAD; // @4 SysTick reload value register
	__IO uint32_t VAL; // @8 SysTick current value register
	__IO uint32_t CALIB; // @12 SysTick calibration value register
};

// STK->CTRL SysTick control and status register
enum {
	STK_CTRL_COUNTFLAG = 1UL<<16, // COUNTFLAG
	STK_CTRL_CLKSOURCE = 1UL<<2, // Clock source selection
	STK_CTRL_TICKINT = 1UL<<1, // SysTick exception request enable
	STK_CTRL_ENABLE = 1UL<<0, // Counter enable		
};

// STK->LOAD SysTick reload value register
enum {
	STK_LOAD_RELOAD = ((1UL<<24)-1) << 0, // RELOAD value		
};
inline void stk_load_set_reload(struct STK_Type* p, uint32_t val) { p->LOAD = (p->LOAD & ~STK_LOAD_RELOAD) | ((val<<0) & STK_LOAD_RELOAD); }
inline uint32_t stk_load_get_reload(struct STK_Type* p) { return (p->LOAD & STK_LOAD_RELOAD) >> 0 ; }

// STK->VAL SysTick current value register
enum {
	STK_VAL_CURRENT = ((1UL<<24)-1) << 0, // Current counter value		
};
inline void stk_val_set_current(struct STK_Type* p, uint32_t val) { p->VAL = (p->VAL & ~STK_VAL_CURRENT) | ((val<<0) & STK_VAL_CURRENT); }
inline uint32_t stk_val_get_current(struct STK_Type* p) { return (p->VAL & STK_VAL_CURRENT) >> 0 ; }

// STK->CALIB SysTick calibration value register
enum {
	STK_CALIB_NOREF = 1UL<<31, // NOREF flag. Reads as zero
	STK_CALIB_SKEW = 1UL<<30, // SKEW flag: Indicates whether the TENMS value is exact
	STK_CALIB_TENMS = ((1UL<<24)-1) << 0, // Calibration value		
};
inline void stk_calib_set_tenms(struct STK_Type* p, uint32_t val) { p->CALIB = (p->CALIB & ~STK_CALIB_TENMS) | ((val<<0) & STK_CALIB_TENMS); }
inline uint32_t stk_calib_get_tenms(struct STK_Type* p) { return (p->CALIB & STK_CALIB_TENMS) >> 0 ; }

/* Single Wire Protocol Master Interface */
struct SWPMI1_Type {
	__IO uint16_t CR; // @0 SWPMI Configuration/Control register
	 uint8_t RESERVED0[2]; // @2 
	__IO uint8_t BRR; // @4 SWPMI Bitrate register
	 uint8_t RESERVED1[7]; // @5 
	__I uint16_t ISR; // @12 SWPMI Interrupt and Status register
	 uint8_t RESERVED2[2]; // @14 
	__O uint16_t ICR; // @16 SWPMI Interrupt Flag Clear register
	 uint8_t RESERVED3[2]; // @18 
	__IO uint16_t IER; // @20 SWPMI Interrupt Enable register
	 uint8_t RESERVED4[2]; // @22 
	__I uint8_t RFL; // @24 SWPMI Receive Frame Length register
	 uint8_t RESERVED5[3]; // @25 
	__O uint32_t TDR; // @28 SWPMI Transmit data register
	__I uint32_t RDR; // @32 SWPMI Receive data register
};

// SWPMI1->CR SWPMI Configuration/Control register
enum {
	SWPMI1_CR_DEACT = 1UL<<10, // Single wire protocol master interface deactivate
	SWPMI1_CR_SWPME = 1UL<<5, // Single wire protocol master interface enable
	SWPMI1_CR_LPBK = 1UL<<4, // Loopback mode enable
	SWPMI1_CR_TXMODE = 1UL<<3, // Transmission buffering mode
	SWPMI1_CR_RXMODE = 1UL<<2, // Reception buffering mode
	SWPMI1_CR_TXDMA = 1UL<<1, // Transmission DMA enable
	SWPMI1_CR_RXDMA = 1UL<<0, // Reception DMA enable		
};

// SWPMI1->BRR SWPMI Bitrate register
enum {
	SWPMI1_BRR_BR = ((1UL<<6)-1) << 0, // Bitrate prescaler		
};
inline void swpmi1_brr_set_br(struct SWPMI1_Type* p, uint32_t val) { p->BRR = (p->BRR & ~SWPMI1_BRR_BR) | ((val<<0) & SWPMI1_BRR_BR); }
inline uint32_t swpmi1_brr_get_br(struct SWPMI1_Type* p) { return (p->BRR & SWPMI1_BRR_BR) >> 0 ; }

// SWPMI1->ISR SWPMI Interrupt and Status register
enum {
	SWPMI1_ISR_DEACTF = 1UL<<10, // DEACTIVATED flag
	SWPMI1_ISR_SUSP = 1UL<<9, // SUSPEND flag
	SWPMI1_ISR_SRF = 1UL<<8, // Slave resume flag
	SWPMI1_ISR_TCF = 1UL<<7, // Transfer complete flag
	SWPMI1_ISR_TXE = 1UL<<6, // Transmit data register empty
	SWPMI1_ISR_RXNE = 1UL<<5, // Receive data register not empty
	SWPMI1_ISR_TXUNRF = 1UL<<4, // Transmit underrun error flag
	SWPMI1_ISR_RXOVRF = 1UL<<3, // Receive overrun error flag
	SWPMI1_ISR_RXBERF = 1UL<<2, // Receive CRC error flag
	SWPMI1_ISR_TXBEF = 1UL<<1, // Transmit buffer empty flag
	SWPMI1_ISR_RXBFF = 1UL<<0, // Receive buffer full flag		
};

// SWPMI1->ICR SWPMI Interrupt Flag Clear register
enum {
	SWPMI1_ICR_CSRF = 1UL<<8, // Clear slave resume flag
	SWPMI1_ICR_CTCF = 1UL<<7, // Clear transfer complete flag
	SWPMI1_ICR_CTXUNRF = 1UL<<4, // Clear transmit underrun error flag
	SWPMI1_ICR_CRXOVRF = 1UL<<3, // Clear receive overrun error flag
	SWPMI1_ICR_CRXBERF = 1UL<<2, // Clear receive CRC error flag
	SWPMI1_ICR_CTXBEF = 1UL<<1, // Clear transmit buffer empty flag
	SWPMI1_ICR_CRXBFF = 1UL<<0, // Clear receive buffer full flag		
};

// SWPMI1->IER SWPMI Interrupt Enable register
enum {
	SWPMI1_IER_SRIE = 1UL<<8, // Slave resume interrupt enable
	SWPMI1_IER_TCIE = 1UL<<7, // Transmit complete interrupt enable
	SWPMI1_IER_TIE = 1UL<<6, // Transmit interrupt enable
	SWPMI1_IER_RIE = 1UL<<5, // Receive interrupt enable
	SWPMI1_IER_TXUNRIE = 1UL<<4, // Transmit underrun error interrupt enable
	SWPMI1_IER_RXOVRIE = 1UL<<3, // Receive overrun error interrupt enable
	SWPMI1_IER_RXBERIE = 1UL<<2, // Receive CRC error interrupt enable
	SWPMI1_IER_TXBEIE = 1UL<<1, // Transmit buffer empty interrupt enable
	SWPMI1_IER_RXBFIE = 1UL<<0, // Receive buffer full interrupt enable		
};

// SWPMI1->RFL SWPMI Receive Frame Length register
enum {
	SWPMI1_RFL_RFL = ((1UL<<5)-1) << 0, // Receive frame length		
};
inline uint32_t swpmi1_rfl_get_rfl(struct SWPMI1_Type* p) { return (p->RFL & SWPMI1_RFL_RFL) >> 0 ; }

/* System configuration controller */
struct SYSCFG_Type {
	__IO uint16_t MEMRMP; // @0 memory remap register
	 uint8_t RESERVED0[2]; // @2 
	__IO uint32_t CFGR1; // @4 configuration register 1
	__IO uint16_t EXTICR1; // @8 external interrupt configuration register 1
	 uint8_t RESERVED1[2]; // @10 
	__IO uint16_t EXTICR2; // @12 external interrupt configuration register 2
	 uint8_t RESERVED2[2]; // @14 
	__IO uint16_t EXTICR3; // @16 external interrupt configuration register 3
	 uint8_t RESERVED3[2]; // @18 
	__IO uint16_t EXTICR4; // @20 external interrupt configuration register 4
	 uint8_t RESERVED4[2]; // @22 
	__IO uint8_t SCSR; // @24 SCSR
	 uint8_t RESERVED5[3]; // @25 
	__IO uint16_t CFGR2; // @28 CFGR2
	 uint8_t RESERVED6[2]; // @30 
	__O uint32_t SWPR; // @32 SWPR
	__O uint8_t SKR; // @36 SKR
};

// SYSCFG->MEMRMP memory remap register
enum {
	SYSCFG_MEMRMP_FB_MODE = 1UL<<8, // Flash Bank mode selection
	SYSCFG_MEMRMP_QFS = 1UL<<3, // QUADSPI memory mapping swap
	SYSCFG_MEMRMP_MEM_MODE = ((1UL<<3)-1) << 0, // Memory mapping selection		
};
inline void syscfg_memrmp_set_mem_mode(struct SYSCFG_Type* p, uint32_t val) { p->MEMRMP = (p->MEMRMP & ~SYSCFG_MEMRMP_MEM_MODE) | ((val<<0) & SYSCFG_MEMRMP_MEM_MODE); }
inline uint32_t syscfg_memrmp_get_mem_mode(struct SYSCFG_Type* p) { return (p->MEMRMP & SYSCFG_MEMRMP_MEM_MODE) >> 0 ; }

// SYSCFG->CFGR1 configuration register 1
enum {
	SYSCFG_CFGR1_FPU_IE = ((1UL<<6)-1) << 26, // Floating Point Unit interrupts enable bits
	SYSCFG_CFGR1_I2C3_FMP = 1UL<<22, // I2C3 Fast-mode Plus driving capability activation
	SYSCFG_CFGR1_I2C2_FMP = 1UL<<21, // I2C2 Fast-mode Plus driving capability activation
	SYSCFG_CFGR1_I2C1_FMP = 1UL<<20, // I2C1 Fast-mode Plus driving capability activation
	SYSCFG_CFGR1_I2C_PB9_FMP = 1UL<<19, // Fast-mode Plus (Fm+) driving capability activation on PB9
	SYSCFG_CFGR1_I2C_PB8_FMP = 1UL<<18, // Fast-mode Plus (Fm+) driving capability activation on PB8
	SYSCFG_CFGR1_I2C_PB7_FMP = 1UL<<17, // Fast-mode Plus (Fm+) driving capability activation on PB7
	SYSCFG_CFGR1_I2C_PB6_FMP = 1UL<<16, // Fast-mode Plus (Fm+) driving capability activation on PB6
	SYSCFG_CFGR1_BOOSTEN = 1UL<<8, // I/O analog switch voltage booster enable
	SYSCFG_CFGR1_FWDIS = 1UL<<0, // Firewall disable		
};
inline void syscfg_cfgr1_set_fpu_ie(struct SYSCFG_Type* p, uint32_t val) { p->CFGR1 = (p->CFGR1 & ~SYSCFG_CFGR1_FPU_IE) | ((val<<26) & SYSCFG_CFGR1_FPU_IE); }
inline uint32_t syscfg_cfgr1_get_fpu_ie(struct SYSCFG_Type* p) { return (p->CFGR1 & SYSCFG_CFGR1_FPU_IE) >> 26 ; }

// SYSCFG->EXTICR1 external interrupt configuration register 1
enum {
	SYSCFG_EXTICR1_EXTI3 = ((1UL<<3)-1) << 12, // EXTI 3 configuration bits
	SYSCFG_EXTICR1_EXTI2 = ((1UL<<3)-1) << 8, // EXTI 2 configuration bits
	SYSCFG_EXTICR1_EXTI1 = ((1UL<<3)-1) << 4, // EXTI 1 configuration bits
	SYSCFG_EXTICR1_EXTI0 = ((1UL<<3)-1) << 0, // EXTI 0 configuration bits		
};
inline void syscfg_exticr1_set_exti3(struct SYSCFG_Type* p, uint32_t val) { p->EXTICR1 = (p->EXTICR1 & ~SYSCFG_EXTICR1_EXTI3) | ((val<<12) & SYSCFG_EXTICR1_EXTI3); }
inline void syscfg_exticr1_set_exti2(struct SYSCFG_Type* p, uint32_t val) { p->EXTICR1 = (p->EXTICR1 & ~SYSCFG_EXTICR1_EXTI2) | ((val<<8) & SYSCFG_EXTICR1_EXTI2); }
inline void syscfg_exticr1_set_exti1(struct SYSCFG_Type* p, uint32_t val) { p->EXTICR1 = (p->EXTICR1 & ~SYSCFG_EXTICR1_EXTI1) | ((val<<4) & SYSCFG_EXTICR1_EXTI1); }
inline void syscfg_exticr1_set_exti0(struct SYSCFG_Type* p, uint32_t val) { p->EXTICR1 = (p->EXTICR1 & ~SYSCFG_EXTICR1_EXTI0) | ((val<<0) & SYSCFG_EXTICR1_EXTI0); }
inline uint32_t syscfg_exticr1_get_exti3(struct SYSCFG_Type* p) { return (p->EXTICR1 & SYSCFG_EXTICR1_EXTI3) >> 12 ; }
inline uint32_t syscfg_exticr1_get_exti2(struct SYSCFG_Type* p) { return (p->EXTICR1 & SYSCFG_EXTICR1_EXTI2) >> 8 ; }
inline uint32_t syscfg_exticr1_get_exti1(struct SYSCFG_Type* p) { return (p->EXTICR1 & SYSCFG_EXTICR1_EXTI1) >> 4 ; }
inline uint32_t syscfg_exticr1_get_exti0(struct SYSCFG_Type* p) { return (p->EXTICR1 & SYSCFG_EXTICR1_EXTI0) >> 0 ; }

// SYSCFG->EXTICR2 external interrupt configuration register 2
enum {
	SYSCFG_EXTICR2_EXTI7 = ((1UL<<3)-1) << 12, // EXTI 7 configuration bits
	SYSCFG_EXTICR2_EXTI6 = ((1UL<<3)-1) << 8, // EXTI 6 configuration bits
	SYSCFG_EXTICR2_EXTI5 = ((1UL<<3)-1) << 4, // EXTI 5 configuration bits
	SYSCFG_EXTICR2_EXTI4 = ((1UL<<3)-1) << 0, // EXTI 4 configuration bits		
};
inline void syscfg_exticr2_set_exti7(struct SYSCFG_Type* p, uint32_t val) { p->EXTICR2 = (p->EXTICR2 & ~SYSCFG_EXTICR2_EXTI7) | ((val<<12) & SYSCFG_EXTICR2_EXTI7); }
inline void syscfg_exticr2_set_exti6(struct SYSCFG_Type* p, uint32_t val) { p->EXTICR2 = (p->EXTICR2 & ~SYSCFG_EXTICR2_EXTI6) | ((val<<8) & SYSCFG_EXTICR2_EXTI6); }
inline void syscfg_exticr2_set_exti5(struct SYSCFG_Type* p, uint32_t val) { p->EXTICR2 = (p->EXTICR2 & ~SYSCFG_EXTICR2_EXTI5) | ((val<<4) & SYSCFG_EXTICR2_EXTI5); }
inline void syscfg_exticr2_set_exti4(struct SYSCFG_Type* p, uint32_t val) { p->EXTICR2 = (p->EXTICR2 & ~SYSCFG_EXTICR2_EXTI4) | ((val<<0) & SYSCFG_EXTICR2_EXTI4); }
inline uint32_t syscfg_exticr2_get_exti7(struct SYSCFG_Type* p) { return (p->EXTICR2 & SYSCFG_EXTICR2_EXTI7) >> 12 ; }
inline uint32_t syscfg_exticr2_get_exti6(struct SYSCFG_Type* p) { return (p->EXTICR2 & SYSCFG_EXTICR2_EXTI6) >> 8 ; }
inline uint32_t syscfg_exticr2_get_exti5(struct SYSCFG_Type* p) { return (p->EXTICR2 & SYSCFG_EXTICR2_EXTI5) >> 4 ; }
inline uint32_t syscfg_exticr2_get_exti4(struct SYSCFG_Type* p) { return (p->EXTICR2 & SYSCFG_EXTICR2_EXTI4) >> 0 ; }

// SYSCFG->EXTICR3 external interrupt configuration register 3
enum {
	SYSCFG_EXTICR3_EXTI11 = ((1UL<<3)-1) << 12, // EXTI 11 configuration bits
	SYSCFG_EXTICR3_EXTI10 = ((1UL<<3)-1) << 8, // EXTI 10 configuration bits
	SYSCFG_EXTICR3_EXTI9 = ((1UL<<3)-1) << 4, // EXTI 9 configuration bits
	SYSCFG_EXTICR3_EXTI8 = ((1UL<<3)-1) << 0, // EXTI 8 configuration bits		
};
inline void syscfg_exticr3_set_exti11(struct SYSCFG_Type* p, uint32_t val) { p->EXTICR3 = (p->EXTICR3 & ~SYSCFG_EXTICR3_EXTI11) | ((val<<12) & SYSCFG_EXTICR3_EXTI11); }
inline void syscfg_exticr3_set_exti10(struct SYSCFG_Type* p, uint32_t val) { p->EXTICR3 = (p->EXTICR3 & ~SYSCFG_EXTICR3_EXTI10) | ((val<<8) & SYSCFG_EXTICR3_EXTI10); }
inline void syscfg_exticr3_set_exti9(struct SYSCFG_Type* p, uint32_t val) { p->EXTICR3 = (p->EXTICR3 & ~SYSCFG_EXTICR3_EXTI9) | ((val<<4) & SYSCFG_EXTICR3_EXTI9); }
inline void syscfg_exticr3_set_exti8(struct SYSCFG_Type* p, uint32_t val) { p->EXTICR3 = (p->EXTICR3 & ~SYSCFG_EXTICR3_EXTI8) | ((val<<0) & SYSCFG_EXTICR3_EXTI8); }
inline uint32_t syscfg_exticr3_get_exti11(struct SYSCFG_Type* p) { return (p->EXTICR3 & SYSCFG_EXTICR3_EXTI11) >> 12 ; }
inline uint32_t syscfg_exticr3_get_exti10(struct SYSCFG_Type* p) { return (p->EXTICR3 & SYSCFG_EXTICR3_EXTI10) >> 8 ; }
inline uint32_t syscfg_exticr3_get_exti9(struct SYSCFG_Type* p) { return (p->EXTICR3 & SYSCFG_EXTICR3_EXTI9) >> 4 ; }
inline uint32_t syscfg_exticr3_get_exti8(struct SYSCFG_Type* p) { return (p->EXTICR3 & SYSCFG_EXTICR3_EXTI8) >> 0 ; }

// SYSCFG->EXTICR4 external interrupt configuration register 4
enum {
	SYSCFG_EXTICR4_EXTI15 = ((1UL<<3)-1) << 12, // EXTI15 configuration bits
	SYSCFG_EXTICR4_EXTI14 = ((1UL<<3)-1) << 8, // EXTI14 configuration bits
	SYSCFG_EXTICR4_EXTI13 = ((1UL<<3)-1) << 4, // EXTI13 configuration bits
	SYSCFG_EXTICR4_EXTI12 = ((1UL<<3)-1) << 0, // EXTI12 configuration bits		
};
inline void syscfg_exticr4_set_exti15(struct SYSCFG_Type* p, uint32_t val) { p->EXTICR4 = (p->EXTICR4 & ~SYSCFG_EXTICR4_EXTI15) | ((val<<12) & SYSCFG_EXTICR4_EXTI15); }
inline void syscfg_exticr4_set_exti14(struct SYSCFG_Type* p, uint32_t val) { p->EXTICR4 = (p->EXTICR4 & ~SYSCFG_EXTICR4_EXTI14) | ((val<<8) & SYSCFG_EXTICR4_EXTI14); }
inline void syscfg_exticr4_set_exti13(struct SYSCFG_Type* p, uint32_t val) { p->EXTICR4 = (p->EXTICR4 & ~SYSCFG_EXTICR4_EXTI13) | ((val<<4) & SYSCFG_EXTICR4_EXTI13); }
inline void syscfg_exticr4_set_exti12(struct SYSCFG_Type* p, uint32_t val) { p->EXTICR4 = (p->EXTICR4 & ~SYSCFG_EXTICR4_EXTI12) | ((val<<0) & SYSCFG_EXTICR4_EXTI12); }
inline uint32_t syscfg_exticr4_get_exti15(struct SYSCFG_Type* p) { return (p->EXTICR4 & SYSCFG_EXTICR4_EXTI15) >> 12 ; }
inline uint32_t syscfg_exticr4_get_exti14(struct SYSCFG_Type* p) { return (p->EXTICR4 & SYSCFG_EXTICR4_EXTI14) >> 8 ; }
inline uint32_t syscfg_exticr4_get_exti13(struct SYSCFG_Type* p) { return (p->EXTICR4 & SYSCFG_EXTICR4_EXTI13) >> 4 ; }
inline uint32_t syscfg_exticr4_get_exti12(struct SYSCFG_Type* p) { return (p->EXTICR4 & SYSCFG_EXTICR4_EXTI12) >> 0 ; }

// SYSCFG->SCSR SCSR
enum {
	SYSCFG_SCSR_SRAM2BSY = 1UL<<1, // SRAM2 busy by erase operation
	SYSCFG_SCSR_SRAM2ER = 1UL<<0, // SRAM2 Erase		
};

// SYSCFG->CFGR2 CFGR2
enum {
	SYSCFG_CFGR2_SPF = 1UL<<8, // SRAM2 parity error flag
	SYSCFG_CFGR2_ECCL = 1UL<<3, // ECC Lock
	SYSCFG_CFGR2_PVDL = 1UL<<2, // PVD lock enable bit
	SYSCFG_CFGR2_SPL = 1UL<<1, // SRAM2 parity lock bit
	SYSCFG_CFGR2_CLL = 1UL<<0, // OCKUP (Hardfault) output enable bit		
};

/* Advanced-timers */
struct TIM1_Type {
	__IO uint16_t CR1; // @0 control register 1
	 uint8_t RESERVED0[2]; // @2 
	__IO uint16_t CR2; // @4 control register 2
	 uint8_t RESERVED1[2]; // @6 
	__IO uint16_t SMCR; // @8 slave mode control register
	 uint8_t RESERVED2[2]; // @10 
	__IO uint16_t DIER; // @12 DMA/Interrupt enable register
	 uint8_t RESERVED3[2]; // @14 
	__IO uint16_t SR; // @16 status register
	 uint8_t RESERVED4[2]; // @18 
	__O uint8_t EGR; // @20 event generation register
	 uint8_t RESERVED5[3]; // @21 
	union {  // @24
		__IO uint16_t CCMR1_Output; // capture/compare mode register 1 (output mode)
		__IO uint16_t CCMR1_Input; // capture/compare mode register 1 (input mode)
	};
	 uint8_t RESERVED6[2]; // @26 
	union {  // @28
		__IO uint16_t CCMR2_Output; // capture/compare mode register 2 (output mode)
		__IO uint16_t CCMR2_Input; // capture/compare mode register 2 (input mode)
	};
	 uint8_t RESERVED7[2]; // @30 
	__IO uint16_t CCER; // @32 capture/compare enable register
	 uint8_t RESERVED8[2]; // @34 
	__IO uint16_t CNT; // @36 counter
	 uint8_t RESERVED9[2]; // @38 
	__IO uint16_t PSC; // @40 prescaler
	 uint8_t RESERVED10[2]; // @42 
	__IO uint16_t ARR; // @44 auto-reload register
	 uint8_t RESERVED11[2]; // @46 
	__IO uint8_t RCR; // @48 repetition counter register
	 uint8_t RESERVED12[3]; // @49 
	__IO uint16_t CCR1; // @52 capture/compare register 1
	 uint8_t RESERVED13[2]; // @54 
	__IO uint16_t CCR2; // @56 capture/compare register 2
	 uint8_t RESERVED14[2]; // @58 
	__IO uint16_t CCR3; // @60 capture/compare register 3
	 uint8_t RESERVED15[2]; // @62 
	__IO uint16_t CCR4; // @64 capture/compare register 4
	 uint8_t RESERVED16[2]; // @66 
	__IO uint16_t BDTR; // @68 break and dead-time register
	 uint8_t RESERVED17[2]; // @70 
	__IO uint16_t DCR; // @72 DMA control register
	 uint8_t RESERVED18[2]; // @74 
	__IO uint16_t DMAR; // @76 DMA address for full transfer
	 uint8_t RESERVED19[2]; // @78 
	__IO uint8_t OR1; // @80 DMA address for full transfer
	 uint8_t RESERVED20[3]; // @81 
	__IO uint32_t CCMR3_Output; // @84 capture/compare mode register 2 (output mode)
	__IO uint32_t CCR5; // @88 capture/compare register 4
	__IO uint16_t CCR6; // @92 capture/compare register 4
	 uint8_t RESERVED21[2]; // @94 
	__IO uint32_t OR2; // @96 DMA address for full transfer
	__IO uint16_t OR3; // @100 DMA address for full transfer
};

// TIM1->CR1 control register 1
enum {
	TIM1_CR1_CKD = ((1UL<<2)-1) << 8, // Clock division
	TIM1_CR1_ARPE = 1UL<<7, // Auto-reload preload enable
	TIM1_CR1_CMS = ((1UL<<2)-1) << 5, // Center-aligned mode selection
	TIM1_CR1_DIR = 1UL<<4, // Direction
	TIM1_CR1_OPM = 1UL<<3, // One-pulse mode
	TIM1_CR1_URS = 1UL<<2, // Update request source
	TIM1_CR1_UDIS = 1UL<<1, // Update disable
	TIM1_CR1_CEN = 1UL<<0, // Counter enable		
};
inline void tim1_cr1_set_ckd(struct TIM1_Type* p, uint32_t val) { p->CR1 = (p->CR1 & ~TIM1_CR1_CKD) | ((val<<8) & TIM1_CR1_CKD); }
inline void tim1_cr1_set_cms(struct TIM1_Type* p, uint32_t val) { p->CR1 = (p->CR1 & ~TIM1_CR1_CMS) | ((val<<5) & TIM1_CR1_CMS); }
inline uint32_t tim1_cr1_get_ckd(struct TIM1_Type* p) { return (p->CR1 & TIM1_CR1_CKD) >> 8 ; }
inline uint32_t tim1_cr1_get_cms(struct TIM1_Type* p) { return (p->CR1 & TIM1_CR1_CMS) >> 5 ; }

// TIM1->CR2 control register 2
enum {
	TIM1_CR2_OIS4 = 1UL<<14, // Output Idle state 4
	TIM1_CR2_OIS3N = 1UL<<13, // Output Idle state 3
	TIM1_CR2_OIS3 = 1UL<<12, // Output Idle state 3
	TIM1_CR2_OIS2N = 1UL<<11, // Output Idle state 2
	TIM1_CR2_OIS2 = 1UL<<10, // Output Idle state 2
	TIM1_CR2_OIS1N = 1UL<<9, // Output Idle state 1
	TIM1_CR2_OIS1 = 1UL<<8, // Output Idle state 1
	TIM1_CR2_TI1S = 1UL<<7, // TI1 selection
	TIM1_CR2_MMS = ((1UL<<3)-1) << 4, // Master mode selection
	TIM1_CR2_CCDS = 1UL<<3, // Capture/compare DMA selection
	TIM1_CR2_CCUS = 1UL<<2, // Capture/compare control update selection
	TIM1_CR2_CCPC = 1UL<<0, // Capture/compare preloaded control		
};
inline void tim1_cr2_set_mms(struct TIM1_Type* p, uint32_t val) { p->CR2 = (p->CR2 & ~TIM1_CR2_MMS) | ((val<<4) & TIM1_CR2_MMS); }
inline uint32_t tim1_cr2_get_mms(struct TIM1_Type* p) { return (p->CR2 & TIM1_CR2_MMS) >> 4 ; }

// TIM1->SMCR slave mode control register
enum {
	TIM1_SMCR_ETP = 1UL<<15, // External trigger polarity
	TIM1_SMCR_ECE = 1UL<<14, // External clock enable
	TIM1_SMCR_ETPS = ((1UL<<2)-1) << 12, // External trigger prescaler
	TIM1_SMCR_ETF = ((1UL<<4)-1) << 8, // External trigger filter
	TIM1_SMCR_MSM = 1UL<<7, // Master/Slave mode
	TIM1_SMCR_TS = ((1UL<<3)-1) << 4, // Trigger selection
	TIM1_SMCR_SMS = ((1UL<<3)-1) << 0, // Slave mode selection		
};
inline void tim1_smcr_set_etps(struct TIM1_Type* p, uint32_t val) { p->SMCR = (p->SMCR & ~TIM1_SMCR_ETPS) | ((val<<12) & TIM1_SMCR_ETPS); }
inline void tim1_smcr_set_etf(struct TIM1_Type* p, uint32_t val) { p->SMCR = (p->SMCR & ~TIM1_SMCR_ETF) | ((val<<8) & TIM1_SMCR_ETF); }
inline void tim1_smcr_set_ts(struct TIM1_Type* p, uint32_t val) { p->SMCR = (p->SMCR & ~TIM1_SMCR_TS) | ((val<<4) & TIM1_SMCR_TS); }
inline void tim1_smcr_set_sms(struct TIM1_Type* p, uint32_t val) { p->SMCR = (p->SMCR & ~TIM1_SMCR_SMS) | ((val<<0) & TIM1_SMCR_SMS); }
inline uint32_t tim1_smcr_get_etps(struct TIM1_Type* p) { return (p->SMCR & TIM1_SMCR_ETPS) >> 12 ; }
inline uint32_t tim1_smcr_get_etf(struct TIM1_Type* p) { return (p->SMCR & TIM1_SMCR_ETF) >> 8 ; }
inline uint32_t tim1_smcr_get_ts(struct TIM1_Type* p) { return (p->SMCR & TIM1_SMCR_TS) >> 4 ; }
inline uint32_t tim1_smcr_get_sms(struct TIM1_Type* p) { return (p->SMCR & TIM1_SMCR_SMS) >> 0 ; }

// TIM1->DIER DMA/Interrupt enable register
enum {
	TIM1_DIER_TDE = 1UL<<14, // Trigger DMA request enable
	TIM1_DIER_COMDE = 1UL<<13, // COM DMA request enable
	TIM1_DIER_CC4DE = 1UL<<12, // Capture/Compare 4 DMA request enable
	TIM1_DIER_CC3DE = 1UL<<11, // Capture/Compare 3 DMA request enable
	TIM1_DIER_CC2DE = 1UL<<10, // Capture/Compare 2 DMA request enable
	TIM1_DIER_CC1DE = 1UL<<9, // Capture/Compare 1 DMA request enable
	TIM1_DIER_UDE = 1UL<<8, // Update DMA request enable
	TIM1_DIER_BIE = 1UL<<7, // Break interrupt enable
	TIM1_DIER_TIE = 1UL<<6, // Trigger interrupt enable
	TIM1_DIER_COMIE = 1UL<<5, // COM interrupt enable
	TIM1_DIER_CC4IE = 1UL<<4, // Capture/Compare 4 interrupt enable
	TIM1_DIER_CC3IE = 1UL<<3, // Capture/Compare 3 interrupt enable
	TIM1_DIER_CC2IE = 1UL<<2, // Capture/Compare 2 interrupt enable
	TIM1_DIER_CC1IE = 1UL<<1, // Capture/Compare 1 interrupt enable
	TIM1_DIER_UIE = 1UL<<0, // Update interrupt enable		
};

// TIM1->SR status register
enum {
	TIM1_SR_CC4OF = 1UL<<12, // Capture/Compare 4 overcapture flag
	TIM1_SR_CC3OF = 1UL<<11, // Capture/Compare 3 overcapture flag
	TIM1_SR_CC2OF = 1UL<<10, // Capture/compare 2 overcapture flag
	TIM1_SR_CC1OF = 1UL<<9, // Capture/Compare 1 overcapture flag
	TIM1_SR_BIF = 1UL<<7, // Break interrupt flag
	TIM1_SR_TIF = 1UL<<6, // Trigger interrupt flag
	TIM1_SR_COMIF = 1UL<<5, // COM interrupt flag
	TIM1_SR_CC4IF = 1UL<<4, // Capture/Compare 4 interrupt flag
	TIM1_SR_CC3IF = 1UL<<3, // Capture/Compare 3 interrupt flag
	TIM1_SR_CC2IF = 1UL<<2, // Capture/Compare 2 interrupt flag
	TIM1_SR_CC1IF = 1UL<<1, // Capture/compare 1 interrupt flag
	TIM1_SR_UIF = 1UL<<0, // Update interrupt flag		
};

// TIM1->EGR event generation register
enum {
	TIM1_EGR_BG = 1UL<<7, // Break generation
	TIM1_EGR_TG = 1UL<<6, // Trigger generation
	TIM1_EGR_COMG = 1UL<<5, // Capture/Compare control update generation
	TIM1_EGR_CC4G = 1UL<<4, // Capture/compare 4 generation
	TIM1_EGR_CC3G = 1UL<<3, // Capture/compare 3 generation
	TIM1_EGR_CC2G = 1UL<<2, // Capture/compare 2 generation
	TIM1_EGR_CC1G = 1UL<<1, // Capture/compare 1 generation
	TIM1_EGR_UG = 1UL<<0, // Update generation		
};

// TIM1->CCMR1_Output capture/compare mode register 1 (output mode)
enum {
	TIM1_CCMR1_OUTPUT_OC2CE = 1UL<<15, // Output Compare 2 clear enable
	TIM1_CCMR1_OUTPUT_OC2M = ((1UL<<3)-1) << 12, // Output Compare 2 mode
	TIM1_CCMR1_OUTPUT_OC2PE = 1UL<<11, // Output Compare 2 preload enable
	TIM1_CCMR1_OUTPUT_OC2FE = 1UL<<10, // Output Compare 2 fast enable
	TIM1_CCMR1_OUTPUT_CC2S = ((1UL<<2)-1) << 8, // Capture/Compare 2 selection
	TIM1_CCMR1_OUTPUT_OC1CE = 1UL<<7, // Output Compare 1 clear enable
	TIM1_CCMR1_OUTPUT_OC1M = ((1UL<<3)-1) << 4, // Output Compare 1 mode
	TIM1_CCMR1_OUTPUT_OC1PE = 1UL<<3, // Output Compare 1 preload enable
	TIM1_CCMR1_OUTPUT_OC1FE = 1UL<<2, // Output Compare 1 fast enable
	TIM1_CCMR1_OUTPUT_CC1S = ((1UL<<2)-1) << 0, // Capture/Compare 1 selection		
};
inline void tim1_ccmr1_output_set_oc2m(struct TIM1_Type* p, uint32_t val) { p->CCMR1_Output = (p->CCMR1_Output & ~TIM1_CCMR1_OUTPUT_OC2M) | ((val<<12) & TIM1_CCMR1_OUTPUT_OC2M); }
inline void tim1_ccmr1_output_set_cc2s(struct TIM1_Type* p, uint32_t val) { p->CCMR1_Output = (p->CCMR1_Output & ~TIM1_CCMR1_OUTPUT_CC2S) | ((val<<8) & TIM1_CCMR1_OUTPUT_CC2S); }
inline void tim1_ccmr1_output_set_oc1m(struct TIM1_Type* p, uint32_t val) { p->CCMR1_Output = (p->CCMR1_Output & ~TIM1_CCMR1_OUTPUT_OC1M) | ((val<<4) & TIM1_CCMR1_OUTPUT_OC1M); }
inline void tim1_ccmr1_output_set_cc1s(struct TIM1_Type* p, uint32_t val) { p->CCMR1_Output = (p->CCMR1_Output & ~TIM1_CCMR1_OUTPUT_CC1S) | ((val<<0) & TIM1_CCMR1_OUTPUT_CC1S); }
inline uint32_t tim1_ccmr1_output_get_oc2m(struct TIM1_Type* p) { return (p->CCMR1_Output & TIM1_CCMR1_OUTPUT_OC2M) >> 12 ; }
inline uint32_t tim1_ccmr1_output_get_cc2s(struct TIM1_Type* p) { return (p->CCMR1_Output & TIM1_CCMR1_OUTPUT_CC2S) >> 8 ; }
inline uint32_t tim1_ccmr1_output_get_oc1m(struct TIM1_Type* p) { return (p->CCMR1_Output & TIM1_CCMR1_OUTPUT_OC1M) >> 4 ; }
inline uint32_t tim1_ccmr1_output_get_cc1s(struct TIM1_Type* p) { return (p->CCMR1_Output & TIM1_CCMR1_OUTPUT_CC1S) >> 0 ; }

// TIM1->CCMR2_Output capture/compare mode register 2 (output mode)
enum {
	TIM1_CCMR2_OUTPUT_OC4CE = 1UL<<15, // Output compare 4 clear enable
	TIM1_CCMR2_OUTPUT_OC4M = ((1UL<<3)-1) << 12, // Output compare 4 mode
	TIM1_CCMR2_OUTPUT_OC4PE = 1UL<<11, // Output compare 4 preload enable
	TIM1_CCMR2_OUTPUT_OC4FE = 1UL<<10, // Output compare 4 fast enable
	TIM1_CCMR2_OUTPUT_CC4S = ((1UL<<2)-1) << 8, // Capture/Compare 4 selection
	TIM1_CCMR2_OUTPUT_OC3CE = 1UL<<7, // Output compare 3 clear enable
	TIM1_CCMR2_OUTPUT_OC3M = ((1UL<<3)-1) << 4, // Output compare 3 mode
	TIM1_CCMR2_OUTPUT_OC3PE = 1UL<<3, // Output compare 3 preload enable
	TIM1_CCMR2_OUTPUT_OC3FE = 1UL<<2, // Output compare 3 fast enable
	TIM1_CCMR2_OUTPUT_CC3S = ((1UL<<2)-1) << 0, // Capture/Compare 3 selection		
};
inline void tim1_ccmr2_output_set_oc4m(struct TIM1_Type* p, uint32_t val) { p->CCMR2_Output = (p->CCMR2_Output & ~TIM1_CCMR2_OUTPUT_OC4M) | ((val<<12) & TIM1_CCMR2_OUTPUT_OC4M); }
inline void tim1_ccmr2_output_set_cc4s(struct TIM1_Type* p, uint32_t val) { p->CCMR2_Output = (p->CCMR2_Output & ~TIM1_CCMR2_OUTPUT_CC4S) | ((val<<8) & TIM1_CCMR2_OUTPUT_CC4S); }
inline void tim1_ccmr2_output_set_oc3m(struct TIM1_Type* p, uint32_t val) { p->CCMR2_Output = (p->CCMR2_Output & ~TIM1_CCMR2_OUTPUT_OC3M) | ((val<<4) & TIM1_CCMR2_OUTPUT_OC3M); }
inline void tim1_ccmr2_output_set_cc3s(struct TIM1_Type* p, uint32_t val) { p->CCMR2_Output = (p->CCMR2_Output & ~TIM1_CCMR2_OUTPUT_CC3S) | ((val<<0) & TIM1_CCMR2_OUTPUT_CC3S); }
inline uint32_t tim1_ccmr2_output_get_oc4m(struct TIM1_Type* p) { return (p->CCMR2_Output & TIM1_CCMR2_OUTPUT_OC4M) >> 12 ; }
inline uint32_t tim1_ccmr2_output_get_cc4s(struct TIM1_Type* p) { return (p->CCMR2_Output & TIM1_CCMR2_OUTPUT_CC4S) >> 8 ; }
inline uint32_t tim1_ccmr2_output_get_oc3m(struct TIM1_Type* p) { return (p->CCMR2_Output & TIM1_CCMR2_OUTPUT_OC3M) >> 4 ; }
inline uint32_t tim1_ccmr2_output_get_cc3s(struct TIM1_Type* p) { return (p->CCMR2_Output & TIM1_CCMR2_OUTPUT_CC3S) >> 0 ; }

// TIM1->CCER capture/compare enable register
enum {
	TIM1_CCER_CC4P = 1UL<<13, // Capture/Compare 3 output Polarity
	TIM1_CCER_CC4E = 1UL<<12, // Capture/Compare 4 output enable
	TIM1_CCER_CC3NP = 1UL<<11, // Capture/Compare 3 output Polarity
	TIM1_CCER_CC3NE = 1UL<<10, // Capture/Compare 3 complementary output enable
	TIM1_CCER_CC3P = 1UL<<9, // Capture/Compare 3 output Polarity
	TIM1_CCER_CC3E = 1UL<<8, // Capture/Compare 3 output enable
	TIM1_CCER_CC2NP = 1UL<<7, // Capture/Compare 2 output Polarity
	TIM1_CCER_CC2NE = 1UL<<6, // Capture/Compare 2 complementary output enable
	TIM1_CCER_CC2P = 1UL<<5, // Capture/Compare 2 output Polarity
	TIM1_CCER_CC2E = 1UL<<4, // Capture/Compare 2 output enable
	TIM1_CCER_CC1NP = 1UL<<3, // Capture/Compare 1 output Polarity
	TIM1_CCER_CC1NE = 1UL<<2, // Capture/Compare 1 complementary output enable
	TIM1_CCER_CC1P = 1UL<<1, // Capture/Compare 1 output Polarity
	TIM1_CCER_CC1E = 1UL<<0, // Capture/Compare 1 output enable		
};

// TIM1->BDTR break and dead-time register
enum {
	TIM1_BDTR_MOE = 1UL<<15, // Main output enable
	TIM1_BDTR_AOE = 1UL<<14, // Automatic output enable
	TIM1_BDTR_BKP = 1UL<<13, // Break polarity
	TIM1_BDTR_BKE = 1UL<<12, // Break enable
	TIM1_BDTR_OSSR = 1UL<<11, // Off-state selection for Run mode
	TIM1_BDTR_OSSI = 1UL<<10, // Off-state selection for Idle mode
	TIM1_BDTR_LOCK = ((1UL<<2)-1) << 8, // Lock configuration
	TIM1_BDTR_DTG = ((1UL<<8)-1) << 0, // Dead-time generator setup		
};
inline void tim1_bdtr_set_lock(struct TIM1_Type* p, uint32_t val) { p->BDTR = (p->BDTR & ~TIM1_BDTR_LOCK) | ((val<<8) & TIM1_BDTR_LOCK); }
inline void tim1_bdtr_set_dtg(struct TIM1_Type* p, uint32_t val) { p->BDTR = (p->BDTR & ~TIM1_BDTR_DTG) | ((val<<0) & TIM1_BDTR_DTG); }
inline uint32_t tim1_bdtr_get_lock(struct TIM1_Type* p) { return (p->BDTR & TIM1_BDTR_LOCK) >> 8 ; }
inline uint32_t tim1_bdtr_get_dtg(struct TIM1_Type* p) { return (p->BDTR & TIM1_BDTR_DTG) >> 0 ; }

// TIM1->DCR DMA control register
enum {
	TIM1_DCR_DBL = ((1UL<<5)-1) << 8, // DMA burst length
	TIM1_DCR_DBA = ((1UL<<5)-1) << 0, // DMA base address		
};
inline void tim1_dcr_set_dbl(struct TIM1_Type* p, uint32_t val) { p->DCR = (p->DCR & ~TIM1_DCR_DBL) | ((val<<8) & TIM1_DCR_DBL); }
inline void tim1_dcr_set_dba(struct TIM1_Type* p, uint32_t val) { p->DCR = (p->DCR & ~TIM1_DCR_DBA) | ((val<<0) & TIM1_DCR_DBA); }
inline uint32_t tim1_dcr_get_dbl(struct TIM1_Type* p) { return (p->DCR & TIM1_DCR_DBL) >> 8 ; }
inline uint32_t tim1_dcr_get_dba(struct TIM1_Type* p) { return (p->DCR & TIM1_DCR_DBA) >> 0 ; }

// TIM1->OR1 DMA address for full transfer
enum {
	TIM1_OR1_TI1_RMP = 1UL<<4, // Input Capture 1 remap
	TIM1_OR1_ETR_ADC3_RMP = ((1UL<<2)-1) << 2, // External trigger remap on ADC3 analog watchdog
	TIM1_OR1_ETR_ADC1_RMP = ((1UL<<2)-1) << 0, // External trigger remap on ADC1 analog watchdog		
};
inline void tim1_or1_set_etr_adc3_rmp(struct TIM1_Type* p, uint32_t val) { p->OR1 = (p->OR1 & ~TIM1_OR1_ETR_ADC3_RMP) | ((val<<2) & TIM1_OR1_ETR_ADC3_RMP); }
inline void tim1_or1_set_etr_adc1_rmp(struct TIM1_Type* p, uint32_t val) { p->OR1 = (p->OR1 & ~TIM1_OR1_ETR_ADC1_RMP) | ((val<<0) & TIM1_OR1_ETR_ADC1_RMP); }
inline uint32_t tim1_or1_get_etr_adc3_rmp(struct TIM1_Type* p) { return (p->OR1 & TIM1_OR1_ETR_ADC3_RMP) >> 2 ; }
inline uint32_t tim1_or1_get_etr_adc1_rmp(struct TIM1_Type* p) { return (p->OR1 & TIM1_OR1_ETR_ADC1_RMP) >> 0 ; }

// TIM1->CCMR3_Output capture/compare mode register 2 (output mode)
enum {
	TIM1_CCMR3_OUTPUT_OC6M_BIT3 = 1UL<<24, // Output Compare 6 mode bit 3
	TIM1_CCMR3_OUTPUT_OC5M_BIT3 = ((1UL<<3)-1) << 16, // Output Compare 5 mode bit 3
	TIM1_CCMR3_OUTPUT_OC6CE = 1UL<<15, // Output compare 6 clear enable
	TIM1_CCMR3_OUTPUT_OC6M = ((1UL<<3)-1) << 12, // Output compare 6 mode
	TIM1_CCMR3_OUTPUT_OC6PE = 1UL<<11, // Output compare 6 preload enable
	TIM1_CCMR3_OUTPUT_OC6FE = 1UL<<10, // Output compare 6 fast enable
	TIM1_CCMR3_OUTPUT_OC5CE = 1UL<<7, // Output compare 5 clear enable
	TIM1_CCMR3_OUTPUT_OC5M = ((1UL<<3)-1) << 4, // Output compare 5 mode
	TIM1_CCMR3_OUTPUT_OC5PE = 1UL<<3, // Output compare 5 preload enable
	TIM1_CCMR3_OUTPUT_OC5FE = 1UL<<2, // Output compare 5 fast enable		
};
inline void tim1_ccmr3_output_set_oc5m_bit3(struct TIM1_Type* p, uint32_t val) { p->CCMR3_Output = (p->CCMR3_Output & ~TIM1_CCMR3_OUTPUT_OC5M_BIT3) | ((val<<16) & TIM1_CCMR3_OUTPUT_OC5M_BIT3); }
inline void tim1_ccmr3_output_set_oc6m(struct TIM1_Type* p, uint32_t val) { p->CCMR3_Output = (p->CCMR3_Output & ~TIM1_CCMR3_OUTPUT_OC6M) | ((val<<12) & TIM1_CCMR3_OUTPUT_OC6M); }
inline void tim1_ccmr3_output_set_oc5m(struct TIM1_Type* p, uint32_t val) { p->CCMR3_Output = (p->CCMR3_Output & ~TIM1_CCMR3_OUTPUT_OC5M) | ((val<<4) & TIM1_CCMR3_OUTPUT_OC5M); }
inline uint32_t tim1_ccmr3_output_get_oc5m_bit3(struct TIM1_Type* p) { return (p->CCMR3_Output & TIM1_CCMR3_OUTPUT_OC5M_BIT3) >> 16 ; }
inline uint32_t tim1_ccmr3_output_get_oc6m(struct TIM1_Type* p) { return (p->CCMR3_Output & TIM1_CCMR3_OUTPUT_OC6M) >> 12 ; }
inline uint32_t tim1_ccmr3_output_get_oc5m(struct TIM1_Type* p) { return (p->CCMR3_Output & TIM1_CCMR3_OUTPUT_OC5M) >> 4 ; }

// TIM1->CCR5 capture/compare register 4
enum {
	TIM1_CCR5_GC5C3 = 1UL<<31, // Group Channel 5 and Channel 3
	TIM1_CCR5_GC5C2 = 1UL<<30, // Group Channel 5 and Channel 2
	TIM1_CCR5_GC5C1 = 1UL<<29, // Group Channel 5 and Channel 1
	TIM1_CCR5_CCR5 = ((1UL<<16)-1) << 0, // Capture/Compare value		
};
inline void tim1_ccr5_set_ccr5(struct TIM1_Type* p, uint32_t val) { p->CCR5 = (p->CCR5 & ~TIM1_CCR5_CCR5) | ((val<<0) & TIM1_CCR5_CCR5); }
inline uint32_t tim1_ccr5_get_ccr5(struct TIM1_Type* p) { return (p->CCR5 & TIM1_CCR5_CCR5) >> 0 ; }

// TIM1->OR2 DMA address for full transfer
enum {
	TIM1_OR2_ETRSEL = ((1UL<<3)-1) << 14, // ETR source selection
	TIM1_OR2_BKCMP2P = 1UL<<11, // BRK COMP2 input polarity
	TIM1_OR2_BKCMP1P = 1UL<<10, // BRK COMP1 input polarity
	TIM1_OR2_BKINP = 1UL<<9, // BRK BKIN input polarity
	TIM1_OR2_BKDFBK0E = 1UL<<8, // BRK DFSDM_BREAK0 enable
	TIM1_OR2_BKCMP2E = 1UL<<2, // BRK COMP2 enable
	TIM1_OR2_BKCMP1E = 1UL<<1, // BRK COMP1 enable
	TIM1_OR2_BKINE = 1UL<<0, // BRK BKIN input enable		
};
inline void tim1_or2_set_etrsel(struct TIM1_Type* p, uint32_t val) { p->OR2 = (p->OR2 & ~TIM1_OR2_ETRSEL) | ((val<<14) & TIM1_OR2_ETRSEL); }
inline uint32_t tim1_or2_get_etrsel(struct TIM1_Type* p) { return (p->OR2 & TIM1_OR2_ETRSEL) >> 14 ; }

// TIM1->OR3 DMA address for full transfer
enum {
	TIM1_OR3_BK2CMP2P = 1UL<<11, // BRK2 COMP2 input polarity
	TIM1_OR3_BK2CMP1P = 1UL<<10, // BRK2 COMP1 input polarity
	TIM1_OR3_BK2INP = 1UL<<9, // BRK2 BKIN input polarity
	TIM1_OR3_BK2DFBK0E = 1UL<<8, // BRK2 DFSDM_BREAK0 enable
	TIM1_OR3_BK2CMP2E = 1UL<<2, // BRK2 COMP2 enable
	TIM1_OR3_BK2CMP1E = 1UL<<1, // BRK2 COMP1 enable
	TIM1_OR3_BK2INE = 1UL<<0, // BRK2 BKIN input enable		
};

// Valid Casts:
 
inline struct TIM6_Type* TIM1_as_TIM6_Type(struct TIM1_Type* p) { return (struct TIM6_Type*)p; }


/* General purpose timers */
struct TIM15_Type {
	__IO uint16_t CR1; // @0 control register 1
	 uint8_t RESERVED0[2]; // @2 
	__IO uint16_t CR2; // @4 control register 2
	 uint8_t RESERVED1[6]; // @6 
	__IO uint16_t DIER; // @12 DMA/Interrupt enable register
	 uint8_t RESERVED2[2]; // @14 
	__IO uint16_t SR; // @16 status register
	 uint8_t RESERVED3[2]; // @18 
	__O uint8_t EGR; // @20 event generation register
	 uint8_t RESERVED4[3]; // @21 
	union {  // @24
		__IO uint32_t CCMR1_Output; // capture/compare mode register (output mode)
		__IO uint8_t CCMR1_Input; // capture/compare mode register 1 (input mode)
	};
	 uint8_t RESERVED5[4]; // @28 
	__IO uint8_t CCER; // @32 capture/compare enable register
	 uint8_t RESERVED6[3]; // @33 
	__IO uint32_t CNT; // @36 counter
	__IO uint16_t PSC; // @40 prescaler
	 uint8_t RESERVED7[2]; // @42 
	__IO uint16_t ARR; // @44 auto-reload register
	 uint8_t RESERVED8[2]; // @46 
	__IO uint8_t RCR; // @48 repetition counter register
	 uint8_t RESERVED9[3]; // @49 
	__IO uint16_t CCR1; // @52 capture/compare register 1
	 uint8_t RESERVED10[14]; // @54 
	__IO uint32_t BDTR; // @68 break and dead-time register
	__IO uint16_t DCR; // @72 DMA control register
	 uint8_t RESERVED11[2]; // @74 
	__IO uint16_t DMAR; // @76 DMA address for full transfer
};

// TIM15->CR1 control register 1
enum {
	TIM15_CR1_UIFREMAP = 1UL<<11, // UIF status bit remapping
	TIM15_CR1_CKD = ((1UL<<2)-1) << 8, // Clock division
	TIM15_CR1_ARPE = 1UL<<7, // Auto-reload preload enable
	TIM15_CR1_OPM = 1UL<<3, // One-pulse mode
	TIM15_CR1_URS = 1UL<<2, // Update request source
	TIM15_CR1_UDIS = 1UL<<1, // Update disable
	TIM15_CR1_CEN = 1UL<<0, // Counter enable		
};
inline void tim15_cr1_set_ckd(struct TIM15_Type* p, uint32_t val) { p->CR1 = (p->CR1 & ~TIM15_CR1_CKD) | ((val<<8) & TIM15_CR1_CKD); }
inline uint32_t tim15_cr1_get_ckd(struct TIM15_Type* p) { return (p->CR1 & TIM15_CR1_CKD) >> 8 ; }

// TIM15->CR2 control register 2
enum {
	TIM15_CR2_OIS1N = 1UL<<9, // Output Idle state 1
	TIM15_CR2_OIS1 = 1UL<<8, // Output Idle state 1
	TIM15_CR2_CCDS = 1UL<<3, // Capture/compare DMA selection
	TIM15_CR2_CCUS = 1UL<<2, // Capture/compare control update selection
	TIM15_CR2_CCPC = 1UL<<0, // Capture/compare preloaded control		
};

// TIM15->DIER DMA/Interrupt enable register
enum {
	TIM15_DIER_TDE = 1UL<<14, // Trigger DMA request enable
	TIM15_DIER_COMDE = 1UL<<13, // COM DMA request enable
	TIM15_DIER_CC1DE = 1UL<<9, // Capture/Compare 1 DMA request enable
	TIM15_DIER_UDE = 1UL<<8, // Update DMA request enable
	TIM15_DIER_BIE = 1UL<<7, // Break interrupt enable
	TIM15_DIER_TIE = 1UL<<6, // Trigger interrupt enable
	TIM15_DIER_COMIE = 1UL<<5, // COM interrupt enable
	TIM15_DIER_CC1IE = 1UL<<1, // Capture/Compare 1 interrupt enable
	TIM15_DIER_UIE = 1UL<<0, // Update interrupt enable		
};

// TIM15->SR status register
enum {
	TIM15_SR_CC1OF = 1UL<<9, // Capture/Compare 1 overcapture flag
	TIM15_SR_BIF = 1UL<<7, // Break interrupt flag
	TIM15_SR_TIF = 1UL<<6, // Trigger interrupt flag
	TIM15_SR_COMIF = 1UL<<5, // COM interrupt flag
	TIM15_SR_CC1IF = 1UL<<1, // Capture/compare 1 interrupt flag
	TIM15_SR_UIF = 1UL<<0, // Update interrupt flag		
};

// TIM15->EGR event generation register
enum {
	TIM15_EGR_BG = 1UL<<7, // Break generation
	TIM15_EGR_TG = 1UL<<6, // Trigger generation
	TIM15_EGR_COMG = 1UL<<5, // Capture/Compare control update generation
	TIM15_EGR_CC1G = 1UL<<1, // Capture/compare 1 generation
	TIM15_EGR_UG = 1UL<<0, // Update generation		
};

// TIM15->CCMR1_Output capture/compare mode register (output mode)
enum {
	TIM15_CCMR1_OUTPUT_OC1M_2 = 1UL<<16, // Output Compare 1 mode
	TIM15_CCMR1_OUTPUT_OC1M = ((1UL<<3)-1) << 4, // Output Compare 1 mode
	TIM15_CCMR1_OUTPUT_OC1PE = 1UL<<3, // Output Compare 1 preload enable
	TIM15_CCMR1_OUTPUT_OC1FE = 1UL<<2, // Output Compare 1 fast enable
	TIM15_CCMR1_OUTPUT_CC1S = ((1UL<<2)-1) << 0, // Capture/Compare 1 selection		
};
inline void tim15_ccmr1_output_set_oc1m(struct TIM15_Type* p, uint32_t val) { p->CCMR1_Output = (p->CCMR1_Output & ~TIM15_CCMR1_OUTPUT_OC1M) | ((val<<4) & TIM15_CCMR1_OUTPUT_OC1M); }
inline void tim15_ccmr1_output_set_cc1s(struct TIM15_Type* p, uint32_t val) { p->CCMR1_Output = (p->CCMR1_Output & ~TIM15_CCMR1_OUTPUT_CC1S) | ((val<<0) & TIM15_CCMR1_OUTPUT_CC1S); }
inline uint32_t tim15_ccmr1_output_get_oc1m(struct TIM15_Type* p) { return (p->CCMR1_Output & TIM15_CCMR1_OUTPUT_OC1M) >> 4 ; }
inline uint32_t tim15_ccmr1_output_get_cc1s(struct TIM15_Type* p) { return (p->CCMR1_Output & TIM15_CCMR1_OUTPUT_CC1S) >> 0 ; }

// TIM15->CCER capture/compare enable register
enum {
	TIM15_CCER_CC1NP = 1UL<<3, // Capture/Compare 1 output Polarity
	TIM15_CCER_CC1NE = 1UL<<2, // Capture/Compare 1 complementary output enable
	TIM15_CCER_CC1P = 1UL<<1, // Capture/Compare 1 output Polarity
	TIM15_CCER_CC1E = 1UL<<0, // Capture/Compare 1 output enable		
};

// TIM15->CNT counter
enum {
	TIM15_CNT_UIFCPY = 1UL<<31, // UIF Copy
	TIM15_CNT_CNT = ((1UL<<16)-1) << 0, // counter value		
};
inline void tim15_cnt_set_cnt(struct TIM15_Type* p, uint32_t val) { p->CNT = (p->CNT & ~TIM15_CNT_CNT) | ((val<<0) & TIM15_CNT_CNT); }
inline uint32_t tim15_cnt_get_cnt(struct TIM15_Type* p) { return (p->CNT & TIM15_CNT_CNT) >> 0 ; }

// TIM15->BDTR break and dead-time register
enum {
	TIM15_BDTR_BKF = ((1UL<<4)-1) << 16, // Break filter
	TIM15_BDTR_MOE = 1UL<<15, // Main output enable
	TIM15_BDTR_AOE = 1UL<<14, // Automatic output enable
	TIM15_BDTR_BKP = 1UL<<13, // Break polarity
	TIM15_BDTR_BKE = 1UL<<12, // Break enable
	TIM15_BDTR_OSSR = 1UL<<11, // Off-state selection for Run mode
	TIM15_BDTR_OSSI = 1UL<<10, // Off-state selection for Idle mode
	TIM15_BDTR_LOCK = ((1UL<<2)-1) << 8, // Lock configuration
	TIM15_BDTR_DTG = ((1UL<<8)-1) << 0, // Dead-time generator setup		
};
inline void tim15_bdtr_set_bkf(struct TIM15_Type* p, uint32_t val) { p->BDTR = (p->BDTR & ~TIM15_BDTR_BKF) | ((val<<16) & TIM15_BDTR_BKF); }
inline void tim15_bdtr_set_lock(struct TIM15_Type* p, uint32_t val) { p->BDTR = (p->BDTR & ~TIM15_BDTR_LOCK) | ((val<<8) & TIM15_BDTR_LOCK); }
inline void tim15_bdtr_set_dtg(struct TIM15_Type* p, uint32_t val) { p->BDTR = (p->BDTR & ~TIM15_BDTR_DTG) | ((val<<0) & TIM15_BDTR_DTG); }
inline uint32_t tim15_bdtr_get_bkf(struct TIM15_Type* p) { return (p->BDTR & TIM15_BDTR_BKF) >> 16 ; }
inline uint32_t tim15_bdtr_get_lock(struct TIM15_Type* p) { return (p->BDTR & TIM15_BDTR_LOCK) >> 8 ; }
inline uint32_t tim15_bdtr_get_dtg(struct TIM15_Type* p) { return (p->BDTR & TIM15_BDTR_DTG) >> 0 ; }

// TIM15->DCR DMA control register
enum {
	TIM15_DCR_DBL = ((1UL<<5)-1) << 8, // DMA burst length
	TIM15_DCR_DBA = ((1UL<<5)-1) << 0, // DMA base address		
};
inline void tim15_dcr_set_dbl(struct TIM15_Type* p, uint32_t val) { p->DCR = (p->DCR & ~TIM15_DCR_DBL) | ((val<<8) & TIM15_DCR_DBL); }
inline void tim15_dcr_set_dba(struct TIM15_Type* p, uint32_t val) { p->DCR = (p->DCR & ~TIM15_DCR_DBA) | ((val<<0) & TIM15_DCR_DBA); }
inline uint32_t tim15_dcr_get_dbl(struct TIM15_Type* p) { return (p->DCR & TIM15_DCR_DBL) >> 8 ; }
inline uint32_t tim15_dcr_get_dba(struct TIM15_Type* p) { return (p->DCR & TIM15_DCR_DBA) >> 0 ; }

/* General purpose timers */
struct TIM16_Type {
	__IO uint16_t CR1; // @0 control register 1
	 uint8_t RESERVED0[2]; // @2 
	__IO uint16_t CR2; // @4 control register 2
	 uint8_t RESERVED1[6]; // @6 
	__IO uint16_t DIER; // @12 DMA/Interrupt enable register
	 uint8_t RESERVED2[2]; // @14 
	__IO uint16_t SR; // @16 status register
	 uint8_t RESERVED3[2]; // @18 
	__O uint8_t EGR; // @20 event generation register
	 uint8_t RESERVED4[3]; // @21 
	union {  // @24
		__IO uint32_t CCMR1_Output; // capture/compare mode register (output mode)
		__IO uint8_t CCMR1_Input; // capture/compare mode register 1 (input mode)
	};
	 uint8_t RESERVED5[4]; // @28 
	__IO uint8_t CCER; // @32 capture/compare enable register
	 uint8_t RESERVED6[3]; // @33 
	__IO uint32_t CNT; // @36 counter
	__IO uint16_t PSC; // @40 prescaler
	 uint8_t RESERVED7[2]; // @42 
	__IO uint16_t ARR; // @44 auto-reload register
	 uint8_t RESERVED8[2]; // @46 
	__IO uint8_t RCR; // @48 repetition counter register
	 uint8_t RESERVED9[3]; // @49 
	__IO uint16_t CCR1; // @52 capture/compare register 1
	 uint8_t RESERVED10[14]; // @54 
	__IO uint32_t BDTR; // @68 break and dead-time register
	__IO uint16_t DCR; // @72 DMA control register
	 uint8_t RESERVED11[2]; // @74 
	__IO uint16_t DMAR; // @76 DMA address for full transfer
	 uint8_t RESERVED12[2]; // @78 
	__IO uint8_t OR1; // @80 TIM16 option register 1
	 uint8_t RESERVED13[15]; // @81 
	__IO uint16_t OR2; // @96 TIM17 option register 1
};

// TIM16->CR1 control register 1
enum {
	TIM16_CR1_UIFREMAP = 1UL<<11, // UIF status bit remapping
	TIM16_CR1_CKD = ((1UL<<2)-1) << 8, // Clock division
	TIM16_CR1_ARPE = 1UL<<7, // Auto-reload preload enable
	TIM16_CR1_OPM = 1UL<<3, // One-pulse mode
	TIM16_CR1_URS = 1UL<<2, // Update request source
	TIM16_CR1_UDIS = 1UL<<1, // Update disable
	TIM16_CR1_CEN = 1UL<<0, // Counter enable		
};
inline void tim16_cr1_set_ckd(struct TIM16_Type* p, uint32_t val) { p->CR1 = (p->CR1 & ~TIM16_CR1_CKD) | ((val<<8) & TIM16_CR1_CKD); }
inline uint32_t tim16_cr1_get_ckd(struct TIM16_Type* p) { return (p->CR1 & TIM16_CR1_CKD) >> 8 ; }

// TIM16->CR2 control register 2
enum {
	TIM16_CR2_OIS1N = 1UL<<9, // Output Idle state 1
	TIM16_CR2_OIS1 = 1UL<<8, // Output Idle state 1
	TIM16_CR2_CCDS = 1UL<<3, // Capture/compare DMA selection
	TIM16_CR2_CCUS = 1UL<<2, // Capture/compare control update selection
	TIM16_CR2_CCPC = 1UL<<0, // Capture/compare preloaded control		
};

// TIM16->DIER DMA/Interrupt enable register
enum {
	TIM16_DIER_TDE = 1UL<<14, // Trigger DMA request enable
	TIM16_DIER_COMDE = 1UL<<13, // COM DMA request enable
	TIM16_DIER_CC1DE = 1UL<<9, // Capture/Compare 1 DMA request enable
	TIM16_DIER_UDE = 1UL<<8, // Update DMA request enable
	TIM16_DIER_BIE = 1UL<<7, // Break interrupt enable
	TIM16_DIER_TIE = 1UL<<6, // Trigger interrupt enable
	TIM16_DIER_COMIE = 1UL<<5, // COM interrupt enable
	TIM16_DIER_CC1IE = 1UL<<1, // Capture/Compare 1 interrupt enable
	TIM16_DIER_UIE = 1UL<<0, // Update interrupt enable		
};

// TIM16->SR status register
enum {
	TIM16_SR_CC1OF = 1UL<<9, // Capture/Compare 1 overcapture flag
	TIM16_SR_BIF = 1UL<<7, // Break interrupt flag
	TIM16_SR_TIF = 1UL<<6, // Trigger interrupt flag
	TIM16_SR_COMIF = 1UL<<5, // COM interrupt flag
	TIM16_SR_CC1IF = 1UL<<1, // Capture/compare 1 interrupt flag
	TIM16_SR_UIF = 1UL<<0, // Update interrupt flag		
};

// TIM16->EGR event generation register
enum {
	TIM16_EGR_BG = 1UL<<7, // Break generation
	TIM16_EGR_TG = 1UL<<6, // Trigger generation
	TIM16_EGR_COMG = 1UL<<5, // Capture/Compare control update generation
	TIM16_EGR_CC1G = 1UL<<1, // Capture/compare 1 generation
	TIM16_EGR_UG = 1UL<<0, // Update generation		
};

// TIM16->CCMR1_Output capture/compare mode register (output mode)
enum {
	TIM16_CCMR1_OUTPUT_OC1M_2 = 1UL<<16, // Output Compare 1 mode
	TIM16_CCMR1_OUTPUT_OC1M = ((1UL<<3)-1) << 4, // Output Compare 1 mode
	TIM16_CCMR1_OUTPUT_OC1PE = 1UL<<3, // Output Compare 1 preload enable
	TIM16_CCMR1_OUTPUT_OC1FE = 1UL<<2, // Output Compare 1 fast enable
	TIM16_CCMR1_OUTPUT_CC1S = ((1UL<<2)-1) << 0, // Capture/Compare 1 selection		
};
inline void tim16_ccmr1_output_set_oc1m(struct TIM16_Type* p, uint32_t val) { p->CCMR1_Output = (p->CCMR1_Output & ~TIM16_CCMR1_OUTPUT_OC1M) | ((val<<4) & TIM16_CCMR1_OUTPUT_OC1M); }
inline void tim16_ccmr1_output_set_cc1s(struct TIM16_Type* p, uint32_t val) { p->CCMR1_Output = (p->CCMR1_Output & ~TIM16_CCMR1_OUTPUT_CC1S) | ((val<<0) & TIM16_CCMR1_OUTPUT_CC1S); }
inline uint32_t tim16_ccmr1_output_get_oc1m(struct TIM16_Type* p) { return (p->CCMR1_Output & TIM16_CCMR1_OUTPUT_OC1M) >> 4 ; }
inline uint32_t tim16_ccmr1_output_get_cc1s(struct TIM16_Type* p) { return (p->CCMR1_Output & TIM16_CCMR1_OUTPUT_CC1S) >> 0 ; }

// TIM16->CCER capture/compare enable register
enum {
	TIM16_CCER_CC1NP = 1UL<<3, // Capture/Compare 1 output Polarity
	TIM16_CCER_CC1NE = 1UL<<2, // Capture/Compare 1 complementary output enable
	TIM16_CCER_CC1P = 1UL<<1, // Capture/Compare 1 output Polarity
	TIM16_CCER_CC1E = 1UL<<0, // Capture/Compare 1 output enable		
};

// TIM16->CNT counter
enum {
	TIM16_CNT_UIFCPY = 1UL<<31, // UIF Copy
	TIM16_CNT_CNT = ((1UL<<16)-1) << 0, // counter value		
};
inline void tim16_cnt_set_cnt(struct TIM16_Type* p, uint32_t val) { p->CNT = (p->CNT & ~TIM16_CNT_CNT) | ((val<<0) & TIM16_CNT_CNT); }
inline uint32_t tim16_cnt_get_cnt(struct TIM16_Type* p) { return (p->CNT & TIM16_CNT_CNT) >> 0 ; }

// TIM16->BDTR break and dead-time register
enum {
	TIM16_BDTR_BKF = ((1UL<<4)-1) << 16, // Break filter
	TIM16_BDTR_MOE = 1UL<<15, // Main output enable
	TIM16_BDTR_AOE = 1UL<<14, // Automatic output enable
	TIM16_BDTR_BKP = 1UL<<13, // Break polarity
	TIM16_BDTR_BKE = 1UL<<12, // Break enable
	TIM16_BDTR_OSSR = 1UL<<11, // Off-state selection for Run mode
	TIM16_BDTR_OSSI = 1UL<<10, // Off-state selection for Idle mode
	TIM16_BDTR_LOCK = ((1UL<<2)-1) << 8, // Lock configuration
	TIM16_BDTR_DTG = ((1UL<<8)-1) << 0, // Dead-time generator setup		
};
inline void tim16_bdtr_set_bkf(struct TIM16_Type* p, uint32_t val) { p->BDTR = (p->BDTR & ~TIM16_BDTR_BKF) | ((val<<16) & TIM16_BDTR_BKF); }
inline void tim16_bdtr_set_lock(struct TIM16_Type* p, uint32_t val) { p->BDTR = (p->BDTR & ~TIM16_BDTR_LOCK) | ((val<<8) & TIM16_BDTR_LOCK); }
inline void tim16_bdtr_set_dtg(struct TIM16_Type* p, uint32_t val) { p->BDTR = (p->BDTR & ~TIM16_BDTR_DTG) | ((val<<0) & TIM16_BDTR_DTG); }
inline uint32_t tim16_bdtr_get_bkf(struct TIM16_Type* p) { return (p->BDTR & TIM16_BDTR_BKF) >> 16 ; }
inline uint32_t tim16_bdtr_get_lock(struct TIM16_Type* p) { return (p->BDTR & TIM16_BDTR_LOCK) >> 8 ; }
inline uint32_t tim16_bdtr_get_dtg(struct TIM16_Type* p) { return (p->BDTR & TIM16_BDTR_DTG) >> 0 ; }

// TIM16->DCR DMA control register
enum {
	TIM16_DCR_DBL = ((1UL<<5)-1) << 8, // DMA burst length
	TIM16_DCR_DBA = ((1UL<<5)-1) << 0, // DMA base address		
};
inline void tim16_dcr_set_dbl(struct TIM16_Type* p, uint32_t val) { p->DCR = (p->DCR & ~TIM16_DCR_DBL) | ((val<<8) & TIM16_DCR_DBL); }
inline void tim16_dcr_set_dba(struct TIM16_Type* p, uint32_t val) { p->DCR = (p->DCR & ~TIM16_DCR_DBA) | ((val<<0) & TIM16_DCR_DBA); }
inline uint32_t tim16_dcr_get_dbl(struct TIM16_Type* p) { return (p->DCR & TIM16_DCR_DBL) >> 8 ; }
inline uint32_t tim16_dcr_get_dba(struct TIM16_Type* p) { return (p->DCR & TIM16_DCR_DBA) >> 0 ; }

// TIM16->OR1 TIM16 option register 1
enum {
	TIM16_OR1_TI1_RMP = ((1UL<<2)-1) << 0, // Input capture 1 remap		
};
inline void tim16_or1_set_ti1_rmp(struct TIM16_Type* p, uint32_t val) { p->OR1 = (p->OR1 & ~TIM16_OR1_TI1_RMP) | ((val<<0) & TIM16_OR1_TI1_RMP); }
inline uint32_t tim16_or1_get_ti1_rmp(struct TIM16_Type* p) { return (p->OR1 & TIM16_OR1_TI1_RMP) >> 0 ; }

// TIM16->OR2 TIM17 option register 1
enum {
	TIM16_OR2_BKCMP2P = 1UL<<11, // BRK COMP2 input polarit
	TIM16_OR2_BKCMP1P = 1UL<<10, // BRK COMP1 input polarity
	TIM16_OR2_BKINP = 1UL<<9, // BRK BKIN input polarity
	TIM16_OR2_BKDFBK1E = 1UL<<8, // BRK DFSDM_BREAK1 enable
	TIM16_OR2_BKCMP2E = 1UL<<2, // BRK COMP2 enable
	TIM16_OR2_BKCMP1E = 1UL<<1, // BRK COMP1 enable
	TIM16_OR2_BKINE = 1UL<<0, // BRK BKIN input enable		
};

// Valid Casts:
 
inline struct TIM15_Type* TIM16_as_TIM15_Type(struct TIM16_Type* p) { return (struct TIM15_Type*)p; }


/* General-purpose-timers */
struct TIM2_Type {
	__IO uint16_t CR1; // @0 control register 1
	 uint8_t RESERVED0[2]; // @2 
	__IO uint8_t CR2; // @4 control register 2
	 uint8_t RESERVED1[3]; // @5 
	__IO uint16_t SMCR; // @8 slave mode control register
	 uint8_t RESERVED2[2]; // @10 
	__IO uint16_t DIER; // @12 DMA/Interrupt enable register
	 uint8_t RESERVED3[2]; // @14 
	__IO uint16_t SR; // @16 status register
	 uint8_t RESERVED4[2]; // @18 
	__O uint8_t EGR; // @20 event generation register
	 uint8_t RESERVED5[3]; // @21 
	union {  // @24
		__IO uint16_t CCMR1_Output; // capture/compare mode register 1 (output mode)
		__IO uint16_t CCMR1_Input; // capture/compare mode register 1 (input mode)
	};
	 uint8_t RESERVED6[2]; // @26 
	union {  // @28
		__IO uint16_t CCMR2_Output; // capture/compare mode register 2 (output mode)
		__IO uint16_t CCMR2_Input; // capture/compare mode register 2 (input mode)
	};
	 uint8_t RESERVED7[2]; // @30 
	__IO uint16_t CCER; // @32 capture/compare enable register
	 uint8_t RESERVED8[2]; // @34 
	__IO uint32_t CNT; // @36 counter
	__IO uint16_t PSC; // @40 prescaler
	 uint8_t RESERVED9[2]; // @42 
	__IO uint32_t ARR; // @44 auto-reload register
	 uint8_t RESERVED10[4]; // @48 
	__IO uint32_t CCR1; // @52 capture/compare register 1
	__IO uint32_t CCR2; // @56 capture/compare register 2
	__IO uint32_t CCR3; // @60 capture/compare register 3
	__IO uint32_t CCR4; // @64 capture/compare register 4
	 uint8_t RESERVED11[4]; // @68 
	__IO uint16_t DCR; // @72 DMA control register
	 uint8_t RESERVED12[2]; // @74 
	__IO uint16_t DMAR; // @76 DMA address for full transfer
	 uint8_t RESERVED13[2]; // @78 
	__IO uint8_t OR; // @80 TIM2 option register
};

// TIM2->CR1 control register 1
enum {
	TIM2_CR1_CKD = ((1UL<<2)-1) << 8, // Clock division
	TIM2_CR1_ARPE = 1UL<<7, // Auto-reload preload enable
	TIM2_CR1_CMS = ((1UL<<2)-1) << 5, // Center-aligned mode selection
	TIM2_CR1_DIR = 1UL<<4, // Direction
	TIM2_CR1_OPM = 1UL<<3, // One-pulse mode
	TIM2_CR1_URS = 1UL<<2, // Update request source
	TIM2_CR1_UDIS = 1UL<<1, // Update disable
	TIM2_CR1_CEN = 1UL<<0, // Counter enable		
};
inline void tim2_cr1_set_ckd(struct TIM2_Type* p, uint32_t val) { p->CR1 = (p->CR1 & ~TIM2_CR1_CKD) | ((val<<8) & TIM2_CR1_CKD); }
inline void tim2_cr1_set_cms(struct TIM2_Type* p, uint32_t val) { p->CR1 = (p->CR1 & ~TIM2_CR1_CMS) | ((val<<5) & TIM2_CR1_CMS); }
inline uint32_t tim2_cr1_get_ckd(struct TIM2_Type* p) { return (p->CR1 & TIM2_CR1_CKD) >> 8 ; }
inline uint32_t tim2_cr1_get_cms(struct TIM2_Type* p) { return (p->CR1 & TIM2_CR1_CMS) >> 5 ; }

// TIM2->CR2 control register 2
enum {
	TIM2_CR2_TI1S = 1UL<<7, // TI1 selection
	TIM2_CR2_MMS = ((1UL<<3)-1) << 4, // Master mode selection
	TIM2_CR2_CCDS = 1UL<<3, // Capture/compare DMA selection		
};
inline void tim2_cr2_set_mms(struct TIM2_Type* p, uint32_t val) { p->CR2 = (p->CR2 & ~TIM2_CR2_MMS) | ((val<<4) & TIM2_CR2_MMS); }
inline uint32_t tim2_cr2_get_mms(struct TIM2_Type* p) { return (p->CR2 & TIM2_CR2_MMS) >> 4 ; }

// TIM2->SMCR slave mode control register
enum {
	TIM2_SMCR_ETP = 1UL<<15, // External trigger polarity
	TIM2_SMCR_ECE = 1UL<<14, // External clock enable
	TIM2_SMCR_ETPS = ((1UL<<2)-1) << 12, // External trigger prescaler
	TIM2_SMCR_ETF = ((1UL<<4)-1) << 8, // External trigger filter
	TIM2_SMCR_MSM = 1UL<<7, // Master/Slave mode
	TIM2_SMCR_TS = ((1UL<<3)-1) << 4, // Trigger selection
	TIM2_SMCR_SMS = ((1UL<<3)-1) << 0, // Slave mode selection		
};
inline void tim2_smcr_set_etps(struct TIM2_Type* p, uint32_t val) { p->SMCR = (p->SMCR & ~TIM2_SMCR_ETPS) | ((val<<12) & TIM2_SMCR_ETPS); }
inline void tim2_smcr_set_etf(struct TIM2_Type* p, uint32_t val) { p->SMCR = (p->SMCR & ~TIM2_SMCR_ETF) | ((val<<8) & TIM2_SMCR_ETF); }
inline void tim2_smcr_set_ts(struct TIM2_Type* p, uint32_t val) { p->SMCR = (p->SMCR & ~TIM2_SMCR_TS) | ((val<<4) & TIM2_SMCR_TS); }
inline void tim2_smcr_set_sms(struct TIM2_Type* p, uint32_t val) { p->SMCR = (p->SMCR & ~TIM2_SMCR_SMS) | ((val<<0) & TIM2_SMCR_SMS); }
inline uint32_t tim2_smcr_get_etps(struct TIM2_Type* p) { return (p->SMCR & TIM2_SMCR_ETPS) >> 12 ; }
inline uint32_t tim2_smcr_get_etf(struct TIM2_Type* p) { return (p->SMCR & TIM2_SMCR_ETF) >> 8 ; }
inline uint32_t tim2_smcr_get_ts(struct TIM2_Type* p) { return (p->SMCR & TIM2_SMCR_TS) >> 4 ; }
inline uint32_t tim2_smcr_get_sms(struct TIM2_Type* p) { return (p->SMCR & TIM2_SMCR_SMS) >> 0 ; }

// TIM2->DIER DMA/Interrupt enable register
enum {
	TIM2_DIER_TDE = 1UL<<14, // Trigger DMA request enable
	TIM2_DIER_COMDE = 1UL<<13, // COM DMA request enable
	TIM2_DIER_CC4DE = 1UL<<12, // Capture/Compare 4 DMA request enable
	TIM2_DIER_CC3DE = 1UL<<11, // Capture/Compare 3 DMA request enable
	TIM2_DIER_CC2DE = 1UL<<10, // Capture/Compare 2 DMA request enable
	TIM2_DIER_CC1DE = 1UL<<9, // Capture/Compare 1 DMA request enable
	TIM2_DIER_UDE = 1UL<<8, // Update DMA request enable
	TIM2_DIER_TIE = 1UL<<6, // Trigger interrupt enable
	TIM2_DIER_CC4IE = 1UL<<4, // Capture/Compare 4 interrupt enable
	TIM2_DIER_CC3IE = 1UL<<3, // Capture/Compare 3 interrupt enable
	TIM2_DIER_CC2IE = 1UL<<2, // Capture/Compare 2 interrupt enable
	TIM2_DIER_CC1IE = 1UL<<1, // Capture/Compare 1 interrupt enable
	TIM2_DIER_UIE = 1UL<<0, // Update interrupt enable		
};

// TIM2->SR status register
enum {
	TIM2_SR_CC4OF = 1UL<<12, // Capture/Compare 4 overcapture flag
	TIM2_SR_CC3OF = 1UL<<11, // Capture/Compare 3 overcapture flag
	TIM2_SR_CC2OF = 1UL<<10, // Capture/compare 2 overcapture flag
	TIM2_SR_CC1OF = 1UL<<9, // Capture/Compare 1 overcapture flag
	TIM2_SR_TIF = 1UL<<6, // Trigger interrupt flag
	TIM2_SR_CC4IF = 1UL<<4, // Capture/Compare 4 interrupt flag
	TIM2_SR_CC3IF = 1UL<<3, // Capture/Compare 3 interrupt flag
	TIM2_SR_CC2IF = 1UL<<2, // Capture/Compare 2 interrupt flag
	TIM2_SR_CC1IF = 1UL<<1, // Capture/compare 1 interrupt flag
	TIM2_SR_UIF = 1UL<<0, // Update interrupt flag		
};

// TIM2->EGR event generation register
enum {
	TIM2_EGR_TG = 1UL<<6, // Trigger generation
	TIM2_EGR_CC4G = 1UL<<4, // Capture/compare 4 generation
	TIM2_EGR_CC3G = 1UL<<3, // Capture/compare 3 generation
	TIM2_EGR_CC2G = 1UL<<2, // Capture/compare 2 generation
	TIM2_EGR_CC1G = 1UL<<1, // Capture/compare 1 generation
	TIM2_EGR_UG = 1UL<<0, // Update generation		
};

// TIM2->CCMR1_Output capture/compare mode register 1 (output mode)
enum {
	TIM2_CCMR1_OUTPUT_OC2CE = 1UL<<15, // Output compare 2 clear enable
	TIM2_CCMR1_OUTPUT_OC2M = ((1UL<<3)-1) << 12, // Output compare 2 mode
	TIM2_CCMR1_OUTPUT_OC2PE = 1UL<<11, // Output compare 2 preload enable
	TIM2_CCMR1_OUTPUT_OC2FE = 1UL<<10, // Output compare 2 fast enable
	TIM2_CCMR1_OUTPUT_CC2S = ((1UL<<2)-1) << 8, // Capture/Compare 2 selection
	TIM2_CCMR1_OUTPUT_OC1CE = 1UL<<7, // Output compare 1 clear enable
	TIM2_CCMR1_OUTPUT_OC1M = ((1UL<<3)-1) << 4, // Output compare 1 mode
	TIM2_CCMR1_OUTPUT_OC1PE = 1UL<<3, // Output compare 1 preload enable
	TIM2_CCMR1_OUTPUT_OC1FE = 1UL<<2, // Output compare 1 fast enable
	TIM2_CCMR1_OUTPUT_CC1S = ((1UL<<2)-1) << 0, // Capture/Compare 1 selection		
};
inline void tim2_ccmr1_output_set_oc2m(struct TIM2_Type* p, uint32_t val) { p->CCMR1_Output = (p->CCMR1_Output & ~TIM2_CCMR1_OUTPUT_OC2M) | ((val<<12) & TIM2_CCMR1_OUTPUT_OC2M); }
inline void tim2_ccmr1_output_set_cc2s(struct TIM2_Type* p, uint32_t val) { p->CCMR1_Output = (p->CCMR1_Output & ~TIM2_CCMR1_OUTPUT_CC2S) | ((val<<8) & TIM2_CCMR1_OUTPUT_CC2S); }
inline void tim2_ccmr1_output_set_oc1m(struct TIM2_Type* p, uint32_t val) { p->CCMR1_Output = (p->CCMR1_Output & ~TIM2_CCMR1_OUTPUT_OC1M) | ((val<<4) & TIM2_CCMR1_OUTPUT_OC1M); }
inline void tim2_ccmr1_output_set_cc1s(struct TIM2_Type* p, uint32_t val) { p->CCMR1_Output = (p->CCMR1_Output & ~TIM2_CCMR1_OUTPUT_CC1S) | ((val<<0) & TIM2_CCMR1_OUTPUT_CC1S); }
inline uint32_t tim2_ccmr1_output_get_oc2m(struct TIM2_Type* p) { return (p->CCMR1_Output & TIM2_CCMR1_OUTPUT_OC2M) >> 12 ; }
inline uint32_t tim2_ccmr1_output_get_cc2s(struct TIM2_Type* p) { return (p->CCMR1_Output & TIM2_CCMR1_OUTPUT_CC2S) >> 8 ; }
inline uint32_t tim2_ccmr1_output_get_oc1m(struct TIM2_Type* p) { return (p->CCMR1_Output & TIM2_CCMR1_OUTPUT_OC1M) >> 4 ; }
inline uint32_t tim2_ccmr1_output_get_cc1s(struct TIM2_Type* p) { return (p->CCMR1_Output & TIM2_CCMR1_OUTPUT_CC1S) >> 0 ; }

// TIM2->CCMR2_Output capture/compare mode register 2 (output mode)
enum {
	TIM2_CCMR2_OUTPUT_OC4CE = 1UL<<15, // Output compare 4 clear enable
	TIM2_CCMR2_OUTPUT_OC4M = ((1UL<<3)-1) << 12, // Output compare 4 mode
	TIM2_CCMR2_OUTPUT_OC4PE = 1UL<<11, // Output compare 4 preload enable
	TIM2_CCMR2_OUTPUT_OC4FE = 1UL<<10, // Output compare 4 fast enable
	TIM2_CCMR2_OUTPUT_CC4S = ((1UL<<2)-1) << 8, // Capture/Compare 4 selection
	TIM2_CCMR2_OUTPUT_OC3CE = 1UL<<7, // Output compare 3 clear enable
	TIM2_CCMR2_OUTPUT_OC3M = ((1UL<<3)-1) << 4, // Output compare 3 mode
	TIM2_CCMR2_OUTPUT_OC3PE = 1UL<<3, // Output compare 3 preload enable
	TIM2_CCMR2_OUTPUT_OC3FE = 1UL<<2, // Output compare 3 fast enable
	TIM2_CCMR2_OUTPUT_CC3S = ((1UL<<2)-1) << 0, // Capture/Compare 3 selection		
};
inline void tim2_ccmr2_output_set_oc4m(struct TIM2_Type* p, uint32_t val) { p->CCMR2_Output = (p->CCMR2_Output & ~TIM2_CCMR2_OUTPUT_OC4M) | ((val<<12) & TIM2_CCMR2_OUTPUT_OC4M); }
inline void tim2_ccmr2_output_set_cc4s(struct TIM2_Type* p, uint32_t val) { p->CCMR2_Output = (p->CCMR2_Output & ~TIM2_CCMR2_OUTPUT_CC4S) | ((val<<8) & TIM2_CCMR2_OUTPUT_CC4S); }
inline void tim2_ccmr2_output_set_oc3m(struct TIM2_Type* p, uint32_t val) { p->CCMR2_Output = (p->CCMR2_Output & ~TIM2_CCMR2_OUTPUT_OC3M) | ((val<<4) & TIM2_CCMR2_OUTPUT_OC3M); }
inline void tim2_ccmr2_output_set_cc3s(struct TIM2_Type* p, uint32_t val) { p->CCMR2_Output = (p->CCMR2_Output & ~TIM2_CCMR2_OUTPUT_CC3S) | ((val<<0) & TIM2_CCMR2_OUTPUT_CC3S); }
inline uint32_t tim2_ccmr2_output_get_oc4m(struct TIM2_Type* p) { return (p->CCMR2_Output & TIM2_CCMR2_OUTPUT_OC4M) >> 12 ; }
inline uint32_t tim2_ccmr2_output_get_cc4s(struct TIM2_Type* p) { return (p->CCMR2_Output & TIM2_CCMR2_OUTPUT_CC4S) >> 8 ; }
inline uint32_t tim2_ccmr2_output_get_oc3m(struct TIM2_Type* p) { return (p->CCMR2_Output & TIM2_CCMR2_OUTPUT_OC3M) >> 4 ; }
inline uint32_t tim2_ccmr2_output_get_cc3s(struct TIM2_Type* p) { return (p->CCMR2_Output & TIM2_CCMR2_OUTPUT_CC3S) >> 0 ; }

// TIM2->CCER capture/compare enable register
enum {
	TIM2_CCER_CC4NP = 1UL<<15, // Capture/Compare 4 output Polarity
	TIM2_CCER_CC4P = 1UL<<13, // Capture/Compare 3 output Polarity
	TIM2_CCER_CC4E = 1UL<<12, // Capture/Compare 4 output enable
	TIM2_CCER_CC3NP = 1UL<<11, // Capture/Compare 3 output Polarity
	TIM2_CCER_CC3P = 1UL<<9, // Capture/Compare 3 output Polarity
	TIM2_CCER_CC3E = 1UL<<8, // Capture/Compare 3 output enable
	TIM2_CCER_CC2NP = 1UL<<7, // Capture/Compare 2 output Polarity
	TIM2_CCER_CC2P = 1UL<<5, // Capture/Compare 2 output Polarity
	TIM2_CCER_CC2E = 1UL<<4, // Capture/Compare 2 output enable
	TIM2_CCER_CC1NP = 1UL<<3, // Capture/Compare 1 output Polarity
	TIM2_CCER_CC1P = 1UL<<1, // Capture/Compare 1 output Polarity
	TIM2_CCER_CC1E = 1UL<<0, // Capture/Compare 1 output enable		
};

// TIM2->CNT counter
enum {
	TIM2_CNT_CNT_H = ((1UL<<16)-1) << 16, // High counter value (TIM2 only)
	TIM2_CNT_CNT_L = ((1UL<<16)-1) << 0, // Low counter value		
};
inline void tim2_cnt_set_cnt_h(struct TIM2_Type* p, uint32_t val) { p->CNT = (p->CNT & ~TIM2_CNT_CNT_H) | ((val<<16) & TIM2_CNT_CNT_H); }
inline void tim2_cnt_set_cnt_l(struct TIM2_Type* p, uint32_t val) { p->CNT = (p->CNT & ~TIM2_CNT_CNT_L) | ((val<<0) & TIM2_CNT_CNT_L); }
inline uint32_t tim2_cnt_get_cnt_h(struct TIM2_Type* p) { return (p->CNT & TIM2_CNT_CNT_H) >> 16 ; }
inline uint32_t tim2_cnt_get_cnt_l(struct TIM2_Type* p) { return (p->CNT & TIM2_CNT_CNT_L) >> 0 ; }

// TIM2->ARR auto-reload register
enum {
	TIM2_ARR_ARR_H = ((1UL<<16)-1) << 16, // High Auto-reload value (TIM2 only)
	TIM2_ARR_ARR_L = ((1UL<<16)-1) << 0, // Low Auto-reload value		
};
inline void tim2_arr_set_arr_h(struct TIM2_Type* p, uint32_t val) { p->ARR = (p->ARR & ~TIM2_ARR_ARR_H) | ((val<<16) & TIM2_ARR_ARR_H); }
inline void tim2_arr_set_arr_l(struct TIM2_Type* p, uint32_t val) { p->ARR = (p->ARR & ~TIM2_ARR_ARR_L) | ((val<<0) & TIM2_ARR_ARR_L); }
inline uint32_t tim2_arr_get_arr_h(struct TIM2_Type* p) { return (p->ARR & TIM2_ARR_ARR_H) >> 16 ; }
inline uint32_t tim2_arr_get_arr_l(struct TIM2_Type* p) { return (p->ARR & TIM2_ARR_ARR_L) >> 0 ; }

// TIM2->CCR1 capture/compare register 1
enum {
	TIM2_CCR1_CCR1_H = ((1UL<<16)-1) << 16, // High Capture/Compare 1 value (TIM2 only)
	TIM2_CCR1_CCR1_L = ((1UL<<16)-1) << 0, // Low Capture/Compare 1 value		
};
inline void tim2_ccr1_set_ccr1_h(struct TIM2_Type* p, uint32_t val) { p->CCR1 = (p->CCR1 & ~TIM2_CCR1_CCR1_H) | ((val<<16) & TIM2_CCR1_CCR1_H); }
inline void tim2_ccr1_set_ccr1_l(struct TIM2_Type* p, uint32_t val) { p->CCR1 = (p->CCR1 & ~TIM2_CCR1_CCR1_L) | ((val<<0) & TIM2_CCR1_CCR1_L); }
inline uint32_t tim2_ccr1_get_ccr1_h(struct TIM2_Type* p) { return (p->CCR1 & TIM2_CCR1_CCR1_H) >> 16 ; }
inline uint32_t tim2_ccr1_get_ccr1_l(struct TIM2_Type* p) { return (p->CCR1 & TIM2_CCR1_CCR1_L) >> 0 ; }

// TIM2->CCR2 capture/compare register 2
enum {
	TIM2_CCR2_CCR2_H = ((1UL<<16)-1) << 16, // High Capture/Compare 2 value (TIM2 only)
	TIM2_CCR2_CCR2_L = ((1UL<<16)-1) << 0, // Low Capture/Compare 2 value		
};
inline void tim2_ccr2_set_ccr2_h(struct TIM2_Type* p, uint32_t val) { p->CCR2 = (p->CCR2 & ~TIM2_CCR2_CCR2_H) | ((val<<16) & TIM2_CCR2_CCR2_H); }
inline void tim2_ccr2_set_ccr2_l(struct TIM2_Type* p, uint32_t val) { p->CCR2 = (p->CCR2 & ~TIM2_CCR2_CCR2_L) | ((val<<0) & TIM2_CCR2_CCR2_L); }
inline uint32_t tim2_ccr2_get_ccr2_h(struct TIM2_Type* p) { return (p->CCR2 & TIM2_CCR2_CCR2_H) >> 16 ; }
inline uint32_t tim2_ccr2_get_ccr2_l(struct TIM2_Type* p) { return (p->CCR2 & TIM2_CCR2_CCR2_L) >> 0 ; }

// TIM2->CCR3 capture/compare register 3
enum {
	TIM2_CCR3_CCR3_H = ((1UL<<16)-1) << 16, // High Capture/Compare value (TIM2 only)
	TIM2_CCR3_CCR3_L = ((1UL<<16)-1) << 0, // Low Capture/Compare value		
};
inline void tim2_ccr3_set_ccr3_h(struct TIM2_Type* p, uint32_t val) { p->CCR3 = (p->CCR3 & ~TIM2_CCR3_CCR3_H) | ((val<<16) & TIM2_CCR3_CCR3_H); }
inline void tim2_ccr3_set_ccr3_l(struct TIM2_Type* p, uint32_t val) { p->CCR3 = (p->CCR3 & ~TIM2_CCR3_CCR3_L) | ((val<<0) & TIM2_CCR3_CCR3_L); }
inline uint32_t tim2_ccr3_get_ccr3_h(struct TIM2_Type* p) { return (p->CCR3 & TIM2_CCR3_CCR3_H) >> 16 ; }
inline uint32_t tim2_ccr3_get_ccr3_l(struct TIM2_Type* p) { return (p->CCR3 & TIM2_CCR3_CCR3_L) >> 0 ; }

// TIM2->CCR4 capture/compare register 4
enum {
	TIM2_CCR4_CCR4_H = ((1UL<<16)-1) << 16, // High Capture/Compare value (TIM2 only)
	TIM2_CCR4_CCR4_L = ((1UL<<16)-1) << 0, // Low Capture/Compare value		
};
inline void tim2_ccr4_set_ccr4_h(struct TIM2_Type* p, uint32_t val) { p->CCR4 = (p->CCR4 & ~TIM2_CCR4_CCR4_H) | ((val<<16) & TIM2_CCR4_CCR4_H); }
inline void tim2_ccr4_set_ccr4_l(struct TIM2_Type* p, uint32_t val) { p->CCR4 = (p->CCR4 & ~TIM2_CCR4_CCR4_L) | ((val<<0) & TIM2_CCR4_CCR4_L); }
inline uint32_t tim2_ccr4_get_ccr4_h(struct TIM2_Type* p) { return (p->CCR4 & TIM2_CCR4_CCR4_H) >> 16 ; }
inline uint32_t tim2_ccr4_get_ccr4_l(struct TIM2_Type* p) { return (p->CCR4 & TIM2_CCR4_CCR4_L) >> 0 ; }

// TIM2->DCR DMA control register
enum {
	TIM2_DCR_DBL = ((1UL<<5)-1) << 8, // DMA burst length
	TIM2_DCR_DBA = ((1UL<<5)-1) << 0, // DMA base address		
};
inline void tim2_dcr_set_dbl(struct TIM2_Type* p, uint32_t val) { p->DCR = (p->DCR & ~TIM2_DCR_DBL) | ((val<<8) & TIM2_DCR_DBL); }
inline void tim2_dcr_set_dba(struct TIM2_Type* p, uint32_t val) { p->DCR = (p->DCR & ~TIM2_DCR_DBA) | ((val<<0) & TIM2_DCR_DBA); }
inline uint32_t tim2_dcr_get_dbl(struct TIM2_Type* p) { return (p->DCR & TIM2_DCR_DBL) >> 8 ; }
inline uint32_t tim2_dcr_get_dba(struct TIM2_Type* p) { return (p->DCR & TIM2_DCR_DBA) >> 0 ; }

// TIM2->OR TIM2 option register
enum {
	TIM2_OR_TI4_RMP = ((1UL<<2)-1) << 3, // Internal trigger
	TIM2_OR_ETR_RMP = ((1UL<<3)-1) << 0, // Timer2 ETR remap		
};
inline void tim2_or_set_ti4_rmp(struct TIM2_Type* p, uint32_t val) { p->OR = (p->OR & ~TIM2_OR_TI4_RMP) | ((val<<3) & TIM2_OR_TI4_RMP); }
inline void tim2_or_set_etr_rmp(struct TIM2_Type* p, uint32_t val) { p->OR = (p->OR & ~TIM2_OR_ETR_RMP) | ((val<<0) & TIM2_OR_ETR_RMP); }
inline uint32_t tim2_or_get_ti4_rmp(struct TIM2_Type* p) { return (p->OR & TIM2_OR_TI4_RMP) >> 3 ; }
inline uint32_t tim2_or_get_etr_rmp(struct TIM2_Type* p) { return (p->OR & TIM2_OR_ETR_RMP) >> 0 ; }


/* Basic-timers */
struct TIM6_Type {
	__IO uint8_t CR1; // @0 control register 1
	 uint8_t RESERVED0[3]; // @1 
	__IO uint8_t CR2; // @4 control register 2
	 uint8_t RESERVED1[7]; // @5 
	__IO uint16_t DIER; // @12 DMA/Interrupt enable register
	 uint8_t RESERVED2[2]; // @14 
	__IO uint8_t SR; // @16 status register
	 uint8_t RESERVED3[3]; // @17 
	__O uint8_t EGR; // @20 event generation register
	 uint8_t RESERVED4[15]; // @21 
	__IO uint16_t CNT; // @36 counter
	 uint8_t RESERVED5[2]; // @38 
	__IO uint16_t PSC; // @40 prescaler
	 uint8_t RESERVED6[2]; // @42 
	__IO uint16_t ARR; // @44 auto-reload register
};

// TIM6->CR1 control register 1
enum {
	TIM6_CR1_ARPE = 1UL<<7, // Auto-reload preload enable
	TIM6_CR1_OPM = 1UL<<3, // One-pulse mode
	TIM6_CR1_URS = 1UL<<2, // Update request source
	TIM6_CR1_UDIS = 1UL<<1, // Update disable
	TIM6_CR1_CEN = 1UL<<0, // Counter enable		
};

// TIM6->CR2 control register 2
enum {
	TIM6_CR2_MMS = ((1UL<<3)-1) << 4, // Master mode selection		
};
inline void tim6_cr2_set_mms(struct TIM6_Type* p, uint32_t val) { p->CR2 = (p->CR2 & ~TIM6_CR2_MMS) | ((val<<4) & TIM6_CR2_MMS); }
inline uint32_t tim6_cr2_get_mms(struct TIM6_Type* p) { return (p->CR2 & TIM6_CR2_MMS) >> 4 ; }

// TIM6->DIER DMA/Interrupt enable register
enum {
	TIM6_DIER_UDE = 1UL<<8, // Update DMA request enable
	TIM6_DIER_UIE = 1UL<<0, // Update interrupt enable		
};

// TIM6->SR status register
enum {
	TIM6_SR_UIF = 1UL<<0, // Update interrupt flag		
};

// TIM6->EGR event generation register
enum {
	TIM6_EGR_UG = 1UL<<0, // Update generation		
};


/* Touch sensing controller */
struct TSC_Type {
	__IO uint32_t CR; // @0 control register
	__IO uint8_t IER; // @4 interrupt enable register
	 uint8_t RESERVED0[3]; // @5 
	__IO uint8_t ICR; // @8 interrupt clear register
	 uint8_t RESERVED1[3]; // @9 
	__IO uint8_t ISR; // @12 interrupt status register
	 uint8_t RESERVED2[3]; // @13 
	__IO uint32_t IOHCR; // @16 I/O hysteresis control register
	 uint8_t RESERVED3[4]; // @20 
	__IO uint32_t IOASCR; // @24 I/O analog switch control register
	 uint8_t RESERVED4[4]; // @28 
	__IO uint32_t IOSCR; // @32 I/O sampling control register
	 uint8_t RESERVED5[4]; // @36 
	__IO uint32_t IOCCR; // @40 I/O channel control register
	 uint8_t RESERVED6[4]; // @44 
	__IO uint32_t IOGCSR; // @48 I/O group control status register
	__I uint16_t IOG1CR; // @52 I/O group x counter register
	 uint8_t RESERVED7[2]; // @54 
	__I uint16_t IOG2CR; // @56 I/O group x counter register
	 uint8_t RESERVED8[2]; // @58 
	__I uint16_t IOG3CR; // @60 I/O group x counter register
	 uint8_t RESERVED9[2]; // @62 
	__I uint16_t IOG4CR; // @64 I/O group x counter register
	 uint8_t RESERVED10[2]; // @66 
	__I uint16_t IOG5CR; // @68 I/O group x counter register
	 uint8_t RESERVED11[2]; // @70 
	__I uint16_t IOG6CR; // @72 I/O group x counter register
	 uint8_t RESERVED12[2]; // @74 
	__I uint16_t IOG7CR; // @76 I/O group x counter register
	 uint8_t RESERVED13[2]; // @78 
	__I uint16_t IOG8CR; // @80 I/O group x counter register
};

// TSC->CR control register
enum {
	TSC_CR_CTPH = ((1UL<<4)-1) << 28, // Charge transfer pulse high
	TSC_CR_CTPL = ((1UL<<4)-1) << 24, // Charge transfer pulse low
	TSC_CR_SSD = ((1UL<<7)-1) << 17, // Spread spectrum deviation
	TSC_CR_SSE = 1UL<<16, // Spread spectrum enable
	TSC_CR_SSPSC = 1UL<<15, // Spread spectrum prescaler
	TSC_CR_PGPSC = ((1UL<<3)-1) << 12, // pulse generator prescaler
	TSC_CR_MCV = ((1UL<<3)-1) << 5, // Max count value
	TSC_CR_IODEF = 1UL<<4, // I/O Default mode
	TSC_CR_SYNCPOL = 1UL<<3, // Synchronization pin polarity
	TSC_CR_AM = 1UL<<2, // Acquisition mode
	TSC_CR_START = 1UL<<1, // Start a new acquisition
	TSC_CR_TSCE = 1UL<<0, // Touch sensing controller enable		
};
inline void tsc_cr_set_ctph(struct TSC_Type* p, uint32_t val) { p->CR = (p->CR & ~TSC_CR_CTPH) | ((val<<28) & TSC_CR_CTPH); }
inline void tsc_cr_set_ctpl(struct TSC_Type* p, uint32_t val) { p->CR = (p->CR & ~TSC_CR_CTPL) | ((val<<24) & TSC_CR_CTPL); }
inline void tsc_cr_set_ssd(struct TSC_Type* p, uint32_t val) { p->CR = (p->CR & ~TSC_CR_SSD) | ((val<<17) & TSC_CR_SSD); }
inline void tsc_cr_set_pgpsc(struct TSC_Type* p, uint32_t val) { p->CR = (p->CR & ~TSC_CR_PGPSC) | ((val<<12) & TSC_CR_PGPSC); }
inline void tsc_cr_set_mcv(struct TSC_Type* p, uint32_t val) { p->CR = (p->CR & ~TSC_CR_MCV) | ((val<<5) & TSC_CR_MCV); }
inline uint32_t tsc_cr_get_ctph(struct TSC_Type* p) { return (p->CR & TSC_CR_CTPH) >> 28 ; }
inline uint32_t tsc_cr_get_ctpl(struct TSC_Type* p) { return (p->CR & TSC_CR_CTPL) >> 24 ; }
inline uint32_t tsc_cr_get_ssd(struct TSC_Type* p) { return (p->CR & TSC_CR_SSD) >> 17 ; }
inline uint32_t tsc_cr_get_pgpsc(struct TSC_Type* p) { return (p->CR & TSC_CR_PGPSC) >> 12 ; }
inline uint32_t tsc_cr_get_mcv(struct TSC_Type* p) { return (p->CR & TSC_CR_MCV) >> 5 ; }

// TSC->IER interrupt enable register
enum {
	TSC_IER_MCEIE = 1UL<<1, // Max count error interrupt enable
	TSC_IER_EOAIE = 1UL<<0, // End of acquisition interrupt enable		
};

// TSC->ICR interrupt clear register
enum {
	TSC_ICR_MCEIC = 1UL<<1, // Max count error interrupt clear
	TSC_ICR_EOAIC = 1UL<<0, // End of acquisition interrupt clear		
};

// TSC->ISR interrupt status register
enum {
	TSC_ISR_MCEF = 1UL<<1, // Max count error flag
	TSC_ISR_EOAF = 1UL<<0, // End of acquisition flag		
};

// TSC->IOGCSR I/O group control status register
enum {
	TSC_IOGCSR_G8S = 1UL<<23, // Analog I/O group x status
	TSC_IOGCSR_G7S = 1UL<<22, // Analog I/O group x status
	TSC_IOGCSR_G6S = 1UL<<21, // Analog I/O group x status
	TSC_IOGCSR_G5S = 1UL<<20, // Analog I/O group x status
	TSC_IOGCSR_G4S = 1UL<<19, // Analog I/O group x status
	TSC_IOGCSR_G3S = 1UL<<18, // Analog I/O group x status
	TSC_IOGCSR_G2S = 1UL<<17, // Analog I/O group x status
	TSC_IOGCSR_G1S = 1UL<<16, // Analog I/O group x status
	TSC_IOGCSR_G8E = 1UL<<7, // Analog I/O group x enable
	TSC_IOGCSR_G7E = 1UL<<6, // Analog I/O group x enable
	TSC_IOGCSR_G6E = 1UL<<5, // Analog I/O group x enable
	TSC_IOGCSR_G5E = 1UL<<4, // Analog I/O group x enable
	TSC_IOGCSR_G4E = 1UL<<3, // Analog I/O group x enable
	TSC_IOGCSR_G3E = 1UL<<2, // Analog I/O group x enable
	TSC_IOGCSR_G2E = 1UL<<1, // Analog I/O group x enable
	TSC_IOGCSR_G1E = 1UL<<0, // Analog I/O group x enable		
};

// TSC->IOG1CR I/O group x counter register
enum {
	TSC_IOG1CR_CNT = ((1UL<<14)-1) << 0, // Counter value		
};
inline uint32_t tsc_iog1cr_get_cnt(struct TSC_Type* p) { return (p->IOG1CR & TSC_IOG1CR_CNT) >> 0 ; }

// TSC->IOG2CR I/O group x counter register
enum {
	TSC_IOG2CR_CNT = ((1UL<<14)-1) << 0, // Counter value		
};
inline uint32_t tsc_iog2cr_get_cnt(struct TSC_Type* p) { return (p->IOG2CR & TSC_IOG2CR_CNT) >> 0 ; }

// TSC->IOG3CR I/O group x counter register
enum {
	TSC_IOG3CR_CNT = ((1UL<<14)-1) << 0, // Counter value		
};
inline uint32_t tsc_iog3cr_get_cnt(struct TSC_Type* p) { return (p->IOG3CR & TSC_IOG3CR_CNT) >> 0 ; }

// TSC->IOG4CR I/O group x counter register
enum {
	TSC_IOG4CR_CNT = ((1UL<<14)-1) << 0, // Counter value		
};
inline uint32_t tsc_iog4cr_get_cnt(struct TSC_Type* p) { return (p->IOG4CR & TSC_IOG4CR_CNT) >> 0 ; }

// TSC->IOG5CR I/O group x counter register
enum {
	TSC_IOG5CR_CNT = ((1UL<<14)-1) << 0, // Counter value		
};
inline uint32_t tsc_iog5cr_get_cnt(struct TSC_Type* p) { return (p->IOG5CR & TSC_IOG5CR_CNT) >> 0 ; }

// TSC->IOG6CR I/O group x counter register
enum {
	TSC_IOG6CR_CNT = ((1UL<<14)-1) << 0, // Counter value		
};
inline uint32_t tsc_iog6cr_get_cnt(struct TSC_Type* p) { return (p->IOG6CR & TSC_IOG6CR_CNT) >> 0 ; }

// TSC->IOG7CR I/O group x counter register
enum {
	TSC_IOG7CR_CNT = ((1UL<<14)-1) << 0, // Counter value		
};
inline uint32_t tsc_iog7cr_get_cnt(struct TSC_Type* p) { return (p->IOG7CR & TSC_IOG7CR_CNT) >> 0 ; }

// TSC->IOG8CR I/O group x counter register
enum {
	TSC_IOG8CR_CNT = ((1UL<<14)-1) << 0, // Counter value		
};
inline uint32_t tsc_iog8cr_get_cnt(struct TSC_Type* p) { return (p->IOG8CR & TSC_IOG8CR_CNT) >> 0 ; }


/* Universal synchronous asynchronous receiver transmitter */
struct USART1_Type {
	__IO uint32_t CR1; // @0 Control register 1
	__IO uint32_t CR2; // @4 Control register 2
	__IO uint32_t CR3; // @8 Control register 3
	__IO uint16_t BRR; // @12 Baud rate register
	 uint8_t RESERVED0[2]; // @14 
	__IO uint16_t GTPR; // @16 Guard time and prescaler register
	 uint8_t RESERVED1[2]; // @18 
	__IO uint32_t RTOR; // @20 Receiver timeout register
	__O uint8_t RQR; // @24 Request register
	 uint8_t RESERVED2[3]; // @25 
	__I uint32_t ISR; // @28 Interrupt & status register
	__O uint32_t ICR; // @32 Interrupt flag clear register
	__I uint16_t RDR; // @36 Receive data register
	 uint8_t RESERVED3[2]; // @38 
	__IO uint16_t TDR; // @40 Transmit data register
};

// USART1->CR1 Control register 1
enum {
	USART1_CR1_M1 = 1UL<<28, // Word length
	USART1_CR1_EOBIE = 1UL<<27, // End of Block interrupt enable
	USART1_CR1_RTOIE = 1UL<<26, // Receiver timeout interrupt enable
	USART1_CR1_DEAT = ((1UL<<5)-1) << 21, // DEAT0
	USART1_CR1_DEDT = ((1UL<<5)-1) << 16, // DEDT0
	USART1_CR1_OVER8 = 1UL<<15, // Oversampling mode
	USART1_CR1_CMIE = 1UL<<14, // Character match interrupt enable
	USART1_CR1_MME = 1UL<<13, // Mute mode enable
	USART1_CR1_M0 = 1UL<<12, // Word length
	USART1_CR1_WAKE = 1UL<<11, // Receiver wakeup method
	USART1_CR1_PCE = 1UL<<10, // Parity control enable
	USART1_CR1_PS = 1UL<<9, // Parity selection
	USART1_CR1_PEIE = 1UL<<8, // PE interrupt enable
	USART1_CR1_TXEIE = 1UL<<7, // interrupt enable
	USART1_CR1_TCIE = 1UL<<6, // Transmission complete interrupt enable
	USART1_CR1_RXNEIE = 1UL<<5, // RXNE interrupt enable
	USART1_CR1_IDLEIE = 1UL<<4, // IDLE interrupt enable
	USART1_CR1_TE = 1UL<<3, // Transmitter enable
	USART1_CR1_RE = 1UL<<2, // Receiver enable
	USART1_CR1_UESM = 1UL<<1, // USART enable in Stop mode
	USART1_CR1_UE = 1UL<<0, // USART enable		
};
inline void usart1_cr1_set_deat(struct USART1_Type* p, uint32_t val) { p->CR1 = (p->CR1 & ~USART1_CR1_DEAT) | ((val<<21) & USART1_CR1_DEAT); }
inline void usart1_cr1_set_dedt(struct USART1_Type* p, uint32_t val) { p->CR1 = (p->CR1 & ~USART1_CR1_DEDT) | ((val<<16) & USART1_CR1_DEDT); }
inline uint32_t usart1_cr1_get_deat(struct USART1_Type* p) { return (p->CR1 & USART1_CR1_DEAT) >> 21 ; }
inline uint32_t usart1_cr1_get_dedt(struct USART1_Type* p) { return (p->CR1 & USART1_CR1_DEDT) >> 16 ; }

// USART1->CR2 Control register 2
enum {
	USART1_CR2_ADD = ((1UL<<8)-1) << 24, // Address of the USART node
	USART1_CR2_RTOEN = 1UL<<23, // Receiver timeout enable
	USART1_CR2_ABRMOD = ((1UL<<2)-1) << 21, // Auto baud rate mode
	USART1_CR2_ABREN = 1UL<<20, // Auto baud rate enable
	USART1_CR2_MSBFIRST = 1UL<<19, // Most significant bit first
	USART1_CR2_TAINV = 1UL<<18, // Binary data inversion
	USART1_CR2_TXINV = 1UL<<17, // TX pin active level inversion
	USART1_CR2_RXINV = 1UL<<16, // RX pin active level inversion
	USART1_CR2_SWAP = 1UL<<15, // Swap TX/RX pins
	USART1_CR2_LINEN = 1UL<<14, // LIN mode enable
	USART1_CR2_STOP = ((1UL<<2)-1) << 12, // STOP bits
	USART1_CR2_CLKEN = 1UL<<11, // Clock enable
	USART1_CR2_CPOL = 1UL<<10, // Clock polarity
	USART1_CR2_CPHA = 1UL<<9, // Clock phase
	USART1_CR2_LBCL = 1UL<<8, // Last bit clock pulse
	USART1_CR2_LBDIE = 1UL<<6, // LIN break detection interrupt enable
	USART1_CR2_LBDL = 1UL<<5, // LIN break detection length
	USART1_CR2_ADDM7 = 1UL<<4, // 7-bit Address Detection/4-bit Address Detection		
};
inline void usart1_cr2_set_add(struct USART1_Type* p, uint32_t val) { p->CR2 = (p->CR2 & ~USART1_CR2_ADD) | ((val<<24) & USART1_CR2_ADD); }
inline void usart1_cr2_set_abrmod(struct USART1_Type* p, uint32_t val) { p->CR2 = (p->CR2 & ~USART1_CR2_ABRMOD) | ((val<<21) & USART1_CR2_ABRMOD); }
inline void usart1_cr2_set_stop(struct USART1_Type* p, uint32_t val) { p->CR2 = (p->CR2 & ~USART1_CR2_STOP) | ((val<<12) & USART1_CR2_STOP); }
inline uint32_t usart1_cr2_get_add(struct USART1_Type* p) { return (p->CR2 & USART1_CR2_ADD) >> 24 ; }
inline uint32_t usart1_cr2_get_abrmod(struct USART1_Type* p) { return (p->CR2 & USART1_CR2_ABRMOD) >> 21 ; }
inline uint32_t usart1_cr2_get_stop(struct USART1_Type* p) { return (p->CR2 & USART1_CR2_STOP) >> 12 ; }

// USART1->CR3 Control register 3
enum {
	USART1_CR3_WUFIE = 1UL<<22, // Wakeup from Stop mode interrupt enable
	USART1_CR3_WUS = ((1UL<<2)-1) << 20, // Wakeup from Stop mode interrupt flag selection
	USART1_CR3_SCARCNT = ((1UL<<3)-1) << 17, // Smartcard auto-retry count
	USART1_CR3_DEP = 1UL<<15, // Driver enable polarity selection
	USART1_CR3_DEM = 1UL<<14, // Driver enable mode
	USART1_CR3_DDRE = 1UL<<13, // DMA Disable on Reception Error
	USART1_CR3_OVRDIS = 1UL<<12, // Overrun Disable
	USART1_CR3_ONEBIT = 1UL<<11, // One sample bit method enable
	USART1_CR3_CTSIE = 1UL<<10, // CTS interrupt enable
	USART1_CR3_CTSE = 1UL<<9, // CTS enable
	USART1_CR3_RTSE = 1UL<<8, // RTS enable
	USART1_CR3_DMAT = 1UL<<7, // DMA enable transmitter
	USART1_CR3_DMAR = 1UL<<6, // DMA enable receiver
	USART1_CR3_SCEN = 1UL<<5, // Smartcard mode enable
	USART1_CR3_NACK = 1UL<<4, // Smartcard NACK enable
	USART1_CR3_HDSEL = 1UL<<3, // Half-duplex selection
	USART1_CR3_IRLP = 1UL<<2, // Ir low-power
	USART1_CR3_IREN = 1UL<<1, // Ir mode enable
	USART1_CR3_EIE = 1UL<<0, // Error interrupt enable		
};
inline void usart1_cr3_set_wus(struct USART1_Type* p, uint32_t val) { p->CR3 = (p->CR3 & ~USART1_CR3_WUS) | ((val<<20) & USART1_CR3_WUS); }
inline void usart1_cr3_set_scarcnt(struct USART1_Type* p, uint32_t val) { p->CR3 = (p->CR3 & ~USART1_CR3_SCARCNT) | ((val<<17) & USART1_CR3_SCARCNT); }
inline uint32_t usart1_cr3_get_wus(struct USART1_Type* p) { return (p->CR3 & USART1_CR3_WUS) >> 20 ; }
inline uint32_t usart1_cr3_get_scarcnt(struct USART1_Type* p) { return (p->CR3 & USART1_CR3_SCARCNT) >> 17 ; }

// USART1->BRR Baud rate register
enum {
	USART1_BRR_DIV_MANTISSA = ((1UL<<12)-1) << 4, // DIV_Mantissa
	USART1_BRR_DIV_FRACTION = ((1UL<<4)-1) << 0, // DIV_Fraction		
};
inline void usart1_brr_set_div_mantissa(struct USART1_Type* p, uint32_t val) { p->BRR = (p->BRR & ~USART1_BRR_DIV_MANTISSA) | ((val<<4) & USART1_BRR_DIV_MANTISSA); }
inline void usart1_brr_set_div_fraction(struct USART1_Type* p, uint32_t val) { p->BRR = (p->BRR & ~USART1_BRR_DIV_FRACTION) | ((val<<0) & USART1_BRR_DIV_FRACTION); }
inline uint32_t usart1_brr_get_div_mantissa(struct USART1_Type* p) { return (p->BRR & USART1_BRR_DIV_MANTISSA) >> 4 ; }
inline uint32_t usart1_brr_get_div_fraction(struct USART1_Type* p) { return (p->BRR & USART1_BRR_DIV_FRACTION) >> 0 ; }

// USART1->GTPR Guard time and prescaler register
enum {
	USART1_GTPR_GT = ((1UL<<8)-1) << 8, // Guard time value
	USART1_GTPR_PSC = ((1UL<<8)-1) << 0, // Prescaler value		
};
inline void usart1_gtpr_set_gt(struct USART1_Type* p, uint32_t val) { p->GTPR = (p->GTPR & ~USART1_GTPR_GT) | ((val<<8) & USART1_GTPR_GT); }
inline void usart1_gtpr_set_psc(struct USART1_Type* p, uint32_t val) { p->GTPR = (p->GTPR & ~USART1_GTPR_PSC) | ((val<<0) & USART1_GTPR_PSC); }
inline uint32_t usart1_gtpr_get_gt(struct USART1_Type* p) { return (p->GTPR & USART1_GTPR_GT) >> 8 ; }
inline uint32_t usart1_gtpr_get_psc(struct USART1_Type* p) { return (p->GTPR & USART1_GTPR_PSC) >> 0 ; }

// USART1->RTOR Receiver timeout register
enum {
	USART1_RTOR_BLEN = ((1UL<<8)-1) << 24, // Block Length
	USART1_RTOR_RTO = ((1UL<<24)-1) << 0, // Receiver timeout value		
};
inline void usart1_rtor_set_blen(struct USART1_Type* p, uint32_t val) { p->RTOR = (p->RTOR & ~USART1_RTOR_BLEN) | ((val<<24) & USART1_RTOR_BLEN); }
inline void usart1_rtor_set_rto(struct USART1_Type* p, uint32_t val) { p->RTOR = (p->RTOR & ~USART1_RTOR_RTO) | ((val<<0) & USART1_RTOR_RTO); }
inline uint32_t usart1_rtor_get_blen(struct USART1_Type* p) { return (p->RTOR & USART1_RTOR_BLEN) >> 24 ; }
inline uint32_t usart1_rtor_get_rto(struct USART1_Type* p) { return (p->RTOR & USART1_RTOR_RTO) >> 0 ; }

// USART1->RQR Request register
enum {
	USART1_RQR_TXFRQ = 1UL<<4, // Transmit data flush request
	USART1_RQR_RXFRQ = 1UL<<3, // Receive data flush request
	USART1_RQR_MMRQ = 1UL<<2, // Mute mode request
	USART1_RQR_SBKRQ = 1UL<<1, // Send break request
	USART1_RQR_ABRRQ = 1UL<<0, // Auto baud rate request		
};

// USART1->ISR Interrupt & status register
enum {
	USART1_ISR_TCBGT = 1UL<<25, // Transmission complete before guard time completion
	USART1_ISR_REACK = 1UL<<22, // REACK
	USART1_ISR_TEACK = 1UL<<21, // TEACK
	USART1_ISR_WUF = 1UL<<20, // WUF
	USART1_ISR_RWU = 1UL<<19, // RWU
	USART1_ISR_SBKF = 1UL<<18, // SBKF
	USART1_ISR_CMF = 1UL<<17, // CMF
	USART1_ISR_BUSY = 1UL<<16, // BUSY
	USART1_ISR_ABRF = 1UL<<15, // ABRF
	USART1_ISR_ABRE = 1UL<<14, // ABRE
	USART1_ISR_EOBF = 1UL<<12, // EOBF
	USART1_ISR_RTOF = 1UL<<11, // RTOF
	USART1_ISR_CTS = 1UL<<10, // CTS
	USART1_ISR_CTSIF = 1UL<<9, // CTSIF
	USART1_ISR_LBDF = 1UL<<8, // LBDF
	USART1_ISR_TXE = 1UL<<7, // TXE
	USART1_ISR_TC = 1UL<<6, // TC
	USART1_ISR_RXNE = 1UL<<5, // RXNE
	USART1_ISR_IDLE = 1UL<<4, // IDLE
	USART1_ISR_ORE = 1UL<<3, // ORE
	USART1_ISR_NF = 1UL<<2, // NF
	USART1_ISR_FE = 1UL<<1, // FE
	USART1_ISR_PE = 1UL<<0, // PE		
};

// USART1->ICR Interrupt flag clear register
enum {
	USART1_ICR_WUCF = 1UL<<20, // Wakeup from Stop mode clear flag
	USART1_ICR_CMCF = 1UL<<17, // Character match clear flag
	USART1_ICR_EOBCF = 1UL<<12, // End of block clear flag
	USART1_ICR_RTOCF = 1UL<<11, // Receiver timeout clear flag
	USART1_ICR_CTSCF = 1UL<<9, // CTS clear flag
	USART1_ICR_LBDCF = 1UL<<8, // LIN break detection clear flag
	USART1_ICR_TCCF = 1UL<<6, // Transmission complete clear flag
	USART1_ICR_IDLECF = 1UL<<4, // Idle line detected clear flag
	USART1_ICR_ORECF = 1UL<<3, // Overrun error clear flag
	USART1_ICR_NCF = 1UL<<2, // Noise detected clear flag
	USART1_ICR_FECF = 1UL<<1, // Framing error clear flag
	USART1_ICR_PECF = 1UL<<0, // Parity error clear flag		
};

// USART1->RDR Receive data register
enum {
	USART1_RDR_RDR = ((1UL<<9)-1) << 0, // Receive data value		
};
inline uint32_t usart1_rdr_get_rdr(struct USART1_Type* p) { return (p->RDR & USART1_RDR_RDR) >> 0 ; }

// USART1->TDR Transmit data register
enum {
	USART1_TDR_TDR = ((1UL<<9)-1) << 0, // Transmit data value		
};
inline void usart1_tdr_set_tdr(struct USART1_Type* p, uint32_t val) { p->TDR = (p->TDR & ~USART1_TDR_TDR) | ((val<<0) & USART1_TDR_TDR); }
inline uint32_t usart1_tdr_get_tdr(struct USART1_Type* p) { return (p->TDR & USART1_TDR_TDR) >> 0 ; }




/* Universal serial bus full-speed device interface */
struct USB_SRAM_Type {
	__IO uint16_t EP0R; // @0 endpoint 0 register
	 uint8_t RESERVED0[2]; // @2 
	__IO uint16_t EP1R; // @4 endpoint 1 register
	 uint8_t RESERVED1[2]; // @6 
	__IO uint16_t EP2R; // @8 endpoint 2 register
	 uint8_t RESERVED2[2]; // @10 
	__IO uint16_t EP3R; // @12 endpoint 3 register
	 uint8_t RESERVED3[2]; // @14 
	__IO uint16_t EP4R; // @16 endpoint 4 register
	 uint8_t RESERVED4[2]; // @18 
	__IO uint16_t EP5R; // @20 endpoint 5 register
	 uint8_t RESERVED5[2]; // @22 
	__IO uint16_t EP6R; // @24 endpoint 6 register
	 uint8_t RESERVED6[2]; // @26 
	__IO uint16_t EP7R; // @28 endpoint 7 register
	 uint8_t RESERVED7[34]; // @30 
	__IO uint16_t CNTR; // @64 control register
	 uint8_t RESERVED8[2]; // @66 
	__IO uint16_t ISTR; // @68 interrupt status register
	 uint8_t RESERVED9[2]; // @70 
	__I uint16_t FNR; // @72 frame number register
	 uint8_t RESERVED10[2]; // @74 
	__IO uint8_t DADDR; // @76 device address
	 uint8_t RESERVED11[3]; // @77 
	__IO uint16_t BTABLE; // @80 Buffer table address
	 uint8_t RESERVED12[2]; // @82 
	__IO uint8_t LPMCSR; // @84 LPM control and status register
	 uint8_t RESERVED13[3]; // @85 
	__IO uint16_t BCDR; // @88 Battery charging detector
};

// USB_SRAM->EP0R endpoint 0 register
enum {
	USB_SRAM_EP0R_CTR_RX = 1UL<<15, // Correct transfer for reception
	USB_SRAM_EP0R_DTOG_RX = 1UL<<14, // Data Toggle, for reception transfers
	USB_SRAM_EP0R_STAT_RX = ((1UL<<2)-1) << 12, // Status bits, for reception transfers
	USB_SRAM_EP0R_SETUP = 1UL<<11, // Setup transaction completed
	USB_SRAM_EP0R_EP_TYPE = ((1UL<<2)-1) << 9, // Endpoint type
	USB_SRAM_EP0R_EP_KIND = 1UL<<8, // Endpoint kind
	USB_SRAM_EP0R_CTR_TX = 1UL<<7, // Correct Transfer for transmission
	USB_SRAM_EP0R_DTOG_TX = 1UL<<6, // Data Toggle, for transmission transfers
	USB_SRAM_EP0R_STAT_TX = ((1UL<<2)-1) << 4, // Status bits, for transmission transfers
	USB_SRAM_EP0R_EA = ((1UL<<4)-1) << 0, // Endpoint address		
};
inline void usb_sram_ep0r_set_stat_rx(struct USB_SRAM_Type* p, uint32_t val) { p->EP0R = (p->EP0R & ~USB_SRAM_EP0R_STAT_RX) | ((val<<12) & USB_SRAM_EP0R_STAT_RX); }
inline void usb_sram_ep0r_set_ep_type(struct USB_SRAM_Type* p, uint32_t val) { p->EP0R = (p->EP0R & ~USB_SRAM_EP0R_EP_TYPE) | ((val<<9) & USB_SRAM_EP0R_EP_TYPE); }
inline void usb_sram_ep0r_set_stat_tx(struct USB_SRAM_Type* p, uint32_t val) { p->EP0R = (p->EP0R & ~USB_SRAM_EP0R_STAT_TX) | ((val<<4) & USB_SRAM_EP0R_STAT_TX); }
inline void usb_sram_ep0r_set_ea(struct USB_SRAM_Type* p, uint32_t val) { p->EP0R = (p->EP0R & ~USB_SRAM_EP0R_EA) | ((val<<0) & USB_SRAM_EP0R_EA); }
inline uint32_t usb_sram_ep0r_get_stat_rx(struct USB_SRAM_Type* p) { return (p->EP0R & USB_SRAM_EP0R_STAT_RX) >> 12 ; }
inline uint32_t usb_sram_ep0r_get_ep_type(struct USB_SRAM_Type* p) { return (p->EP0R & USB_SRAM_EP0R_EP_TYPE) >> 9 ; }
inline uint32_t usb_sram_ep0r_get_stat_tx(struct USB_SRAM_Type* p) { return (p->EP0R & USB_SRAM_EP0R_STAT_TX) >> 4 ; }
inline uint32_t usb_sram_ep0r_get_ea(struct USB_SRAM_Type* p) { return (p->EP0R & USB_SRAM_EP0R_EA) >> 0 ; }

// USB_SRAM->EP1R endpoint 1 register
enum {
	USB_SRAM_EP1R_CTR_RX = 1UL<<15, // Correct transfer for reception
	USB_SRAM_EP1R_DTOG_RX = 1UL<<14, // Data Toggle, for reception transfers
	USB_SRAM_EP1R_STAT_RX = ((1UL<<2)-1) << 12, // Status bits, for reception transfers
	USB_SRAM_EP1R_SETUP = 1UL<<11, // Setup transaction completed
	USB_SRAM_EP1R_EP_TYPE = ((1UL<<2)-1) << 9, // Endpoint type
	USB_SRAM_EP1R_EP_KIND = 1UL<<8, // Endpoint kind
	USB_SRAM_EP1R_CTR_TX = 1UL<<7, // Correct Transfer for transmission
	USB_SRAM_EP1R_DTOG_TX = 1UL<<6, // Data Toggle, for transmission transfers
	USB_SRAM_EP1R_STAT_TX = ((1UL<<2)-1) << 4, // Status bits, for transmission transfers
	USB_SRAM_EP1R_EA = ((1UL<<4)-1) << 0, // Endpoint address		
};
inline void usb_sram_ep1r_set_stat_rx(struct USB_SRAM_Type* p, uint32_t val) { p->EP1R = (p->EP1R & ~USB_SRAM_EP1R_STAT_RX) | ((val<<12) & USB_SRAM_EP1R_STAT_RX); }
inline void usb_sram_ep1r_set_ep_type(struct USB_SRAM_Type* p, uint32_t val) { p->EP1R = (p->EP1R & ~USB_SRAM_EP1R_EP_TYPE) | ((val<<9) & USB_SRAM_EP1R_EP_TYPE); }
inline void usb_sram_ep1r_set_stat_tx(struct USB_SRAM_Type* p, uint32_t val) { p->EP1R = (p->EP1R & ~USB_SRAM_EP1R_STAT_TX) | ((val<<4) & USB_SRAM_EP1R_STAT_TX); }
inline void usb_sram_ep1r_set_ea(struct USB_SRAM_Type* p, uint32_t val) { p->EP1R = (p->EP1R & ~USB_SRAM_EP1R_EA) | ((val<<0) & USB_SRAM_EP1R_EA); }
inline uint32_t usb_sram_ep1r_get_stat_rx(struct USB_SRAM_Type* p) { return (p->EP1R & USB_SRAM_EP1R_STAT_RX) >> 12 ; }
inline uint32_t usb_sram_ep1r_get_ep_type(struct USB_SRAM_Type* p) { return (p->EP1R & USB_SRAM_EP1R_EP_TYPE) >> 9 ; }
inline uint32_t usb_sram_ep1r_get_stat_tx(struct USB_SRAM_Type* p) { return (p->EP1R & USB_SRAM_EP1R_STAT_TX) >> 4 ; }
inline uint32_t usb_sram_ep1r_get_ea(struct USB_SRAM_Type* p) { return (p->EP1R & USB_SRAM_EP1R_EA) >> 0 ; }

// USB_SRAM->EP2R endpoint 2 register
enum {
	USB_SRAM_EP2R_CTR_RX = 1UL<<15, // Correct transfer for reception
	USB_SRAM_EP2R_DTOG_RX = 1UL<<14, // Data Toggle, for reception transfers
	USB_SRAM_EP2R_STAT_RX = ((1UL<<2)-1) << 12, // Status bits, for reception transfers
	USB_SRAM_EP2R_SETUP = 1UL<<11, // Setup transaction completed
	USB_SRAM_EP2R_EP_TYPE = ((1UL<<2)-1) << 9, // Endpoint type
	USB_SRAM_EP2R_EP_KIND = 1UL<<8, // Endpoint kind
	USB_SRAM_EP2R_CTR_TX = 1UL<<7, // Correct Transfer for transmission
	USB_SRAM_EP2R_DTOG_TX = 1UL<<6, // Data Toggle, for transmission transfers
	USB_SRAM_EP2R_STAT_TX = ((1UL<<2)-1) << 4, // Status bits, for transmission transfers
	USB_SRAM_EP2R_EA = ((1UL<<4)-1) << 0, // Endpoint address		
};
inline void usb_sram_ep2r_set_stat_rx(struct USB_SRAM_Type* p, uint32_t val) { p->EP2R = (p->EP2R & ~USB_SRAM_EP2R_STAT_RX) | ((val<<12) & USB_SRAM_EP2R_STAT_RX); }
inline void usb_sram_ep2r_set_ep_type(struct USB_SRAM_Type* p, uint32_t val) { p->EP2R = (p->EP2R & ~USB_SRAM_EP2R_EP_TYPE) | ((val<<9) & USB_SRAM_EP2R_EP_TYPE); }
inline void usb_sram_ep2r_set_stat_tx(struct USB_SRAM_Type* p, uint32_t val) { p->EP2R = (p->EP2R & ~USB_SRAM_EP2R_STAT_TX) | ((val<<4) & USB_SRAM_EP2R_STAT_TX); }
inline void usb_sram_ep2r_set_ea(struct USB_SRAM_Type* p, uint32_t val) { p->EP2R = (p->EP2R & ~USB_SRAM_EP2R_EA) | ((val<<0) & USB_SRAM_EP2R_EA); }
inline uint32_t usb_sram_ep2r_get_stat_rx(struct USB_SRAM_Type* p) { return (p->EP2R & USB_SRAM_EP2R_STAT_RX) >> 12 ; }
inline uint32_t usb_sram_ep2r_get_ep_type(struct USB_SRAM_Type* p) { return (p->EP2R & USB_SRAM_EP2R_EP_TYPE) >> 9 ; }
inline uint32_t usb_sram_ep2r_get_stat_tx(struct USB_SRAM_Type* p) { return (p->EP2R & USB_SRAM_EP2R_STAT_TX) >> 4 ; }
inline uint32_t usb_sram_ep2r_get_ea(struct USB_SRAM_Type* p) { return (p->EP2R & USB_SRAM_EP2R_EA) >> 0 ; }

// USB_SRAM->EP3R endpoint 3 register
enum {
	USB_SRAM_EP3R_CTR_RX = 1UL<<15, // Correct transfer for reception
	USB_SRAM_EP3R_DTOG_RX = 1UL<<14, // Data Toggle, for reception transfers
	USB_SRAM_EP3R_STAT_RX = ((1UL<<2)-1) << 12, // Status bits, for reception transfers
	USB_SRAM_EP3R_SETUP = 1UL<<11, // Setup transaction completed
	USB_SRAM_EP3R_EP_TYPE = ((1UL<<2)-1) << 9, // Endpoint type
	USB_SRAM_EP3R_EP_KIND = 1UL<<8, // Endpoint kind
	USB_SRAM_EP3R_CTR_TX = 1UL<<7, // Correct Transfer for transmission
	USB_SRAM_EP3R_DTOG_TX = 1UL<<6, // Data Toggle, for transmission transfers
	USB_SRAM_EP3R_STAT_TX = ((1UL<<2)-1) << 4, // Status bits, for transmission transfers
	USB_SRAM_EP3R_EA = ((1UL<<4)-1) << 0, // Endpoint address		
};
inline void usb_sram_ep3r_set_stat_rx(struct USB_SRAM_Type* p, uint32_t val) { p->EP3R = (p->EP3R & ~USB_SRAM_EP3R_STAT_RX) | ((val<<12) & USB_SRAM_EP3R_STAT_RX); }
inline void usb_sram_ep3r_set_ep_type(struct USB_SRAM_Type* p, uint32_t val) { p->EP3R = (p->EP3R & ~USB_SRAM_EP3R_EP_TYPE) | ((val<<9) & USB_SRAM_EP3R_EP_TYPE); }
inline void usb_sram_ep3r_set_stat_tx(struct USB_SRAM_Type* p, uint32_t val) { p->EP3R = (p->EP3R & ~USB_SRAM_EP3R_STAT_TX) | ((val<<4) & USB_SRAM_EP3R_STAT_TX); }
inline void usb_sram_ep3r_set_ea(struct USB_SRAM_Type* p, uint32_t val) { p->EP3R = (p->EP3R & ~USB_SRAM_EP3R_EA) | ((val<<0) & USB_SRAM_EP3R_EA); }
inline uint32_t usb_sram_ep3r_get_stat_rx(struct USB_SRAM_Type* p) { return (p->EP3R & USB_SRAM_EP3R_STAT_RX) >> 12 ; }
inline uint32_t usb_sram_ep3r_get_ep_type(struct USB_SRAM_Type* p) { return (p->EP3R & USB_SRAM_EP3R_EP_TYPE) >> 9 ; }
inline uint32_t usb_sram_ep3r_get_stat_tx(struct USB_SRAM_Type* p) { return (p->EP3R & USB_SRAM_EP3R_STAT_TX) >> 4 ; }
inline uint32_t usb_sram_ep3r_get_ea(struct USB_SRAM_Type* p) { return (p->EP3R & USB_SRAM_EP3R_EA) >> 0 ; }

// USB_SRAM->EP4R endpoint 4 register
enum {
	USB_SRAM_EP4R_CTR_RX = 1UL<<15, // Correct transfer for reception
	USB_SRAM_EP4R_DTOG_RX = 1UL<<14, // Data Toggle, for reception transfers
	USB_SRAM_EP4R_STAT_RX = ((1UL<<2)-1) << 12, // Status bits, for reception transfers
	USB_SRAM_EP4R_SETUP = 1UL<<11, // Setup transaction completed
	USB_SRAM_EP4R_EP_TYPE = ((1UL<<2)-1) << 9, // Endpoint type
	USB_SRAM_EP4R_EP_KIND = 1UL<<8, // Endpoint kind
	USB_SRAM_EP4R_CTR_TX = 1UL<<7, // Correct Transfer for transmission
	USB_SRAM_EP4R_DTOG_TX = 1UL<<6, // Data Toggle, for transmission transfers
	USB_SRAM_EP4R_STAT_TX = ((1UL<<2)-1) << 4, // Status bits, for transmission transfers
	USB_SRAM_EP4R_EA = ((1UL<<4)-1) << 0, // Endpoint address		
};
inline void usb_sram_ep4r_set_stat_rx(struct USB_SRAM_Type* p, uint32_t val) { p->EP4R = (p->EP4R & ~USB_SRAM_EP4R_STAT_RX) | ((val<<12) & USB_SRAM_EP4R_STAT_RX); }
inline void usb_sram_ep4r_set_ep_type(struct USB_SRAM_Type* p, uint32_t val) { p->EP4R = (p->EP4R & ~USB_SRAM_EP4R_EP_TYPE) | ((val<<9) & USB_SRAM_EP4R_EP_TYPE); }
inline void usb_sram_ep4r_set_stat_tx(struct USB_SRAM_Type* p, uint32_t val) { p->EP4R = (p->EP4R & ~USB_SRAM_EP4R_STAT_TX) | ((val<<4) & USB_SRAM_EP4R_STAT_TX); }
inline void usb_sram_ep4r_set_ea(struct USB_SRAM_Type* p, uint32_t val) { p->EP4R = (p->EP4R & ~USB_SRAM_EP4R_EA) | ((val<<0) & USB_SRAM_EP4R_EA); }
inline uint32_t usb_sram_ep4r_get_stat_rx(struct USB_SRAM_Type* p) { return (p->EP4R & USB_SRAM_EP4R_STAT_RX) >> 12 ; }
inline uint32_t usb_sram_ep4r_get_ep_type(struct USB_SRAM_Type* p) { return (p->EP4R & USB_SRAM_EP4R_EP_TYPE) >> 9 ; }
inline uint32_t usb_sram_ep4r_get_stat_tx(struct USB_SRAM_Type* p) { return (p->EP4R & USB_SRAM_EP4R_STAT_TX) >> 4 ; }
inline uint32_t usb_sram_ep4r_get_ea(struct USB_SRAM_Type* p) { return (p->EP4R & USB_SRAM_EP4R_EA) >> 0 ; }

// USB_SRAM->EP5R endpoint 5 register
enum {
	USB_SRAM_EP5R_CTR_RX = 1UL<<15, // Correct transfer for reception
	USB_SRAM_EP5R_DTOG_RX = 1UL<<14, // Data Toggle, for reception transfers
	USB_SRAM_EP5R_STAT_RX = ((1UL<<2)-1) << 12, // Status bits, for reception transfers
	USB_SRAM_EP5R_SETUP = 1UL<<11, // Setup transaction completed
	USB_SRAM_EP5R_EP_TYPE = ((1UL<<2)-1) << 9, // Endpoint type
	USB_SRAM_EP5R_EP_KIND = 1UL<<8, // Endpoint kind
	USB_SRAM_EP5R_CTR_TX = 1UL<<7, // Correct Transfer for transmission
	USB_SRAM_EP5R_DTOG_TX = 1UL<<6, // Data Toggle, for transmission transfers
	USB_SRAM_EP5R_STAT_TX = ((1UL<<2)-1) << 4, // Status bits, for transmission transfers
	USB_SRAM_EP5R_EA = ((1UL<<4)-1) << 0, // Endpoint address		
};
inline void usb_sram_ep5r_set_stat_rx(struct USB_SRAM_Type* p, uint32_t val) { p->EP5R = (p->EP5R & ~USB_SRAM_EP5R_STAT_RX) | ((val<<12) & USB_SRAM_EP5R_STAT_RX); }
inline void usb_sram_ep5r_set_ep_type(struct USB_SRAM_Type* p, uint32_t val) { p->EP5R = (p->EP5R & ~USB_SRAM_EP5R_EP_TYPE) | ((val<<9) & USB_SRAM_EP5R_EP_TYPE); }
inline void usb_sram_ep5r_set_stat_tx(struct USB_SRAM_Type* p, uint32_t val) { p->EP5R = (p->EP5R & ~USB_SRAM_EP5R_STAT_TX) | ((val<<4) & USB_SRAM_EP5R_STAT_TX); }
inline void usb_sram_ep5r_set_ea(struct USB_SRAM_Type* p, uint32_t val) { p->EP5R = (p->EP5R & ~USB_SRAM_EP5R_EA) | ((val<<0) & USB_SRAM_EP5R_EA); }
inline uint32_t usb_sram_ep5r_get_stat_rx(struct USB_SRAM_Type* p) { return (p->EP5R & USB_SRAM_EP5R_STAT_RX) >> 12 ; }
inline uint32_t usb_sram_ep5r_get_ep_type(struct USB_SRAM_Type* p) { return (p->EP5R & USB_SRAM_EP5R_EP_TYPE) >> 9 ; }
inline uint32_t usb_sram_ep5r_get_stat_tx(struct USB_SRAM_Type* p) { return (p->EP5R & USB_SRAM_EP5R_STAT_TX) >> 4 ; }
inline uint32_t usb_sram_ep5r_get_ea(struct USB_SRAM_Type* p) { return (p->EP5R & USB_SRAM_EP5R_EA) >> 0 ; }

// USB_SRAM->EP6R endpoint 6 register
enum {
	USB_SRAM_EP6R_CTR_RX = 1UL<<15, // Correct transfer for reception
	USB_SRAM_EP6R_DTOG_RX = 1UL<<14, // Data Toggle, for reception transfers
	USB_SRAM_EP6R_STAT_RX = ((1UL<<2)-1) << 12, // Status bits, for reception transfers
	USB_SRAM_EP6R_SETUP = 1UL<<11, // Setup transaction completed
	USB_SRAM_EP6R_EP_TYPE = ((1UL<<2)-1) << 9, // Endpoint type
	USB_SRAM_EP6R_EP_KIND = 1UL<<8, // Endpoint kind
	USB_SRAM_EP6R_CTR_TX = 1UL<<7, // Correct Transfer for transmission
	USB_SRAM_EP6R_DTOG_TX = 1UL<<6, // Data Toggle, for transmission transfers
	USB_SRAM_EP6R_STAT_TX = ((1UL<<2)-1) << 4, // Status bits, for transmission transfers
	USB_SRAM_EP6R_EA = ((1UL<<4)-1) << 0, // Endpoint address		
};
inline void usb_sram_ep6r_set_stat_rx(struct USB_SRAM_Type* p, uint32_t val) { p->EP6R = (p->EP6R & ~USB_SRAM_EP6R_STAT_RX) | ((val<<12) & USB_SRAM_EP6R_STAT_RX); }
inline void usb_sram_ep6r_set_ep_type(struct USB_SRAM_Type* p, uint32_t val) { p->EP6R = (p->EP6R & ~USB_SRAM_EP6R_EP_TYPE) | ((val<<9) & USB_SRAM_EP6R_EP_TYPE); }
inline void usb_sram_ep6r_set_stat_tx(struct USB_SRAM_Type* p, uint32_t val) { p->EP6R = (p->EP6R & ~USB_SRAM_EP6R_STAT_TX) | ((val<<4) & USB_SRAM_EP6R_STAT_TX); }
inline void usb_sram_ep6r_set_ea(struct USB_SRAM_Type* p, uint32_t val) { p->EP6R = (p->EP6R & ~USB_SRAM_EP6R_EA) | ((val<<0) & USB_SRAM_EP6R_EA); }
inline uint32_t usb_sram_ep6r_get_stat_rx(struct USB_SRAM_Type* p) { return (p->EP6R & USB_SRAM_EP6R_STAT_RX) >> 12 ; }
inline uint32_t usb_sram_ep6r_get_ep_type(struct USB_SRAM_Type* p) { return (p->EP6R & USB_SRAM_EP6R_EP_TYPE) >> 9 ; }
inline uint32_t usb_sram_ep6r_get_stat_tx(struct USB_SRAM_Type* p) { return (p->EP6R & USB_SRAM_EP6R_STAT_TX) >> 4 ; }
inline uint32_t usb_sram_ep6r_get_ea(struct USB_SRAM_Type* p) { return (p->EP6R & USB_SRAM_EP6R_EA) >> 0 ; }

// USB_SRAM->EP7R endpoint 7 register
enum {
	USB_SRAM_EP7R_CTR_RX = 1UL<<15, // Correct transfer for reception
	USB_SRAM_EP7R_DTOG_RX = 1UL<<14, // Data Toggle, for reception transfers
	USB_SRAM_EP7R_STAT_RX = ((1UL<<2)-1) << 12, // Status bits, for reception transfers
	USB_SRAM_EP7R_SETUP = 1UL<<11, // Setup transaction completed
	USB_SRAM_EP7R_EP_TYPE = ((1UL<<2)-1) << 9, // Endpoint type
	USB_SRAM_EP7R_EP_KIND = 1UL<<8, // Endpoint kind
	USB_SRAM_EP7R_CTR_TX = 1UL<<7, // Correct Transfer for transmission
	USB_SRAM_EP7R_DTOG_TX = 1UL<<6, // Data Toggle, for transmission transfers
	USB_SRAM_EP7R_STAT_TX = ((1UL<<2)-1) << 4, // Status bits, for transmission transfers
	USB_SRAM_EP7R_EA = ((1UL<<4)-1) << 0, // Endpoint address		
};
inline void usb_sram_ep7r_set_stat_rx(struct USB_SRAM_Type* p, uint32_t val) { p->EP7R = (p->EP7R & ~USB_SRAM_EP7R_STAT_RX) | ((val<<12) & USB_SRAM_EP7R_STAT_RX); }
inline void usb_sram_ep7r_set_ep_type(struct USB_SRAM_Type* p, uint32_t val) { p->EP7R = (p->EP7R & ~USB_SRAM_EP7R_EP_TYPE) | ((val<<9) & USB_SRAM_EP7R_EP_TYPE); }
inline void usb_sram_ep7r_set_stat_tx(struct USB_SRAM_Type* p, uint32_t val) { p->EP7R = (p->EP7R & ~USB_SRAM_EP7R_STAT_TX) | ((val<<4) & USB_SRAM_EP7R_STAT_TX); }
inline void usb_sram_ep7r_set_ea(struct USB_SRAM_Type* p, uint32_t val) { p->EP7R = (p->EP7R & ~USB_SRAM_EP7R_EA) | ((val<<0) & USB_SRAM_EP7R_EA); }
inline uint32_t usb_sram_ep7r_get_stat_rx(struct USB_SRAM_Type* p) { return (p->EP7R & USB_SRAM_EP7R_STAT_RX) >> 12 ; }
inline uint32_t usb_sram_ep7r_get_ep_type(struct USB_SRAM_Type* p) { return (p->EP7R & USB_SRAM_EP7R_EP_TYPE) >> 9 ; }
inline uint32_t usb_sram_ep7r_get_stat_tx(struct USB_SRAM_Type* p) { return (p->EP7R & USB_SRAM_EP7R_STAT_TX) >> 4 ; }
inline uint32_t usb_sram_ep7r_get_ea(struct USB_SRAM_Type* p) { return (p->EP7R & USB_SRAM_EP7R_EA) >> 0 ; }

// USB_SRAM->CNTR control register
enum {
	USB_SRAM_CNTR_CTRM = 1UL<<15, // Correct transfer interrupt mask
	USB_SRAM_CNTR_PMAOVRM = 1UL<<14, // Packet memory area over / underrun interrupt mask
	USB_SRAM_CNTR_ERRM = 1UL<<13, // Error interrupt mask
	USB_SRAM_CNTR_WKUPM = 1UL<<12, // Wakeup interrupt mask
	USB_SRAM_CNTR_SUSPM = 1UL<<11, // Suspend mode interrupt mask
	USB_SRAM_CNTR_RESETM = 1UL<<10, // USB reset interrupt mask
	USB_SRAM_CNTR_SOFM = 1UL<<9, // Start of frame interrupt mask
	USB_SRAM_CNTR_ESOFM = 1UL<<8, // Expected start of frame interrupt mask
	USB_SRAM_CNTR_L1REQM = 1UL<<7, // LPM L1 state request interrupt mask
	USB_SRAM_CNTR_L1RESUME = 1UL<<5, // LPM L1 Resume request
	USB_SRAM_CNTR_RESUME = 1UL<<4, // Resume request
	USB_SRAM_CNTR_FSUSP = 1UL<<3, // Force suspend
	USB_SRAM_CNTR_LPMODE = 1UL<<2, // Low-power mode
	USB_SRAM_CNTR_PDWN = 1UL<<1, // Power down
	USB_SRAM_CNTR_FRES = 1UL<<0, // Force USB Reset		
};

// USB_SRAM->ISTR interrupt status register
enum {
	USB_SRAM_ISTR_CTR = 1UL<<15, // Correct transfer
	USB_SRAM_ISTR_PMAOVR = 1UL<<14, // Packet memory area over / underrun
	USB_SRAM_ISTR_ERR = 1UL<<13, // Error
	USB_SRAM_ISTR_WKUP = 1UL<<12, // Wakeup
	USB_SRAM_ISTR_SUSP = 1UL<<11, // Suspend mode request
	USB_SRAM_ISTR_RESET = 1UL<<10, // reset request
	USB_SRAM_ISTR_SOF = 1UL<<9, // start of frame
	USB_SRAM_ISTR_ESOF = 1UL<<8, // Expected start frame
	USB_SRAM_ISTR_L1REQ = 1UL<<7, // LPM L1 state request
	USB_SRAM_ISTR_DIR = 1UL<<4, // Direction of transaction
	USB_SRAM_ISTR_EP_ID = ((1UL<<4)-1) << 0, // Endpoint Identifier		
};
inline void usb_sram_istr_set_ep_id(struct USB_SRAM_Type* p, uint32_t val) { p->ISTR = (p->ISTR & ~USB_SRAM_ISTR_EP_ID) | ((val<<0) & USB_SRAM_ISTR_EP_ID); }
inline uint32_t usb_sram_istr_get_ep_id(struct USB_SRAM_Type* p) { return (p->ISTR & USB_SRAM_ISTR_EP_ID) >> 0 ; }

// USB_SRAM->FNR frame number register
enum {
	USB_SRAM_FNR_RXDP = 1UL<<15, // Receive data + line status
	USB_SRAM_FNR_RXDM = 1UL<<14, // Receive data - line status
	USB_SRAM_FNR_LCK = 1UL<<13, // Locked
	USB_SRAM_FNR_LSOF = ((1UL<<2)-1) << 11, // Lost SOF
	USB_SRAM_FNR_FN = ((1UL<<11)-1) << 0, // Frame number		
};
inline uint32_t usb_sram_fnr_get_lsof(struct USB_SRAM_Type* p) { return (p->FNR & USB_SRAM_FNR_LSOF) >> 11 ; }
inline uint32_t usb_sram_fnr_get_fn(struct USB_SRAM_Type* p) { return (p->FNR & USB_SRAM_FNR_FN) >> 0 ; }

// USB_SRAM->DADDR device address
enum {
	USB_SRAM_DADDR_EF = 1UL<<7, // Enable function
	USB_SRAM_DADDR_ADD = ((1UL<<7)-1) << 0, // Device address		
};
inline void usb_sram_daddr_set_add(struct USB_SRAM_Type* p, uint32_t val) { p->DADDR = (p->DADDR & ~USB_SRAM_DADDR_ADD) | ((val<<0) & USB_SRAM_DADDR_ADD); }
inline uint32_t usb_sram_daddr_get_add(struct USB_SRAM_Type* p) { return (p->DADDR & USB_SRAM_DADDR_ADD) >> 0 ; }

// USB_SRAM->BTABLE Buffer table address
enum {
	USB_SRAM_BTABLE_BTABLE = ((1UL<<13)-1) << 3, // Buffer table		
};
inline void usb_sram_btable_set_btable(struct USB_SRAM_Type* p, uint32_t val) { p->BTABLE = (p->BTABLE & ~USB_SRAM_BTABLE_BTABLE) | ((val<<3) & USB_SRAM_BTABLE_BTABLE); }
inline uint32_t usb_sram_btable_get_btable(struct USB_SRAM_Type* p) { return (p->BTABLE & USB_SRAM_BTABLE_BTABLE) >> 3 ; }

// USB_SRAM->LPMCSR LPM control and status register
enum {
	USB_SRAM_LPMCSR_BESL = ((1UL<<4)-1) << 4, // BESL value
	USB_SRAM_LPMCSR_REMWAKE = 1UL<<3, // bRemoteWake value
	USB_SRAM_LPMCSR_LPMACK = 1UL<<1, // LPM Token acknowledge enable
	USB_SRAM_LPMCSR_LPMEN = 1UL<<0, // LPM support enable		
};
inline void usb_sram_lpmcsr_set_besl(struct USB_SRAM_Type* p, uint32_t val) { p->LPMCSR = (p->LPMCSR & ~USB_SRAM_LPMCSR_BESL) | ((val<<4) & USB_SRAM_LPMCSR_BESL); }
inline uint32_t usb_sram_lpmcsr_get_besl(struct USB_SRAM_Type* p) { return (p->LPMCSR & USB_SRAM_LPMCSR_BESL) >> 4 ; }

// USB_SRAM->BCDR Battery charging detector
enum {
	USB_SRAM_BCDR_DPPU = 1UL<<15, // DP pull-up control
	USB_SRAM_BCDR_PS2DET = 1UL<<7, // DM pull-up detection status
	USB_SRAM_BCDR_SDET = 1UL<<6, // Secondary detection
	USB_SRAM_BCDR_PDET = 1UL<<5, // Primary detection
	USB_SRAM_BCDR_DCDET = 1UL<<4, // Data contact detection
	USB_SRAM_BCDR_SDEN = 1UL<<3, // Secondary detection
	USB_SRAM_BCDR_PDEN = 1UL<<2, // Primary detection
	USB_SRAM_BCDR_DCDEN = 1UL<<1, // Data contact detection
	USB_SRAM_BCDR_BCDEN = 1UL<<0, // Battery charging detector		
};

/* Voltage reference buffer */
struct VREFBUF_Type {
	__IO uint8_t CSR; // @0 VREF control and status register
	 uint8_t RESERVED0[3]; // @1 
	__IO uint8_t CCR; // @4 calibration control register
};

// VREFBUF->CSR VREF control and status register
enum {
	VREFBUF_CSR_VRR = 1UL<<3, // Voltage reference buffer ready
	VREFBUF_CSR_VRS = 1UL<<2, // Voltage reference scale
	VREFBUF_CSR_HIZ = 1UL<<1, // High impedance mode
	VREFBUF_CSR_ENVR = 1UL<<0, // Voltage reference buffer enable		
};

// VREFBUF->CCR calibration control register
enum {
	VREFBUF_CCR_TRIM = ((1UL<<6)-1) << 0, // Trimming code		
};
inline void vrefbuf_ccr_set_trim(struct VREFBUF_Type* p, uint32_t val) { p->CCR = (p->CCR & ~VREFBUF_CCR_TRIM) | ((val<<0) & VREFBUF_CCR_TRIM); }
inline uint32_t vrefbuf_ccr_get_trim(struct VREFBUF_Type* p) { return (p->CCR & VREFBUF_CCR_TRIM) >> 0 ; }

/* System window watchdog */
struct WWDG_Type {
	__IO uint8_t CR; // @0 Control register
	 uint8_t RESERVED0[3]; // @1 
	__IO uint16_t CFR; // @4 Configuration register
	 uint8_t RESERVED1[2]; // @6 
	__IO uint8_t SR; // @8 Status register
};

// WWDG->CR Control register
enum {
	WWDG_CR_WDGA = 1UL<<7, // Activation bit
	WWDG_CR_T = ((1UL<<7)-1) << 0, // 7-bit counter (MSB to LSB)		
};
inline void wwdg_cr_set_t(struct WWDG_Type* p, uint32_t val) { p->CR = (p->CR & ~WWDG_CR_T) | ((val<<0) & WWDG_CR_T); }
inline uint32_t wwdg_cr_get_t(struct WWDG_Type* p) { return (p->CR & WWDG_CR_T) >> 0 ; }

// WWDG->CFR Configuration register
enum {
	WWDG_CFR_EWI = 1UL<<9, // Early wakeup interrupt
	WWDG_CFR_WDGTB = ((1UL<<2)-1) << 7, // Timer base
	WWDG_CFR_W = ((1UL<<7)-1) << 0, // 7-bit window value		
};
inline void wwdg_cfr_set_wdgtb(struct WWDG_Type* p, uint32_t val) { p->CFR = (p->CFR & ~WWDG_CFR_WDGTB) | ((val<<7) & WWDG_CFR_WDGTB); }
inline void wwdg_cfr_set_w(struct WWDG_Type* p, uint32_t val) { p->CFR = (p->CFR & ~WWDG_CFR_W) | ((val<<0) & WWDG_CFR_W); }
inline uint32_t wwdg_cfr_get_wdgtb(struct WWDG_Type* p) { return (p->CFR & WWDG_CFR_WDGTB) >> 7 ; }
inline uint32_t wwdg_cfr_get_w(struct WWDG_Type* p) { return (p->CFR & WWDG_CFR_W) >> 0 ; }

// WWDG->SR Status register
enum {
	WWDG_SR_EWIF = 1UL<<0, // Early wakeup interrupt flag		
};


#undef __I
#undef __O
#undef __IO


extern struct ADC_Type	ADC;	// @0x50040000 
extern struct ADC12_Common_Type	ADC12_Common;	// @0x50000300 
extern struct AES_Type	AES;	// @0x50060000 
extern struct CAN_Type	CAN1;	// @0x40006400 
extern struct COMP_Type	COMP;	// @0x40010200 
extern struct CRC_Type	CRC;	// @0x40023000 
extern struct CRS_Type	CRS;	// @0x40006000 
extern struct DAC1_Type	DAC1;	// @0x40007400 
extern struct DBGMCU_Type	DBGMCU;	// @0xE0042000 
extern struct DFSDM_Type	DFSDM;	// @0x40016000 
extern struct DMA1_Type	DMA1;	// @0x40020000 
extern struct DMA1_Type 	DMA2;	// @0x40020400
extern struct EXTI_Type	EXTI;	// @0x40010400 
extern struct FIREWALL_Type	FIREWALL;	// @0x40011C00 
extern struct FLASH_Type	FLASH;	// @0x40022000 
extern struct FPU_Type	FPU;	// @0xE000EF34 
extern struct FPU_CPACR_Type	FPU_CPACR;	// @0xE000ED88 
extern struct GPIOA_Type	GPIOA;	// @0x48000000 
extern struct GPIOA_Type 	GPIOB;	// @0x48000400
extern struct GPIOA_Type 	GPIOC;	// @0x48000800
extern struct GPIOA_Type 	GPIOD;	// @0x48000C00
extern struct GPIOA_Type 	GPIOE;	// @0x48001000
extern struct GPIOA_Type 	GPIOH;	// @0x48001C00
extern struct I2C1_Type	I2C1;	// @0x40005400 
extern struct I2C1_Type 	I2C2;	// @0x40005800
extern struct I2C1_Type 	I2C3;	// @0x40005C00
extern struct I2C1_Type 	I2C4;	// @0x40008400
extern struct IWDG_Type	IWDG;	// @0x40003000 
extern struct LCD_Type	LCD;	// @0x40002400 
extern struct LPTIM1_Type	LPTIM1;	// @0x40007C00 
extern struct LPTIM1_Type 	LPTIM2;	// @0x40009400
extern struct LPUART1_Type	LPUART1;	// @0x40008000 
extern struct MPU_Type	MPU;	// @0xE000ED90 
extern struct NVIC_Type	NVIC;	// @0xE000E100 
extern struct NVIC_STIR_Type	NVIC_STIR;	// @0xE000EF00 
extern struct OPAMP_Type	OPAMP;	// @0x40007800 
extern struct PWR_Type	PWR;	// @0x40007000 
extern struct QUADSPI_Type	QUADSPI;	// @0xA0001000 
extern struct RCC_Type	RCC;	// @0x40021000 
extern struct RNG_Type	RNG;	// @0x50060800 
extern struct RTC_Type	RTC;	// @0x40002800 
extern struct SAI1_Type	SAI1;	// @0x40015400 
extern struct SCB_Type	SCB;	// @0xE000ED00 
extern struct SCB_ACTRL_Type	SCB_ACTRL;	// @0xE000E008 
extern struct SDMMC_Type	SDMMC;	// @0x40012800 
extern struct SPI1_Type	SPI1;	// @0x40013000 
extern struct SPI1_Type 	SPI2;	// @0x40003800
extern struct SPI1_Type 	SPI3;	// @0x40003C00
extern struct STK_Type	STK;	// @0xE000E010 
extern struct SWPMI1_Type	SWPMI1;	// @0x40008800 
extern struct SYSCFG_Type	SYSCFG;	// @0x40010000 
extern struct TIM1_Type	TIM1;	// @0x40012C00 Also: TIM6_Type
extern struct TIM15_Type	TIM15;	// @0x40014000 
extern struct TIM16_Type	TIM16;	// @0x40014400 Also: TIM15_Type
extern struct TIM2_Type	TIM2;	// @0x40000000 
extern struct TIM2_Type 	TIM3;	// @0x40000400
extern struct TIM6_Type	TIM6;	// @0x40001000 
extern struct TIM6_Type 	TIM7;	// @0x40001400
extern struct TSC_Type	TSC;	// @0x40024000 
extern struct USART1_Type 	UART4;	// @0x40004C00
extern struct USART1_Type	USART1;	// @0x40013800 
extern struct USART1_Type 	USART2;	// @0x40004400
extern struct USART1_Type 	USART3;	// @0x40004800
extern struct USB_SRAM_Type 	USB_FS;	// @0x40006800
extern struct USB_SRAM_Type	USB_SRAM;	// @0x40006C00 
extern struct VREFBUF_Type	VREFBUF;	// @0x40010030 
extern struct WWDG_Type	WWDG;	// @0x40002C00 

