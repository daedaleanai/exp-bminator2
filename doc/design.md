# How to understand this code

The source code is organized in one self-contained directory, src/ with the following files.

    Makefile        self contained build system
    openocd.cfg     configuration for flashing an STM32 over an ST-link programmer

The build system is a simple make file that compiles all the .c files with the appropriate compiler settings and
then links using the .ld script below.  The only depenencies are an arm-none-eabi-gcc compiler suite and either
the st-link tool or openocd. Invocations:

    make            # builds main.elf
    make flash      # uses st-link to burn it into the target device
    make flash2     # uses openocd to do the same
    make clean      # deletes all files that can be regenerated by running make 

The generated binaries are linked using a custom link script

    stm32l432kc.ld  defines memory sizes and absolute addresses of all the built in peripherals of the STM32L432
    sections.ld     included by the above.

The sections.ld files defines a layout consisting of code, initialized data and zeroed data (bss) that are written into flash. 
the reset handler in boot.c copies the data segment to RAM and zeroes out the bss segment before doing anything else. 

The device addresses in the main .ld file are generated by a tool (not included here) that parses an SVD register description
file for the microcontroller at hand. This same SVD file and tool is used to generate a header file with structure definitions for all peripherals
and constants for all their registers, as well as some convenience routines to set bitfields in registers and constants for all the interrupts.

The intent of this tool is to generate C definitions that are very close to the programming reference manual.  For each device there is a struct,
repeated devices are identified, so that eg. USART2 is the same type as USART1, named after the first such device, so struct USART1_Type, etc.
The constants are prefixed with device and register names so that a visual inspection allows to identify misuse of bitfields.

    stm32l4xx.h     device specific header.
    cortex_m4.h     a trimmed version of the system file provided by ARM for the core used in the STM32L4xx family.
    vectors.c       the interrupt handler vector table, also generated from the SVD.

When the device boots it first loads the stack value from the vector table and jumps to the ResetHandler, which is set up in boot.c.
For convenience of debugging, simple handlers for all the system traps are defined in fault.c.

    boot.c      the reset handler
    clock.h     definition of cycleCount(), which is our primary means of timekeeping.
    fault.c     handlers for memory bus and other faults, to print a minimal debug message on the debug console
    nvic.h      functions to enable and disable interrupts in the cortex M4

The resethandler in boot.c sets up the system clock tree, and configures the CPU built in interrupt timer STK to run at the
core frequency of 80MHz.  We use this counter for timekeeping in the cycleCount() function. 

    main.c      the main application, further described below
    output.[ch] functions that format the outgoing messages according to the ICD
    input.[ch]  a facility to parse incoming messages

Device drivers:

    gpio2.[ch]  a facility to set up the GPIO pin functions
    spi.[ch]    a very low level driver for SPI handling transactions from a queue over DMA
    usart.h     a very low level driver for an IRQ driven UART

Device independent facilities:
    tprintf.[ch]     a third party printf facility
    binary.h         serializing and deserializing binary messages
    msgq.h           a queue of messages with a fixed maximum size
    ringbuffer.[ch]  a character fifo useful for the usart driver
    runtimer.[ch]    a facility to keep track of how often and how long things run

    bme280.[ch]      definitions for the registers of the BME280 humidity sensor
    bmi08x.h         definitions for the registers of the BMI088 accelerometer and gyroscope
    bmxspi.[ch]      functions to test and configure the BMI and BME devices over SPI. 


# structure of the application

  - initialize pinout, irqs and peripherals
  - initialize and self-test BMI088 and BME380
  - set up irq handlers for accel, gyro, shutter, and periodic events
  - the accel and gyro irqs push SPI transactions on the spiq, which are handled by DMA
  - the other irqs push messages on the event queue evq
  - incoming packets on USART1 are parsed by the USART1 irq.  valid requests are pushed
	on the spiq, invalid ones on the cmdq.
  - the mainloop copies spiq, evq and cmdq to the USART1 outq, which is also handled by DMA
	separating out the normal measurements from the command responses.

![Data Flow](dataflow.png)

TODO describe principles behind design.